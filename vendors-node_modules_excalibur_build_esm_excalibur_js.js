"use strict";
(self["webpackChunkexcalibur_webpack"] = self["webpackChunkexcalibur_webpack"] || []).push([["vendors-node_modules_excalibur_build_esm_excalibur_js"],{

/***/ "./node_modules/excalibur/build/esm/excalibur.js":
/*!*******************************************************!*\
  !*** ./node_modules/excalibur/build/esm/excalibur.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionContext": () => (/* binding */ __webpack_exports__ActionContext),
/* harmony export */   "ActionQueue": () => (/* binding */ __webpack_exports__ActionQueue),
/* harmony export */   "ActionSequence": () => (/* binding */ __webpack_exports__ActionSequence),
/* harmony export */   "ActionsComponent": () => (/* binding */ __webpack_exports__ActionsComponent),
/* harmony export */   "ActionsSystem": () => (/* binding */ __webpack_exports__ActionsSystem),
/* harmony export */   "ActivateEvent": () => (/* binding */ __webpack_exports__ActivateEvent),
/* harmony export */   "Actor": () => (/* binding */ __webpack_exports__Actor),
/* harmony export */   "AddedComponent": () => (/* binding */ __webpack_exports__AddedComponent),
/* harmony export */   "AddedEntity": () => (/* binding */ __webpack_exports__AddedEntity),
/* harmony export */   "AffineMatrix": () => (/* binding */ __webpack_exports__AffineMatrix),
/* harmony export */   "Animation": () => (/* binding */ __webpack_exports__Animation),
/* harmony export */   "AnimationDirection": () => (/* binding */ __webpack_exports__AnimationDirection),
/* harmony export */   "AnimationStrategy": () => (/* binding */ __webpack_exports__AnimationStrategy),
/* harmony export */   "ArcadeSolver": () => (/* binding */ __webpack_exports__ArcadeSolver),
/* harmony export */   "AudioContextFactory": () => (/* binding */ __webpack_exports__AudioContextFactory),
/* harmony export */   "Axis": () => (/* binding */ __webpack_exports__Axis),
/* harmony export */   "BaseAlign": () => (/* binding */ __webpack_exports__BaseAlign),
/* harmony export */   "Blink": () => (/* binding */ __webpack_exports__Blink),
/* harmony export */   "BodyComponent": () => (/* binding */ __webpack_exports__BodyComponent),
/* harmony export */   "BoundingBox": () => (/* binding */ __webpack_exports__BoundingBox),
/* harmony export */   "BroadphaseStrategy": () => (/* binding */ __webpack_exports__BroadphaseStrategy),
/* harmony export */   "BrowserComponent": () => (/* binding */ __webpack_exports__BrowserComponent),
/* harmony export */   "BrowserEvents": () => (/* binding */ __webpack_exports__BrowserEvents),
/* harmony export */   "Camera": () => (/* binding */ __webpack_exports__Camera),
/* harmony export */   "Canvas": () => (/* binding */ __webpack_exports__Canvas),
/* harmony export */   "Circle": () => (/* binding */ __webpack_exports__Circle),
/* harmony export */   "CircleCollider": () => (/* binding */ __webpack_exports__CircleCollider),
/* harmony export */   "Class": () => (/* binding */ __webpack_exports__Class),
/* harmony export */   "Clock": () => (/* binding */ __webpack_exports__Clock),
/* harmony export */   "ClosestLine": () => (/* binding */ __webpack_exports__ClosestLine),
/* harmony export */   "ClosestLineJumpTable": () => (/* binding */ __webpack_exports__ClosestLineJumpTable),
/* harmony export */   "Collider": () => (/* binding */ __webpack_exports__Collider),
/* harmony export */   "ColliderComponent": () => (/* binding */ __webpack_exports__ColliderComponent),
/* harmony export */   "CollisionContact": () => (/* binding */ __webpack_exports__CollisionContact),
/* harmony export */   "CollisionEndEvent": () => (/* binding */ __webpack_exports__CollisionEndEvent),
/* harmony export */   "CollisionGroup": () => (/* binding */ __webpack_exports__CollisionGroup),
/* harmony export */   "CollisionGroupManager": () => (/* binding */ __webpack_exports__CollisionGroupManager),
/* harmony export */   "CollisionJumpTable": () => (/* binding */ __webpack_exports__CollisionJumpTable),
/* harmony export */   "CollisionPostSolveEvent": () => (/* binding */ __webpack_exports__CollisionPostSolveEvent),
/* harmony export */   "CollisionPreSolveEvent": () => (/* binding */ __webpack_exports__CollisionPreSolveEvent),
/* harmony export */   "CollisionResolutionStrategy": () => (/* binding */ __webpack_exports__CollisionResolutionStrategy),
/* harmony export */   "CollisionStartEvent": () => (/* binding */ __webpack_exports__CollisionStartEvent),
/* harmony export */   "CollisionSystem": () => (/* binding */ __webpack_exports__CollisionSystem),
/* harmony export */   "CollisionType": () => (/* binding */ __webpack_exports__CollisionType),
/* harmony export */   "Color": () => (/* binding */ __webpack_exports__Color),
/* harmony export */   "ColorBlindFlags": () => (/* binding */ __webpack_exports__ColorBlindFlags),
/* harmony export */   "ColorBlindnessMode": () => (/* binding */ __webpack_exports__ColorBlindnessMode),
/* harmony export */   "ColorBlindnessPostProcessor": () => (/* binding */ __webpack_exports__ColorBlindnessPostProcessor),
/* harmony export */   "Component": () => (/* binding */ __webpack_exports__Component),
/* harmony export */   "CompositeCollider": () => (/* binding */ __webpack_exports__CompositeCollider),
/* harmony export */   "Configurable": () => (/* binding */ __webpack_exports__Configurable),
/* harmony export */   "ConsoleAppender": () => (/* binding */ __webpack_exports__ConsoleAppender),
/* harmony export */   "ContactConstraintPoint": () => (/* binding */ __webpack_exports__ContactConstraintPoint),
/* harmony export */   "ContactEndEvent": () => (/* binding */ __webpack_exports__ContactEndEvent),
/* harmony export */   "ContactStartEvent": () => (/* binding */ __webpack_exports__ContactStartEvent),
/* harmony export */   "CoordPlane": () => (/* binding */ __webpack_exports__CoordPlane),
/* harmony export */   "DeactivateEvent": () => (/* binding */ __webpack_exports__DeactivateEvent),
/* harmony export */   "Debug": () => (/* binding */ __webpack_exports__Debug),
/* harmony export */   "DebugGraphicsComponent": () => (/* binding */ __webpack_exports__DebugGraphicsComponent),
/* harmony export */   "DebugSystem": () => (/* binding */ __webpack_exports__DebugSystem),
/* harmony export */   "DebugText": () => (/* binding */ __webpack_exports__DebugText),
/* harmony export */   "DegreeOfFreedom": () => (/* binding */ __webpack_exports__DegreeOfFreedom),
/* harmony export */   "Delay": () => (/* binding */ __webpack_exports__Delay),
/* harmony export */   "Detector": () => (/* binding */ __webpack_exports__Detector),
/* harmony export */   "Die": () => (/* binding */ __webpack_exports__Die),
/* harmony export */   "Direction": () => (/* binding */ __webpack_exports__Direction),
/* harmony export */   "DisplayMode": () => (/* binding */ __webpack_exports__DisplayMode),
/* harmony export */   "DynamicTree": () => (/* binding */ __webpack_exports__DynamicTree),
/* harmony export */   "DynamicTreeCollisionProcessor": () => (/* binding */ __webpack_exports__DynamicTreeCollisionProcessor),
/* harmony export */   "EX_VERSION": () => (/* binding */ __webpack_exports__EX_VERSION),
/* harmony export */   "EaseBy": () => (/* binding */ __webpack_exports__EaseBy),
/* harmony export */   "EaseTo": () => (/* binding */ __webpack_exports__EaseTo),
/* harmony export */   "EasingFunctions": () => (/* binding */ __webpack_exports__EasingFunctions),
/* harmony export */   "EdgeCollider": () => (/* binding */ __webpack_exports__EdgeCollider),
/* harmony export */   "ElasticToActorStrategy": () => (/* binding */ __webpack_exports__ElasticToActorStrategy),
/* harmony export */   "EmitterType": () => (/* binding */ __webpack_exports__EmitterType),
/* harmony export */   "Engine": () => (/* binding */ __webpack_exports__Engine),
/* harmony export */   "EnterTriggerEvent": () => (/* binding */ __webpack_exports__EnterTriggerEvent),
/* harmony export */   "EnterViewPortEvent": () => (/* binding */ __webpack_exports__EnterViewPortEvent),
/* harmony export */   "Entity": () => (/* binding */ __webpack_exports__Entity),
/* harmony export */   "EntityManager": () => (/* binding */ __webpack_exports__EntityManager),
/* harmony export */   "EventDispatcher": () => (/* binding */ __webpack_exports__EventDispatcher),
/* harmony export */   "EventTypes": () => (/* binding */ __webpack_exports__EventTypes),
/* harmony export */   "Events": () => (/* binding */ __webpack_exports__Events),
/* harmony export */   "ExResponse": () => (/* binding */ __webpack_exports__ExResponse),
/* harmony export */   "ExcaliburGraphicsContext2DCanvas": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContext2DCanvas),
/* harmony export */   "ExcaliburGraphicsContextWebGL": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContextWebGL),
/* harmony export */   "ExcaliburWebGLContextAccessor": () => (/* binding */ __webpack_exports__ExcaliburWebGLContextAccessor),
/* harmony export */   "ExitTriggerEvent": () => (/* binding */ __webpack_exports__ExitTriggerEvent),
/* harmony export */   "ExitViewPortEvent": () => (/* binding */ __webpack_exports__ExitViewPortEvent),
/* harmony export */   "Fade": () => (/* binding */ __webpack_exports__Fade),
/* harmony export */   "Flags": () => (/* binding */ __webpack_exports__Flags),
/* harmony export */   "Follow": () => (/* binding */ __webpack_exports__Follow),
/* harmony export */   "Font": () => (/* binding */ __webpack_exports__Font),
/* harmony export */   "FontStyle": () => (/* binding */ __webpack_exports__FontStyle),
/* harmony export */   "FontUnit": () => (/* binding */ __webpack_exports__FontUnit),
/* harmony export */   "FpsSampler": () => (/* binding */ __webpack_exports__FpsSampler),
/* harmony export */   "FrameStats": () => (/* binding */ __webpack_exports__FrameStats),
/* harmony export */   "Future": () => (/* binding */ __webpack_exports__Future),
/* harmony export */   "GameEvent": () => (/* binding */ __webpack_exports__GameEvent),
/* harmony export */   "GameStartEvent": () => (/* binding */ __webpack_exports__GameStartEvent),
/* harmony export */   "GameStopEvent": () => (/* binding */ __webpack_exports__GameStopEvent),
/* harmony export */   "GamepadAxisEvent": () => (/* binding */ __webpack_exports__GamepadAxisEvent),
/* harmony export */   "GamepadButtonEvent": () => (/* binding */ __webpack_exports__GamepadButtonEvent),
/* harmony export */   "GamepadConnectEvent": () => (/* binding */ __webpack_exports__GamepadConnectEvent),
/* harmony export */   "GamepadDisconnectEvent": () => (/* binding */ __webpack_exports__GamepadDisconnectEvent),
/* harmony export */   "Gif": () => (/* binding */ __webpack_exports__Gif),
/* harmony export */   "GlobalCoordinates": () => (/* binding */ __webpack_exports__GlobalCoordinates),
/* harmony export */   "Graphic": () => (/* binding */ __webpack_exports__Graphic),
/* harmony export */   "GraphicsComponent": () => (/* binding */ __webpack_exports__GraphicsComponent),
/* harmony export */   "GraphicsGroup": () => (/* binding */ __webpack_exports__GraphicsGroup),
/* harmony export */   "GraphicsLayer": () => (/* binding */ __webpack_exports__GraphicsLayer),
/* harmony export */   "GraphicsLayers": () => (/* binding */ __webpack_exports__GraphicsLayers),
/* harmony export */   "GraphicsSystem": () => (/* binding */ __webpack_exports__GraphicsSystem),
/* harmony export */   "HiddenEvent": () => (/* binding */ __webpack_exports__HiddenEvent),
/* harmony export */   "ImageFiltering": () => (/* binding */ __webpack_exports__ImageFiltering),
/* harmony export */   "ImageSource": () => (/* binding */ __webpack_exports__ImageSource),
/* harmony export */   "InitializeEvent": () => (/* binding */ __webpack_exports__InitializeEvent),
/* harmony export */   "Input": () => (/* binding */ __webpack_exports__Input),
/* harmony export */   "Integrator": () => (/* binding */ __webpack_exports__Integrator),
/* harmony export */   "IsometricEntityComponent": () => (/* binding */ __webpack_exports__IsometricEntityComponent),
/* harmony export */   "IsometricEntitySystem": () => (/* binding */ __webpack_exports__IsometricEntitySystem),
/* harmony export */   "IsometricMap": () => (/* binding */ __webpack_exports__IsometricMap),
/* harmony export */   "IsometricTile": () => (/* binding */ __webpack_exports__IsometricTile),
/* harmony export */   "KillEvent": () => (/* binding */ __webpack_exports__KillEvent),
/* harmony export */   "Label": () => (/* binding */ __webpack_exports__Label),
/* harmony export */   "LimitCameraBoundsStrategy": () => (/* binding */ __webpack_exports__LimitCameraBoundsStrategy),
/* harmony export */   "Line": () => (/* binding */ __webpack_exports__Line),
/* harmony export */   "LineSegment": () => (/* binding */ __webpack_exports__LineSegment),
/* harmony export */   "Loader": () => (/* binding */ __webpack_exports__Loader),
/* harmony export */   "LockCameraToActorAxisStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorAxisStrategy),
/* harmony export */   "LockCameraToActorStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorStrategy),
/* harmony export */   "LogLevel": () => (/* binding */ __webpack_exports__LogLevel),
/* harmony export */   "Logger": () => (/* binding */ __webpack_exports__Logger),
/* harmony export */   "Matrix": () => (/* binding */ __webpack_exports__Matrix),
/* harmony export */   "MatrixLocations": () => (/* binding */ __webpack_exports__MatrixLocations),
/* harmony export */   "MediaEvent": () => (/* binding */ __webpack_exports__MediaEvent),
/* harmony export */   "Meet": () => (/* binding */ __webpack_exports__Meet),
/* harmony export */   "MotionComponent": () => (/* binding */ __webpack_exports__MotionComponent),
/* harmony export */   "MotionSystem": () => (/* binding */ __webpack_exports__MotionSystem),
/* harmony export */   "MoveBy": () => (/* binding */ __webpack_exports__MoveBy),
/* harmony export */   "MoveTo": () => (/* binding */ __webpack_exports__MoveTo),
/* harmony export */   "NativeSoundEvent": () => (/* binding */ __webpack_exports__NativeSoundEvent),
/* harmony export */   "NativeSoundProcessedEvent": () => (/* binding */ __webpack_exports__NativeSoundProcessedEvent),
/* harmony export */   "Observable": () => (/* binding */ __webpack_exports__Observable),
/* harmony export */   "OffscreenSystem": () => (/* binding */ __webpack_exports__OffscreenSystem),
/* harmony export */   "Pair": () => (/* binding */ __webpack_exports__Pair),
/* harmony export */   "ParallaxComponent": () => (/* binding */ __webpack_exports__ParallaxComponent),
/* harmony export */   "ParallelActions": () => (/* binding */ __webpack_exports__ParallelActions),
/* harmony export */   "ParseGif": () => (/* binding */ __webpack_exports__ParseGif),
/* harmony export */   "Particle": () => (/* binding */ __webpack_exports__Particle),
/* harmony export */   "ParticleEmitter": () => (/* binding */ __webpack_exports__ParticleEmitter),
/* harmony export */   "Physics": () => (/* binding */ __webpack_exports__Physics),
/* harmony export */   "PhysicsStats": () => (/* binding */ __webpack_exports__PhysicsStats),
/* harmony export */   "PointerComponent": () => (/* binding */ __webpack_exports__PointerComponent),
/* harmony export */   "PointerSystem": () => (/* binding */ __webpack_exports__PointerSystem),
/* harmony export */   "Polygon": () => (/* binding */ __webpack_exports__Polygon),
/* harmony export */   "PolygonCollider": () => (/* binding */ __webpack_exports__PolygonCollider),
/* harmony export */   "Pool": () => (/* binding */ __webpack_exports__Pool),
/* harmony export */   "PostCollisionEvent": () => (/* binding */ __webpack_exports__PostCollisionEvent),
/* harmony export */   "PostDebugDrawEvent": () => (/* binding */ __webpack_exports__PostDebugDrawEvent),
/* harmony export */   "PostDrawEvent": () => (/* binding */ __webpack_exports__PostDrawEvent),
/* harmony export */   "PostFrameEvent": () => (/* binding */ __webpack_exports__PostFrameEvent),
/* harmony export */   "PostKillEvent": () => (/* binding */ __webpack_exports__PostKillEvent),
/* harmony export */   "PostUpdateEvent": () => (/* binding */ __webpack_exports__PostUpdateEvent),
/* harmony export */   "PreCollisionEvent": () => (/* binding */ __webpack_exports__PreCollisionEvent),
/* harmony export */   "PreDebugDrawEvent": () => (/* binding */ __webpack_exports__PreDebugDrawEvent),
/* harmony export */   "PreDrawEvent": () => (/* binding */ __webpack_exports__PreDrawEvent),
/* harmony export */   "PreFrameEvent": () => (/* binding */ __webpack_exports__PreFrameEvent),
/* harmony export */   "PreKillEvent": () => (/* binding */ __webpack_exports__PreKillEvent),
/* harmony export */   "PreUpdateEvent": () => (/* binding */ __webpack_exports__PreUpdateEvent),
/* harmony export */   "Projection": () => (/* binding */ __webpack_exports__Projection),
/* harmony export */   "QuadIndexBuffer": () => (/* binding */ __webpack_exports__QuadIndexBuffer),
/* harmony export */   "Query": () => (/* binding */ __webpack_exports__Query),
/* harmony export */   "QueryManager": () => (/* binding */ __webpack_exports__QueryManager),
/* harmony export */   "RadiusAroundActorStrategy": () => (/* binding */ __webpack_exports__RadiusAroundActorStrategy),
/* harmony export */   "Random": () => (/* binding */ __webpack_exports__Random),
/* harmony export */   "Raster": () => (/* binding */ __webpack_exports__Raster),
/* harmony export */   "Ray": () => (/* binding */ __webpack_exports__Ray),
/* harmony export */   "RealisticSolver": () => (/* binding */ __webpack_exports__RealisticSolver),
/* harmony export */   "Rectangle": () => (/* binding */ __webpack_exports__Rectangle),
/* harmony export */   "RemovedComponent": () => (/* binding */ __webpack_exports__RemovedComponent),
/* harmony export */   "RemovedEntity": () => (/* binding */ __webpack_exports__RemovedEntity),
/* harmony export */   "Repeat": () => (/* binding */ __webpack_exports__Repeat),
/* harmony export */   "RepeatForever": () => (/* binding */ __webpack_exports__RepeatForever),
/* harmony export */   "Resolution": () => (/* binding */ __webpack_exports__Resolution),
/* harmony export */   "Resource": () => (/* binding */ __webpack_exports__Resource),
/* harmony export */   "RotateBy": () => (/* binding */ __webpack_exports__RotateBy),
/* harmony export */   "RotateTo": () => (/* binding */ __webpack_exports__RotateTo),
/* harmony export */   "RotationType": () => (/* binding */ __webpack_exports__RotationType),
/* harmony export */   "ScaleBy": () => (/* binding */ __webpack_exports__ScaleBy),
/* harmony export */   "ScaleTo": () => (/* binding */ __webpack_exports__ScaleTo),
/* harmony export */   "Scene": () => (/* binding */ __webpack_exports__Scene),
/* harmony export */   "Screen": () => (/* binding */ __webpack_exports__Screen),
/* harmony export */   "ScreenAppender": () => (/* binding */ __webpack_exports__ScreenAppender),
/* harmony export */   "ScreenElement": () => (/* binding */ __webpack_exports__ScreenElement),
/* harmony export */   "ScreenShader": () => (/* binding */ __webpack_exports__ScreenShader),
/* harmony export */   "ScrollPreventionMode": () => (/* binding */ __webpack_exports__ScrollPreventionMode),
/* harmony export */   "Semaphore": () => (/* binding */ __webpack_exports__Semaphore),
/* harmony export */   "Shader": () => (/* binding */ __webpack_exports__Shader),
/* harmony export */   "Shape": () => (/* binding */ __webpack_exports__Shape),
/* harmony export */   "Side": () => (/* binding */ __webpack_exports__Side),
/* harmony export */   "Sound": () => (/* binding */ __webpack_exports__Sound),
/* harmony export */   "Sprite": () => (/* binding */ __webpack_exports__Sprite),
/* harmony export */   "SpriteFont": () => (/* binding */ __webpack_exports__SpriteFont),
/* harmony export */   "SpriteSheet": () => (/* binding */ __webpack_exports__SpriteSheet),
/* harmony export */   "StandardClock": () => (/* binding */ __webpack_exports__StandardClock),
/* harmony export */   "StateMachine": () => (/* binding */ __webpack_exports__StateMachine),
/* harmony export */   "StrategyContainer": () => (/* binding */ __webpack_exports__StrategyContainer),
/* harmony export */   "Stream": () => (/* binding */ __webpack_exports__Stream),
/* harmony export */   "System": () => (/* binding */ __webpack_exports__System),
/* harmony export */   "SystemManager": () => (/* binding */ __webpack_exports__SystemManager),
/* harmony export */   "SystemType": () => (/* binding */ __webpack_exports__SystemType),
/* harmony export */   "TagComponent": () => (/* binding */ __webpack_exports__TagComponent),
/* harmony export */   "TestClock": () => (/* binding */ __webpack_exports__TestClock),
/* harmony export */   "Text": () => (/* binding */ __webpack_exports__Text),
/* harmony export */   "TextAlign": () => (/* binding */ __webpack_exports__TextAlign),
/* harmony export */   "TextureLoader": () => (/* binding */ __webpack_exports__TextureLoader),
/* harmony export */   "Tile": () => (/* binding */ __webpack_exports__Tile),
/* harmony export */   "TileMap": () => (/* binding */ __webpack_exports__TileMap),
/* harmony export */   "Timer": () => (/* binding */ __webpack_exports__Timer),
/* harmony export */   "Toaster": () => (/* binding */ __webpack_exports__Toaster),
/* harmony export */   "Transform": () => (/* binding */ __webpack_exports__Transform),
/* harmony export */   "TransformComponent": () => (/* binding */ __webpack_exports__TransformComponent),
/* harmony export */   "TreeNode": () => (/* binding */ __webpack_exports__TreeNode),
/* harmony export */   "Trigger": () => (/* binding */ __webpack_exports__Trigger),
/* harmony export */   "TwoPI": () => (/* binding */ __webpack_exports__TwoPI),
/* harmony export */   "Util": () => (/* binding */ __webpack_exports__Util),
/* harmony export */   "Vector": () => (/* binding */ __webpack_exports__Vector),
/* harmony export */   "VectorView": () => (/* binding */ __webpack_exports__VectorView),
/* harmony export */   "VertexBuffer": () => (/* binding */ __webpack_exports__VertexBuffer),
/* harmony export */   "VertexLayout": () => (/* binding */ __webpack_exports__VertexLayout),
/* harmony export */   "VisibleEvent": () => (/* binding */ __webpack_exports__VisibleEvent),
/* harmony export */   "WebAudio": () => (/* binding */ __webpack_exports__WebAudio),
/* harmony export */   "WebAudioInstance": () => (/* binding */ __webpack_exports__WebAudioInstance),
/* harmony export */   "World": () => (/* binding */ __webpack_exports__World),
/* harmony export */   "canonicalizeAngle": () => (/* binding */ __webpack_exports__canonicalizeAngle),
/* harmony export */   "clamp": () => (/* binding */ __webpack_exports__clamp),
/* harmony export */   "createId": () => (/* binding */ __webpack_exports__createId),
/* harmony export */   "frac": () => (/* binding */ __webpack_exports__frac),
/* harmony export */   "hasGraphicsTick": () => (/* binding */ __webpack_exports__hasGraphicsTick),
/* harmony export */   "hasOnInitialize": () => (/* binding */ __webpack_exports__hasOnInitialize),
/* harmony export */   "hasOnPostUpdate": () => (/* binding */ __webpack_exports__hasOnPostUpdate),
/* harmony export */   "hasOnPreUpdate": () => (/* binding */ __webpack_exports__hasOnPreUpdate),
/* harmony export */   "hasPostDraw": () => (/* binding */ __webpack_exports__hasPostDraw),
/* harmony export */   "hasPreDraw": () => (/* binding */ __webpack_exports__hasPreDraw),
/* harmony export */   "has_initialize": () => (/* binding */ __webpack_exports__has_initialize),
/* harmony export */   "has_postupdate": () => (/* binding */ __webpack_exports__has_postupdate),
/* harmony export */   "has_preupdate": () => (/* binding */ __webpack_exports__has_preupdate),
/* harmony export */   "isAddedComponent": () => (/* binding */ __webpack_exports__isAddedComponent),
/* harmony export */   "isAddedSystemEntity": () => (/* binding */ __webpack_exports__isAddedSystemEntity),
/* harmony export */   "isRemoveSystemEntity": () => (/* binding */ __webpack_exports__isRemoveSystemEntity),
/* harmony export */   "isRemovedComponent": () => (/* binding */ __webpack_exports__isRemovedComponent),
/* harmony export */   "isScreenElement": () => (/* binding */ __webpack_exports__isScreenElement),
/* harmony export */   "maxMessages": () => (/* binding */ __webpack_exports__maxMessages),
/* harmony export */   "obsolete": () => (/* binding */ __webpack_exports__obsolete),
/* harmony export */   "pixelSnapEpsilon": () => (/* binding */ __webpack_exports__pixelSnapEpsilon),
/* harmony export */   "randomInRange": () => (/* binding */ __webpack_exports__randomInRange),
/* harmony export */   "randomIntInRange": () => (/* binding */ __webpack_exports__randomIntInRange),
/* harmony export */   "range": () => (/* binding */ __webpack_exports__range),
/* harmony export */   "resetObsoleteCounter": () => (/* binding */ __webpack_exports__resetObsoleteCounter),
/* harmony export */   "sign": () => (/* binding */ __webpack_exports__sign),
/* harmony export */   "toDegrees": () => (/* binding */ __webpack_exports__toDegrees),
/* harmony export */   "toRadians": () => (/* binding */ __webpack_exports__toRadians),
/* harmony export */   "vec": () => (/* binding */ __webpack_exports__vec),
/* harmony export */   "webgl": () => (/* binding */ __webpack_exports__webgl)
/* harmony export */ });
/*!
 * excalibur - 0.27.0 - 2022-7-8
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2022 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
/******/ var __webpack_modules__ = ({

/***/ 4662:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_314__) => {

__nested_webpack_require_314__(3430);
var entryUnbind = __nested_webpack_require_314__(8791);

module.exports = entryUnbind('Array', 'sort');


/***/ }),

/***/ 8343:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_528__) => {

__nested_webpack_require_528__(4769);
var path = __nested_webpack_require_528__(9276);

module.exports = path.Object.keys;


/***/ }),

/***/ 7111:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_723__) => {

var isCallable = __nested_webpack_require_723__(6733);
var tryToString = __nested_webpack_require_723__(9821);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1131__) => {

var isObject = __nested_webpack_require_1131__(5052);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9540:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1503__) => {

var toIndexedObject = __nested_webpack_require_1503__(905);
var toAbsoluteIndex = __nested_webpack_require_1503__(3231);
var lengthOfArrayLike = __nested_webpack_require_1503__(9646);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6038:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2862__) => {


var fails = __nested_webpack_require_2862__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ 9794:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3268__) => {

var toAbsoluteIndex = __nested_webpack_require_3268__(3231);
var lengthOfArrayLike = __nested_webpack_require_3268__(9646);
var createProperty = __nested_webpack_require_3268__(2324);

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ 3867:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3897__) => {

var arraySlice = __nested_webpack_require_3897__(9794);

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;


/***/ }),

/***/ 7079:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_5163__) => {

var uncurryThis = __nested_webpack_require_5163__(5968);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_5465__) => {

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_5465__(1601);
var isCallable = __nested_webpack_require_5465__(6733);
var classofRaw = __nested_webpack_require_5465__(7079);
var wellKnownSymbol = __nested_webpack_require_5465__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7081:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_6579__) => {

var hasOwn = __nested_webpack_require_6579__(8270);
var ownKeys = __nested_webpack_require_6579__(4826);
var getOwnPropertyDescriptorModule = __nested_webpack_require_6579__(7933);
var definePropertyModule = __nested_webpack_require_6579__(1787);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 5762:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7302__) => {

var DESCRIPTORS = __nested_webpack_require_7302__(7400);
var definePropertyModule = __nested_webpack_require_7302__(1787);
var createPropertyDescriptor = __nested_webpack_require_7302__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2324:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7998__) => {


var toPropertyKey = __nested_webpack_require_7998__(9310);
var definePropertyModule = __nested_webpack_require_7998__(1787);
var createPropertyDescriptor = __nested_webpack_require_7998__(5358);

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 4768:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8491__) => {

var isCallable = __nested_webpack_require_8491__(6733);
var definePropertyModule = __nested_webpack_require_8491__(1787);
var makeBuiltIn = __nested_webpack_require_8491__(6039);
var defineGlobalProperty = __nested_webpack_require_8491__(8400);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 8400:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9486__) => {

var global = __nested_webpack_require_9486__(9859);

// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 9563:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9934__) => {


var tryToString = __nested_webpack_require_9934__(9821);

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ 7400:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10250__) => {

var fails = __nested_webpack_require_10250__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10650__) => {

var global = __nested_webpack_require_10650__(9859);
var isObject = __nested_webpack_require_10650__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_11071__) => {

var userAgent = __nested_webpack_require_11071__(598);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_11302__) => {

var UA = __nested_webpack_require_11302__(598);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_11473__) => {

var getBuiltIn = __nested_webpack_require_11473__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_11673__) => {

var global = __nested_webpack_require_11673__(9859);
var userAgent = __nested_webpack_require_11673__(598);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_12595__) => {

var userAgent = __nested_webpack_require_12595__(598);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 8791:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_12828__) => {

var global = __nested_webpack_require_12828__(9859);
var uncurryThis = __nested_webpack_require_12828__(5968);

module.exports = function (CONSTRUCTOR, METHOD) {
  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);
};


/***/ }),

/***/ 3837:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_13347__) => {

var global = __nested_webpack_require_13347__(9859);
var getOwnPropertyDescriptor = (__nested_webpack_require_13347__(7933).f);
var createNonEnumerableProperty = __nested_webpack_require_13347__(5762);
var defineBuiltIn = __nested_webpack_require_13347__(4768);
var defineGlobalProperty = __nested_webpack_require_13347__(8400);
var copyConstructorProperties = __nested_webpack_require_13347__(7081);
var isForced = __nested_webpack_require_13347__(6541);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 7188:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_16131__) => {

var fails = __nested_webpack_require_16131__(4229);

module.exports = !fails(function () {
  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 266:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_16559__) => {

var NATIVE_BIND = __nested_webpack_require_16559__(7188);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 1805:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_16840__) => {

var DESCRIPTORS = __nested_webpack_require_16840__(7400);
var hasOwn = __nested_webpack_require_16840__(8270);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 5968:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_17622__) => {

var NATIVE_BIND = __nested_webpack_require_17622__(7188);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_18107__) => {

var global = __nested_webpack_require_18107__(9859);
var isCallable = __nested_webpack_require_18107__(6733);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5300:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_18544__) => {

var aCallable = __nested_webpack_require_18544__(7111);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_18868__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es-x/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __nested_webpack_require_18868__.g == 'object' && __nested_webpack_require_18868__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 8270:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_19584__) => {

var uncurryThis = __nested_webpack_require_19584__(5968);
var toObject = __nested_webpack_require_19584__(2991);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es-x/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 4394:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20140__) => {

var DESCRIPTORS = __nested_webpack_require_20140__(7400);
var fails = __nested_webpack_require_20140__(4229);
var createElement = __nested_webpack_require_20140__(2635);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 9337:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20662__) => {

var uncurryThis = __nested_webpack_require_20662__(5968);
var fails = __nested_webpack_require_20662__(4229);
var classof = __nested_webpack_require_20662__(7079);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 8511:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21331__) => {

var uncurryThis = __nested_webpack_require_21331__(5968);
var isCallable = __nested_webpack_require_21331__(6733);
var store = __nested_webpack_require_21331__(5353);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 6407:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21849__) => {

var NATIVE_WEAK_MAP = __nested_webpack_require_21849__(8694);
var global = __nested_webpack_require_21849__(9859);
var uncurryThis = __nested_webpack_require_21849__(5968);
var isObject = __nested_webpack_require_21849__(5052);
var createNonEnumerableProperty = __nested_webpack_require_21849__(5762);
var hasOwn = __nested_webpack_require_21849__(8270);
var shared = __nested_webpack_require_21849__(5353);
var sharedKey = __nested_webpack_require_21849__(4399);
var hiddenKeys = __nested_webpack_require_21849__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 6733:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 6541:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_24068__) => {

var fails = __nested_webpack_require_24068__(4229);
var isCallable = __nested_webpack_require_24068__(6733);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_24766__) => {

var isCallable = __nested_webpack_require_24766__(6733);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 4231:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 9395:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_25075__) => {

var getBuiltIn = __nested_webpack_require_25075__(1333);
var isCallable = __nested_webpack_require_25075__(6733);
var isPrototypeOf = __nested_webpack_require_25075__(1321);
var USE_SYMBOL_AS_UID = __nested_webpack_require_25075__(6969);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 9646:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_25604__) => {

var toLength = __nested_webpack_require_25604__(4237);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 6039:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_25901__) => {

var fails = __nested_webpack_require_25901__(4229);
var isCallable = __nested_webpack_require_25901__(6733);
var hasOwn = __nested_webpack_require_25901__(8270);
var DESCRIPTORS = __nested_webpack_require_25901__(7400);
var CONFIGURABLE_FUNCTION_NAME = (__nested_webpack_require_25901__(1805).CONFIGURABLE);
var inspectSource = __nested_webpack_require_25901__(8511);
var InternalStateModule = __nested_webpack_require_25901__(6407);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (String(name).slice(0, 7) === 'Symbol(') {
    name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 917:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es-x/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 3839:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_28622__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var V8_VERSION = __nested_webpack_require_28622__(6358);
var fails = __nested_webpack_require_28622__(4229);

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8694:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_29409__) => {

var global = __nested_webpack_require_29409__(9859);
var isCallable = __nested_webpack_require_29409__(6733);
var inspectSource = __nested_webpack_require_29409__(8511);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 1787:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_29750__) => {

var DESCRIPTORS = __nested_webpack_require_29750__(7400);
var IE8_DOM_DEFINE = __nested_webpack_require_29750__(4394);
var V8_PROTOTYPE_DEFINE_BUG = __nested_webpack_require_29750__(7137);
var anObject = __nested_webpack_require_29750__(1176);
var toPropertyKey = __nested_webpack_require_29750__(9310);

var $TypeError = TypeError;
// eslint-disable-next-line es-x/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_31658__) => {

var DESCRIPTORS = __nested_webpack_require_31658__(7400);
var call = __nested_webpack_require_31658__(266);
var propertyIsEnumerableModule = __nested_webpack_require_31658__(9195);
var createPropertyDescriptor = __nested_webpack_require_31658__(5358);
var toIndexedObject = __nested_webpack_require_31658__(905);
var toPropertyKey = __nested_webpack_require_31658__(9310);
var hasOwn = __nested_webpack_require_31658__(8270);
var IE8_DOM_DEFINE = __nested_webpack_require_31658__(4394);

// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8151:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_32743__) => {

var internalObjectKeys = __nested_webpack_require_32743__(140);
var enumBugKeys = __nested_webpack_require_32743__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1321:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33474__) => {

var uncurryThis = __nested_webpack_require_33474__(5968);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 140:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33661__) => {

var uncurryThis = __nested_webpack_require_33661__(5968);
var hasOwn = __nested_webpack_require_33661__(8270);
var toIndexedObject = __nested_webpack_require_33661__(905);
var indexOf = (__nested_webpack_require_33661__(9540).indexOf);
var hiddenKeys = __nested_webpack_require_33661__(5977);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_34390__) => {

var internalObjectKeys = __nested_webpack_require_34390__(140);
var enumBugKeys = __nested_webpack_require_34390__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es-x/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ ((__unused_webpack_module, exports) => {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_35508__) => {

var call = __nested_webpack_require_35508__(266);
var isCallable = __nested_webpack_require_35508__(6733);
var isObject = __nested_webpack_require_35508__(5052);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4826:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_36276__) => {

var getBuiltIn = __nested_webpack_require_36276__(1333);
var uncurryThis = __nested_webpack_require_36276__(5968);
var getOwnPropertyNamesModule = __nested_webpack_require_36276__(8151);
var getOwnPropertySymbolsModule = __nested_webpack_require_36276__(894);
var anObject = __nested_webpack_require_36276__(1176);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_36992__) => {

var global = __nested_webpack_require_36992__(9859);

module.exports = global;


/***/ }),

/***/ 8885:
/***/ ((module) => {

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 4399:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_37450__) => {

var shared = __nested_webpack_require_37450__(3036);
var uid = __nested_webpack_require_37450__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_37733__) => {

var global = __nested_webpack_require_37733__(9859);
var defineGlobalProperty = __nested_webpack_require_37733__(8400);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_38046__) => {

var IS_PURE = __nested_webpack_require_38046__(4231);
var store = __nested_webpack_require_38046__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.23.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 3231:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_38600__) => {

var toIntegerOrInfinity = __nested_webpack_require_38600__(3329);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 905:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_39143__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __nested_webpack_require_39143__(9337);
var requireObjectCoercible = __nested_webpack_require_39143__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 3329:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_39486__) => {

var trunc = __nested_webpack_require_39486__(917);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 4237:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_39906__) => {

var toIntegerOrInfinity = __nested_webpack_require_39906__(3329);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_40308__) => {

var requireObjectCoercible = __nested_webpack_require_40308__(8885);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2066:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_40650__) => {

var call = __nested_webpack_require_40650__(266);
var isObject = __nested_webpack_require_40650__(5052);
var isSymbol = __nested_webpack_require_40650__(9395);
var getMethod = __nested_webpack_require_40650__(5300);
var ordinaryToPrimitive = __nested_webpack_require_40650__(2914);
var wellKnownSymbol = __nested_webpack_require_40650__(95);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 9310:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41669__) => {

var toPrimitive = __nested_webpack_require_41669__(2066);
var isSymbol = __nested_webpack_require_41669__(9395);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_42063__) => {

var wellKnownSymbol = __nested_webpack_require_42063__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3326:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_42349__) => {

var classof = __nested_webpack_require_42349__(1589);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 9821:
/***/ ((module) => {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 1441:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_42873__) => {

var uncurryThis = __nested_webpack_require_42873__(5968);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_43225__) => {

/* eslint-disable es-x/no-symbol -- required for testing */
var NATIVE_SYMBOL = __nested_webpack_require_43225__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 7137:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_43517__) => {

var DESCRIPTORS = __nested_webpack_require_43517__(7400);
var fails = __nested_webpack_require_43517__(4229);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 95:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_44041__) => {

var global = __nested_webpack_require_44041__(9859);
var shared = __nested_webpack_require_44041__(3036);
var hasOwn = __nested_webpack_require_44041__(8270);
var uid = __nested_webpack_require_44041__(1441);
var NATIVE_SYMBOL = __nested_webpack_require_44041__(3839);
var USE_SYMBOL_AS_UID = __nested_webpack_require_44041__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3430:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_45150__) => {


var $ = __nested_webpack_require_45150__(3103);
var uncurryThis = __nested_webpack_require_45150__(5968);
var aCallable = __nested_webpack_require_45150__(7111);
var toObject = __nested_webpack_require_45150__(2991);
var lengthOfArrayLike = __nested_webpack_require_45150__(9646);
var deletePropertyOrThrow = __nested_webpack_require_45150__(9563);
var toString = __nested_webpack_require_45150__(3326);
var fails = __nested_webpack_require_45150__(4229);
var internalSort = __nested_webpack_require_45150__(3867);
var arrayMethodIsStrict = __nested_webpack_require_45150__(6038);
var FF = __nested_webpack_require_45150__(2671);
var IE_OR_EDGE = __nested_webpack_require_45150__(8506);
var V8 = __nested_webpack_require_45150__(6358);
var WEBKIT = __nested_webpack_require_45150__(9811);

var test = [];
var un$Sort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_48306__) => {

var $ = __nested_webpack_require_48306__(3103);
var toObject = __nested_webpack_require_48306__(2991);
var nativeKeys = __nested_webpack_require_48306__(5632);
var fails = __nested_webpack_require_48306__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 1388:
/***/ ((module, __webpack_exports__, __nested_webpack_require_48830__) => {

/* harmony export */ __nested_webpack_require_48830__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_48830__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_48830__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_48830__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_48830__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://./Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 7379:
/***/ ((module, __webpack_exports__, __nested_webpack_require_56383__) => {

/* harmony export */ __nested_webpack_require_56383__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_56383__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_56383__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_56383__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_56383__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\r\n#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}", "",{"version":3,"sources":["webpack://./Util/Toaster.css"],"names":[],"mappings":";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB","sourcesContent":["\r\n#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2609:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 272:
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nested_webpack_require_62364__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_62364__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_62364__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__nested_webpack_require_62364__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_62364__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_62364__.o(definition, key) && !__nested_webpack_require_62364__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__nested_webpack_require_62364__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_62364__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_62364__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__nested_webpack_require_62364__.d(__webpack_exports__, {
  "fWn": () => (/* reexport */ ActionContext),
  "Ia8": () => (/* reexport */ ActionQueue),
  "rqv": () => (/* reexport */ ActionSequence),
  "hLI": () => (/* reexport */ ActionsComponent),
  "yyv": () => (/* reexport */ ActionsSystem),
  "tX5": () => (/* reexport */ ActivateEvent),
  "vtX": () => (/* reexport */ Actor),
  "r7K": () => (/* reexport */ AddedComponent),
  "lCh": () => (/* reexport */ AddedEntity),
  "cE4": () => (/* reexport */ AffineMatrix),
  "fwF": () => (/* reexport */ Animation),
  "sce": () => (/* reexport */ AnimationDirection),
  "_c7": () => (/* reexport */ AnimationStrategy),
  "KUs": () => (/* reexport */ ArcadeSolver),
  "Ajp": () => (/* reexport */ AudioContextFactory),
  "RDh": () => (/* reexport */ Axis),
  "_H9": () => (/* reexport */ BaseAlign),
  "mxs": () => (/* reexport */ Blink),
  "OmD": () => (/* reexport */ BodyComponent),
  "kBf": () => (/* reexport */ BoundingBox),
  "C4F": () => (/* reexport */ BroadphaseStrategy),
  "NQt": () => (/* reexport */ BrowserComponent),
  "JjN": () => (/* reexport */ BrowserEvents),
  "V1s": () => (/* reexport */ Camera),
  "Xz7": () => (/* reexport */ Canvas),
  "Cdc": () => (/* reexport */ Circle),
  "FKn": () => (/* reexport */ CircleCollider),
  "wTW": () => (/* reexport */ Class),
  "SUY": () => (/* reexport */ Clock),
  "ab2": () => (/* reexport */ ClosestLine),
  "GfZ": () => (/* reexport */ ClosestLineJumpTable),
  "YMS": () => (/* reexport */ Collider),
  "oyv": () => (/* reexport */ ColliderComponent),
  "aUb": () => (/* reexport */ CollisionContact),
  "SdD": () => (/* reexport */ CollisionEndEvent),
  "JUv": () => (/* reexport */ CollisionGroup),
  "jEj": () => (/* reexport */ CollisionGroupManager),
  "TFq": () => (/* reexport */ CollisionJumpTable),
  "HDU": () => (/* reexport */ CollisionPostSolveEvent),
  "R_y": () => (/* reexport */ CollisionPreSolveEvent),
  "ydN": () => (/* reexport */ CollisionResolutionStrategy),
  "t50": () => (/* reexport */ CollisionStartEvent),
  "s$$": () => (/* reexport */ CollisionSystem),
  "v2G": () => (/* reexport */ CollisionType),
  "Ilk": () => (/* reexport */ Color),
  "s9i": () => (/* reexport */ ColorBlindFlags),
  "dxL": () => (/* reexport */ ColorBlindnessMode),
  "LLX": () => (/* reexport */ ColorBlindnessPostProcessor),
  "wA2": () => (/* reexport */ Component),
  "R_p": () => (/* reexport */ CompositeCollider),
  "IQ$": () => (/* reexport */ Configurable),
  "I5F": () => (/* reexport */ ConsoleAppender),
  "X8$": () => (/* reexport */ ContactConstraintPoint),
  "FR6": () => (/* reexport */ ContactEndEvent),
  "U8o": () => (/* reexport */ ContactStartEvent),
  "kbG": () => (/* reexport */ CoordPlane),
  "iS_": () => (/* reexport */ DeactivateEvent),
  "cGG": () => (/* reexport */ Debug),
  "RPN": () => (/* reexport */ DebugGraphicsComponent),
  "skb": () => (/* reexport */ DebugSystem),
  "SLU": () => (/* reexport */ DebugText),
  "RdJ": () => (/* reexport */ DegreeOfFreedom),
  "cNu": () => (/* reexport */ Delay),
  "gU7": () => (/* reexport */ Detector),
  "LSk": () => (/* reexport */ Die),
  "Nmp": () => (/* reexport */ Direction),
  "d1Y": () => (/* reexport */ DisplayMode),
  "xrL": () => (/* reexport */ DynamicTree),
  "sRW": () => (/* reexport */ DynamicTreeCollisionProcessor),
  "cmV": () => (/* binding */ EX_VERSION),
  "qWz": () => (/* reexport */ EaseBy),
  "N0Q": () => (/* reexport */ EaseTo),
  "q8b": () => (/* reexport */ EasingFunctions),
  "ynB": () => (/* reexport */ EdgeCollider),
  "jT9": () => (/* reexport */ ElasticToActorStrategy),
  "wAz": () => (/* reexport */ EmitterType),
  "D4V": () => (/* reexport */ Engine),
  "N6H": () => (/* reexport */ EnterTriggerEvent),
  "W1A": () => (/* reexport */ EnterViewPortEvent),
  "JHW": () => (/* reexport */ Entity),
  "v2K": () => (/* reexport */ EntityManager),
  "pBf": () => (/* reexport */ EventDispatcher),
  "GMl": () => (/* reexport */ EventTypes),
  "zW2": () => (/* reexport */ Events_namespaceObject),
  "B0K": () => (/* reexport */ ExResponse),
  "Nv7": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),
  "C_p": () => (/* reexport */ ExcaliburGraphicsContextWebGL),
  "iqw": () => (/* reexport */ ExcaliburWebGLContextAccessor),
  "MUA": () => (/* reexport */ ExitTriggerEvent),
  "xqU": () => (/* reexport */ ExitViewPortEvent),
  "pTp": () => (/* reexport */ Fade),
  "vUK": () => (/* reexport */ Flags),
  "j9l": () => (/* reexport */ Follow),
  "Zxw": () => (/* reexport */ Font),
  "Hdx": () => (/* reexport */ FontStyle),
  "Z$d": () => (/* reexport */ FontUnit),
  "iqV": () => (/* reexport */ FpsSampler),
  "o$7": () => (/* reexport */ FrameStats),
  "olM": () => (/* reexport */ Future),
  "Zm$": () => (/* reexport */ GameEvent),
  "$QH": () => (/* reexport */ GameStartEvent),
  "i78": () => (/* reexport */ GameStopEvent),
  "h6u": () => (/* reexport */ GamepadAxisEvent),
  "hts": () => (/* reexport */ GamepadButtonEvent),
  "j88": () => (/* reexport */ GamepadConnectEvent),
  "VME": () => (/* reexport */ GamepadDisconnectEvent),
  "nt": () => (/* reexport */ Gif),
  "Ukr": () => (/* reexport */ GlobalCoordinates),
  "zsu": () => (/* reexport */ Graphic),
  "oA6": () => (/* reexport */ GraphicsComponent),
  "TVh": () => (/* reexport */ GraphicsGroup),
  "TwZ": () => (/* reexport */ GraphicsLayer),
  "GTT": () => (/* reexport */ GraphicsLayers),
  "xxj": () => (/* reexport */ GraphicsSystem),
  "XdK": () => (/* reexport */ HiddenEvent),
  "Jmb": () => (/* reexport */ ImageFiltering),
  "cXo": () => (/* reexport */ ImageSource),
  "Dm5": () => (/* reexport */ InitializeEvent),
  "IIB": () => (/* reexport */ Input_Index_namespaceObject),
  "zI0": () => (/* reexport */ Integrator),
  "LYD": () => (/* reexport */ IsometricEntityComponent),
  "cEG": () => (/* reexport */ IsometricEntitySystem),
  "SEl": () => (/* reexport */ IsometricMap),
  "t9V": () => (/* reexport */ IsometricTile),
  "SKZ": () => (/* reexport */ KillEvent),
  "__J": () => (/* reexport */ Label),
  "RI$": () => (/* reexport */ LimitCameraBoundsStrategy),
  "x12": () => (/* reexport */ Line),
  "ccz": () => (/* reexport */ LineSegment),
  "aNw": () => (/* reexport */ Loader),
  "xwn": () => (/* reexport */ LockCameraToActorAxisStrategy),
  "dNK": () => (/* reexport */ LockCameraToActorStrategy),
  "ini": () => (/* reexport */ LogLevel),
  "YdH": () => (/* reexport */ Logger),
  "y3G": () => (/* reexport */ Matrix),
  "l57": () => (/* reexport */ MatrixLocations),
  "xn0": () => (/* reexport */ MediaEvent),
  "t2V": () => (/* reexport */ Meet),
  "uxB": () => (/* reexport */ MotionComponent),
  "cpd": () => (/* reexport */ MotionSystem),
  "fiy": () => (/* reexport */ MoveBy),
  "$XZ": () => (/* reexport */ MoveTo),
  "uqK": () => (/* reexport */ NativeSoundEvent),
  "STE": () => (/* reexport */ NativeSoundProcessedEvent),
  "y$z": () => (/* reexport */ Observable),
  "mAD": () => (/* reexport */ OffscreenSystem),
  "sOq": () => (/* reexport */ Pair),
  "hUw": () => (/* reexport */ ParallaxComponent),
  "_0G": () => (/* reexport */ ParallelActions),
  "Sqs": () => (/* reexport */ ParseGif),
  "hpZ": () => (/* reexport */ Particle),
  "Vol": () => (/* reexport */ ParticleEmitter),
  "wIZ": () => (/* reexport */ Physics),
  "cBi": () => (/* reexport */ PhysicsStats),
  "RFv": () => (/* reexport */ PointerComponent),
  "kfC": () => (/* reexport */ PointerSystem),
  "mgq": () => (/* reexport */ Polygon),
  "YVA": () => (/* reexport */ PolygonCollider),
  "Kgp": () => (/* reexport */ Pool),
  "HH$": () => (/* reexport */ PostCollisionEvent),
  "M_d": () => (/* reexport */ PostDebugDrawEvent),
  "rgh": () => (/* reexport */ PostDrawEvent),
  "Ra6": () => (/* reexport */ PostFrameEvent),
  "KhR": () => (/* reexport */ PostKillEvent),
  "BS5": () => (/* reexport */ PostUpdateEvent),
  "xhz": () => (/* reexport */ PreCollisionEvent),
  "xOq": () => (/* reexport */ PreDebugDrawEvent),
  "a9j": () => (/* reexport */ PreDrawEvent),
  "bHk": () => (/* reexport */ PreFrameEvent),
  "CgK": () => (/* reexport */ PreKillEvent),
  "cuY": () => (/* reexport */ PreUpdateEvent),
  "kvE": () => (/* reexport */ Projection),
  "SBu": () => (/* reexport */ QuadIndexBuffer),
  "AE_": () => (/* reexport */ Query),
  "ctO": () => (/* reexport */ QueryManager),
  "OLH": () => (/* reexport */ RadiusAroundActorStrategy),
  "kky": () => (/* reexport */ Random),
  "nSF": () => (/* reexport */ Raster),
  "zHn": () => (/* reexport */ Ray),
  "zwx": () => (/* reexport */ RealisticSolver),
  "AeJ": () => (/* reexport */ Rectangle),
  "hLz": () => (/* reexport */ RemovedComponent),
  "D9g": () => (/* reexport */ RemovedEntity),
  "wA": () => (/* reexport */ Repeat),
  "jhr": () => (/* reexport */ RepeatForever),
  "GVs": () => (/* reexport */ Resolution),
  "_zO": () => (/* reexport */ Resource),
  "w6$": () => (/* reexport */ RotateBy),
  "mhV": () => (/* reexport */ RotateTo),
  "MOD": () => (/* reexport */ RotationType),
  "kwd": () => (/* reexport */ ScaleBy),
  "Lmr": () => (/* reexport */ ScaleTo),
  "xsS": () => (/* reexport */ Scene),
  "lLr": () => (/* reexport */ Screen),
  "Z$r": () => (/* reexport */ ScreenAppender),
  "IXb": () => (/* reexport */ ScreenElement),
  "SGH": () => (/* reexport */ ScreenShader),
  "SMj": () => (/* reexport */ ScrollPreventionMode),
  "L34": () => (/* reexport */ Semaphore),
  "exe": () => (/* reexport */ Shader),
  "bnF": () => (/* reexport */ Shape),
  "MFA": () => (/* reexport */ Side),
  "$uU": () => (/* reexport */ Sound),
  "jyi": () => (/* reexport */ Sprite),
  "E03": () => (/* reexport */ SpriteFont),
  "V6q": () => (/* reexport */ SpriteSheet),
  "rg2": () => (/* reexport */ StandardClock),
  "DVW": () => (/* reexport */ StateMachine),
  "nVo": () => (/* reexport */ StrategyContainer),
  "F6N": () => (/* reexport */ Stream),
  "xP7": () => (/* reexport */ System),
  "Odq": () => (/* reexport */ SystemManager),
  "Zif": () => (/* reexport */ SystemType),
  "ZGJ": () => (/* reexport */ TagComponent),
  "MJk": () => (/* reexport */ TestClock),
  "xvT": () => (/* reexport */ Text),
  "PHM": () => (/* reexport */ TextAlign),
  "dpR": () => (/* reexport */ TextureLoader),
  "n9L": () => (/* reexport */ Tile),
  "KwO": () => (/* reexport */ TileMap),
  "B7y": () => (/* reexport */ Timer),
  "x7r": () => (/* reexport */ Toaster),
  "wx7": () => (/* reexport */ Transform),
  "Uvn": () => (/* reexport */ TransformComponent),
  "OFT": () => (/* reexport */ TreeNode),
  "xzN": () => (/* reexport */ Trigger),
  "M5Z": () => (/* reexport */ TwoPI),
  "ZrN": () => (/* reexport */ Util_Index_namespaceObject),
  "OWs": () => (/* reexport */ Vector),
  "dF9": () => (/* reexport */ VectorView),
  "oZy": () => (/* reexport */ VertexBuffer),
  "rD2": () => (/* reexport */ VertexLayout),
  "VHo": () => (/* reexport */ VisibleEvent),
  "ohE": () => (/* reexport */ WebAudio),
  "R$E": () => (/* reexport */ WebAudioInstance),
  "q3I": () => (/* reexport */ World),
  "Pab": () => (/* reexport */ canonicalizeAngle),
  "uZ5": () => (/* reexport */ clamp),
  "McK": () => (/* reexport */ createId),
  "F9c": () => (/* reexport */ frac),
  "k0b": () => (/* reexport */ hasGraphicsTick),
  "hnT": () => (/* reexport */ hasOnInitialize),
  "RSJ": () => (/* reexport */ hasOnPostUpdate),
  "Mku": () => (/* reexport */ hasOnPreUpdate),
  "h90": () => (/* reexport */ hasPostDraw),
  "rms": () => (/* reexport */ hasPreDraw),
  "ErP": () => (/* reexport */ has_initialize),
  "aVg": () => (/* reexport */ has_postupdate),
  "lPc": () => (/* reexport */ has_preupdate),
  "Z8E": () => (/* reexport */ isAddedComponent),
  "_N2": () => (/* reexport */ isAddedSystemEntity),
  "yFn": () => (/* reexport */ isRemoveSystemEntity),
  "lNv": () => (/* reexport */ isRemovedComponent),
  "cu9": () => (/* reexport */ isScreenElement),
  "MZQ": () => (/* reexport */ maxMessages),
  "FUM": () => (/* reexport */ obsolete),
  "BxR": () => (/* reexport */ pixelSnapEpsilon),
  "vdf": () => (/* reexport */ randomInRange),
  "iaL": () => (/* reexport */ randomIntInRange),
  "w6H": () => (/* reexport */ range),
  "Q4c": () => (/* reexport */ resetObsoleteCounter),
  "Xxe": () => (/* reexport */ sign),
  "Uxb": () => (/* reexport */ toDegrees),
  "Yr5": () => (/* reexport */ toRadians),
  "Bhw": () => (/* reexport */ vec),
  "yOA": () => (/* reexport */ webgl_util_namespaceObject)
});

// NAMESPACE OBJECT: ./Events.ts
var Events_namespaceObject = {};
__nested_webpack_require_62364__.r(Events_namespaceObject);
__nested_webpack_require_62364__.d(Events_namespaceObject, {
  "ActivateEvent": () => (ActivateEvent),
  "CollisionEndEvent": () => (CollisionEndEvent),
  "CollisionPostSolveEvent": () => (CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (CollisionPreSolveEvent),
  "CollisionStartEvent": () => (CollisionStartEvent),
  "ContactEndEvent": () => (ContactEndEvent),
  "ContactStartEvent": () => (ContactStartEvent),
  "DeactivateEvent": () => (DeactivateEvent),
  "EnterTriggerEvent": () => (EnterTriggerEvent),
  "EnterViewPortEvent": () => (EnterViewPortEvent),
  "EventTypes": () => (EventTypes),
  "ExitTriggerEvent": () => (ExitTriggerEvent),
  "ExitViewPortEvent": () => (ExitViewPortEvent),
  "GameEvent": () => (GameEvent),
  "GameStartEvent": () => (GameStartEvent),
  "GameStopEvent": () => (GameStopEvent),
  "GamepadAxisEvent": () => (GamepadAxisEvent),
  "GamepadButtonEvent": () => (GamepadButtonEvent),
  "GamepadConnectEvent": () => (GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (GamepadDisconnectEvent),
  "HiddenEvent": () => (HiddenEvent),
  "InitializeEvent": () => (InitializeEvent),
  "KillEvent": () => (KillEvent),
  "PostCollisionEvent": () => (PostCollisionEvent),
  "PostDebugDrawEvent": () => (PostDebugDrawEvent),
  "PostDrawEvent": () => (PostDrawEvent),
  "PostFrameEvent": () => (PostFrameEvent),
  "PostKillEvent": () => (PostKillEvent),
  "PostUpdateEvent": () => (PostUpdateEvent),
  "PreCollisionEvent": () => (PreCollisionEvent),
  "PreDebugDrawEvent": () => (PreDebugDrawEvent),
  "PreDrawEvent": () => (PreDrawEvent),
  "PreFrameEvent": () => (PreFrameEvent),
  "PreKillEvent": () => (PreKillEvent),
  "PreUpdateEvent": () => (PreUpdateEvent),
  "VisibleEvent": () => (VisibleEvent)
});

// NAMESPACE OBJECT: ./Graphics/Context/webgl-util.ts
var webgl_util_namespaceObject = {};
__nested_webpack_require_62364__.r(webgl_util_namespaceObject);
__nested_webpack_require_62364__.d(webgl_util_namespaceObject, {
  "getAttributeComponentSize": () => (getAttributeComponentSize),
  "getAttributePointerType": () => (getAttributePointerType),
  "getGlTypeSizeBytes": () => (getGlTypeSizeBytes)
});

// NAMESPACE OBJECT: ./Util/DrawUtil.ts
var DrawUtil_namespaceObject = {};
__nested_webpack_require_62364__.r(DrawUtil_namespaceObject);
__nested_webpack_require_62364__.d(DrawUtil_namespaceObject, {
  "circle": () => (circle),
  "line": () => (line),
  "point": () => (point),
  "roundRect": () => (roundRect),
  "vector": () => (vector)
});

// NAMESPACE OBJECT: ./Input/Index.ts
var Input_Index_namespaceObject = {};
__nested_webpack_require_62364__.r(Input_Index_namespaceObject);
__nested_webpack_require_62364__.d(Input_Index_namespaceObject, {
  "Axes": () => (Axes),
  "Buttons": () => (Buttons),
  "Gamepad": () => (Gamepad),
  "Gamepads": () => (Gamepads),
  "KeyEvent": () => (KeyEvent),
  "Keyboard": () => (Keyboard),
  "Keys": () => (Keys),
  "NativePointerButton": () => (NativePointerButton),
  "PointerButton": () => (PointerButton),
  "PointerComponent": () => (PointerComponent),
  "PointerEvent": () => (PointerEvent),
  "PointerEventReceiver": () => (PointerEventReceiver),
  "PointerScope": () => (PointerScope),
  "PointerSystem": () => (PointerSystem),
  "PointerType": () => (PointerType),
  "WheelDeltaMode": () => (WheelDeltaMode),
  "WheelEvent": () => (WheelEvent)
});

// NAMESPACE OBJECT: ./Util/Index.ts
var Util_Index_namespaceObject = {};
__nested_webpack_require_62364__.r(Util_Index_namespaceObject);
__nested_webpack_require_62364__.d(Util_Index_namespaceObject, {
  "ConsoleAppender": () => (ConsoleAppender),
  "DrawUtil": () => (DrawUtil_namespaceObject),
  "EasingFunctions": () => (EasingFunctions),
  "LogLevel": () => (LogLevel),
  "Logger": () => (Logger),
  "Observable": () => (Observable),
  "ScreenAppender": () => (ScreenAppender),
  "addItemToArray": () => (addItemToArray),
  "contains": () => (contains),
  "delay": () => (delay),
  "fail": () => (fail),
  "getPosition": () => (getPosition),
  "removeItemFromArray": () => (removeItemFromArray)
});

// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js
var sort = __nested_webpack_require_62364__(4662);
// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js
var keys = __nested_webpack_require_62364__(8343);
;// CONCATENATED MODULE: ./Polyfill.ts


/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}

;// CONCATENATED MODULE: ./Flags.ts
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Force excalibur to load the Canvas 2D graphics context fallback
     *
     * @warning not all features of excalibur are supported in the Canvas 2D fallback
     */
    static useCanvasGraphicsContext() {
        Flags.enable('use-canvas-context');
    }
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};

;// CONCATENATED MODULE: ./Id.ts
/**
 * Create a branded ID type from a number
 */
function createId(type, value) {
    return { type, value };
}
;

;// CONCATENATED MODULE: ./Math/Random.ts
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}

;// CONCATENATED MODULE: ./Math/util.ts

/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Returns the fractional part of a number
 * @param x
 */
function frac(x) {
    if (x >= 0) {
        return x - Math.floor(x);
    }
    else {
        return x - Math.ceil(x);
    }
}
/**
 * Returns the sign of a number, if 0 returns 0
 */
function sign(val) {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
}
;
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}

;// CONCATENATED MODULE: ./Math/vector.ts

/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    static min(vec1, vec2) {
        return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));
    }
    static max(vec1, vec2) {
        return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        const deltaX = this.x - v.x;
        const deltaY = this.y - v.y;
        return deltaX * deltaX + deltaY * deltaY;
    }
    /**
     * Clamps the current vector's magnitude mutating it
     * @param magnitude
     */
    clampMagnitude(magnitude) {
        const size = this.size;
        const newSize = clamp(size, 0, magnitude);
        this.size = newSize;
        return this;
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale, dest) {
        const result = dest || new Vector(0, 0);
        if (sizeOrScale instanceof Vector) {
            result.x = this.x * sizeOrScale.x;
            result.y = this.y * sizeOrScale.y;
        }
        else {
            result.x = this.x * sizeOrScale;
            result.y = this.y * sizeOrScale;
        }
        return result;
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     * @param dest Optionally copy the result into a provided vector
     */
    add(v, dest) {
        if (dest) {
            dest.x = this.x + v.x;
            dest.y = this.y + v.y;
            return dest;
        }
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone(dest) {
        const v = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);
        v.x = this.x;
        v.y = this.y;
        return v;
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}

;// CONCATENATED MODULE: ./Util/Log.ts
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}

;// CONCATENATED MODULE: ./Color.ts
/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
}
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}

;// CONCATENATED MODULE: ./Collision/Side.ts

/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction (via dot product)
     */
    function fromDirection(direction) {
        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
        let max = -Number.MAX_VALUE;
        let maxIndex = -1;
        for (let i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));

;// CONCATENATED MODULE: ./Collision/BoundingBox.ts



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Returns a new instance of [[BoundingBox]] that is a copy of the current instance
     */
    clone() {
        return new BoundingBox(this.left, this.top, this.right, this.bottom);
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return Side.Right;
                }
                return Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return Side.Bottom;
                }
                return Side.Top;
            }
        }
        return Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Scale a bounding box by a scale factor, optionally provide a point
     * @param scale
     * @param point
     */
    scale(scale, point = Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    /**
     * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box
     * @param matrix
     */
    transform(matrix) {
        // inlined these calculations to not use vectors would speed it up slightly
        // const matFirstColumn = vec(matrix.data[0], matrix.data[1]);
        // const xa = matFirstColumn.scale(this.left);
        const xa1 = matrix.data[0] * this.left;
        const xa2 = matrix.data[1] * this.left;
        // const xb = matFirstColumn.scale(this.right);
        const xb1 = matrix.data[0] * this.right;
        const xb2 = matrix.data[1] * this.right;
        // const matSecondColumn = vec(matrix.data[2], matrix.data[3]);
        // const ya = matSecondColumn.scale(this.top);
        const ya1 = matrix.data[2] * this.top;
        const ya2 = matrix.data[3] * this.top;
        // const yb = matSecondColumn.scale(this.bottom);
        const yb1 = matrix.data[2] * this.bottom;
        const yb2 = matrix.data[3] * this.bottom;
        const matrixPos = matrix.getPosition();
        // const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);
        // const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);
        const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;
        const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;
        const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;
        const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;
        return new BoundingBox({
            left,
            top,
            right,
            bottom //: bottomRight.y
        });
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new Vector(this.left, this.top));
        results.push(new Vector(this.right, this.top));
        results.push(new Vector(this.right, this.bottom));
        results.push(new Vector(this.left, this.bottom));
        return results;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof Vector) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new Vector(this.width, this.height);
    }
    /**
     * Returns true if the bounding boxes overlap.
     * @param other
     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
     * This epsilon is useful in stable collision simulations.
     */
    overlaps(other, epsilon) {
        const e = epsilon || 0;
        if (other.hasZeroDimensions()) {
            return this.contains(other);
        }
        if (this.hasZeroDimensions()) {
            return other.contains(this);
        }
        const totalBoundingBox = this.combine(other);
        return totalBoundingBox.width + e < other.width + this.width &&
            totalBoundingBox.height + e < other.height + this.height;
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}

;// CONCATENATED MODULE: ./Util/Future.ts
/**
 * Future is a wrapper around a native browser Promise to allow resolving/rejecting at any time
 */
class Future {
    constructor() {
        this._isCompleted = false;
        this.promise = new Promise((resolve, reject) => {
            this._resolver = resolve;
            this._rejecter = reject;
        });
    }
    get isCompleted() {
        return this._isCompleted;
    }
    resolve(value) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._resolver(value);
    }
    reject(error) {
        if (this._isCompleted) {
            return;
        }
        this._isCompleted = true;
        this._rejecter(error);
    }
}

;// CONCATENATED MODULE: ./Util/Util.ts


/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new Vector(oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Create a promise that resolves after a certain number of milliseconds
 *
 * It is strongly recommended you pass the excalibur clock so delays are bound to the
 * excalibur clock which would be unaffected by stop/pause.
 * @param milliseconds
 * @param clock
 */
function delay(milliseconds, clock) {
    var _a;
    const future = new Future();
    const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;
    schedule(() => {
        future.resolve();
    }, milliseconds);
    return future.promise;
}

;// CONCATENATED MODULE: ./Math/matrix.ts



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- | -------- |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleX = 1;
        this._scaleSignX = 1;
        this._scaleY = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
        const mat = dest || new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static fromFloat32Array(data) {
        const matrix = new Matrix();
        matrix.data = data;
        return matrix;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {Matrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[4] = -Math.sin(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[5] = Math.cos(angleRadians);
        return mat;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof Vector) {
            const result = dest || new Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];
            const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new Matrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            const a31 = this.data[2];
            const a41 = this.data[3];
            const a12 = this.data[4];
            const a22 = this.data[5];
            const a32 = this.data[6];
            const a42 = this.data[7];
            const a13 = this.data[8];
            const a23 = this.data[9];
            const a33 = this.data[10];
            const a43 = this.data[11];
            const a14 = this.data[12];
            const a24 = this.data[13];
            const a34 = this.data[14];
            const a44 = this.data[15];
            const b11 = other.data[0];
            const b21 = other.data[1];
            const b31 = other.data[2];
            const b41 = other.data[3];
            const b12 = other.data[4];
            const b22 = other.data[5];
            const b32 = other.data[6];
            const b42 = other.data[7];
            const b13 = other.data[8];
            const b23 = other.data[9];
            const b33 = other.data[10];
            const b43 = other.data[11];
            const b14 = other.data[12];
            const b24 = other.data[13];
            const b34 = other.data[14];
            const b44 = other.data[15];
            result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            const s = this.getScale();
            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);
            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);
            return result;
        }
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[4]).size;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[5]).size;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (this._scaleX === val) {
            return;
        }
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
        this._scaleX = val;
    }
    setScaleY(val) {
        if (this._scaleY === val) {
            return;
        }
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
        this._scaleY = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    getAffineInverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = target || Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}

;// CONCATENATED MODULE: ./Math/affine-matrix.ts



class AffineMatrix {
    constructor() {
        /**
         * |         |         |          |
         * | ------- | ------- | -------- |
         * | data[0] | data[2] | data[4]  |
         * | data[1] | data[3] | data[5]  |
         * |   0     |    0    |    1     |
         */
        this.data = new Float64Array(6);
        this._scale = new Float64Array([1, 1]);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
        return new DOMMatrix([...this.data]);
    }
    static identity() {
        const mat = new AffineMatrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = AffineMatrix.identity();
        mat.data[4] = x;
        mat.data[5] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = AffineMatrix.identity();
        mat.data[0] = sx;
        mat.data[3] = sy;
        mat._scale[0] = sx;
        mat._scale[1] = sy;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = AffineMatrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[2] = -Math.sin(angleRadians);
        mat.data[3] = Math.cos(angleRadians);
        return mat;
    }
    setPosition(x, y) {
        this.data[4] = x;
        this.data[5] = y;
    }
    getPosition() {
        return vec(this.data[4], this.data[5]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a12 - sine * a11;
        this.data[3] = cosine * a22 - sine * a21;
        return this;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        // const a31 = 0;
        const a12 = this.data[2];
        const a22 = this.data[3];
        // const a32 = 0;
        const a13 = this.data[4];
        const a23 = this.data[5];
        // const a33 = 1;
        // Doesn't change z
        this.data[4] = a11 * x + a12 * y + a13;
        this.data[5] = a21 * x + a22 * y + a23;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a12 * y;
        this.data[3] = a22 * y;
        this._scale[0] = x;
        this._scale[1] = y;
        return this;
    }
    determinant() {
        return this.data[0] * this.data[3] - this.data[1] * this.data[2];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    inverse(target) {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.determinant();
        const inverseDet = 1 / det; // TODO zero check
        const a = this.data[0];
        const b = this.data[2];
        const c = this.data[1];
        const d = this.data[3];
        const m = target || AffineMatrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[2] = -b * inverseDet;
        m.data[3] = a * inverseDet;
        const tx = this.data[4];
        const ty = this.data[5];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[4] = -(tx * m.data[0] + ty * m.data[2]);
        m.data[5] = -(tx * m.data[1] + ty * m.data[3]);
        return m;
    }
    multiply(vectorOrMatrix, dest) {
        if (vectorOrMatrix instanceof Vector) {
            const result = dest || new Vector(0, 0);
            const vector = vectorOrMatrix;
            // these shenanigans are to allow dest and vector to be the same instance
            const resultX = vector.x * this.data[0] + vector.y * this.data[2] + this.data[4];
            const resultY = vector.x * this.data[1] + vector.y * this.data[3] + this.data[5];
            result.x = resultX;
            result.y = resultY;
            return result;
        }
        else {
            const result = dest || new AffineMatrix();
            const other = vectorOrMatrix;
            const a11 = this.data[0];
            const a21 = this.data[1];
            //  const a31 = 0;
            const a12 = this.data[2];
            const a22 = this.data[3];
            //  const a32 = 0;
            const a13 = this.data[4];
            const a23 = this.data[5];
            //  const a33 = 1;
            const b11 = other.data[0];
            const b21 = other.data[1];
            //  const b31 = 0;
            const b12 = other.data[2];
            const b22 = other.data[3];
            //  const b32 = 0;
            const b13 = other.data[4];
            const b23 = other.data[5];
            //  const b33 = 1;
            result.data[0] = a11 * b11 + a12 * b21; // + a13 * b31; // zero
            result.data[1] = a21 * b11 + a22 * b21; // + a23 * b31; // zero
            result.data[2] = a11 * b12 + a12 * b22; // + a13 * b32; // zero
            result.data[3] = a21 * b12 + a22 * b22; // + a23 * b32; // zero
            result.data[4] = a11 * b13 + a12 * b23 + a13; // * b33; // one
            result.data[5] = a21 * b13 + a22 * b23 + a23; // * b33; // one
            const s = this.getScale();
            result._scaleSignX = sign(s.x) * sign(result._scaleSignX);
            result._scaleSignY = sign(s.y) * sign(result._scaleSignY);
            return result;
        }
    }
    to4x4() {
        const mat = new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = this.data[2];
        mat.data[5] = this.data[3];
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = this.data[4];
        mat.data[13] = this.data[5];
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[2] = -sine * currentScale.x;
        this.data[3] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[2]).distance();
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[3]).distance();
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        if (val === this._scale[0]) {
            return;
        }
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[2] = xscale.y * val;
        this._scale[0] = val;
    }
    setScaleY(val) {
        if (val === this._scale[1]) {
            return;
        }
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[3] = yscale.y * val;
        this._scale[1] = val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 1 &&
            this.data[4] === 0 &&
            this.data[5] === 0);
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {AffineMatrix} Current matrix as identity
     */
    reset() {
        const mat = this;
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 1;
        mat.data[4] = 0;
        mat.data[5] = 0;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
        const mat = dest || new AffineMatrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        return mat;
    }
    toString() {
        return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts

class TransformStack {
    constructor() {
        this._transforms = [];
        this._currentTransform = AffineMatrix.identity();
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone();
    }
    restore() {
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts

class StateStack {
    constructor() {
        this._states = [];
        this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
        return {
            opacity: 1,
            z: 0,
            tint: Color.White
        };
    }
    _cloneState() {
        return {
            opacity: this._currentState.opacity,
            z: this._currentState.z,
            tint: this._currentState.tint.clone()
        };
    }
    save() {
        this._states.push(this._currentState);
        this._currentState = this._cloneState();
    }
    restore() {
        this._currentState = this._states.pop();
    }
    get current() {
        return this._currentState;
    }
    set current(val) {
        this._currentState = val;
    }
}

;// CONCATENATED MODULE: ./Events.ts
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
class ContactStartEvent {
    constructor(target, other, contact) {
        this.target = target;
        this.other = other;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(target, other) {
        this.target = target;
        this.other = other;
    }
}
class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
        super();
        this.other = other;
        this.contact = contact;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene activation
     */
    constructor(context, target) {
        super();
        this.context = context;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene deactivation
     */
    constructor(context, target) {
        super();
        this.context = context;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}

;// CONCATENATED MODULE: ./EventDispatcher.ts

class EventDispatcher {
    constructor() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._deferedHandlerRemovals = [];
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    _processDeferredHandlerRemovals() {
        for (const eventHandler of this._deferedHandlerRemovals) {
            this._removeHandler(eventHandler.name, eventHandler.handler);
        }
        this._deferedHandlerRemovals.length = 0;
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        this._processDeferredHandlerRemovals();
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        if (!event) {
            event = new GameEvent();
        }
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i](event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        this._processDeferredHandlerRemovals();
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
        this._deferedHandlerRemovals.push({ name: eventName, handler });
    }
    _removeHandler(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                if (index > -1) {
                    this._handlers[eventName].splice(index, 1);
                }
            }
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this._processDeferredHandlerRemovals();
        const metaHandler = (event) => {
            const ev = event || new GameEvent();
            this.off(eventName, metaHandler);
            handler(ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Resource.ts


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = Logger.getInstance();
        this.events = new EventDispatcher();
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}

;// CONCATENATED MODULE: ./Util/Watch.ts
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}

;// CONCATENATED MODULE: ./Graphics/Graphic.ts




/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].
 * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the
 * [[Graphic]] abstract class.
 *
 * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]
 */
class Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this.id = Graphic._ID++;
        this.transform = AffineMatrix.identity();
        this.tint = null;
        this._transformStale = true;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        this._flipHorizontal = false;
        this._flipVertical = false;
        this._rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        this._scale = Vector.One;
        this._origin = null;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
        }
    }
    isStale() {
        return this._transformStale;
    }
    /**
     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
     */
    get flipHorizontal() {
        return this._flipHorizontal;
    }
    set flipHorizontal(value) {
        this._flipHorizontal = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
     */
    get flipVertical() {
        return this._flipVertical;
    }
    set flipVertical(value) {
        this._flipVertical = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the rotation of the graphic
     */
    get rotation() {
        return this._rotation;
    }
    set rotation(value) {
        this._rotation = value;
        this._transformStale = true;
    }
    /**
     * Gets or sets the scale of the graphic, this affects the width and
     */
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = watch(value, () => {
            this._transformStale = true;
        });
        this._transformStale = true;
    }
    /**
     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
     */
    get origin() {
        return this._origin;
    }
    set origin(value) {
        this._origin = watch(value, () => {
            this._transformStale = true;
        });
        this._transformStale = true;
    }
    cloneGraphicOptions() {
        return {
            origin: this.origin ? this.origin.clone() : null,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : null
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
        this._transformStale = true;
    }
    set height(value) {
        this._height = value;
        this._transformStale = true;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        if (this._transformStale) {
            this.transform.reset();
            this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
            this._rotate(this.transform);
            this._flip(this.transform);
            this._transformStale = false;
        }
        ex.multiply(this.transform);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
        if (this.tint) {
            ex.tint = this.tint;
        }
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any additional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;

;// CONCATENATED MODULE: ./Graphics/Sprite.ts


class Sprite extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._logger = Logger.getInstance();
        this._dirty = true;
        this._logNotLoadedWarning = false;
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    static from(image) {
        return new Sprite({
            image: image
        });
    }
    get width() {
        return Math.abs(this.destSize.width * this.scale.x);
    }
    get height() {
        return Math.abs(this.destSize.height * this.scale.y);
    }
    set width(newWidth) {
        newWidth /= Math.abs(this.scale.x);
        this.destSize.width = newWidth;
        super.width = Math.ceil(this.destSize.width);
    }
    set height(newHeight) {
        newHeight /= Math.abs(this.scale.y);
        this.destSize.height = newHeight;
        super.height = Math.ceil(this.destSize.height);
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width) * this.scale.x;
        this.height = Math.ceil(this.destSize.height) * this.scale.y;
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded() && this._dirty) {
            this._dirty = false;
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
        else {
            if (!this._logNotLoadedWarning) {
                this._logger.warn(`ImageSource ${this.image.path}` +
                    ` is not yet loaded and won't be drawn. Please call .load() or include in a Loader.\n\n` +
                    `Read https://excaliburjs.com/docs/imagesource for more information.`);
            }
            this._logNotLoadedWarning = true;
        }
    }
    clone() {
        return new Sprite({
            image: this.image,
            sourceView: { ...this.sourceView },
            destSize: { ...this.destSize },
            ...this.cloneGraphicOptions()
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Filtering.ts
/**
 * Describes the different image filtering modes
 */
var ImageFiltering;
(function (ImageFiltering) {
    /**
     * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.
     *
     * Useful for Pixel art aesthetics.
     */
    ImageFiltering["Pixel"] = "Pixel";
    /**
     * Blended is useful when you have high resolution artwork and would like it blended and smoothed
     */
    ImageFiltering["Blended"] = "Blended";
})(ImageFiltering || (ImageFiltering = {}));

;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts


/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    static register(context) {
        TextureLoader._GL = context;
        TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    static get(image) {
        return TextureLoader._TEXTURE_MAP.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    static has(image) {
        return TextureLoader._TEXTURE_MAP.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    static load(image, filtering, forceUpdate = false) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        // If reuse the texture if it's from the same source
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            }
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        TextureLoader.checkImageSizeSupportedAndLog(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // NEAREST for pixel art, LINEAR for hi-res
        const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        TextureLoader._TEXTURE_MAP.set(image, tex);
        return tex;
    }
    static delete(image) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
            gl.deleteTexture(tex);
        }
    }
    /**
     * Takes an image and returns if it meets size criteria for hardware
     * @param image
     * @returns if the image will be supported at runtime
     */
    static checkImageSizeSupportedAndLog(image) {
        var _a;
        const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : 'internal canvas bitmap';
        if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {
            TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of ` +
                `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `
                + `for excalibur to render properly.\n\nImages will likely render as black rectangles.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
            return false;
        }
        else if (image.width > 4096 || image.height > 4096) {
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits
            TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, ` +
                `it is recommended you resize images to a maximum (4096x4096).\n\n` +
                `Images will likely render as black rectangles on some mobile platforms.\n\n` +
                `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
        }
        return true;
    }
}
TextureLoader._LOGGER = Logger.getInstance();
/**
 * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]
 */
TextureLoader.filtering = ImageFiltering.Blended;
TextureLoader._TEXTURE_MAP = new Map();
TextureLoader._MAX_TEXTURE_SIZE = 0;

;// CONCATENATED MODULE: ./Graphics/ImageSource.ts





class ImageSource {
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute
     * @param bustCache {boolean} Should excalibur add a cache busting querystring?
     * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]
     */
    constructor(path, bustCache = false, filtering) {
        this.path = path;
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image element
         */
        this.data = new Image();
        this._readyFuture = new Future();
        /**
         * Promise the resolves when the image is loaded and ready for use, does not initiate loading
         */
        this.ready = this._readyFuture.promise;
        this._resource = new Resource(path, 'blob', bustCache);
        this._filtering = filtering;
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
    }
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        if (!this._src) {
            // this boosts speed of access
            this._src = this.data.src;
        }
        return !!this._src;
    }
    get image() {
        return this.data;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    async load() {
        if (this.isLoaded()) {
            return this.data;
        }
        try {
            // Load base64 or blob if needed
            let url;
            if (!this.path.includes('data:image/')) {
                const blob = await this._resource.load();
                url = URL.createObjectURL(blob);
            }
            else {
                url = this.path;
            }
            // Decode the image
            const image = new Image();
            // Use Image.onload over Image.decode()
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1055828#c7
            // Otherwise chrome will throw still Image.decode() failures for large textures
            const loadedFuture = new Future();
            image.onload = () => loadedFuture.resolve();
            image.src = url;
            image.setAttribute('data-original-src', this.path);
            await loadedFuture.promise;
            // Set results
            this.data = image;
        }
        catch (error) {
            throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
        }
        TextureLoader.load(this.data, this._filtering);
        // todo emit complete
        this._readyFuture.resolve(this.data);
        return this.data;
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts


/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
        this._logger = Logger.getInstance();
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x, y) {
        if (x >= this.columns || x < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);
            return null;
        }
        if (y >= this.rows || y < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);
            return null;
        }
        const spriteIndex = x + y * this.columns;
        return this.sprites[spriteIndex];
    }
    /**
     * Create a sprite sheet from a sparse set of [[SourceView]] rectangles
     * @param options
     */
    static fromImageSourceWithSourceViews(options) {
        const sprites = options.sourceViews.map(sourceView => {
            return new Sprite({
                image: options.image,
                sourceView
            });
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = { x: 0, y: 0, ...originOffset };
        const marginDefaults = { x: 0, y: 0, ...margin };
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts




class SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this._logger = Logger.getInstance();
        this._alreadyWarnedAlphabet = false;
        this._alreadyWarnedSpriteSheet = false;
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
    }
    _getCharacterSprites(text) {
        const results = [];
        // handle case insensitive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                if (!this._alreadyWarnedAlphabet) {
                    this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
                    this._alreadyWarnedAlphabet = true;
                }
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                if (!this._alreadyWarnedSpriteSheet) {
                    this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
                    this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');
                    this._alreadyWarnedSpriteSheet = true;
                }
            }
        }
        return results;
    }
    measureText(text) {
        const lines = text.split('\n');
        const maxWidthLine = lines.reduce((a, b) => {
            return a.length > b.length ? a : b;
        });
        const sprites = this._getCharacterSprites(maxWidthLine);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);
    }
    _drawImage(ex, x, y) {
        let xCursor = 0;
        let yCursor = 0;
        let height = 0;
        const lines = this._text.split('\n');
        for (const line of lines) {
            for (const sprite of this._getCharacterSprites(line)) {
                // draw it in the right spot and increase the cursor by sprite width
                sprite.draw(ex, x + xCursor, y + yCursor);
                xCursor += sprite.width + this.spacing;
                height = Math.max(height, sprite.height);
            }
            xCursor = 0;
            yCursor += height;
        }
    }
    render(ex, text, _color, x, y) {
        // SpriteFont doesn't support _color, yet...
        this._text = text;
        const bounds = this.measureText(text);
        this.width = bounds.width;
        this.height = bounds.height;
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this.draw(ex, x, y);
            ex.restore();
        }
        this.draw(ex, x, y);
    }
    clone() {
        return new SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png
/* harmony default export */ const debug_font = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=");
;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts


/**
 * Internal debugtext helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = debug_font;
        this.size = 16;
        this.load();
    }
    load() {
        this._imageSource = new ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 3,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+ ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, null, pos.x, pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/render-source.ts
class RenderSource {
    constructor(_gl, _texture) {
        this._gl = _gl;
        this._texture = _texture;
    }
    use() {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
    }
    disable() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/render-target.ts

class RenderTarget {
    constructor(options) {
        this.width = options.width;
        this.height = options.height;
        this._gl = options.gl;
        this._setupFramebuffer();
    }
    setResolution(width, height) {
        const gl = this._gl;
        this.width = width;
        this.height = height;
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    get frameBuffer() {
        return this._frameBuffer;
    }
    get frameTexture() {
        return this._frameTexture;
    }
    _setupFramebuffer() {
        // Allocates frame buffer
        const gl = this._gl;
        this._frameTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        // set the filtering so we don't need mips
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // attach the texture as the first color attachment
        const attachmentPoint = gl.COLOR_ATTACHMENT0;
        // After this bind all draw calls will draw to this framebuffer texture
        this._frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);
        // Reset after initialized
        this.disable();
    }
    toRenderSource() {
        const source = new RenderSource(this._gl, this._frameTexture);
        return source;
    }
    /**
     * When called, all drawing gets redirected to this render target
     */
    use() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        // very important to set the viewport to the size of the framebuffer texture
        gl.viewport(0, 0, this.width, this.height);
    }
    /**
     * When called, all drawing is sent back to the canvas
     */
    disable() {
        const gl = this._gl;
        // passing null switches rendering back to the canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/webgl-adapter.ts
/**
 * Must be accessed after Engine construction time to ensure the context has been created
 */
class ExcaliburWebGLContextAccessor {
    static clear() {
        ExcaliburWebGLContextAccessor._GL = null;
    }
    static register(gl) {
        ExcaliburWebGLContextAccessor._GL = gl;
    }
    // current webgl context
    static get gl() {
        if (!ExcaliburWebGLContextAccessor._GL) {
            throw Error('Attempted gl access before init');
        }
        return ExcaliburWebGLContextAccessor._GL;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-vertex.glsl
/* harmony default export */ const line_vertex = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\n\r\nout lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-fragment.glsl
/* harmony default export */ const line_fragment = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Color\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  fragColor = v_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts
/**
 * Return the size of the GlType in bytes
 * @param gl
 * @param type
 */
function getGlTypeSizeBytes(gl, type) {
    switch (type) {
        case gl.FLOAT:
            return 4;
        case gl.SHORT:
            return 2;
        case gl.UNSIGNED_SHORT:
            return 2;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        default:
            return 1;
    }
}
/**
 * Based on the type return the number of attribute components
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 * @param gl
 * @param type
 */
function getAttributeComponentSize(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
            return 1;
        case gl.FLOAT_VEC2:
            return 2;
        case gl.FLOAT_VEC3:
            return 3;
        case gl.FLOAT_VEC4:
            return 4;
        case gl.BYTE:
            return 1;
        case gl.UNSIGNED_BYTE:
            return 1;
        case gl.UNSIGNED_SHORT:
        case gl.SHORT:
            return 1;
        default:
            return 1;
    }
}
/**
 * Based on the attribute return the corresponding supported attrib pointer type
 * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
 *
 * @param gl
 * @param type
 */
function getAttributePointerType(gl, type) {
    switch (type) {
        case gl.LOW_FLOAT:
        case gl.HIGH_FLOAT:
        case gl.FLOAT:
        case gl.FLOAT_VEC2:
        case gl.FLOAT_VEC3:
        case gl.FLOAT_VEC4:
            return gl.FLOAT;
        case gl.BYTE:
            return gl.BYTE;
        case gl.UNSIGNED_BYTE:
            return gl.UNSIGNED_BYTE;
        case gl.SHORT:
            return gl.SHORT;
        case gl.UNSIGNED_SHORT:
            return gl.UNSIGNED_SHORT;
        default:
            return gl.FLOAT;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shader.ts


class Shader {
    /**
     * Create a shader program in excalibur
     * @param options specify shader vertex and fragment source
     */
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this.uniforms = {};
        this.attributes = {};
        this._compiled = false;
        const { vertexSource, fragmentSource } = options;
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
    }
    get compiled() {
        return this._compiled;
    }
    /**
     * Binds the shader program
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        Shader._ACTIVE_SHADER_INSTANCE = this;
    }
    isCurrentlyBound() {
        return Shader._ACTIVE_SHADER_INSTANCE === this;
    }
    /**
     * Compile the current shader against a webgl context
     */
    compile() {
        const gl = this._gl;
        const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);
        this.program = this._createProgram(gl, vertexShader, fragmentShader);
        const attributes = this.getAttributes();
        for (const attribute of attributes) {
            this.attributes[attribute.name] = attribute;
        }
        const uniforms = this.getUniforms();
        for (const uniform of uniforms) {
            this.uniforms[uniform.name] = uniform;
        }
        this._compiled = true;
        return this.program;
    }
    getUniforms() {
        const gl = this._gl;
        const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        const uniforms = [];
        for (let i = 0; i < uniformCount; i++) {
            const uniform = gl.getActiveUniform(this.program, i);
            const uniformLocation = gl.getUniformLocation(this.program, uniform.name);
            uniforms.push({
                name: uniform.name,
                glType: uniform.type,
                location: uniformLocation
            });
        }
        return uniforms;
    }
    getAttributes() {
        const gl = this._gl;
        const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
        const attributes = [];
        for (let i = 0; i < attributeCount; i++) {
            const attribute = gl.getActiveAttrib(this.program, i);
            const attributeLocation = gl.getAttribLocation(this.program, attribute.name);
            attributes.push({
                name: attribute.name,
                glType: getAttributePointerType(gl, attribute.type),
                size: getAttributeComponentSize(gl, attribute.type),
                location: attributeLocation,
                normalized: false
            });
        }
        return attributes;
    }
    /**
     * Set a texture in a gpu texture slot
     * @param slotNumber
     * @param texture
     */
    setTexture(slotNumber, texture) {
        const gl = this._gl;
        gl.activeTexture(gl.TEXTURE0 + slotNumber);
        gl.bindTexture(gl.TEXTURE_2D, texture);
    }
    /**
     * Set an integer uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformInt(name, value) {
        this.setUniform('uniform1i', name, ~~value);
    }
    /**
     * Set an integer array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformIntArray(name, value) {
        this.setUniform('uniform1iv', name, value);
    }
    /**
     * Set a boolean uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformBoolean(name, value) {
        this.setUniform('uniform1i', name, value ? 1 : 0);
    }
    /**
     * Set a float uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloat(name, value) {
        this.setUniform('uniform1f', name, value);
    }
    /**
     * Set a float array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatArray(name, value) {
        this.setUniform('uniform1fv', name, value);
    }
    /**
     * Set a [[Vector]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatVector(name, value) {
        this.setUniform('uniform2f', name, value.x, value.y);
    }
    /**
     * Set an [[Matrix]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformMatrix(name, value) {
        this.setUniform('uniformMatrix4fv', name, false, value.data);
    }
    /**
     * Set any available uniform type in webgl
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     */
    setUniform(uniformType, name, ...value) {
        if (!this._compiled) {
            throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);
        }
        if (!this.isCurrentlyBound()) {
            throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +
                ' must call `shader.use()` before setting uniforms');
        }
        const gl = this._gl;
        const location = gl.getUniformLocation(this.program, name);
        if (location) {
            const args = [location, ...value];
            this._gl[uniformType].apply(this._gl, args);
        }
        else {
            throw Error(`Uniform ${uniformType}:${name} doesn\'t exist or is not used in the shader source code,` +
                ' unused uniforms are optimized away by most browsers');
        }
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            const errorInfo = gl.getShaderInfoLog(shader);
            throw Error(`Could not compile ${typeName} shader:\n\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);
        }
        return shader;
    }
    _processSourceForError(source, errorInfo) {
        const lines = source.split('\n');
        const errorLineStart = errorInfo.search(/\d:\d/);
        const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);
        const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));
        for (let i = 0; i < lines.length; i++) {
            lines[i] = `${i + 1}: ${lines[i]}${error2 === (i + 1) ? ' <----- ERROR!' : ''}`;
        }
        return '\n\nSource:\n' + lines.join('\n');
    }
}
Shader._ACTIVE_SHADER_INSTANCE = null;

;// CONCATENATED MODULE: ./Graphics/Context/vertex-buffer.ts

/**
 * Helper around vertex buffer to simplify creating and uploading geometry
 *
 * Under the hood uses Float32Array
 */
class VertexBuffer {
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        /**
         * If the vertices never change switching 'static' can be more efficient on the gpu
         *
         * Default is 'dynamic'
         */
        this.type = 'dynamic';
        const { size, type, data } = options;
        this.buffer = this._gl.createBuffer();
        if (!data && !size) {
            throw Error('Must either provide data or a size to the VertexBuffer');
        }
        if (!data) {
            this.bufferData = new Float32Array(size);
        }
        else {
            this.bufferData = data;
        }
        this.type = type !== null && type !== void 0 ? type : this.type;
        // Allocate buffer
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
    }
    /**
     * Bind this vertex buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    }
    /**
     * Upload vertex buffer geometry to the GPU
     */
    upload(count) {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        if (count) {
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);
        }
        else {
            // TODO always use bufferSubData? need to perf test it
            gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/vertex-layout.ts



/**
 * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing
 * the memory layout for your vertices inside a particular buffer
 *
 * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.
 *
 * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you
 */
class VertexLayout {
    constructor(options) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this._logger = Logger.getInstance();
        this._layout = [];
        this._attributes = [];
        this._vertexTotalSizeBytes = 0;
        const { shader, vertexBuffer, attributes } = options;
        this._vertexBuffer = vertexBuffer;
        this._attributes = attributes;
        this._shader = shader;
        this.initialize();
    }
    get vertexBuffer() {
        return this._vertexBuffer;
    }
    get attributes() {
        return this._attributes;
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        return this._vertexTotalSizeBytes;
    }
    /**
     * Layouts need shader locations and must be bound to a shader
     */
    initialize() {
        if (!this._shader.compiled) {
            throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');
        }
        this._layout.length = 0;
        const shaderAttributes = this._shader.attributes;
        for (const attribute of this._attributes) {
            const attrib = shaderAttributes[attribute[0]];
            if (!attrib) {
                throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}` +
                    ` not found in the shader source code:\n ${this._shader.vertexSource}`);
            }
            if (attrib.size !== attribute[1]) {
                throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`
                    + ` doesnt match shader source size ${attrib.size}:\n ${this._shader.vertexSource}`);
            }
            this._layout.push(attrib);
        }
        // calc size
        let componentsPerVertex = 0;
        for (const vertAttribute of this._layout) {
            const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);
            this._vertexTotalSizeBytes += typeSize * vertAttribute.size;
            componentsPerVertex += vertAttribute.size;
        }
        if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {
            this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`
                + ` (${this._vertexBuffer.bufferData.length})`);
        }
    }
    /**
     * Bind this layout with it's associated vertex buffer
     *
     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
     */
    use(uploadBuffer = false, count) {
        const gl = this._gl;
        if (!this._shader.isCurrentlyBound()) {
            throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');
        }
        this._vertexBuffer.bind();
        if (uploadBuffer) {
            this._vertexBuffer.upload(count);
        }
        let offset = 0;
        // TODO switch to VAOs if the extension is
        for (const vert of this._layout) {
            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
            gl.enableVertexAttribArray(vert.location);
            offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer/line-renderer.ts




class LineRenderer {
    constructor() {
        this.type = 'ex.line';
        this.priority = 0;
        this._maxLines = 10922;
        this._vertexIndex = 0;
        this._lineCount = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            vertexSource: line_vertex,
            fragmentSource: line_fragment
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._vertexBuffer = new VertexBuffer({
            size: 6 * 2 * this._maxLines,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            vertexBuffer: this._vertexBuffer,
            shader: this._shader,
            attributes: [
                ['a_position', 2],
                ['a_color', 4]
            ]
        });
    }
    draw(start, end, color) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._lineCount++;
        const transform = this._context.getTransform();
        const finalStart = transform.multiply(start);
        const finalEnd = transform.multiply(end);
        const vertexBuffer = this._vertexBuffer.bufferData;
        // Start
        vertexBuffer[this._vertexIndex++] = finalStart.x;
        vertexBuffer[this._vertexIndex++] = finalStart.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        // End
        vertexBuffer[this._vertexIndex++] = finalEnd.x;
        vertexBuffer[this._vertexIndex++] = finalEnd.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
    }
    _isFull() {
        if (this._lineCount >= this._maxLines) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._lineCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._lineCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line
        GraphicsDiagnostics.DrawnImagesCount += this._lineCount;
        GraphicsDiagnostics.DrawCallCount++;
        // reset
        this._vertexIndex = 0;
        this._lineCount = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-vertex.glsl
/* harmony default export */ const point_vertex = ("#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\nin float a_size;\r\nout lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-fragment.glsl
/* harmony default export */ const point_fragment = ("#version 300 es\r\n\r\nprecision mediump float;\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n  // \"premultiply\" the color by alpha\r\n  vec4 color = v_color;\r\n  color.a = color.a * alpha;\r\n  color.rgb = color.rgb * color.a;\r\n  fragColor = color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer/point-renderer.ts







class PointRenderer {
    constructor() {
        this.type = 'ex.point';
        this.priority = 0;
        this._maxPoints = 10922;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            vertexSource: point_vertex,
            fragmentSource: point_fragment
        });
        this._shader.compile();
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        this._buffer = new VertexBuffer({
            size: 7 * this._maxPoints,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_color', 4],
                ['a_size', 1]
            ]
        });
    }
    draw(point, color, size) {
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._pointCount++;
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const finalPoint = transform.multiply(point);
        if (snapToPixel) {
            finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);
            finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);
        }
        const vertexBuffer = this._buffer.bufferData;
        vertexBuffer[this._vertexIndex++] = finalPoint.x;
        vertexBuffer[this._vertexIndex++] = finalPoint.y;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a * opacity;
        vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());
    }
    _isFull() {
        if (this._pointCount >= this._maxPoints) {
            return true;
        }
        return false;
    }
    hasPendingDraws() {
        return this._pointCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._pointCount === 0) {
            return;
        }
        const gl = this._gl;
        this._shader.use();
        this._layout.use(true);
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        gl.drawArrays(gl.POINTS, 0, this._pointCount);
        GraphicsDiagnostics.DrawnImagesCount += this._pointCount;
        GraphicsDiagnostics.DrawCallCount++;
        this._pointCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-vertex.glsl
/* harmony default export */ const screen_vertex = ("#version 300 es\r\nin vec2 a_position;\r\n\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n  gl_Position = vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texcoord to the fragment shader.\r\n  v_texcoord = a_texcoord;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-fragment.glsl
/* harmony default export */ const screen_fragment = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// Passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// The texture.\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   fragColor = texture(u_texture, v_texcoord);\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/screen-pass-painter/screen-pass-painter.ts





/**
 * This is responsible for painting the entire screen during the render passes
 */
class ScreenPassPainter {
    constructor(gl) {
        this._gl = gl;
        this._shader = new Shader({
            vertexSource: screen_vertex,
            fragmentSource: screen_fragment
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new VertexBuffer({
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                1, 1, 1, 1
            ])
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_texcoord', 2]
            ]
        });
        this._buffer.upload();
    }
    renderWithPostProcessor(postprocessor) {
        const gl = this._gl;
        postprocessor.getShader().use();
        postprocessor.getLayout().use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    renderToScreen() {
        const gl = this._gl;
        this._shader.use();
        this._layout.use();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/quad-index-buffer.ts


/**
 * Helper that defines and index buffer for quad geometry
 *
 * Index buffers allow you to save space in vertex buffers when you share vertices in geometry
 * it is almost always worth it in terms of performance to use an index buffer.
 */
class QuadIndexBuffer {
    /**
     * @param numberOfQuads Specify the max number of quads you want to draw
     * @param useUint16 Optionally force a uint16 buffer
     */
    constructor(numberOfQuads, useUint16) {
        this._gl = ExcaliburWebGLContextAccessor.gl;
        this._logger = Logger.getInstance();
        const gl = this._gl;
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        const totalVertices = numberOfQuads * 6;
        if (!useUint16) {
            this.bufferData = new Uint32Array(totalVertices);
        }
        else {
            // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck
            const maxUint16 = 65535;
            const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads
            this.bufferGlType = gl.UNSIGNED_SHORT;
            this.bufferData = new Uint16Array(totalVertices);
            // TODO Should we error if this happens?? maybe not might crash mid game
            if (numberOfQuads > maxUint16Index) {
                this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);
            }
        }
        let currentQuad = 0;
        for (let i = 0; i < totalVertices; i += 6) {
            // first triangle
            this.bufferData[i + 0] = currentQuad + 0;
            this.bufferData[i + 1] = currentQuad + 1;
            this.bufferData[i + 2] = currentQuad + 2;
            // second triangle
            this.bufferData[i + 3] = currentQuad + 2;
            this.bufferData[i + 4] = currentQuad + 1;
            this.bufferData[i + 5] = currentQuad + 3;
            currentQuad += 4;
        }
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    get size() {
        return this.bufferData.length;
    }
    /**
     * Upload data to the GPU
     */
    upload() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);
    }
    /**
     * Bind this index buffer
     */
    bind() {
        const gl = this._gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.frag.glsl
/* harmony default export */ const image_renderer_frag = ("#version 300 es\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_texcoord;\r\n\r\n// Texture index\r\nin lowp float v_textureIndex;\r\n\r\n// Textures in the current draw\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nin vec4 v_tint;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color = vec4(1.0, 0, 0, 1.0);\r\n\r\n   // GLSL is templated out to pick the right texture and set the vec4 color\r\n   %%texture_picker%%\r\n\r\n   color.rgb = color.rgb * v_opacity;\r\n   color.a = color.a * v_opacity;\r\n   fragColor = color * v_tint;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.vert.glsl
/* harmony default export */ const image_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\n// UV coordinate\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\n// Texture number\r\nin lowp float a_textureIndex;\r\nout lowp float v_textureIndex;\r\n\r\nin vec4 a_tint;\r\nout vec4 v_tint;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the tint\r\n   v_tint = a_tint;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/image-renderer/image-renderer.ts










class ImageRenderer {
    constructor() {
        this.type = 'ex.image';
        this.priority = 0;
        this._maxImages = 10922; // max(uint16) / 6 verts
        this._maxTextures = 0;
        // Per flush vars
        this._imageCount = 0;
        this._textures = [];
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // Transform shader source
        // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...
        this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);
        const transformedFrag = this._transformFragmentSource(image_renderer_frag, this._maxTextures);
        // Compile shader
        this._shader = new Shader({
            fragmentSource: transformedFrag,
            vertexSource: image_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        this._shader.setUniformIntArray('u_textures', [...Array(this._maxTextures)].map((_, i) => i));
        // Setup memory layout
        this._buffer = new VertexBuffer({
            size: 10 * 4 * this._maxImages,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_opacity', 1],
                ['a_texcoord', 2],
                ['a_textureIndex', 1],
                ['a_tint', 4]
            ]
        });
        // Setup index buffer
        this._quads = new QuadIndexBuffer(this._maxImages, true);
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    _addImageAsTexture(image) {
        const texture = TextureLoader.load(image);
        if (this._textures.indexOf(texture) === -1) {
            this._textures.push(texture);
        }
    }
    _bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this._maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);
        }
    }
    _getTextureIdForImage(image) {
        if (image) {
            return this._textures.indexOf(TextureLoader.get(image));
        }
        return -1;
    }
    _isFull() {
        if (this._imageCount >= this._maxImages) {
            return true;
        }
        if (this._textures.length >= this._maxTextures) {
            return true;
        }
        return false;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        var _a, _b, _c, _d;
        // Force a render if the batch is full
        if (this._isFull()) {
            this.flush();
        }
        this._imageCount++;
        this._addImageAsTexture(image);
        let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];
        let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];
            dest = [dx, dy];
            width = dwidth;
            height = dheight;
        }
        sx = view[0];
        sy = view[1];
        const sw = view[2];
        const sh = view[3];
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        let topLeft = vec(dest[0], dest[1]);
        let topRight = vec(dest[0] + width, dest[1]);
        let bottomLeft = vec(dest[0], dest[1] + height);
        let bottomRight = vec(dest[0] + width, dest[1] + height);
        topLeft = transform.multiply(topLeft);
        topRight = transform.multiply(topRight);
        bottomLeft = transform.multiply(bottomLeft);
        bottomRight = transform.multiply(bottomRight);
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        const tint = this._context.tint;
        const textureId = this._getTextureIdForImage(image);
        const imageWidth = image.width || width;
        const imageHeight = image.height || height;
        const uvx0 = (sx) / imageWidth;
        const uvy0 = (sy) / imageHeight;
        const uvx1 = (sx + sw - 0.01) / imageWidth;
        const uvy1 = (sy + sh - 0.01) / imageHeight;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = textureId;
        vertexBuffer[this._vertexIndex++] = tint.r / 255;
        vertexBuffer[this._vertexIndex++] = tint.g / 255;
        vertexBuffer[this._vertexIndex++] = tint.b / 255;
        vertexBuffer[this._vertexIndex++] = tint.a;
    }
    hasPendingDraws() {
        return this._imageCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._imageCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true, 4 * 10 * this._imageCount);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind textures to
        this._bindTextures(gl);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._imageCount = 0;
        this._vertexIndex = 0;
        this._textures.length = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl
/* harmony default export */ const rectangle_renderer_frag = ("#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\nin vec2 v_size; // in pixels\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness; // in pixels\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    vec2 uv = v_uv;\r\n    vec2 fragCoord = uv * v_size;\r\n    float maxX = v_size.x - v_strokeThickness;\r\n    float minX = v_strokeThickness;\r\n    float maxY = v_size.y - v_strokeThickness;\r\n    float minY = v_strokeThickness;\r\n\r\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\r\n        fragCoord.y < maxY && fragCoord.y > minY) {\r\n      fragColor = v_color;\r\n    } else {\r\n      fragColor = v_strokeColor;\r\n    }\r\n    fragColor.a *= v_opacity;\r\n    fragColor.rgb *= fragColor.a;\r\n\r\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\r\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\r\n\r\n    // float fHalfBorderDist      = 0.0;\r\n    // float fHalfBorderThickness = 0.0;\r\n\r\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \r\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \r\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else\r\n    // {\r\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\r\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\r\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\r\n        \r\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\r\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\r\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \r\n            \r\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\r\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\r\n    // }\r\n\r\n    // vec4 v4FromColor = v_strokeColor;\r\n    // v4FromColor.rgb *= v4FromColor.a;\r\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\r\n    // if (fHalfBorderDist < 0.0) {\r\n    //     v4ToColor = v_color;\r\n    //     v4ToColor.rgb *= v4ToColor.a;\r\n    // }\r\n\r\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\r\n\r\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\r\n    // gl_FragColor = finalColor;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.vert.glsl
/* harmony default export */ const rectangle_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\nin vec2 a_size;\r\nout vec2 v_size;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through size\r\n   v_size = a_size;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/rectangle-renderer/rectangle-renderer.ts










class RectangleRenderer {
    constructor() {
        this.type = 'ex.rectangle';
        this.priority = 0;
        this._maxRectangles = 10922; // max(uint16) / 6 verts
        this._rectangleCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border
        this._shader = new Shader({
            fragmentSource: rectangle_renderer_frag,
            vertexSource: rectangle_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new VertexBuffer({
            size: 16 * 4 * this._maxRectangles,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_size', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new QuadIndexBuffer(this._maxRectangles, true);
    }
    _isFull() {
        if (this._rectangleCount >= this._maxRectangles) {
            return true;
        }
        return false;
    }
    draw(...args) {
        if (args[0] instanceof Vector && args[1] instanceof Vector) {
            this.drawLine.apply(this, args);
        }
        else {
            this.drawRectangle.apply(this, args);
        }
    }
    drawLine(start, end, color, thickness = 1) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const dir = end.sub(start);
        const length = dir.size;
        const normal = dir.normalize().perpendicular();
        const halfThick = thickness / 2;
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startx, starty)------------------>(endx, endy)
         *    |                                            |
         *    + -------------------------------------------+
         */
        const startTop = transform.multiply(normal.scale(halfThick).add(start));
        const startBottom = transform.multiply(normal.scale(-halfThick).add(start));
        const endTop = transform.multiply(normal.scale(halfThick).add(end));
        const endBottom = transform.multiply(normal.scale(-halfThick).add(end));
        if (snapToPixel) {
            startTop.x = ~~(startTop.x + pixelSnapEpsilon);
            startTop.y = ~~(startTop.y + pixelSnapEpsilon);
            endTop.x = ~~(endTop.x + pixelSnapEpsilon);
            endTop.y = ~~(endTop.y + pixelSnapEpsilon);
            startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);
            startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);
            endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);
            endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        const stroke = Color.Transparent;
        const strokeThickness = 0;
        const width = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = startTop.x;
        vertexBuffer[this._vertexIndex++] = startTop.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = startBottom.x;
        vertexBuffer[this._vertexIndex++] = startBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = endTop.x;
        vertexBuffer[this._vertexIndex++] = endTop.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = endBottom.x;
        vertexBuffer[this._vertexIndex++] = endBottom.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = length;
        vertexBuffer[this._vertexIndex++] = thickness;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    }
    drawRectangle(pos, width, height, color, stroke = Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._rectangleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add(vec(0, 0)));
        const topRight = transform.multiply(pos.add(vec(width, 0)));
        const bottomRight = transform.multiply(pos.add(vec(width, height)));
        const bottomLeft = transform.multiply(pos.add(vec(0, height)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        // TODO uv could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = width;
        vertexBuffer[this._vertexIndex++] = height;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness;
    }
    hasPendingDraws() {
        return this._rectangleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._rectangleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._rectangleCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.frag.glsl
/* harmony default export */ const circle_renderer_frag = ("#version 300 es\r\nprecision highp float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness;\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  // make (0, 0) the center the uv \r\n  vec2 uv = v_uv * 2.0 - 1.0;\r\n\r\n  vec4 color = v_color;\r\n  vec4 strokeColor = v_strokeColor;\r\n\r\n  // circle border is at radius 1.0 \r\n  // dist is > 0 when inside the circle \r\n  float d = length(uv);\r\n  float dist = 1.0 - length(uv);\r\n\r\n  // Fade based on fwidth\r\n  float fade = fwidth(dot(uv, uv));\r\n\r\n  // if dist is greater than 0 step to 1;\r\n  // when we cross this 0 threshold add a smooth fade\r\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\r\n\r\n  // if dist is greater than the stroke thickness step to 1\r\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\r\n\r\n  strokeColor.a *= fill * stroke;\r\n  strokeColor.rgb *= strokeColor.a;\r\n\r\n  color.a *= fill * (1.0 - stroke);\r\n  color.rgb *= color.a;\r\n\r\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\r\n  finalColor.rgb = finalColor.rgb * v_opacity;\r\n  finalColor.a = finalColor.a * v_opacity;\r\n  fragColor = finalColor;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.vert.glsl
/* harmony default export */ const circle_renderer_vert = ("#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/circle-renderer/circle-renderer.ts










class CircleRenderer {
    constructor() {
        this.type = 'ex.circle';
        this.priority = 0;
        this._maxCircles = 10922; // max(uint16) / 6 verts
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
    initialize(gl, context) {
        this._gl = gl;
        this._context = context;
        this._shader = new Shader({
            fragmentSource: circle_renderer_frag,
            vertexSource: circle_renderer_vert
        });
        this._shader.compile();
        // setup uniforms
        this._shader.use();
        this._shader.setUniformMatrix('u_matrix', context.ortho);
        this._buffer = new VertexBuffer({
            size: 14 * 4 * this._maxCircles,
            type: 'dynamic'
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_uv', 2],
                ['a_opacity', 1],
                ['a_color', 4],
                ['a_strokeColor', 4],
                ['a_strokeThickness', 1]
            ]
        });
        this._quads = new QuadIndexBuffer(this._maxCircles, true);
    }
    _isFull() {
        if (this._circleCount >= this._maxCircles) {
            return true;
        }
        return false;
    }
    draw(pos, radius, color, stroke = Color.Transparent, strokeThickness = 0) {
        if (this._isFull()) {
            this.flush();
        }
        this._circleCount++;
        // transform based on current context
        const transform = this._context.getTransform();
        const opacity = this._context.opacity;
        const snapToPixel = this._context.snapToPixel;
        const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));
        const topRight = transform.multiply(pos.add(vec(radius, -radius)));
        const bottomRight = transform.multiply(pos.add(vec(radius, radius)));
        const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));
        if (snapToPixel) {
            topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
            topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
            topRight.x = ~~(topRight.x + pixelSnapEpsilon);
            topRight.y = ~~(topRight.y + pixelSnapEpsilon);
            bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
            bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
            bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
            bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
        }
        // TODO UV could be static vertex buffer
        const uvx0 = 0;
        const uvy0 = 0;
        const uvx1 = 1;
        const uvy1 = 1;
        // update data
        const vertexBuffer = this._layout.vertexBuffer.bufferData;
        // (0, 0) - 0
        vertexBuffer[this._vertexIndex++] = topLeft.x;
        vertexBuffer[this._vertexIndex++] = topLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (0, 1) - 1
        vertexBuffer[this._vertexIndex++] = bottomLeft.x;
        vertexBuffer[this._vertexIndex++] = bottomLeft.y;
        vertexBuffer[this._vertexIndex++] = uvx0;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 0) - 2
        vertexBuffer[this._vertexIndex++] = topRight.x;
        vertexBuffer[this._vertexIndex++] = topRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy0;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
        // (1, 1) - 3
        vertexBuffer[this._vertexIndex++] = bottomRight.x;
        vertexBuffer[this._vertexIndex++] = bottomRight.y;
        vertexBuffer[this._vertexIndex++] = uvx1;
        vertexBuffer[this._vertexIndex++] = uvy1;
        vertexBuffer[this._vertexIndex++] = opacity;
        vertexBuffer[this._vertexIndex++] = color.r / 255;
        vertexBuffer[this._vertexIndex++] = color.g / 255;
        vertexBuffer[this._vertexIndex++] = color.b / 255;
        vertexBuffer[this._vertexIndex++] = color.a;
        vertexBuffer[this._vertexIndex++] = stroke.r / 255;
        vertexBuffer[this._vertexIndex++] = stroke.g / 255;
        vertexBuffer[this._vertexIndex++] = stroke.b / 255;
        vertexBuffer[this._vertexIndex++] = stroke.a;
        vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    }
    hasPendingDraws() {
        return this._circleCount !== 0;
    }
    flush() {
        // nothing to draw early exit
        if (this._circleCount === 0) {
            return;
        }
        const gl = this._gl;
        // Bind the shader
        this._shader.use();
        // Bind the memory layout and upload data
        this._layout.use(true);
        // Update ortho matrix uniform
        this._shader.setUniformMatrix('u_matrix', this._context.ortho);
        // Bind index buffer
        this._quads.bind();
        // Draw all the quads
        gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);
        GraphicsDiagnostics.DrawnImagesCount += this._circleCount;
        GraphicsDiagnostics.DrawCallCount++;
        // Reset
        this._circleCount = 0;
        this._vertexIndex = 0;
    }
}

;// CONCATENATED MODULE: ./Util/Pool.ts

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this.disableWarnings = false;
        this._logger = Logger.getInstance();
    }
    preallocate() {
        for (let i = 0; i < this.maxObjects; i++) {
            this.objects[i] = this.builder();
        }
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
        if (this.index === this.maxObjects) {
            if (!this.disableWarnings) {
                this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            }
            this.maxObjects = this.maxObjects * 2;
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            return this.recycler(this.objects[this.index++], ...args);
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder(...args));
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support
            this.totalAllocations++;
        }
        return objects;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/draw-call.ts


class DrawCall {
    constructor() {
        this.z = 0;
        this.priority = 0;
        this.transform = AffineMatrix.identity();
        this.state = {
            z: 0,
            opacity: 1,
            tint: Color.White
        };
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts










// renderers









const pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
        this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });
        this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });
        this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });
        this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._webglCtx.draw('ex.line', start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._webglCtx.draw('ex.point', point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    constructor(options) {
        this._logger = Logger.getInstance();
        this._renderers = new Map();
        this._isDrawLifecycle = false;
        this.useDrawSorting = true;
        this._drawCallPool = new Pool(() => new DrawCall(), (instance) => {
            instance.priority = 0;
            instance.z = 0;
            instance.renderer = undefined;
            instance.args = undefined;
            return instance;
        }, 4000);
        this._drawCalls = [];
        // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process
        this._postProcessTargets = [];
        this._postprocessors = [];
        this._transform = new TransformStack();
        this._state = new StateStack();
        this.snapToPixel = false;
        this.smoothing = false;
        this.backgroundColor = Color.ExcaliburBlue;
        this._alreadyWarnedDrawLifecycle = false;
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;
        this.__gl = canvasElement.getContext('webgl2', {
            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
            premultipliedAlpha: false,
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
            depth: true,
            powerPreference: 'high-performance'
            // TODO Chromium fixed the bug where this didn't work now it breaks CI :(
            // failIfMajorPerformanceCaveat: true
        });
        if (!this.__gl) {
            throw Error('Failed to retrieve webgl context from browser');
        }
        ExcaliburWebGLContextAccessor.register(this.__gl);
        TextureLoader.register(this.__gl);
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;
        this._drawCallPool.disableWarnings = true;
        this._drawCallPool.preallocate();
        this._init();
    }
    get z() {
        return this._state.current.z;
    }
    set z(value) {
        this._state.current.z = value;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    get ortho() {
        return this._ortho;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        let supported = true;
        if (dim.width > 4096 || dim.height > 4096) {
            supported = false;
        }
        return supported;
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        // Setup builtin renderers
        this.register(new ImageRenderer());
        this.register(new RectangleRenderer());
        this.register(new CircleRenderer());
        this.register(new PointRenderer());
        this.register(new LineRenderer());
        this._screenRenderer = new ScreenPassPainter(gl);
        this._renderTarget = new RenderTarget({
            gl,
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this._postProcessTargets = [
            new RenderTarget({
                gl,
                width: gl.canvas.width,
                height: gl.canvas.height
            }),
            new RenderTarget({
                gl,
                width: gl.canvas.width,
                height: gl.canvas.height
            })
        ];
    }
    register(renderer) {
        this._renderers.set(renderer.type, renderer);
        renderer.initialize(this.__gl, this);
    }
    get(rendererName) {
        return this._renderers.get(rendererName);
    }
    _isCurrentRenderer(renderer) {
        if (!this._currentRenderer || this._currentRenderer === renderer) {
            return true;
        }
        return false;
    }
    beginDrawLifecycle() {
        this._isDrawLifecycle = true;
    }
    endDrawLifecycle() {
        this._isDrawLifecycle = false;
    }
    draw(rendererName, ...args) {
        if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {
            this._logger.warn(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\n` +
                `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);
            this._alreadyWarnedDrawLifecycle = true;
        }
        const renderer = this._renderers.get(rendererName);
        if (renderer) {
            if (this.useDrawSorting) {
                const drawCall = this._drawCallPool.get();
                drawCall.z = this._state.current.z;
                drawCall.priority = renderer.priority;
                drawCall.renderer = rendererName;
                this.getTransform().clone(drawCall.transform);
                drawCall.state.z = this._state.current.z;
                drawCall.state.opacity = this._state.current.opacity;
                drawCall.state.tint = this._state.current.tint;
                drawCall.args = args;
                this._drawCalls.push(drawCall);
            }
            else {
                // Set the current renderer if not defined
                if (!this._currentRenderer) {
                    this._currentRenderer = renderer;
                }
                if (!this._isCurrentRenderer(renderer)) {
                    // switching graphics means we must flush the previous
                    this._currentRenderer.flush();
                }
                // If we are still using the same renderer we can add to the current batch
                renderer.draw(...args);
                this._currentRenderer = renderer;
            }
        }
        else {
            throw Error(`No renderer with name ${rendererName} has been registered`);
        }
    }
    resetTransform() {
        this._transform.current = AffineMatrix.identity();
    }
    updateViewport(resolution) {
        const gl = this.__gl;
        this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);
        this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);
        this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        this.draw('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    drawLine(start, end, color, thickness = 1) {
        this.draw('ex.rectangle', start, end, color, thickness);
    }
    drawRectangle(pos, width, height, color, stroke, strokeThickness) {
        this.draw('ex.rectangle', pos, width, height, color, stroke, strokeThickness);
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.draw('ex.circle', pos, radius, color, stroke, thickness);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~(x + pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + pixelSnapEpsilon) : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    getTransform() {
        return this._transform.current;
    }
    multiply(m) {
        this._transform.current.multiply(m, this._transform.current);
    }
    addPostProcessor(postprocessor) {
        this._postprocessors.push(postprocessor);
        postprocessor.initialize(this.__gl);
    }
    removePostProcessor(postprocessor) {
        const index = this._postprocessors.indexOf(postprocessor);
        if (index !== -1) {
            this._postprocessors.splice(index, 1);
        }
    }
    clearPostProcessors() {
        this._postprocessors.length = 0;
    }
    clear() {
        const gl = this.__gl;
        this._renderTarget.use();
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        const gl = this.__gl;
        // render target captures all draws and redirects to the render target
        this._renderTarget.use();
        if (this.useDrawSorting) {
            // sort draw calls
            // Find the original order of the first instance of the draw call
            const originalSort = new Map();
            for (const [name] of this._renderers) {
                const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);
                originalSort.set(name, firstIndex);
            }
            this._drawCalls.sort((a, b) => {
                const zIndex = a.z - b.z;
                const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);
                const priority = a.priority - b.priority;
                if (zIndex === 0) { // sort by z first
                    if (priority === 0) { // sort by priority
                        return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order
                    }
                    return priority;
                }
                return zIndex;
            });
            const oldTransform = this._transform.current;
            const oldState = this._state.current;
            if (this._drawCalls.length) {
                let currentRendererName = this._drawCalls[0].renderer;
                let currentRenderer = this._renderers.get(currentRendererName);
                for (let i = 0; i < this._drawCalls.length; i++) {
                    // hydrate the state for renderers
                    this._transform.current = this._drawCalls[i].transform;
                    this._state.current = this._drawCalls[i].state;
                    if (this._drawCalls[i].renderer !== currentRendererName) {
                        // switching graphics renderer means we must flush the previous
                        currentRenderer.flush();
                        currentRendererName = this._drawCalls[i].renderer;
                        currentRenderer = this._renderers.get(currentRendererName);
                    }
                    // If we are still using the same renderer we can add to the current batch
                    currentRenderer.draw(...this._drawCalls[i].args);
                }
                if (currentRenderer.hasPendingDraws()) {
                    currentRenderer.flush();
                }
            }
            // reset state
            this._transform.current = oldTransform;
            this._state.current = oldState;
            // reclaim draw calls
            this._drawCallPool.done();
            this._drawCalls.length = 0;
        }
        else {
            // This is the final flush at the moment to draw any leftover pending draw
            for (const renderer of this._renderers.values()) {
                if (renderer.hasPendingDraws()) {
                    renderer.flush();
                }
            }
        }
        this._renderTarget.disable();
        // post process step
        const source = this._renderTarget.toRenderSource();
        source.use();
        // flip flop render targets
        for (let i = 0; i < this._postprocessors.length; i++) {
            this._postProcessTargets[i % 2].use();
            this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);
            this._postProcessTargets[i % 2].toRenderSource().use();
        }
        // passing null switches rendering back to the canvas
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._screenRenderer.renderToScreen();
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts




const ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon = 0.0001;
class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this._ex.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y, this._ex.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = lineOptions.color.toString();
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.x, this._ex.snapToPixel ? ~~(point.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    constructor(options) {
        /**
         * Unused in Canvas implementation
         */
        this.useDrawSorting = false;
        /**
         * Unused in Canvas implementation
         */
        this.z = 0;
        this.backgroundColor = Color.ExcaliburBlue;
        this._state = new StateStack();
        this.snapToPixel = false;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
        this.__ctx = canvasElement.getContext('2d', {
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
        });
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get tint() {
        return this._state.current.tint;
    }
    set tint(color) {
        this._state.current.tint = color;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport(_resolution) {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        GraphicsDiagnostics.DrawCallCount++;
        GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color, stroke, thickness) {
        this.__ctx.save();
        this.__ctx.beginPath();
        if (stroke) {
            this.__ctx.strokeStyle = stroke.toString();
        }
        if (thickness) {
            this.__ctx.lineWidth = thickness;
        }
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        if (stroke) {
            this.__ctx.stroke();
        }
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~(x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x, this.snapToPixel ? ~~(y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    getTransform() {
        throw new Error('Not implemented');
    }
    multiply(_m) {
        this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));
    }
    addPostProcessor(_postprocessor) {
        // pass
    }
    removePostProcessor(_postprocessor) {
        // pass
    }
    clearPostProcessors() {
        // pass
    }
    beginDrawLifecycle() {
        // pass
    }
    endDrawLifecycle() {
        // pass
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
}

;// CONCATENATED MODULE: ./Screen.ts






/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.
     * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]
     * is guaranteed to be on screen.
     */
    DisplayMode["FitContainerAndFill"] = "FitContainerAndFill";
    /**
     * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.
     * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]
     * is guaranteed to be on screen.
     */
    DisplayMode["FitScreenAndFill"] = "FitScreenAndFill";
    /**
     * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in [[FitContainer]].
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use [[Screen.contentArea]] to know the safe to draw area.
     */
    DisplayMode["FitContainerAndZoom"] = "FitContainerAndZoom";
    /**
     * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars
     * (letterbox) that would otherwise be present in [[FitScreen]].
     *
     * **warning** This will clip some drawable area from the user because of the zoom,
     * use [[Screen.contentArea]] to know the safe to draw area.
     */
    DisplayMode["FitScreenAndZoom"] = "FitScreenAndZoom";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            this._isFullScreen = !this._isFullScreen;
            this._logger.debug('Fullscreen Change', this._isFullScreen);
        };
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._listenForPixelRatio();
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
        };
        this._resizeHandler = () => {
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._alreadyWarned = false;
        this._contentArea = new BoundingBox();
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : { ...this.viewport };
        this._contentResolution = this.resolution;
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this.graphicsContext = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._listenForPixelRatio();
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    _listenForPixelRatio() {
        if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {
            // Safari <=13.1 workaround, remove any existing handlers
            this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
        }
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        // Safari <=13.1 workaround
        if (this._mediaQueryList.addEventListener) {
            this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });
        }
        else {
            this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
        }
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._resizeHandler);
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            // Safari <=13.1 workaround
            if (this._mediaQueryList.removeEventListener) {
                this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            }
            else {
                this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
            }
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        switch (this.displayMode) {
            case DisplayMode.FillContainer:
            case DisplayMode.FitContainer:
            case DisplayMode.FitContainerAndFill:
            case DisplayMode.FitContainerAndZoom:
                return this.canvas.parentElement || document.body;
            default:
                return window;
        }
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = { ...this.resolution };
        this.viewport = { ...this.viewport };
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            const supported = this.graphicsContext.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!supported && !this._alreadyWarned) {
                this._alreadyWarned = true; // warn once
                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +
                    ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
            }
        }
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this.graphicsContext.updateViewport(this.resolution);
        this.graphicsContext.resetTransform();
        this.graphicsContext.smoothing = this._antialiasing;
        if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {
            this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);
        }
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this.graphicsContext.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreen using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     *
     * Optionally specify a target element id to go fullscreen, by default the game canvas is used
     * @param elementId
     */
    goFullScreen(elementId) {
        if (elementId) {
            const maybeElement = document.getElementById(elementId);
            if (maybeElement) {
                return maybeElement.requestFullscreen();
            }
        }
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullScreen) {
            newX -= getPosition(this._canvas).x;
            newY -= getPosition(this._canvas).y;
        }
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;
                newX = (newX / window.innerWidth) * this.viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;
                newY = (newY / window.innerHeight) * this.viewport.height;
            }
        }
        newX = (newX / this.viewport.width) * this.resolution.width;
        newY = (newY / this.viewport.height) * this.resolution.height;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        newX = (newX / this.resolution.width) * this.viewport.width;
        newY = (newY / this.resolution.height) * this.viewport.height;
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;
                newX = (newX / this.viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;
                newY = (newY / this.viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullScreen) {
            newX += getPosition(this._canvas).x;
            newY += getPosition(this._canvas).y;
        }
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        // the only difference between screen & world is the camera transform
        if (this._camera) {
            return this._camera.inverse.multiply(point);
        }
        return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        if (this._camera) {
            return this._camera.transform.multiply(point);
        }
        return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
        const topLeft = this.screenToWorldCoordinates(Vector.Zero);
        const right = topLeft.x + this.drawWidth;
        const bottom = topLeft.y + this.drawHeight;
        return new BoundingBox(topLeft.x, topLeft.y, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    /**
     * Returns the content area in screen space where it is safe to place content
     */
    get contentArea() {
        return this._contentArea;
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _computeFitScreenAndFill() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndFill(vw, vh);
    }
    _computeFitContainerAndFill() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const parent = this.canvas.parentElement;
        const vw = parent.clientWidth;
        const vh = parent.clientHeight;
        this._computeFitAndFill(vw, vh);
    }
    _computeFitAndFill(vw, vh) {
        this.viewport = {
            width: vw,
            height: vh
        };
        // if the current screen aspectRatio is less than the original aspectRatio
        if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {
            // compute new resolution to match the original aspect ratio
            this.resolution = {
                width: vw * this._contentResolution.width / vw,
                height: vw * this._contentResolution.width / vw * vh / vw
            };
            const clip = (this.resolution.height - this._contentResolution.height) / 2;
            this._contentArea = new BoundingBox({
                top: clip,
                left: 0,
                right: this._contentResolution.width,
                bottom: this.resolution.height - clip
            });
        }
        else {
            this.resolution = {
                width: vh * this._contentResolution.height / vh * vw / vh,
                height: vh * this._contentResolution.height / vh
            };
            const clip = (this.resolution.width - this._contentResolution.width) / 2;
            this._contentArea = new BoundingBox({
                top: 0,
                left: clip,
                right: this.resolution.width - clip,
                bottom: this._contentResolution.height
            });
        }
    }
    _computeFitScreenAndZoom() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        this.canvas.style.position = 'absolute';
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        this._computeFitAndZoom(vw, vh);
    }
    _computeFitContainerAndZoom() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        this.canvas.style.position = 'absolute';
        const parent = this.canvas.parentElement;
        parent.style.position = 'relative';
        parent.style.overflow = 'hidden';
        const vw = parent.clientWidth;
        const vh = parent.clientHeight;
        this._computeFitAndZoom(vw, vh);
    }
    _computeFitAndZoom(vw, vh) {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (vw / aspect < vh) {
            adjustedWidth = vw;
            adjustedHeight = vw / aspect;
        }
        else {
            adjustedWidth = vh * aspect;
            adjustedHeight = vh;
        }
        const scaleX = vw / adjustedWidth;
        const scaleY = vh / adjustedHeight;
        const maxScaleFactor = Math.max(scaleX, scaleY);
        const zoomedWidth = adjustedWidth * maxScaleFactor;
        const zoomedHeight = adjustedHeight * maxScaleFactor;
        // Center zoomed dimension if bigger than the screen
        if (zoomedWidth > vw) {
            this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';
        }
        else {
            this.canvas.style.left = '';
        }
        if (zoomedHeight > vh) {
            this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';
        }
        else {
            this.canvas.style.top = '';
        }
        this.viewport = {
            width: zoomedWidth,
            height: zoomedHeight
        };
        const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);
        // return safe area
        if (this.viewport.width > vw) {
            const clip = (this.viewport.width - vw) / this.viewport.width * this.resolution.width;
            bounds.top = 0;
            bounds.left = clip / 2;
            bounds.right = this.resolution.width - clip / 2;
            bounds.bottom = this.resolution.height;
        }
        if (this.viewport.height > vh) {
            const clip = (this.viewport.height - vh) / this.viewport.height * this.resolution.height;
            bounds.top = clip / 2;
            bounds.left = 0;
            bounds.bottom = this.resolution.height - clip / 2;
            bounds.right = this.resolution.width;
        }
        this._contentArea = bounds;
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            adjustedWidth = parent.clientWidth;
            adjustedHeight = parent.clientWidth / aspect;
        }
        else {
            adjustedWidth = parent.clientHeight * aspect;
            adjustedHeight = parent.clientHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
        this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _applyDisplayMode() {
        this._setResolutionAndViewportByDisplayMode(this.parent);
        // watch resizing
        if (this.parent instanceof Window) {
            this._browser.window.on('resize', this._resizeHandler);
        }
        else {
            this._resizeObserver = new ResizeObserver(() => {
                this._resizeHandler();
            });
            this._resizeObserver.observe(this.parent);
        }
        this.parent.addEventListener('resize', this._resizeHandler);
    }
    /**
     * Sets the resolution and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
        if (this.displayMode === DisplayMode.FitScreenAndFill) {
            this._computeFitScreenAndFill();
        }
        if (this.displayMode === DisplayMode.FitContainerAndFill) {
            this._computeFitContainerAndFill();
        }
        if (this.displayMode === DisplayMode.FitScreenAndZoom) {
            this._computeFitScreenAndZoom();
        }
        if (this.displayMode === DisplayMode.FitContainerAndZoom) {
            this._computeFitContainerAndZoom();
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;

;// CONCATENATED MODULE: ./Util/WebAudio.ts


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;

;// CONCATENATED MODULE: ./Class.ts

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new EventDispatcher();
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}

;// CONCATENATED MODULE: ./Util/DrawUtil.ts

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Loader.logo.png
/* harmony default export */ const Loader_logo = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");
// EXTERNAL MODULE: ./Loader.css
var Loader_0 = __nested_webpack_require_62364__(1388);
;// CONCATENATED MODULE: ./Graphics/Raster.ts






/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.
 */
class Raster extends Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super(options);
        this.filtering = null;
        this.lineCap = 'butt';
        this.quality = 1;
        this._dirty = true;
        this._smoothing = false;
        this._color = watch(Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;
            this.color = (_b = options.color) !== null && _b !== void 0 ? _b : Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;
            this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;
            this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
            this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;
            this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;
            this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;
        const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;
        this.width = bitmapWidth;
        this.height = bitmapHeight;
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : null,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            lineCap: this.lineCap,
            quality: this.quality,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputted drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s or `quality` set will be factored into the width
     */
    get width() {
        return Math.abs(this._getTotalWidth() * this.scale.x);
    }
    set width(value) {
        value /= Math.abs(this.scale.x);
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` or `quality` set will be factored into the height
     */
    get height() {
        return Math.abs(this._getTotalHeight() * this.scale.y);
    }
    set height(value) {
        value /= Math.abs(this.scale.y);
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;
    }
    _getTotalHeight() {
        var _a;
        return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        this.flagDirty();
        this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        this.flagDirty();
        this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperties(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
        // The webgl texture needs to be updated if it exists after a raster cycle
        TextureLoader.load(this._bitmap, this.filtering, true);
    }
    _applyRasterProperties(ctx) {
        var _a, _b, _c;
        this._bitmap.width = this._getTotalWidth() * this.quality;
        this._bitmap.height = this._getTotalHeight() * this.quality;
        ctx.scale(this.quality, this.quality);
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.lineCap = this.lineCap;
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.scale(1 / this.quality, 1 / this.quality);
        ex.drawImage(this._bitmap, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Canvas.ts

/**
 * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].
 *
 * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends Raster {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    clone() {
        return new Canvas({
            ...this._options,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}

;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};

;// CONCATENATED MODULE: ./Util/StateMachine.ts
class StateMachine {
    constructor() {
        this.states = new Map();
    }
    get currentState() {
        return this._currentState;
    }
    set currentState(state) {
        this._currentState = state;
    }
    static create(machineDescription, data) {
        const machine = new StateMachine();
        machine.data = data;
        for (const stateName in machineDescription.states) {
            machine.states.set(stateName, {
                name: stateName,
                ...machineDescription.states[stateName]
            });
        }
        // validate transitions are states
        for (const state of machine.states.values()) {
            for (const transitionState of state.transitions) {
                if (transitionState === '*') {
                    continue;
                }
                if (!machine.states.has(transitionState)) {
                    throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);
                }
            }
        }
        machine.currentState = machine.startState = machine.states.get(machineDescription.start);
        return machine;
    }
    in(state) {
        return this.currentState.name === state;
    }
    go(stateName, eventData) {
        var _a, _b;
        if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes('*')) {
            const potentialNewState = this.states.get(stateName);
            if (this.currentState.onExit) {
                const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });
                if (canExit === false) {
                    return false;
                }
            }
            if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {
                const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });
                if (canEnter === false) {
                    return false;
                }
            }
            // console.log(`${this.currentState.name} => ${potentialNewState.name} (${eventData})`);
            this.currentState = potentialNewState;
            if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) {
                this.currentState.onState();
            }
            return true;
        }
        return false;
    }
    update(elapsedMs) {
        if (this.currentState.onUpdate) {
            this.currentState.onUpdate(this.data, elapsedMs);
        }
    }
    save(saveKey) {
        localStorage.setItem(saveKey, JSON.stringify({
            currentState: this.currentState.name,
            data: this.data
        }));
    }
    restore(saveKey) {
        const state = JSON.parse(localStorage.getItem(saveKey));
        this.currentState = this.states.get(state.currentState);
        this.data = state.data;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts



/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._audioContext = AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        this._stateMachine = StateMachine.create({
            start: 'STOPPED',
            states: {
                PLAYING: {
                    onEnter: ({ data }) => {
                        // Buffer nodes are single use
                        this._createNewBufferSource();
                        this._handleEnd();
                        this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);
                        data.startedAt = (this._audioContext.currentTime - data.pausedAt);
                        data.pausedAt = 0;
                    },
                    onState: () => this._playStarted(),
                    onExit: ({ to }) => {
                        // If you've exited early only resolve if explicitly STOPPED
                        if (to === 'STOPPED') {
                            this._playingResolve(true);
                        }
                        // Whenever you're not playing... you stop!
                        this._instance.onended = null; // disconnect the wired on-end handler
                        this._instance.disconnect();
                        this._instance.stop(0);
                        this._instance = null;
                    },
                    transitions: ['STOPPED', 'PAUSED', 'SEEK']
                },
                SEEK: {
                    onEnter: ({ eventData: position, data }) => {
                        data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;
                        data.startedAt = 0;
                    },
                    transitions: ['*']
                },
                STOPPED: {
                    onEnter: ({ data }) => {
                        data.pausedAt = 0;
                        data.startedAt = 0;
                        this._playingResolve(true);
                    },
                    transitions: ['PLAYING', 'PAUSED', 'SEEK']
                },
                PAUSED: {
                    onEnter: ({ data }) => {
                        // Playback rate will be a scale factor of how fast/slow the audio is being played
                        // default is 1.0
                        // we need to invert it to get the time scale
                        data.pausedAt = (this._audioContext.currentTime - data.startedAt);
                    },
                    transitions: ['PLAYING', 'STOPPED', 'SEEK']
                }
            }
        }, {
            startedAt: 0,
            pausedAt: 0
        });
        this._volume = 1;
        this._loop = false;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._playStarted = () => { };
        this._playbackRate = 1.0;
        this._createNewBufferSource();
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.value = this._playbackRate;
        this._instance.connect(this._volumeNode);
        this._volumeNode.connect(this._audioContext.destination);
    }
    _handleEnd() {
        if (!this.loop) {
            this._instance.onended = () => {
                this._playingResolve(true);
            };
        }
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            if (!this.loop) {
                this._instance.onended = () => {
                    this._playingResolve(true);
                };
            }
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = clamp(value, 0, 1.0);
        this._volume = value;
        if (this._stateMachine.in('PLAYING') && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    /**
     * Returns the set duration to play, otherwise returns the total duration if unset
     */
    get duration() {
        var _a;
        return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();
    }
    /**
     * Set the duration that this audio should play.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    isPlaying() {
        return this._stateMachine.in('PLAYING');
    }
    isPaused() {
        return this._stateMachine.in('PAUSED') || this._stateMachine.in('SEEK');
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        this._playStarted = playStarted;
        this._stateMachine.go('PLAYING');
        return this._playingPromise;
    }
    pause() {
        this._stateMachine.go('PAUSED');
    }
    stop() {
        this._stateMachine.go('STOPPED');
    }
    seek(position) {
        this._stateMachine.go('PAUSED');
        this._stateMachine.go('SEEK', position);
    }
    getTotalPlaybackDuration() {
        return this._src.duration;
    }
    getPlaybackPosition() {
        const { pausedAt, startedAt } = this._stateMachine.data;
        if (pausedAt) {
            return pausedAt * this._playbackRate;
        }
        if (startedAt) {
            return (this._audioContext.currentTime - startedAt) * this._playbackRate;
        }
        return 0;
    }
    set playbackRate(playbackRate) {
        this._instance.playbackRate.value = this._playbackRate = playbackRate;
    }
    get playbackRate() {
        return this._instance.playbackRate.value;
    }
}

;// CONCATENATED MODULE: ./Events/MediaEvents.ts

class MediaEvent extends GameEvent {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}

;// CONCATENATED MODULE: ./Util/Sound.ts

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts








/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends Class {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super();
        this.logger = Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._isStopped = false;
        // private _isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._playbackRate = 1.0;
        this._audioContext = AudioContextFactory.create();
        this._resource = new Resource('', ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (canPlayFile(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    /**
     * Get the duration that this audio should play. If unset the total natural playback duration will be used.
     */
    get duration() {
        return this._duration;
    }
    /**
     * Set the duration that this audio should play. If unset the total natural playback duration will be used.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
        this._duration = duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    isLoaded() {
        return !!this.data;
    }
    async load() {
        var _a, _b;
        if (this.data) {
            return this.data;
        }
        const arraybuffer = await this._resource.load();
        const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));
        this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : undefined;
        this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));
        return this.data = audiobuffer;
    }
    async decodeAudio(data) {
        try {
            return await this._audioContext.decodeAudioData(data.slice(0));
        }
        catch (e) {
            this.logger.error('Unable to decode ' +
                ' this browser may not fully support this format, or the file may be corrupt, ' +
                'if this is an mp3 try removing id3 tags and album art from the file.');
            return await Promise.reject();
        }
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    isPaused() {
        return this._tracks.some(t => t.isPaused());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this.isPaused()) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this.emit('pause', new NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new NativeSoundEvent(this));
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    get playbackRate() {
        return this._playbackRate;
    }
    set playbackRate(playbackRate) {
        this._playbackRate = playbackRate;
        this._tracks.forEach(t => {
            t.playbackRate = this._playbackRate;
        });
    }
    seek(position, trackId = 0) {
        if (this._tracks.length === 0) {
            this._getTrackInstance(this.data);
        }
        this._tracks[trackId].seek(position);
    }
    getTotalPlaybackDuration() {
        return this.data.duration;
    }
    /**
     * Return the current playback time of the playing track in seconds from the start.
     *
     * Optionally specify the track to query if multiple are playing at once.
     * @param trackId
     */
    getPlaybackPosition(trackId = 0) {
        if (this._tracks.length) {
            return this._tracks[trackId].getPlaybackPosition();
        }
        return 0;
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    async _resumePlayback() {
        if (this.isPaused) {
            const resumed = [];
            // ensure we resume *current* tracks (if paused)
            for (const track of this._tracks) {
                resumed.push(track.play().then(() => {
                    this.emit('playbackend', new NativeSoundEvent(this, track));
                    this._tracks.splice(this.getTrackId(track), 1);
                    return true;
                }));
            }
            this.emit('resume', new NativeSoundEvent(this));
            this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
            // resolve when resumed tracks are done
            await Promise.all(resumed);
        }
        return true;
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    async _startPlayback() {
        const track = await this._getTrackInstance(this.data);
        const complete = await track.play(() => {
            this.emit('playbackstart', new NativeSoundEvent(this, track));
            this.logger.debug('Playing new instance for sound', this.path);
        });
        // when done, remove track
        this.emit('playbackend', new NativeSoundEvent(this, track));
        this._tracks.splice(this.getTrackId(track), 1);
        return complete;
    }
    _getTrackInstance(data) {
        const newTrack = new WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        newTrack.playbackRate = this._playbackRate;
        this._tracks.push(newTrack);
        return newTrack;
    }
}

;// CONCATENATED MODULE: ./Loader.ts












/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends Class {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this.canvas = new Canvas({
            filtering: ImageFiltering.Blended,
            smoothing: true,
            cache: true,
            draw: this.draw.bind(this)
        });
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = Loader_logo;
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        this._loadingFuture = new Future();
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
        this.canvas.width = this._engine.canvas.width;
        this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    async showPlayButton() {
        var _a, _b;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            // Delay is to give the logo a chance to show, otherwise don't delay
            await delay(500, (_a = this._engine) === null || _a === void 0 ? void 0 : _a.clock);
        }
        else {
            const resizeHandler = () => {
                this._positionPlayButton();
            };
            if ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.browser) {
                this._engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            this._positionPlayButton();
            const playButtonClicked = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propagation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this._engine.browser.window.off('resize', resizeHandler);
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return await playButtonClicked;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    update(_engine, _delta) {
        // override me
    }
    areResourcesLoaded() {
        return this._loadingFuture.promise;
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete AND the user has clicked the "Play button"
     */
    async load() {
        var _a, _b;
        await ((_a = this._image) === null || _a === void 0 ? void 0 : _a.decode()); // decode logo if it exists
        this.canvas.flagDirty();
        await Promise.all(this._resourceList.map(async (r) => {
            await r.load().finally(() => {
                // capture progress
                this._numLoaded++;
                this.canvas.flagDirty();
            });
        }));
        // Wire all sound to the engine
        for (const resource of this._resourceList) {
            if (resource instanceof Sound) {
                resource.wireEngine(this._engine);
            }
        }
        this._loadingFuture.resolve();
        // short delay in showing the button for aesthetics
        await delay(200, (_b = this._engine) === null || _b === void 0 ? void 0 : _b.clock);
        this.canvas.flagDirty();
        await this.showPlayButton();
        // Unlock browser AudioContext in after user gesture
        // See: https://github.com/excaliburjs/Excalibur/issues/262
        // See: https://github.com/excaliburjs/Excalibur/issues/1031
        await WebAudio.unlock();
        return (this.data = this._resourceList);
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progress of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
        if (this._engine) {
            const screenHeight = this._engine.screen.viewport.height;
            const screenWidth = this._engine.screen.viewport.width;
            if (this._playButtonRootElement) {
                const left = this._engine.canvas.offsetLeft;
                const top = this._engine.canvas.offsetTop;
                const buttonWidth = this._playButton.clientWidth;
                const buttonHeight = this._playButton.clientHeight;
                if (this.playButtonPosition) {
                    this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                    this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
                }
                else {
                    this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                    this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
                }
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
}

;// CONCATENATED MODULE: ./Util/Detector.ts

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // (✓)
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // (✗)
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionType.ts
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));

;// CONCATENATED MODULE: ./Util/Decorators.ts


const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrace: false,
        ...options
    };
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? { ...descriptor } : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}

;// CONCATENATED MODULE: ./Collision/Physics.ts
var __decorate = ( false) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy["Arcade"] = "arcade";
    CollisionResolutionStrategy["Realistic"] = "realistic";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 0] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    static get gravity() {
        return Physics.acc;
    }
    static set gravity(v) {
        Physics.acc = v;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new Vector(0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Number of position iterations (overlap) to run in the solver
 */
Physics.positionIterations = 3;
/**
 * Number of velocity iteration (response) to run in the solver
 */
Physics.velocityIterations = 8;
/**
 * Amount of overlap to tolerate in pixels
 */
Physics.slop = 1;
/**
 * Amount of positional overlap correction to apply each position iteration of the solver
 * O - meaning no correction, 1 - meaning correct all overlap
 */
Physics.steeringFactor = 0.2;
/**
 * Warm start set to true re-uses impulses from previous frames back in the solver
 */
Physics.warmStart = true;
/**
 * By default bodies do not sleep
 */
Physics.bodiesCanSleepByDefault = false;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
Physics.sleepEpsilon = 0.07;
Physics.wakeThreshold = Physics.sleepEpsilon * 3;
Physics.sleepBias = 0.9;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
__decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);

;// CONCATENATED MODULE: ./Math/coord-plane.ts
/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));

;// CONCATENATED MODULE: ./Math/vector-view.ts

class VectorView extends Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}

;// CONCATENATED MODULE: ./Math/watch-vector.ts

/**
 * Wraps a vector and watches for changes in the x/y, modifies the original vector.
 */
class WatchVector extends Vector {
    constructor(original, change) {
        super(original.x, original.y);
        this.original = original;
        this.change = change;
    }
    get x() {
        return this._x = this.original.x;
    }
    set x(newX) {
        this.change(newX, this._y);
        this._x = this.original.x = newX;
    }
    get y() {
        return this._y = this.original.y;
    }
    set y(newY) {
        this.change(this._x, newY);
        this._y = this.original.y = newY;
    }
}

;// CONCATENATED MODULE: ./Math/transform.ts





class Transform {
    constructor() {
        this._parent = null;
        this._children = [];
        this._pos = vec(0, 0);
        this._rotation = 0;
        this._scale = vec(1, 1);
        this._isDirty = false;
        this._isInverseDirty = false;
        this._matrix = AffineMatrix.identity();
        this._inverse = AffineMatrix.identity();
    }
    get parent() {
        return this._parent;
    }
    set parent(transform) {
        if (this._parent) {
            const index = this._parent._children.indexOf(this);
            if (index > -1) {
                this._parent._children.splice(index, 1);
            }
        }
        this._parent = transform;
        if (this._parent) {
            this._parent._children.push(this);
        }
        this.flagDirty();
    }
    get children() {
        return this._children;
    }
    set pos(v) {
        if (!v.equals(this._pos)) {
            this._pos.x = v.x;
            this._pos.y = v.y;
            this.flagDirty();
        }
    }
    get pos() {
        return new WatchVector(this._pos, (x, y) => {
            if (x !== this._pos.x || y !== this._pos.y) {
                this.flagDirty();
            }
        });
    }
    set globalPos(v) {
        let localPos = v.clone();
        if (this.parent) {
            localPos = this.parent.inverse.multiply(v);
        }
        if (!localPos.equals(this._pos)) {
            this._pos = localPos;
            this.flagDirty();
        }
    }
    get globalPos() {
        return new VectorView({
            getX: () => this.matrix.data[4],
            getY: () => this.matrix.data[5],
            setX: (x) => {
                if (this.parent) {
                    const { x: newX } = this.parent.inverse.multiply(vec(x, this.pos.y));
                    this.pos.x = newX;
                }
                else {
                    this.pos.x = x;
                }
                if (x !== this.matrix.data[4]) {
                    this.flagDirty();
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y));
                    this.pos.y = newY;
                }
                else {
                    this.pos.y = y;
                }
                if (y !== this.matrix.data[5]) {
                    this.flagDirty();
                }
            }
        });
    }
    set rotation(rotation) {
        const canonRotation = canonicalizeAngle(rotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get rotation() {
        return this._rotation;
    }
    set globalRotation(rotation) {
        let inverseRotation = 0;
        if (this.parent) {
            inverseRotation = this.parent.globalRotation;
        }
        const canonRotation = canonicalizeAngle(rotation + inverseRotation);
        if (canonRotation !== this._rotation) {
            this.flagDirty();
        }
        this._rotation = canonRotation;
    }
    get globalRotation() {
        if (this.parent) {
            return this.matrix.getRotation();
        }
        return this.rotation;
    }
    set scale(v) {
        if (!v.equals(this._scale)) {
            this._scale.x = v.x;
            this._scale.y = v.y;
            this.flagDirty();
        }
    }
    get scale() {
        return new WatchVector(this._scale, (x, y) => {
            if (x !== this._scale.x || y !== this._scale.y) {
                this.flagDirty();
            }
        });
    }
    set globalScale(v) {
        let inverseScale = vec(1, 1);
        if (this.parent) {
            inverseScale = this.parent.globalScale;
        }
        this.scale = v.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));
    }
    get globalScale() {
        return new VectorView({
            getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,
            getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.scale.x = x / globalScaleX;
                }
                else {
                    this.scale.x = x;
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.scale.y = y / globalScaleY;
                }
                else {
                    this.scale.y = y;
                }
            }
        });
    }
    get matrix() {
        if (this._isDirty) {
            if (this.parent === null) {
                this._matrix = this._calculateMatrix();
            }
            else {
                this._matrix = this.parent.matrix.multiply(this._calculateMatrix());
            }
            this._isDirty = false;
        }
        return this._matrix;
    }
    get inverse() {
        if (this._isInverseDirty) {
            this._inverse = this.matrix.inverse();
            this._isInverseDirty = false;
        }
        return this._inverse;
    }
    _calculateMatrix() {
        const matrix = AffineMatrix.identity()
            .translate(this.pos.x, this.pos.y)
            .rotate(this.rotation)
            .scale(this.scale.x, this.scale.y);
        return matrix;
    }
    flagDirty() {
        this._isDirty = true;
        this._isInverseDirty = true;
        for (let i = 0; i < this._children.length; i++) {
            this._children[i].flagDirty();
        }
    }
    apply(point) {
        return this.matrix.multiply(point);
    }
    applyInverse(point) {
        return this.inverse.multiply(point);
    }
    setTransform(pos, rotation, scale) {
        this._pos.x = pos.x;
        this._pos.y = pos.y;
        this._rotation = canonicalizeAngle(rotation);
        this._scale.x = scale.x;
        this._scale.y = scale.y;
        this.flagDirty();
    }
    clone(dest) {
        const target = dest !== null && dest !== void 0 ? dest : new Transform();
        this._pos.clone(target._pos);
        target._rotation = this._rotation;
        this._scale.clone(target._scale);
        target.flagDirty();
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependencies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}

;// CONCATENATED MODULE: ./Util/Observable.ts
/**
 * Simple Observable implementation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        const observersLength = this.observers.length;
        for (let i = 0; i < observersLength; i++) {
            this.observers[i].notify(message);
        }
        const subscriptionsLength = this.subscriptions.length;
        for (let i = 0; i < subscriptionsLength; i++) {
            this.subscriptions[i](message);
        }
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts




class TransformComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.transform';
        this._transform = new Transform();
        this._addChildTransform = (child) => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = this._transform;
            }
        };
        /**
         * Observable that emits when the z index changes on this component
         */
        this.zIndexChanged$ = new Observable();
        this._z = 0;
        /**
         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
    }
    get() {
        return this._transform;
    }
    onAdd(owner) {
        for (const child of owner.children) {
            this._addChildTransform(child);
        }
        owner.childrenAdded$.subscribe(child => this._addChildTransform(child));
        owner.childrenRemoved$.subscribe(child => {
            const childTxComponent = child.get(TransformComponent);
            if (childTxComponent) {
                childTxComponent._transform.parent = null;
            }
        });
    }
    onRemove(_previousOwner) {
        this._transform.parent = null;
    }
    /**
     * The z-index ordering of the entity, a higher values are drawn on top of lower values.
     * For example z=99 would be drawn on top of z=0.
     */
    get z() {
        return this._z;
    }
    set z(val) {
        const oldz = this._z;
        this._z = val;
        if (oldz !== val) {
            this.zIndexChanged$.notifyAll(val);
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(v) {
        this._transform.pos = v;
    }
    get globalPos() {
        return this._transform.globalPos;
    }
    set globalPos(v) {
        this._transform.globalPos = v;
    }
    get rotation() {
        return this._transform.rotation;
    }
    set rotation(rotation) {
        this._transform.rotation = rotation;
    }
    get globalRotation() {
        return this._transform.globalRotation;
    }
    set globalRotation(rotation) {
        this._transform.globalRotation = rotation;
    }
    get scale() {
        return this._transform.scale;
    }
    set scale(v) {
        this._transform.scale = v;
    }
    get globalScale() {
        return this._transform.globalScale;
    }
    set globalScale(v) {
        this._transform.globalScale = v;
    }
    applyInverse(v) {
        return this._transform.applyInverse(v);
    }
    apply(v) {
        return this._transform.apply(v);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts


class MotionComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.motion';
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inertia can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}

;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        return CollisionGroup.combine(collisionGroups).invert();
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);

;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Returns whether a it is allowed for 2 colliders in a Pair to collide
     * @param colliderA
     * @param colliderB
     */
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        // Prevent self collision
        if (colliderA.id === colliderB.id) {
            return false;
        }
        // Colliders with the same owner do not collide (composite colliders)
        if (colliderA.owner &&
            colliderB.owner &&
            colliderA.owner.id === colliderB.owner.id) {
            return false;
        }
        // if the pair has a member with zero dimension don't collide
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.active || !bodyB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}

;// CONCATENATED MODULE: ./Math/projection.ts
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts





/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= Physics.boundsPadding;
        b.top -= Physics.boundsPadding;
        b.right += Physics.boundsPadding;
        b.bottom += Physics.boundsPadding;
        // THIS IS CAUSING UNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.overlaps(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}

;// CONCATENATED MODULE: ./Math/ray.ts
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts









/**
 * Responsible for performing the collision broadphase (locating potential collisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor() {
        this._dynamicCollisionTree = new DynamicTree();
        this._pairs = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _pairExists(colliderA, colliderB) {
        // if the collision pair has been calculated already short circuit
        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
        return this._pairs.has(hash);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._pairs.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
                    const pair = new Pair(collider, other);
                    this._pairs.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (Physics.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.size * seconds + // velocity term
                    body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.globalPos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
                        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && Vector.isValid(minTranslate)) {
                        const pair = new Pair(collider, minCollider);
                        if (!this._pairs.has(pair.id)) {
                            this._pairs.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.globalPos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform.get());
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts


/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = createId('collider', Collider._ID++);
        /**
         * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider
         * @internal
         * @hidden
         */
        this.__compositeColliderId = null;
        this.events = new EventDispatcher();
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;

;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts








class CompositeCollider extends Collider {
    constructor(colliders) {
        super();
        this._collisionProcessor = new DynamicTreeCollisionProcessor();
        this._dynamicAABBTree = new DynamicTree();
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        this.events.wire(collider.events);
        collider.__compositeColliderId = this.id;
        this._colliders.push(collider);
        this._collisionProcessor.track(collider);
        this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
        this.events.unwire(collider.events);
        collider.__compositeColliderId = null;
        removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        // TODO transform component world pos
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
        return results;
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const points = [];
        for (const collider of colliders) {
            const vec = collider.rayCast(ray, max);
            if (vec) {
                points.push(vec);
            }
        }
        if (points.length) {
            let minPoint = points[0];
            let minDistance = minPoint.dot(ray.dir);
            for (const point of points) {
                const distance = ray.dir.dot(point);
                if (distance < minDistance) {
                    minPoint = point;
                    minDistance = distance;
                }
            }
            return minPoint;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projs = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projs.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projs.length) {
            const newProjection = new Projection(projs[0].min, projs[0].max);
            for (const proj of projs) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    debug(ex, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.debug(ex, color);
        }
    }
    clone() {
        return new CompositeCollider(this._colliders.map((c) => c.clone()));
    }
}

;// CONCATENATED MODULE: ./Math/line-segment.ts

/**
 * A 2D line segment
 */
class LineSegment {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        if (this._normal) {
            return this._normal;
        }
        return this._normal = this.end.sub(this.begin).normal();
    }
    dir() {
        if (this._dir) {
            return this._dir;
        }
        return this._dir = this.end.sub(this.begin);
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        if (this._slope) {
            return this._slope;
        }
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return this._slope = end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        if (this._length) {
            return this._length;
        }
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return this._length = distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new LineSegment(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
        let dir = sideVector;
        dir = dir.normalize();
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new LineSegment(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts



/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new LineSegment(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts










/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends Collider {
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = Vector.Zero;
        this._globalMatrix = AffineMatrix.identity();
        this.offset = options.offset || Vector.Zero;
        this.radius = options.radius || 0;
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    get worldPos() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Get the radius of the circle
     */
    get radius() {
        var _a;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        return this._naturalRadius * Math.min(scale.x, scale.y);
    }
    /**
     * Set the radius of the circle
     */
    set radius(val) {
        var _a;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        // This is a trade off, the alternative is retooling circles to support ellipse collisions
        this._naturalRadius = val / Math.min(scale.x, scale.y);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this._globalMatrix.getPosition();
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        var _a, _b, _c;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);
        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius).rotate(rotation).scale(scale).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color) {
        var _a, _b, _c, _d;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero);
        ex.save();
        ex.translate(pos.x, pos.y);
        ex.rotate(rotation);
        ex.scale(scale.x, scale.y);
        ex.drawCircle(((_d = this.offset) !== null && _d !== void 0 ? _d : Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);
        ex.restore();
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts




/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        var _a, _b;
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {
            // Add on the parent composite pair for start/end contact
            this.id += '|' + Pair.calculatePairHash((_a = colliderA.__compositeColliderId) !== null && _a !== void 0 ? _a : colliderA.id, (_b = colliderB.__compositeColliderId) !== null && _b !== void 0 ? _b : colliderB.id);
        }
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts








const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.size,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(TransformComponent).get());
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        var _a, _b, _c, _d;
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const incident = other.findSide(separation.axis.negate());
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const reference = separation.side;
        const refDir = reference.dir().normalize();
        // Find our contact points by clipping the incident by the collision side
        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
        }
        // If there is no left there is no collision
        if (clipLeft) {
            // We only want clip points below the reference edge, discard the others
            const points = clipLeft.getPoints().filter((p) => {
                return reference.below(p);
            });
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.center.sub(polyA.center).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            // Points are clipped from incident which is the other collider
            // Store those as locals
            let localPoints = [];
            if (separation.collider === polyA) {
                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            else {
                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
        // both are circles
        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||
            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||
            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||
            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts










/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this._globalMatrix = AffineMatrix.identity();
        this.begin = options.begin || Vector.Zero;
        this.end = options.end || Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const pos = begin.average(end);
        return pos;
    }
    _getTransformedBegin() {
        return this._globalMatrix.multiply(this.begin);
    }
    _getTransformedEnd() {
        return this._globalMatrix.multiply(this.end);
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new LineSegment(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        var _a;
        this._transform = transform;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts














/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends Collider {
    constructor(options) {
        var _a, _b;
        super();
        this._logger = Logger.getInstance();
        this._transformedPoints = [];
        this._sides = [];
        this._localSides = [];
        this._globalMatrix = AffineMatrix.identity();
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        this._localSidesDirty = true;
        this._localBoundsDirty = true;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
        this._globalMatrix.translate(this.offset.x, this.offset.y);
        this.points = (_b = options.points) !== null && _b !== void 0 ? _b : [];
        const counterClockwise = this._isCounterClockwiseWinding(this.points);
        if (!counterClockwise) {
            this.points.reverse();
        }
        if (!this.isConvex()) {
            this._logger.warn('Excalibur only supports convex polygon colliders and will not behave properly.' +
                'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');
        }
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    set points(points) {
        this._localBoundsDirty = true;
        this._localSidesDirty = true;
        this._sidesDirty = true;
        this._points = points;
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    get points() {
        return this._points;
    }
    _isCounterClockwiseWinding(points) {
        // https://stackoverflow.com/a/1165943
        let sum = 0;
        for (let i = 0; i < points.length; i++) {
            sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);
        }
        return sum < 0;
    }
    /**
     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
     * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape
     */
    isConvex() {
        // From SO: https://stackoverflow.com/a/45372025
        if (this.points.length < 3) {
            return false;
        }
        let oldPoint = this.points[this.points.length - 2];
        let newPoint = this.points[this.points.length - 1];
        let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
        let oldDirection = 0;
        let orientation = 0;
        let angleSum = 0;
        for (const [i, point] of this.points.entries()) {
            oldPoint = newPoint;
            oldDirection = direction;
            newPoint = point;
            direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
            if (oldPoint.equals(newPoint)) {
                return false; // repeat point
            }
            let angle = direction - oldDirection;
            if (angle <= -Math.PI) {
                angle += Math.PI * 2;
            }
            else if (angle > Math.PI) {
                angle -= Math.PI * 2;
            }
            if (i === 0) {
                if (angle === 0.0) {
                    return false;
                }
                orientation = angle > 0 ? 1 : -1;
            }
            else {
                if (orientation * angle <= 0) {
                    return false;
                }
            }
            angleSum += angle;
        }
        return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;
    }
    /**
     * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons
     */
    tessellate() {
        const polygons = [];
        for (let i = 1; i < this.points.length - 2; i++) {
            polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);
        }
        polygons.push([this.points[0], this.points[1], this.points[2]]);
        return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));
    }
    /**
     * Triangulate the polygon collider using the "Ear Clipping" algorithm.
     * Returns a new [[CompositeCollider]] made up of smaller triangles.
     */
    triangulate() {
        // https://www.youtube.com/watch?v=hTJFcHutls8
        if (this.points.length < 3) {
            throw Error('Invalid polygon');
        }
        /**
         * Helper to get a vertex in the list
         */
        function getItem(index, list) {
            if (index >= list.length) {
                return list[index % list.length];
            }
            else if (index < 0) {
                return list[index % list.length + list.length];
            }
            else {
                return list[index];
            }
        }
        /**
         * Quick test for point in triangle
         */
        function isPointInTriangle(point, a, b, c) {
            const ab = b.sub(a);
            const bc = c.sub(b);
            const ca = a.sub(c);
            const ap = point.sub(a);
            const bp = point.sub(b);
            const cp = point.sub(c);
            const cross1 = ab.cross(ap);
            const cross2 = bc.cross(bp);
            const cross3 = ca.cross(cp);
            if (cross1 > 0 || cross2 > 0 || cross3 > 0) {
                return false;
            }
            return true;
        }
        const triangles = [];
        const vertices = [...this.points];
        const indices = range(0, this.points.length - 1);
        // 1. Loop through vertices clockwise
        //    if the vertex is convex (interior angle is < 180) (cross product positive)
        //    if the polygon formed by it's edges doesn't contain the points
        //         it's an ear add it to our list of triangles, and restart
        while (indices.length > 3) {
            for (let i = 0; i < indices.length; i++) {
                const a = indices[i];
                const b = getItem(i - 1, indices);
                const c = getItem(i + 1, indices);
                const va = vertices[a];
                const vb = vertices[b];
                const vc = vertices[c];
                // Check convexity
                const leftArm = vb.sub(va);
                const rightArm = vc.sub(va);
                const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex
                if (!isConvex) {
                    continue;
                }
                let isEar = true;
                // Check that if any vertices are in the triangle a, b, c
                for (let j = 0; j < indices.length; j++) {
                    const vertIndex = indices[j];
                    // We can skip these
                    if (vertIndex === a || vertIndex === b || vertIndex === c) {
                        continue;
                    }
                    const point = vertices[vertIndex];
                    if (isPointInTriangle(point, vb, va, vc)) {
                        isEar = false;
                        break;
                    }
                }
                // Add ear to polygon list and remove from list
                if (isEar) {
                    triangles.push([vb, va, vc]);
                    indices.splice(i, 1);
                    break;
                }
            }
        }
        triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);
        return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        if (this._transform) {
            return this._transform.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const points = this.points;
        const len = points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this._globalMatrix.multiply(points[i].clone());
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        if (this._transformedPointsDirty) {
            this._calculateTransformation();
            this._transformedPointsDirty = false;
        }
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sidesDirty) {
            const lines = [];
            const points = this.getTransformedPoints();
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new LineSegment(points[i], points[(i + 1) % len]));
            }
            this._sides = lines;
            this._sidesDirty = false;
        }
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSidesDirty) {
            const lines = [];
            const points = this.points;
            const len = points.length;
            for (let i = 0; i < len; i++) {
                // This winding is important
                lines.push(new LineSegment(points[i], points[(i + 1) % len]));
            }
            this._localSides = lines;
            this._localSidesDirty = false;
        }
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        const axes = [];
        const sides = this.getSides();
        for (let i = 0; i < sides.length; i++) {
            axes.push(sides[i].normal());
        }
        return axes;
    }
    /**
     * Updates the transform for the collision geometry
     *
     * Collision geometry (points/bounds) will not change until this is called.
     * @param transform
     */
    update(transform) {
        var _a;
        this._transform = transform;
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        // This change means an update must be performed in order for geometry to update
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new Ray(point, new Vector(1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof CircleCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        return this.localBounds.transform(this._globalMatrix);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        if (this._localBoundsDirty) {
            this._localBounds = BoundingBox.fromPoints(this.points);
            this._localBoundsDirty = false;
        }
        return this._localBounds;
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        if (this._cachedMass === mass && this._cachedInertia) {
            return this._cachedInertia;
        }
        let numerator = 0;
        let denominator = 0;
        const points = this.points;
        for (let i = 0; i < points.length; i++) {
            const iplusone = (i + 1) % points.length;
            const crossTerm = points[iplusone].cross(points[i]);
            numerator +=
                crossTerm *
                    (points[i].dot(points[i]) + points[i].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));
            denominator += crossTerm;
        }
        this._cachedMass = mass;
        return this._cachedInertia = (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new Projection(min, max);
    }
    debug(ex, color) {
        const firstPoint = this.getTransformedPoints()[0];
        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
        for (let i = 0; i < points.length - 1; i++) {
            ex.drawLine(points[i], points[i + 1], color, 2);
            ex.drawCircle(points[i], 2, color);
            ex.drawCircle(points[i + 1], 2, color);
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
        return new PolygonCollider({
            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, offset = Vector.Zero) {
        return new PolygonCollider({
            points: points,
            offset: offset
        });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
        return new CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
        const logger = Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, Vector.Half, offset),
                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, Vector.Half, offset),
                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts









class ColliderComponent extends Component {
    constructor(collider) {
        super();
        this.type = 'ex.collider';
        this.events = new EventDispatcher();
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new Observable();
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            this.events.wire(collider.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this.events.unwire(this._collider.events);
            this.$colliderRemoved.notifyAll(this._collider);
            this._collider.owner = null;
            this._collider = null;
        }
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx.get());
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite lefthand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
        const collider = Shape.Box(width, height, anchor, center);
        return (this.set(collider));
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
        const poly = Shape.Polygon(points, center);
        return (this.set(poly));
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
        const collider = Shape.Circle(radius, center);
        return (this.set(collider));
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = Shape.Edge(begin, end);
        return (this.set(collider));
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     */
    useCompositeCollider(colliders) {
        return (this.set(new CompositeCollider(colliders)));
    }
}

;// CONCATENATED MODULE: ./Collision/BodyComponent.ts












var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.type = 'ex.body';
        this.dependencies = [TransformComponent, MotionComponent];
        this.id = createId('body', BodyComponent._ID++);
        this.events = new EventDispatcher();
        this._oldTransform = new Transform();
        /**
         * Indicates whether the old transform has been captured at least once for interpolation
         * @internal
         */
        this.__oldTransformCaptured = false;
        /**
         * Enable or disabled the fixed update interpolation, by default interpolation is on.
         */
        this.enableFixedUpdateInterpolate = true;
        /**
         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]
         */
        this.collisionType = CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = CollisionGroup.All;
        /**
         * The amount of mass the body has
         */
        this._mass = Physics.defaultMass;
        /**
         * Amount of "motion" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to "sleep"
         */
        this.sleepMotion = Physics.sleepEpsilon * 5;
        /**
         * Can this body sleep, by default bodies do not sleep
         */
        this.canSleep = Physics.bodiesCanSleepByDefault;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         *
         * Note: this only limits responses in the realistic solver, if velocity/angularVelocity is set the actor will still respond
         */
        this.limitDegreeOfFreedom = [];
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = Vector.Zero;
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
        }
    }
    get matrix() {
        return this.transform.get().matrix;
    }
    get mass() {
        return this._mass;
    }
    set mass(newMass) {
        this._mass = newMass;
        this._cachedInertia = undefined;
        this._cachedInverseInertia = undefined;
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = Physics.sleepEpsilon * 5;
        }
        else {
            this.vel = Vector.Zero;
            this.acc = Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.setSleeping(true);
        }
        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = Physics.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
            this.setSleeping(true);
        }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
        if (this._cachedInertia) {
            return this._cachedInertia;
        }
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(ColliderComponent);
        if (collider) {
            collider.$colliderAdded.subscribe(() => {
                this._cachedInertia = null;
            });
            collider.$colliderRemoved.subscribe(() => {
                this._cachedInertia = null;
            });
            const maybeCollider = collider.get();
            if (maybeCollider) {
                return this._cachedInertia = maybeCollider.getInertia(this.mass);
            }
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        if (this._cachedInverseInertia) {
            return this._cachedInverseInertia;
        }
        return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    /**
     * @deprecated Use globalP0s
     */
    get center() {
        return this.globalPos;
    }
    get transform() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    get pos() {
        return this.transform.pos;
    }
    set pos(val) {
        this.transform.pos = val;
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get globalPos() {
        return this.transform.globalPos;
    }
    set globalPos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The position of the actor last frame (x, y) in pixels
     */
    get oldPos() {
        return this._oldTransform.pos;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * Gets/sets the rotation of the body from the last frame.
     */
    get oldRotation() {
        return this._oldTransform.rotation;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The scale of the actor last frame
     */
    get oldScale() {
        return this._oldTransform.scale;
    }
    /**
     * The scale rate of change of the actor in scale/second
     */
    get scaleFactor() {
        return this.motion.scaleFactor;
    }
    set scaleFactor(scaleFactor) {
        this.motion.scaleFactor = scaleFactor;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impulse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.globalPos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.__oldTransformCaptured = true;
        this.transform.get().clone(this._oldTransform);
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
    }
}
BodyComponent._ID = 0;

;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts





/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends Class {
    constructor(components, name) {
        super();
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this._name = 'anonymous';
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        this._componentTypeToInstance = new Map();
        this._componentStringToInstance = new Map();
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.componentAdded$ = new Observable();
        this.componentRemoved$ = new Observable();
        this._parent = null;
        this.childrenAdded$ = new Observable();
        this.childrenRemoved$ = new Observable();
        this._children = [];
        this._isInitialized = false;
        this._setName(name);
        if (components) {
            for (const component of components) {
                this.addComponent(component);
            }
        }
    }
    _setName(name) {
        if (name) {
            this._name = name;
        }
    }
    get name() {
        return this._name;
    }
    get events() {
        return this.eventDispatcher;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
        return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
        return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Array.from(this._componentStringToInstance.values())
            .filter((c) => c instanceof TagComponent)
            .map((c) => c.type);
        this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
        return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
        this._rebuildMemos();
        const added = new AddedComponent({
            component,
            entity: this
        });
        this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
        const removed = new RemovedComponent({
            component,
            entity: this
        });
        this.componentRemoved$.notifyAll(removed);
        this._rebuildMemos();
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            removeItemFromArray(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        this.children.forEach((c) => {
            this.removeChild(c);
        });
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            queue = queue.concat(curr.children);
            result = result.concat(curr.children);
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.get(c).clone());
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it already exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.type)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component);
            }
            else {
                // early exit component exits
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const constuctorType = component.constructor;
        this._componentTypeToInstance.set(constuctorType, component);
        this._componentStringToInstance.set(component.type, component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this._notifyAddComponent(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof Component) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.has(type)) {
            const component = this.get(type);
            component.owner = null;
            if (component.onRemove) {
                component.onRemove(this);
            }
            const ctor = component.constructor;
            this._componentTypeToInstance.delete(ctor);
            this._componentStringToInstance.delete(component.type);
            this._notifyRemoveComponent(component);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    has(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.has(type);
        }
        else {
            return this._componentTypeToInstance.has(type);
        }
    }
    get(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.get(type);
        }
        else {
            return this._componentTypeToInstance.get(type);
        }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        for (const child of this.children) {
            child.update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
}
Entity._ID = 0;

;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts





/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
class GraphicsLayer {
    constructor(_options, _graphics) {
        this._options = _options;
        this._graphics = _graphics;
        this.graphics = [];
    }
    get name() {
        return this._options.name;
    }
    hide(nameOrGraphic) {
        if (!nameOrGraphic) {
            this.graphics.length = 0;
        }
        else {
            let gfx = null;
            if (nameOrGraphic instanceof Graphic) {
                gfx = nameOrGraphic;
            }
            else {
                gfx = this._graphics.getGraphic(nameOrGraphic);
            }
            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);
            this._graphics.recalculateBounds();
        }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
        options = { ...options };
        let gfx;
        if (nameOrGraphic instanceof Graphic) {
            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
        }
        else {
            gfx = this._graphics.getGraphic(nameOrGraphic);
            if (!gfx) {
                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
            }
        }
        if (gfx) {
            this.graphics.push({ graphic: gfx, options });
            this._graphics.recalculateBounds();
            return gfx;
        }
        else {
            return null;
        }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        options = { ...options };
        this.hide();
        return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
        return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
        this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
        var _a;
        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
        this._options.offset = value;
    }
    get currentKeys() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';
    }
}
class GraphicsLayers {
    constructor(_component) {
        this._component = _component;
        this._layers = [];
        this._layerMap = {};
        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);
        this._maybeAddLayer(this.default);
    }
    create(options) {
        const layer = new GraphicsLayer(options, this._component);
        return this._maybeAddLayer(layer);
    }
    get(name) {
        if (name) {
            return this._getLayer(name);
        }
        return this._layers;
    }
    currentKeys() {
        const graphicsLayerKeys = [];
        for (const layer of this._layers) {
            graphicsLayerKeys.push(layer.currentKeys);
        }
        return graphicsLayerKeys;
    }
    has(name) {
        return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
        if (this._layerMap[layer.name]) {
            // todo log warning
            return this._layerMap[layer.name];
        }
        this._layerMap[layer.name] = layer;
        this._layers.push(layer);
        this._layers.sort((a, b) => a.order - b.order);
        return layer;
    }
    _getLayer(name) {
        return this._layerMap[name];
    }
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends Component {
    constructor(options) {
        super();
        this.type = 'ex.graphics';
        this._graphics = {};
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        /**
         * Offset to apply to graphics by default
         */
        this.offset = Vector.Zero;
        /**
         * Anchor to apply to graphics by default
         */
        this.anchor = Vector.Half;
        /**
         * If set to true graphics added to the component will be copied. This can affect performance
         */
        this.copyGraphics = false;
        this._localBounds = null;
        // Defaults
        options = {
            visible: this.visible,
            ...options
        };
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
        this._graphics = graphics || {};
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.visible = !!visible;
        this.layers = new GraphicsLayers(this);
        if (current && this._graphics[current]) {
            this.show(this._graphics[current]);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
        return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    add(nameOrGraphic, graphic) {
        let name = 'default';
        let graphicToSet = null;
        if (typeof nameOrGraphic === 'string') {
            name = nameOrGraphic;
            graphicToSet = graphic;
        }
        else {
            graphicToSet = nameOrGraphic;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        if (name === 'default') {
            this.show('default');
        }
        return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
        const result = this.layers.default.show(nameOrGraphic, options);
        this.recalculateBounds();
        return result;
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        const result = this.layers.default.use(nameOrGraphic, options);
        this.recalculateBounds();
        return result;
    }
    hide(nameOrGraphic) {
        this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
        this._localBounds = bounds;
    }
    recalculateBounds() {
        let bb = new BoundingBox();
        for (const layer of this.layers.get()) {
            for (const { graphic, options } of layer.graphics) {
                let anchor = this.anchor;
                let offset = this.offset;
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const bounds = graphic.localBounds;
                const offsetX = -bounds.width * anchor.x + offset.x;
                const offsetY = -bounds.height * anchor.y + offset.y;
                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);
            }
        }
        this._localBounds = bb;
    }
    get localBounds() {
        if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
            this.recalculateBounds();
        }
        return this._localBounds;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        for (const layer of this.layers.get()) {
            for (const { graphic } of layer.graphics) {
                if (hasGraphicsTick(graphic)) {
                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Rectangle.ts

/**
 * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]
 */
class Rectangle extends Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle({
            width: this.width,
            height: this.height,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Circle.ts


/**
 * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]
 *
 * Circles default to [[ImageFiltering.Blended]]
 */
class Circle extends Raster {
    constructor(options) {
        var _a, _b;
        super(options);
        this._radius = 0;
        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.filtering = (_b = options.filtering) !== null && _b !== void 0 ? _b : ImageFiltering.Blended;
        this.rasterize();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    clone() {
        return new Circle({
            radius: this.radius,
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Input/PointerComponent.ts

/**
 * Add this component to optionally configure how the pointer
 * system detects pointer events.
 *
 * By default the collider shape is used and graphics bounds is not.
 *
 * If both collider shape and graphics bounds are enabled it will fire events if either or
 * are intersecting the pointer.
 */
class PointerComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.pointer';
        /**
         * Use any existing Collider component geometry for pointer events. This is useful if you want
         * user pointer events only to trigger on the same collision geometry used in the collider component
         * for collision resolution. Default is `true`.
         */
        this.useColliderShape = true;
        /**
         * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned
         * bounds around the graphic to trigger pointer events. Default is `false`.
         */
        this.useGraphicsBounds = false;
    }
}

;// CONCATENATED MODULE: ./Util/EasingFunctions.ts

/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});

;// CONCATENATED MODULE: ./Actions/ActionQueue.ts
/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(elapsedMs);
            if (this._currentAction.isComplete(this._entity)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts

class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(delta) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts

/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts




class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = new Vector(offsetX, offsetY);
        if (speed <= 0) {
            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts



class MoveTo {
    constructor(entity, destx, desty, speed) {
        this.entity = entity;
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = new Vector(destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/RotationType.ts
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));

;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts




class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts




class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._start = undefined;
        this._currentNonCannonAngle = undefined;
        this._distance = undefined;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts



class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = vec(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.y - this._startX) >= (this._distanceX - 0.01) &&
                Math.abs(this._tx.scale.y - this._startY) >= (this._distanceY - 0.01)));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts



class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._offset = new Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= (this._distanceX - 0.01) &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= (this._distanceY - 0.01)));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts
class CallMethod {
    constructor(method) {
        this._method = null;
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(_delta) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts



class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseBy.ts



class EaseBy {
    constructor(entity, offsetX, offsetY, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._offset = new Vector(offsetX, offsetY);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._lerpEnd = this._lerpStart.add(this._offset);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete() {
        return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
        this._initialized = false;
        this._stopped = false;
        this._currentLerpTime = 0;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Blink.ts

class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
            this._elapsedTime = 0;
            this._totalTime = 0;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
            this._graphics.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.visible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Fade.ts


class Fade {
    constructor(entity, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(GraphicsComponent);
        this._endOpacity = endOpacity;
        this._speed = this._ogspeed = speed;
    }
    update(delta) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            this._speed = this._ogspeed;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._graphics.opacity += (this._multiplier *
                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Delay.ts
class Delay {
    constructor(delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Die.ts

class Die {
    constructor(entity) {
        this._stopped = false;
        this._entity = entity;
    }
    update(_delta) {
        this._entity.get(ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Follow.ts



class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._followTx = entityToFollow.get(TransformComponent);
        this._followMotion = entityToFollow.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = vec(m.x, m.y);
        }
        else {
            this._motion.vel = vec(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
        this._stopped = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Meet.ts



class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(TransformComponent);
        this._motion = actor.get(MotionComponent);
        this._meetTx = actorToMeet.get(TransformComponent);
        this._meetMotion = actorToMeet.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._stopped = false;
        this._distanceBetween = undefined;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionContext.ts




















/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsedMs) {
        this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    runAction(action) {
        action.reset();
        this._queue.add(action);
        return this;
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    easeBy(...args) {
        var _a, _b;
        let offsetX = 0;
        let offsetY = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            offsetX = args[0].x;
            offsetY = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            offsetX = args[0];
            offsetY = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));
        return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPos instanceof Vector) {
            x = xOrPos.x;
            y = xOrPos.y;
            speed = yOrSpeed;
        }
        else {
            x = xOrPos;
            y = yOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveTo(this._entity, x, y, speed));
        return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVector instanceof Vector) {
            xOffset = xOffsetOrVector.x;
            yOffset = xOffsetOrVector.y;
            speed = yOffsetOrSpeed;
        }
        else {
            xOffset = xOffsetOrVector;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
        return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
            sizeX = sizeXOrVector.x;
            sizeY = sizeXOrVector.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVector;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVector instanceof Vector) {
            sizeOffsetX = sizeOffsetXOrVector.x;
            sizeOffsetY = sizeOffsetXOrVector.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVector;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        this._queue.add(new Fade(this._entity, opacity, time));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        this._queue.add(new Delay(time));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new Follow(this._entity, entity));
        }
        else {
            this._queue.add(new Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new Meet(this._entity, entity));
        }
        else {
            this._queue.add(new Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts




;
class ActionsComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.actions';
        this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
        this._ctx = new ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queue
     */
    getQueue() {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    runAction(action) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.runAction(action);
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
        return this._ctx.easeTo.apply(this._ctx, args);
    }
    easeBy(...args) {
        return this._ctx.easeBy.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._ctx.toPromise();
    }
}

;// CONCATENATED MODULE: ./Graphics/FontCommon.ts
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
/**
 * Enum representing the text direction, useful for other languages, or writing text in reverse
 */
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./Graphics/Font.ts







/**
 * Represents a system or web font in Excalibur
 *
 * If no options specified, the system sans-serif 10 pixel is used
 *
 * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/
 */
class Font extends Graphic {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        super(options); // <- Graphics properties
        /**
         * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing
         *
         * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]
         */
        this.filtering = ImageFiltering.Blended;
        /**
         * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 2)
         */
        this.quality = 2;
        // Raster properties for fonts
        this.padding = 2;
        this.smoothing = false;
        this.lineWidth = 1;
        this.lineDash = [];
        this.color = Color.Black;
        this.family = 'sans-serif';
        this.style = FontStyle.Normal;
        this.bold = false;
        this.unit = FontUnit.Px;
        this.textAlign = TextAlign.Left;
        this.baseAlign = BaseAlign.Alphabetic;
        this.direction = Direction.LeftToRight;
        this.size = 10;
        this.shadow = null;
        this._textBounds = new BoundingBox();
        this._cachedTextMeasurement = new Map();
        this._bitmapToTextMeasurement = new Map();
        this._textToBitmap = new Map();
        this._bitmapUsage = new Map();
        this._textFragments = [];
        // Raster properties
        this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;
        this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;
        this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;
        this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;
        this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
        this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;
        this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;
        // Font specific properties
        this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;
        this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;
        this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;
        this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;
        this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;
        this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;
        this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;
        this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;
        this.quality = (_r = options === null || options === void 0 ? void 0 : options.quality) !== null && _r !== void 0 ? _r : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_s = options.shadow.blur) !== null && _s !== void 0 ? _s : this.shadow.blur;
            this.shadow.offset = (_t = options.shadow.offset) !== null && _t !== void 0 ? _t : this.shadow.offset;
            this.shadow.color = (_u = options.shadow.color) !== null && _u !== void 0 ? _u : this.shadow.color;
        }
    }
    clone() {
        return new Font({
            ...this.cloneGraphicOptions(),
            size: this.size,
            unit: this.unit,
            family: this.family,
            style: this.style,
            bold: this.bold,
            textAlign: this.textAlign,
            baseAlign: this.baseAlign,
            direction: this.direction,
            shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : null
        });
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(_ex, _x, _y) {
        // TODO weird vestigial drawimage
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Returns a BoundingBox that is the total size of the text including multiple lines
     *
     * Does not include any padding or adjustment
     * @param text
     * @returns BoundingBox
     */
    measureText(text) {
        let measurementDirty = false;
        let cached = this._cachedTextMeasurement.get(text);
        if (!cached) {
            measurementDirty = true;
        }
        const rasterProps = this._getRasterPropertiesHash();
        if (!cached || rasterProps !== cached.rasterProps) {
            measurementDirty = true;
        }
        if (measurementDirty) {
            const lines = text.split('\n');
            const maxWidthLine = lines.reduce((a, b) => {
                return a.length > b.length ? a : b;
            });
            const ctx = this._getTextBitmap(text);
            this._applyFont(ctx); // font must be applied to the context to measure it
            const metrics = ctx.measureText(maxWidthLine);
            let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
            // TODO lineheight makes the text bounds wonky
            const lineAdjustedHeight = textHeight * lines.length;
            textHeight = lineAdjustedHeight;
            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
            const x = 0;
            const y = 0;
            // this._cachedText = text;
            // this._cachedRasterProps = rasterProps;
            // this._measurementDirty = false;
            const measurement = new BoundingBox({
                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,
                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,
                bottom: y + bottomBounds + this.padding,
                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding
            });
            cached = {
                text,
                rasterProps,
                measurement
            };
            this._cachedTextMeasurement.set(text, cached);
            this._bitmapToTextMeasurement.set(ctx, cached);
            return cached.measurement;
        }
        else {
            return cached.measurement;
        }
    }
    _setDimension(textBounds, bitmap) {
        // Changing the width and height clears the context properties
        // We double the bitmap width to account for all possible alignment
        // We scale by "quality" so we render text without jaggies
        bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;
        bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;
    }
    _postDraw(ex) {
        ex.restore();
    }
    /**
     * We need to identify bitmaps with more than just the text content
     *
     * Any properties that can change the rendering of the text
     */
    _getRasterPropertiesHash(color) {
        var _a, _b;
        const hash = '__hashcode__' +
            this.fontString +
            this.showDebug +
            this.textAlign +
            this.baseAlign +
            this.direction +
            JSON.stringify(this.shadow) +
            (this.padding.toString() +
                this.smoothing.toString() +
                this.lineWidth.toString() +
                this.lineDash.toString() +
                ((_a = this.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) +
                (color ? color.toString() : (_b = this.color) === null || _b === void 0 ? void 0 : _b.toString()).toString());
        return hash;
    }
    _applyRasterProperties(ctx, color) {
        var _a, _b, _c;
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = color ? color.toString() : (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _applyFont(ctx) {
        ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);
        ctx.scale(this.quality, this.quality);
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.baseAlign;
        ctx.font = this.fontString;
        ctx.direction = this.direction;
        if (this.shadow) {
            ctx.shadowColor = this.shadow.color.toString();
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offset.x;
            ctx.shadowOffsetY = this.shadow.offset.y;
        }
    }
    _drawText(ctx, text, colorOverride, lineHeight) {
        const lines = text.split('\n');
        this._applyRasterProperties(ctx, colorOverride);
        this._applyFont(ctx);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (this.color) {
                ctx.fillText(line, 0, i * lineHeight);
            }
            if (this.strokeColor) {
                ctx.strokeText(line, 0, i * lineHeight);
            }
        }
        if (this.showDebug) {
            // Horizontal line
            /* istanbul ignore next */
            line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);
            // Vertical line
            /* istanbul ignore next */
            line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);
        }
    }
    _getTextBitmap(text, color) {
        const textAndHash = text + this._getRasterPropertiesHash(color);
        const bitmap = this._textToBitmap.get(textAndHash);
        if (bitmap) {
            return bitmap;
        }
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        this._textToBitmap.set(textAndHash, ctx);
        return ctx;
    }
    _splitTextBitmap(bitmap) {
        const textImages = [];
        let currentX = 0;
        let currentY = 0;
        // 4k is the max for mobile devices
        const width = Math.min(4096, bitmap.canvas.width);
        const height = Math.min(4096, bitmap.canvas.height);
        // Splits the original bitmap into 4k max chunks
        while (currentX < bitmap.canvas.width) {
            while (currentY < bitmap.canvas.height) {
                // create new bitmap
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                // draw current slice to new bitmap in < 4k chunks
                ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);
                textImages.push({ x: currentX, y: currentY, canvas });
                currentY += height;
            }
            currentX += width;
            currentY = 0;
        }
        return textImages;
    }
    render(ex, text, colorOverride, x, y) {
        if (this.showDebug) {
            this.clearCache();
        }
        this.checkAndClearCache();
        // Get bitmap for rastering text, this is cached by raster properties
        const bitmap = this._getTextBitmap(text, colorOverride);
        const isNewBitmap = !this._bitmapUsage.get(bitmap);
        // Bounds of the text
        this._textBounds = this.measureText(text);
        if (isNewBitmap) {
            // Setting dimension is expensive because it invalidates the bitmap
            this._setDimension(this._textBounds, bitmap);
        }
        // Apply affine transformations
        this._preDraw(ex, x, y);
        const lines = text.split('\n');
        const lineHeight = this._textBounds.height / lines.length;
        if (isNewBitmap) {
            // draws the text to the bitmap
            this._drawText(bitmap, text, colorOverride, lineHeight);
            // clean up any existing fragments
            for (const frag of this._textFragments) {
                TextureLoader["delete"](frag.canvas);
            }
            this._textFragments = this._splitTextBitmap(bitmap);
            for (const frag of this._textFragments) {
                TextureLoader.load(frag.canvas, this.filtering, true);
            }
        }
        // draws the bitmap fragments to excalibur graphics context
        for (const frag of this._textFragments) {
            ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2, frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2, frag.canvas.width / this.quality, frag.canvas.height / this.quality);
        }
        this._postDraw(ex);
        // Cache the bitmap for certain amount of time
        this._bitmapUsage.set(bitmap, performance.now());
    }
    /**
     * Get the internal cache size of the font
     * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps
     */
    get cacheSize() {
        return this._bitmapUsage.size;
    }
    /**
     * Force clear all cached text bitmaps
     */
    clearCache() {
        this._bitmapUsage.clear();
    }
    /**
     * Remove any expired cached text bitmaps
     */
    checkAndClearCache() {
        for (const [bitmap, time] of this._bitmapUsage.entries()) {
            // if bitmap hasn't been used in 1 second clear it
            if (time + 1000 < performance.now()) {
                this._bitmapUsage.delete(bitmap);
                // Cleanup measurements
                const measurement = this._bitmapToTextMeasurement.get(bitmap);
                if (measurement) {
                    this._cachedTextMeasurement.delete(measurement.text);
                    this._bitmapToTextMeasurement.delete(bitmap);
                }
                TextureLoader["delete"](bitmap.canvas);
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Text.ts



/**
 * Represent Text graphics in excalibur
 *
 * Useful for in game labels, ui, or overlays
 */
class Text extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        this._textWidth = 0;
        this._textHeight = 0;
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
    }
    clone() {
        var _a, _b;
        return new Text({
            text: this.text.slice(),
            color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : Color.Black,
            font: this.font.clone()
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        const bounds = this.font.measureText(this._text);
        this._textWidth = bounds.width;
        this._textHeight = bounds.height;
    }
    get font() {
        return this._font;
    }
    set font(font) {
        this._font = font;
    }
    get width() {
        if (this._textWidth === 0) {
            this._calculateDimension();
        }
        return this._textWidth * this.scale.x;
    }
    get height() {
        if (this._textHeight === 0) {
            this._calculateDimension();
        }
        return this._textHeight * this.scale.y;
    }
    _calculateDimension() {
        const { width, height } = this.font.measureText(this._text);
        this._textWidth = width;
        this._textHeight = height;
    }
    get localBounds() {
        return this.font.measureText(this._text).scale(this.scale);
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _drawImage(ex, x, y) {
        var _a;
        let color = Color.Black;
        if (this.font instanceof Font) {
            color = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;
        }
        if (this.isStale() || this.font.isStale()) {
            this.font.flipHorizontal = this.flipHorizontal;
            this.font.flipVertical = this.flipVertical;
            this.font.rotation = this.rotation;
            this.font.origin = this.origin;
            this.font.opacity = this.opacity;
        }
        this.font.tint = this.tint;
        const { width, height } = this.font.measureText(this._text);
        this._textWidth = width;
        this._textHeight = height;
        this.font.render(ex, this._text, color, x, y);
        if (this.font.showDebug) {
            ex.debug.drawRect(x - width, y - height, width * 2, height * 2);
        }
    }
}

;// CONCATENATED MODULE: ./Actor.ts



















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Entity {
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        /**
         * The anchor to apply all actor related transformations like rotation,
         * translation, and scaling. By default the anchor is in the center of
         * the actor. By default it is set to the center of the actor (.5, .5)
         *
         * An anchor of (.5, .5) will ensure that drawings are centered.
         *
         * Use `anchor.setTo` to set the anchor to a different point using
         * values between 0 and 1. For example, anchoring to the top-left would be
         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
         */
        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = Logger.getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.worldPos;
            }
        };
        const { name, x, y, pos, coordPlane, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = {
            ...config
        };
        this._setName(name);
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        const tx = new TransformComponent();
        this.addComponent(tx);
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        tx.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : CoordPlane.World;
        this.addComponent(new PointerComponent);
        this.addComponent(new GraphicsComponent({
            anchor: this.anchor
        }));
        this.addComponent(new MotionComponent());
        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.addComponent(new ActionsComponent());
        this.addComponent(new BodyComponent());
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (collider) {
            this.addComponent(new ColliderComponent(collider));
        }
        else if (radius) {
            this.addComponent(new ColliderComponent(Shape.Circle(radius)));
        }
        else {
            if (width > 0 && height > 0) {
                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
            }
            else {
                this.addComponent(new ColliderComponent()); // no collider
            }
        }
        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
        if (color) {
            this.color = color;
            if (width && height) {
                this.graphics.add(new Rectangle({
                    color: color,
                    width,
                    height
                }));
            }
            else if (radius) {
                this.graphics.add(new Circle({
                    color: color,
                    radius
                }));
            }
        }
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
        return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
        return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
        return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
        return this.get(ColliderComponent);
    }
    /**
     * Access to the Actor's built in [[PointerComponent]] config
     */
    get pointer() {
        return this.get(PointerComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
        return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(TransformComponent).scale;
    }
    set scale(scale) {
        this.get(TransformComponent).scale = scale;
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('ex.offscreen');
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor's current graphic
     */
    get color() {
        return this._color;
    }
    set color(v) {
        var _a;
        this._color = v.clone();
        const defaultLayer = this.graphics.layers.default;
        const currentGraphic = (_a = defaultLayer.graphics[0]) === null || _a === void 0 ? void 0 : _a.graphic;
        if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {
            currentGraphic.color = this._color;
        }
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new PreKillEvent(this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new PostKillEvent(this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.active;
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(TransformComponent).z = newZ;
    }
    /**
     * Get the center point of an actor (global position)
     */
    get center() {
        const globalPos = this.getGlobalPos();
        return new Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);
    }
    /**
     * Get the local center point of an actor
     */
    get localCenter() {
        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
        return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
        return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = vec(x, y);
        const collider = this.get(ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(ColliderComponent);
        const otherCollider = actor.get(ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: Vector.Half
};

;// CONCATENATED MODULE: ./ScreenElement.ts





/**
 * Type guard to detect a screen element
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement;
}
/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement extends Actor {
    constructor(config) {
        super({ ...config });
        this.get(TransformComponent).coordPlane = CoordPlane.Screen;
        this.anchor = vec(0, 0);
        this.body.collisionType = CollisionType.PreventCollision;
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}

;// CONCATENATED MODULE: ./Timer.ts


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats, randomRange, random) {
        this._logger = Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this.randomRange = [0, 0];
        this._baseInterval = 10;
        this._generateRandomInterval = () => {
            return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);
        };
        this._complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
            randomRange = options.randomRange;
            random = options.random;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this._callbacks = [];
        this._baseInterval = this.interval = interval;
        if (!!randomRange) {
            if (randomRange[0] > randomRange[1]) {
                throw new Error('min value must be lower than max value for range');
            }
            //We use the instance of ex.Random to generate the range
            this.random = random !== null && random !== void 0 ? random : new Random();
            this.randomRange = randomRange;
            this.interval = this._generateRandomInterval();
            this.on(() => {
                this.interval = this._generateRandomInterval();
            });
        }
        ;
        this.repeats = repeats || this.repeats;
        if (fcn) {
            this.on(fcn);
        }
    }
    get complete() {
        return this._complete;
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (this._running) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this._baseInterval = this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;

;// CONCATENATED MODULE: ./Graphics/ParallaxComponent.ts


class ParallaxComponent extends Component {
    constructor(parallaxFactor) {
        super();
        this.type = 'ex.parallax';
        this.parallaxFactor = vec(1.0, 1.0);
        this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;
    }
}

;// CONCATENATED MODULE: ./Graphics/DebugGraphicsComponent.ts

/**
 * Provide arbitrary drawing for the purposes of debugging your game
 *
 * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]
 *
 */
class DebugGraphicsComponent extends Component {
    constructor(draw, useTransform = true) {
        super();
        this.draw = draw;
        this.useTransform = useTransform;
        this.type = 'ex.debuggraphics';
    }
}

;// CONCATENATED MODULE: ./TileMap/TileMap.ts















/**
 * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.
 *
 * TileMaps are useful for top down or side scrolling grid oriented games.
 */
class TileMap extends Entity {
    /**
     * @param options
     */
    constructor(options) {
        var _a, _b;
        super(null, options.name);
        this._token = 0;
        this._onScreenXStart = 0;
        this._onScreenXEnd = Number.MAX_VALUE;
        this._onScreenYStart = 0;
        this._onScreenYEnd = Number.MAX_VALUE;
        this.logger = Logger.getInstance();
        this.tiles = [];
        this._rows = [];
        this._cols = [];
        this.renderFromTopOfGraphic = false;
        this._collidersDirty = true;
        this._originalOffsets = new WeakMap();
        this.addComponent(new TransformComponent());
        this.addComponent(new MotionComponent());
        this.addComponent(new BodyComponent({
            type: CollisionType.Fixed
        }));
        this.addComponent(new GraphicsComponent({
            onPostDraw: (ctx, delta) => this.draw(ctx, delta)
        }));
        this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));
        this.addComponent(new ColliderComponent());
        this._graphics = this.get(GraphicsComponent);
        this._transform = this.get(TransformComponent);
        this._motion = this.get(MotionComponent);
        this._collider = this.get(ColliderComponent);
        this._composite = this._collider.useCompositeCollider([]);
        this._transform.pos = (_a = options.pos) !== null && _a !== void 0 ? _a : Vector.Zero;
        this._oldPos = this._transform.pos;
        this.renderFromTopOfGraphic = (_b = options.renderFromTopOfGraphic) !== null && _b !== void 0 ? _b : this.renderFromTopOfGraphic;
        this.tileWidth = options.tileWidth;
        this.tileHeight = options.tileHeight;
        this.rows = options.rows;
        this.columns = options.columns;
        this.tiles = new Array(this.rows * this.columns);
        this._rows = new Array(this.rows);
        this._cols = new Array(this.columns);
        let currentCol = [];
        for (let i = 0; i < this.columns; i++) {
            for (let j = 0; j < this.rows; j++) {
                const cd = new Tile({
                    x: i,
                    y: j,
                    map: this
                });
                cd.map = this;
                this.tiles[i + j * this.columns] = cd;
                currentCol.push(cd);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(cd);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this._graphics.localBounds = new BoundingBox({
            left: 0,
            top: 0,
            right: this.columns * this.tileWidth,
            bottom: this.rows * this.tileHeight
        });
    }
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    get x() {
        var _a;
        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(TransformComponent).pos = vec(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this._transform.pos = vec(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this._transform) {
            this._transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
            this._transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this._transform.scale = val;
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(val) {
        this._transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _getOrSetColliderOriginalOffset(collider) {
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return this._originalOffsets.get(collider);
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this._composite.clearColliders();
        const colliders = [];
        this._composite = this._collider.useCompositeCollider([]);
        let current;
        // Bad square tesselation algo
        for (let i = 0; i < this.columns; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                // Columns start with a new collider
                if (j === 0) {
                    current = null;
                }
                const tile = this.tiles[i + j * this.columns];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    // Use custom collider otherwise bounding box
                    if (tile.getColliders().length > 0) {
                        for (const collider of tile.getColliders()) {
                            const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                            collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);
                            collider.owner = this;
                            this._composite.addCollider(collider);
                        }
                        current = null;
                    }
                    else {
                        if (!current) {
                            current = tile.bounds;
                        }
                        else {
                            current = current.combine(tile.bounds);
                        }
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    if (current) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            if (current) {
                // if previous is the same combine it
                const prev = colliders[colliders.length - 1];
                if (prev && prev.top === current.top && prev.bottom === current.bottom) {
                    colliders[colliders.length - 1] = prev.combine(current);
                }
                else {
                    // else new collider
                    colliders.push(current);
                }
            }
        }
        for (const c of colliders) {
            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this._collider.update();
    }
    /**
     * Returns the [[Tile]] by index (row major order)
     */
    getTileByIndex(index) {
        return this.tiles[index];
    }
    /**
     * Returns the [[Tile]] by its x and y integer coordinates
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the [[Tile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const x = Math.floor((point.x - this.pos.x) / this.tileWidth);
        const y = Math.floor((point.y - this.pos.y) / this.tileHeight);
        const tile = this.getTile(x, y);
        if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {
            return tile;
        }
        return null;
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        if (!this._oldPos.equals(this.pos)) {
            this.flagCollidersDirty();
            for (let i = 0; i < this.tiles.length; i++) {
                if (this.tiles[i]) {
                    this.tiles[i].flagDirty();
                }
            }
        }
        if (this._collidersDirty) {
            this._collidersDirty = false;
            this._updateColliders();
        }
        this._token++;
        const worldBounds = engine.getWorldBounds();
        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);
        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);
        let pos = this.pos;
        const maybeParallax = this.get(ParallaxComponent);
        let parallaxOffset = Vector.One;
        if (maybeParallax) {
            const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
            parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);
            pos = pos.add(parallaxOffset);
        }
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);
        // why are we resetting pos?
        this._transform.pos = vec(this.x, this.y);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.columns);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let graphics, graphicsIndex, graphicsLen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                graphics = this.getTile(x, y).getGraphics();
                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                    // draw sprite, warning if sprite doesn't exist
                    const graphic = graphics[graphicsIndex];
                    if (graphic) {
                        if (hasGraphicsTick(graphic)) {
                            graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
                        }
                        const offsetY = this.renderFromTopOfGraphic ? 0 : (graphic.height - this.tileHeight);
                        graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight - offsetY);
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));
    }
    debug(gfx) {
        const width = this.tileWidth * this.columns;
        const height = this.tileHeight * this.rows;
        const pos = Vector.Zero;
        for (let r = 0; r < this.rows + 1; r++) {
            const yOffset = vec(0, r * this.tileHeight);
            gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);
        }
        for (let c = 0; c < this.columns + 1; c++) {
            const xOffset = vec(c * this.tileWidth, 0);
            gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);
        }
        const colliders = this._composite.getColliders();
        for (const collider of colliders) {
            const grayish = Color.Gray;
            grayish.a = 0.5;
            const bounds = collider.localBounds;
            const pos = collider.worldPos.sub(this.pos);
            gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);
        }
    }
}
/**
 * TileMap Tile
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Tiles can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Tile extends Entity {
    constructor(options) {
        var _a, _b;
        super();
        this._posDirty = false;
        this._solid = false;
        this._graphics = [];
        /**
         * Current list of colliders for this tile
         */
        this._colliders = [];
        /**
         * Arbitrary data storage per tile, useful for any game specific data
         */
        this.data = new Map();
        this.x = options.x;
        this.y = options.y;
        this.map = options.map;
        this.width = options.map.tileWidth;
        this.height = options.map.tileHeight;
        this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;
        this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];
        this._recalculate();
    }
    // private _transform: TransformComponent;
    /**
     * Return the world position of the top left corner of the tile
     */
    get pos() {
        if (this._posDirty) {
            this._recalculate();
            this._posDirty = false;
        }
        return this._pos;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagCollidersDirty();
        this._solid = val;
    }
    /**
     * Current list of graphics for this tile
     */
    getGraphics() {
        return this._graphics;
    }
    /**
     * Add another [[Graphic]] to this TileMap tile
     * @param graphic
     */
    addGraphic(graphic) {
        this._graphics.push(graphic);
    }
    /**
     * Remove an instance of a [[Graphic]] from this tile
     */
    removeGraphic(graphic) {
        removeItemFromArray(graphic, this._graphics);
    }
    /**
     * Clear all graphics from this tile
     */
    clearGraphics() {
        this._graphics.length = 0;
    }
    /**
     * Returns the list of colliders
     */
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a custom collider to the [[Tile]] to use instead of it's bounds
     *
     * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the [[Tile]]
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the [[Tile]]
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    flagDirty() {
        return this._posDirty = true;
    }
    _recalculate() {
        this._pos = this.map.pos.add(vec(this.x * this.map.tileWidth, this.y * this.map.tileHeight));
        this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);
        this._posDirty = false;
    }
    get bounds() {
        if (this._posDirty) {
            this._recalculate();
        }
        return this._bounds;
    }
    get center() {
        if (this._posDirty) {
            this._recalculate();
        }
        return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);
    }
}

;// CONCATENATED MODULE: ./Camera.ts









/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new Vector(center.x, currentFocus.y);
            }
            else {
                return new Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return vec(focusX, focusY);
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends Class {
    constructor() {
        super(...arguments);
        this.transform = AffineMatrix.identity();
        this.inverse = AffineMatrix.identity();
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        this._angularVelocity = 0;
        /**
         * Get or set the camera's position
         */
        this._posChanged = false;
        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));
        /**
         * Get or set the camera's velocity
         */
        this.vel = Vector.Zero;
        /**
         * Get or set the camera's acceleration
         */
        this.acc = Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = EasingFunctions.EaseInOutCubic;
        this._easing = EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this._angularVelocity;
    }
    set angularVelocity(value) {
        this._angularVelocity = value;
    }
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._pos = watchAny(vec, () => (this._posChanged = true));
        this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this._engine = _engine;
            this._screen = _engine.screen;
            const currentRes = this._screen.resolution;
            let center = vec(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._screen.peekResolution();
                if (res) {
                    center = vec(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.y;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            // First frame bootstrap
            // Ensure camera tx is correct
            // Run update twice to ensure properties are init'd
            this.updateTransform();
            // Run strategies for first frame
            this.runStrategies(_engine, _engine.clock.elapsed());
            // Setup the first frame viewport
            this.updateViewport();
            // It's important to update the camera after strategies
            // This prevents jitter
            this.updateTransform();
            this.onInitialize(_engine);
            super.emit('initialize', new InitializeEvent(_engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    runStrategies(engine, delta) {
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, engine, delta);
        }
    }
    updateViewport() {
        // recalc viewport
        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.zoom += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        this.runStrategies(_engine, delta);
        this.updateViewport();
        // It's important to update the camera after strategies
        // This prevents jitter
        this.updateTransform();
        this._postupdate(_engine, delta);
    }
    /**
     * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
     * @param ctx Canvas context to apply transformations
     */
    draw(ctx) {
        ctx.multiply(this.transform);
    }
    updateTransform() {
        // center the camera
        const newCanvasWidth = this._screen.resolution.width / this.zoom;
        const newCanvasHeight = this._screen.resolution.height / this.zoom;
        const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);
        // Calculate camera transform
        this.transform.reset();
        this.transform.scale(this.zoom, this.zoom);
        this.transform.translate(cameraPos.x, cameraPos.y);
        this.transform.inverse(this.inverse);
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}

;// CONCATENATED MODULE: ./Trigger.ts





const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = {
            ...triggerDefaults,
            ...opts
        };
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.graphics.visible = opts.visible;
        this.body.collisionType = CollisionType.Passive;
        this.eventDispatcher = new EventDispatcher();
        this.events.on('collisionstart', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('enter', new EnterTriggerEvent(this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.events.on('collisionend', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('exit', new ExitTriggerEvent(this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        if (this.repeat !== 0) {
            this.action.call(this);
            this.repeat--;
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to execute after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}

;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts


// Add/Remove entities and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
        for (const entity of this.entities) {
            // TODO is this right?
            entity.update(_context.engine, elapsed);
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (const entity of this.entities) {
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (isAddedComponent(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (isRemovedComponent(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.active = true;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.componentAdded$.register(this);
            entity.componentRemoved$.register(this);
            // if entity has children
            entity.children.forEach((c) => this.addEntity(c));
            entity.childrenAdded$.register({
                notify: (e) => {
                    this.addEntity(e);
                }
            });
            entity.childrenRemoved$.register({
                notify: (e) => {
                    this.removeEntity(e, false);
                }
            });
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a;
        let id = 0;
        if (idOrEntity instanceof Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.active) {
            entity.kill();
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.componentAdded$.unregister(this);
            entity.componentRemoved$.unregister(this);
            // if entity has children
            entity.children.forEach((c) => this.removeEntity(c, deferred));
            entity.childrenAdded$.clear();
            entity.childrenRemoved$.clear();
            // stats
            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
                this._world.context.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (const entity of this._entitiesToRemove) {
            if (entity.active) {
                continue;
            }
            this.removeEntity(entity, false);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter(e => e.name === name);
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};

;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends Observable {
    constructor(types) {
        super();
        this._entities = [];
        if (types[0] instanceof Function) {
            this.types = types.map(T => (new T).type);
        }
        else {
            this.types = types;
        }
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = buildTypeKey(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new AddedEntity(entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new RemovedEntity(entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof Entity) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
    contain(type) {
        return this.types.indexOf(type) > -1;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[buildTypeKey(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[buildTypeKey(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            // If the component being removed from an entity is a part of a query,
            // it is now disqualified from that query, remove it
            if (this._queries[queryType].contain(component.type)) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new Query(types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = buildTypeKey(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (this.initialized && system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Initialize all systems in the manager
     *
     * Systems added after initialize() will be initialized on add
     */
    initialize() {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world.context);
                }
            }
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(context, delta);
            }
        }
        for (const s of systems) {
            // Get entities that match the system types, pre-sort
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            // Initialize entities if needed
            if (context instanceof Scene) {
                for (const entity of entities) {
                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
                }
            }
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(context, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new QueryManager(this);
        this.entityManager = new EntityManager(this);
        this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        if (type === SystemType.Update) {
            this.entityManager.updateEntities(this.context, delta);
        }
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}

;// CONCATENATED MODULE: ./Collision/Integrator.ts

class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsedMs) {
        const seconds = elapsedMs / 1000;
        // This code looks a little wild, but it's to avoid creating any new Vector instances
        // integration is done in a tight loop so this is key to avoid GC'ing
        motion.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));
        transform.pos
            .add(motion.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS)
            .addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        const rotation = transform.rotation + motion.angularVelocity * seconds;
        transform.scale.add(motion.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);
        const tx = transform.get();
        tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);
    }
}
// Scratch vectors to avoid allocation
EulerIntegrator._POS = new Vector(0, 0);
EulerIntegrator._SCALE = new Vector(1, 1);
EulerIntegrator._ACC = new Vector(0, 0);
EulerIntegrator._VEL = new Vector(0, 0);
EulerIntegrator._VEL_ACC = new Vector(0, 0);
EulerIntegrator._SCALE_FACTOR = new Vector(0, 0);

;// CONCATENATED MODULE: ./Collision/MotionSystem.ts







class MotionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(entities, elapsedMs) {
        let transform;
        let motion;
        for (let i = 0; i < entities.length; i++) {
            transform = entities[i].get(TransformComponent);
            motion = entities[i].get(MotionComponent);
            const optionalBody = entities[i].get(BodyComponent);
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(Physics.gravity);
            }
            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
            // Update transform and motion based on Euler linear algebra
            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts




/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver {
    constructor() {
        this.directionMap = new Map();
        this.distanceMap = new Map();
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Sort contacts by distance to avoid artifacts with seams
        // It's important to solve in a specific order
        contacts.sort((a, b) => {
            const aDist = this.distanceMap.get(a.id);
            const bDist = this.distanceMap.get(b.id);
            return aDist - bDist;
        });
        for (const contact of contacts) {
            // Solve position first in arcade
            this.solvePosition(contact);
            // Solve velocity second in arcade
            this.solveVelocity(contact);
        }
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        for (const contact of contacts) {
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            const distance = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);
            this.distanceMap.set(contact.id, distance);
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            if (contact.isCanceled()) {
                continue;
            }
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
            }
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    solvePosition(contact) {
        var _a, _b;
        const epsilon = .0001;
        // if bounds no longer intersect skip to the next
        // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles
        if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {
            // Cancel the contact to prevent and solving
            contact.cancel();
            return;
        }
        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
            // Cancel near 0 mtv collisions
            contact.cancel();
            return;
        }
        let mtv = contact.mtv;
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                return;
            }
            if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
                // split overlaps if both are Active
                mtv = mtv.scale(0.5);
            }
            // Resolve overlaps
            if (bodyA.collisionType === CollisionType.Active) {
                bodyA.globalPos.x -= mtv.x;
                bodyA.globalPos.y -= mtv.y;
                colliderA.update(bodyA.transform.get());
            }
            if (bodyB.collisionType === CollisionType.Active) {
                bodyB.globalPos.x += mtv.x;
                bodyB.globalPos.y += mtv.y;
                colliderB.update(bodyB.transform.get());
            }
        }
    }
    solveVelocity(contact) {
        var _a, _b;
        if (contact.isCanceled()) {
            return;
        }
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                return;
            }
            const normal = contact.normal;
            const opposite = normal.negate();
            if (bodyA.collisionType === CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform when sliding off
                if (bodyA.vel.normalize().dot(opposite) < 0) {
                    // Cancel out velocity opposite direction of collision normal
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
            }
            if (bodyB.collisionType === CollisionType.Active) {
                // only adjust velocity if the contact normal is opposite to the current velocity
                // this avoids catching edges on a platform
                if (bodyB.vel.normalize().dot(normal) < 0) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts


/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new Vector(0, 0);
        /**
         * Original contact velocity combined with bounciness
         */
        this.originalVelocityAndRestitution = 0;
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.globalPos);
            this.bToContact = this.point.sub(bodyB.globalPos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity between bodyA and bodyB
     */
    getRelativeVelocity() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return Vector.Zero;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts








class RealisticSolver {
    constructor() {
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
    preSolve(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (const contact of contacts) {
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                for (const point of contact.points) {
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.globalPos);
                    const bToContact = point.sub(bodyB.globalPos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = 1.0 / normalMass;
                    contactPoints[pointIndex].tangentMass = 1.0 / tangentMass;
                    // Calculate relative velocity before solving to accurately do restitution
                    const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;
                    const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());
                    contactPoints[pointIndex].originalVelocityAndRestitution = 0;
                    if (relativeVelocity < -0.1) { // TODO what's a good threshold here?
                        contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;
                    }
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (Physics.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (const contact of contacts) {
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (const contact of contacts) {
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (const c of contacts) {
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                for (const point of contactPoints) {
                    if (Physics.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.positionIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = Physics.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = Physics.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce * point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === CollisionType.Active) {
                            // TODO make applyPseudoImpulse function?
                            const impulseForce = impulse.negate().scale(bodyA.inverseMass);
                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyA.globalPos = bodyA.globalPos.add(impulseForce);
                            if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                                bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                            }
                        }
                        if (bodyB.collisionType === CollisionType.Active) {
                            const impulseForce = impulse.scale(bodyB.inverseMass);
                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                                impulseForce.x = 0;
                            }
                            if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                                impulseForce.y = 0;
                            }
                            bodyB.globalPos = bodyB.globalPos.add(impulseForce);
                            if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                                bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                            }
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.velocityIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    // Friction constraint
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity * point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    // Bounce constraint
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // Per Erin it is a mistake to apply the restitution inside the iteration
                        // From Erin Catto's Box2D we keep original contact velocity and adjust by small impulses
                        let impulseDelta = -point.normalMass * (normalVelocity - point.originalVelocityAndRestitution);
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts








class CollisionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._realisticSolver = new RealisticSolver();
        this._arcadeSolver = new ArcadeSolver();
        this._processor = new DynamicTreeCollisionProcessor();
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
    }
    notify(message) {
        if (isAddedSystemEntity(message)) {
            const colliderComponent = message.data.get(ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        }
        else {
            const colliderComponent = message.data.get(ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        }
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    update(entities, elapsedMs) {
        var _a, _b, _c, _d;
        if (!Physics.enabled) {
            return;
        }
        // Collect up all the colliders and update them
        let colliders = [];
        for (const entity of entities) {
            const colliderComp = entity.get(ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
                colliderComp.update();
                if (collider instanceof CompositeCollider) {
                    const compositeColliders = collider.getColliders();
                    colliders = colliders.concat(compositeColliders);
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders);
        // Run broadphase on all colliders and locates potential collisions
        const pairs = this._processor.broadphase(colliders, elapsedMs);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities aren't overlapping
        contacts = solver.solve(contacts);
        // Record contacts for start/end
        for (const contact of contacts) {
            // Process composite ids, things with the same composite id are treated as the same collider for start/end
            const index = contact.id.indexOf('|');
            if (index > 0) {
                const compositeId = contact.id.substring(index + 1);
                this._currentFrameContacts.set(compositeId, contact);
            }
            else {
                this._currentFrameContacts.set(contact.id, contact);
            }
        }
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex);
    }
    runContactStartEnd() {
        // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));
                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));
                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));
                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));
            }
        }
        // find all contacts that have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));
                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));
                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));
                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Animation.ts




var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is play backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
/**
 * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]
 *
 * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]
 */
class Animation extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.events = new EventDispatcher(); // TODO replace with new Emitter
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this.timeScale = 1;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._direction = 1; // TODO only used in ping-pong
        this._done = false;
        this._playing = true;
        this._reversed = false;
        this.frames = options.frames;
        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation({
            frames: this.frames.map((f) => ({ ...f })),
            frameDuration: this.frameDuration,
            reverse: this._reversed,
            strategy: this.strategy,
            ...this.cloneGraphicOptions()
        });
    }
    get width() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame) {
            return Math.abs(maybeFrame.graphic.width * this.scale.x);
        }
        return 0;
    }
    get height() {
        const maybeFrame = this.currentFrame;
        if (maybeFrame) {
            return Math.abs(maybeFrame.graphic.height * this.scale.y);
        }
        return 0;
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => frameIndices.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrameMs
            })),
            strategy: strategy
        });
    }
    /**
     * Returns the current Frame of the animation
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = (this._reversed && this._direction === 1) ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
            this.events.emit('frame', maybeFrame);
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = clamp(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._direction >= this.frames.length) {
                    this._direction = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._direction < 0) {
                    this._direction = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._direction % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', this.currentFrame);
        }
        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = Logger.getInstance();

;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts



class GraphicsGroup extends Graphic {
    constructor(options) {
        super(options);
        this.members = [];
        this.members = options.members;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup({
            members: [...this.members],
            ...this.cloneGraphicOptions()
        });
    }
    _updateDimensions() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        for (const member of this.members) {
            ex.save();
            ex.translate(x, y);
            member.graphic.draw(ex, member.pos.x, member.pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Configurable.ts
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}

;// CONCATENATED MODULE: ./Particles.ts












/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super();
        this.position = new Vector(0, 0);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = Color.White;
        this.endColor = Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = Color.White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        this.visible = true;
        this.isOffscreen = false;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = (position || this.position).add(this.emitter.pos);
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
        this.addComponent((this.transform = new TransformComponent()));
        this.addComponent((this.graphics = new GraphicsComponent()));
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // TODO wut
        if (this.particleSprite) {
            this.graphics.opacity = this.opacity;
            this.graphics.use(this.particleSprite);
        }
        else {
            this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                this.graphics.opacity = this.opacity;
                const tmpColor = this._currentColor.clone();
                tmpColor.a = 1;
                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
                ctx.restore();
            };
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // todo wut
        this.graphics.opacity = this.opacity;
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = [];
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new Vector(0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = null;
        /**
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /**
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = Color.White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = Color.White;
        this._sprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = { ...config };
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
        this.body.collisionType = CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new Random();
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
        return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
        super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
        return this._sprite;
    }
    set particleSprite(val) {
        if (val) {
            this._sprite = val;
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            this.particles.push(p);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.add(p);
            }
        }
    }
    clearParticles() {
        this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
        const vel = randomInRange(this.minVel, this.maxVel, this.random);
        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = randomInRange(0, this.width, this.random);
            ranY = randomInRange(0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = randomInRange(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
            p.graphics.opacity = this.opacity;
            p.graphics.use(this._sprite);
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        var _a;
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            removeItemFromArray(this.deadParticles[i], this.particles);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
            }
        }
        this.deadParticles.length = 0;
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts









class GraphicsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = 0;
        this._token = 0;
        this._sortedTransforms = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
    }
    get sortedTransforms() {
        return this._sortedTransforms;
    }
    initialize(scene) {
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    preupdate() {
        // Graphics context could be switched to fallback in a new frame
        this._graphicsContext = this._engine.graphicsContext;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return a.z - b.z;
            });
            this._zHasChanged = false;
        }
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            this._sortedTransforms.push(tx);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        }
        else {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
            }
        }
    }
    update(_entities, delta) {
        this._token++;
        let graphics;
        // This is a performance enhancement, most things are in world space
        // so if we can only do this once saves a ton of transform updates
        this._graphicsContext.save();
        if (this._camera) {
            this._camera.draw(this._graphicsContext);
        }
        for (const transform of this._sortedTransforms) {
            const entity = transform.owner;
            // If the entity is offscreen skip
            if (entity.hasTag('ex.offscreen')) {
                continue;
            }
            graphics = entity.get(GraphicsComponent);
            // Exit if graphics set to not visible
            if (!graphics.visible) {
                continue;
            }
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            if (transform.coordPlane === CoordPlane.Screen) {
                this._graphicsContext.restore();
            }
            this._graphicsContext.save();
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(delta, this._token);
            // Apply parallax
            const parallax = entity.get(ParallaxComponent);
            if (parallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);
                const parallaxOffset = this._camera.pos.scale(oneMinusFactor);
                this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);
            }
            // Position the entity + estimate lag
            this._applyTransform(entity);
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, delta);
            }
            // TODO remove this hack on the particle redo
            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;
            this._graphicsContext.opacity = graphics.opacity * particleOpacity;
            // Draw the graphics component
            this._drawGraphicsComponent(graphics);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, delta);
            }
            this._graphicsContext.restore();
            // Reset the transform back to the original world space
            if (transform.coordPlane === CoordPlane.Screen) {
                this._graphicsContext.save();
                if (this._camera) {
                    this._camera.draw(this._graphicsContext);
                }
            }
        }
        this._graphicsContext.restore();
    }
    _drawGraphicsComponent(graphicsComponent) {
        var _a, _b;
        if (graphicsComponent.visible) {
            // this should be moved to the graphics system
            for (const layer of graphicsComponent.layers.get()) {
                for (const { graphic, options } of layer.graphics) {
                    let anchor = graphicsComponent.anchor;
                    let offset = graphicsComponent.offset;
                    if (options === null || options === void 0 ? void 0 : options.anchor) {
                        anchor = options.anchor;
                    }
                    if (options === null || options === void 0 ? void 0 : options.offset) {
                        offset = options.offset;
                    }
                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                    const offsetX = -graphic.width * anchor.x + offset.x;
                    const offsetY = -graphic.height * anchor.y + offset.y;
                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
                        if (graphic instanceof GraphicsGroup) {
                            for (const g of graphic.members) {
                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                        else {
                            /* istanbul ignore next */
                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                        }
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(BodyComponent);
            let interpolatedPos = transform.pos;
            let interpolatedScale = transform.scale;
            let interpolatedRotation = transform.rotation;
            if (optionalBody) {
                if (this._engine.fixedUpdateFps &&
                    optionalBody.__oldTransformCaptured &&
                    optionalBody.enableFixedUpdateInterpolate) {
                    // Interpolate graphics if needed
                    const blend = this._engine.currentFrameLagMs / (1000 / this._engine.fixedUpdateFps);
                    interpolatedPos = transform.pos.scale(blend).add(optionalBody.oldPos.scale(1.0 - blend));
                    interpolatedScale = transform.scale.scale(blend).add(optionalBody.oldScale.scale(1.0 - blend));
                    // Rotational lerp https://stackoverflow.com/a/30129248
                    const cosine = (1.0 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);
                    const sine = (1.0 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);
                    interpolatedRotation = Math.atan2(sine, cosine);
                }
            }
            if (transform) {
                this._graphicsContext.z = transform.z;
                this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);
                this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);
                this._graphicsContext.rotate(interpolatedRotation);
            }
        }
    }
}

;// CONCATENATED MODULE: ./Debug/DebugSystem.ts









class DebugSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform'];
        this.systemType = SystemType.Draw;
        this.priority = 999; // lowest priority
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
        var _a;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let debugDraw;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (const entity of entities) {
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = Vector.Zero;
            const lineHeight = vec(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });
                }
                if (txSettings.showAll || txSettings.showPositionLabel) {
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showZIndex) {
                    this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${entity.parent ? 'child of id(' + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            debugDraw = entity.get(DebugGraphicsComponent);
            if (debugDraw) {
                if (!debugDraw.useTransform) {
                    this._graphicsContext.restore();
                }
                debugDraw.draw(this._graphicsContext);
                if (!debugDraw.useTransform) {
                    this._graphicsContext.save();
                    this._applyTransform(entity);
                }
            }
            body = entity.get(BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            motion = entity.get(MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = vec(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = vec(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Input/PointerSystem.ts





/**
 * The PointerSystem is responsible for dispatching pointer events to entities
 * that need them.
 *
 * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use
 * the [[Collider]]'s shape for pointer events.
 */
class PointerSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.pointer'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseColliderShape = false;
        /**
         * Optionally override component configuration for all entities
         */
        this.overrideUseGraphicsBounds = false;
        this.lastFrameEntityToPointers = new Map();
        this.currentFrameEntityToPointers = new Map();
        this._sortedTransforms = [];
        this._sortedEntities = [];
        this._zHasChanged = false;
        this._zIndexUpdate = () => {
            this._zHasChanged = true;
        };
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    preupdate() {
        // event receiver might change per frame
        this._receiver = this._engine.input.pointers;
        if (this._zHasChanged) {
            this._sortedTransforms.sort((a, b) => {
                return b.z - a.z;
            });
            this._sortedEntities = this._sortedTransforms.map(t => t.owner);
            this._zHasChanged = false;
        }
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            this._sortedTransforms.push(tx);
            this._sortedEntities.push(tx.owner);
            tx.zIndexChanged$.subscribe(this._zIndexUpdate);
            this._zHasChanged = true;
        }
        else {
            const tx = entityAddedOrRemoved.data.get(TransformComponent);
            tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
            const index = this._sortedTransforms.indexOf(tx);
            if (index > -1) {
                this._sortedTransforms.splice(index, 1);
                this._sortedEntities.splice(index, 1);
            }
        }
    }
    entityCurrentlyUnderPointer(entity, pointerId) {
        return this.currentFrameEntityToPointers.has(entity.id) &&
            this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entityWasUnderPointer(entity, pointerId) {
        return this.lastFrameEntityToPointers.has(entity.id) &&
            this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entered(entity, pointerId) {
        return this.entityCurrentlyUnderPointer(entity, pointerId) &&
            !this.lastFrameEntityToPointers.has(entity.id);
    }
    left(entity, pointerId) {
        return !this.currentFrameEntityToPointers.has(entity.id) &&
            this.entityWasUnderPointer(entity, pointerId);
    }
    addPointerToEntity(entity, pointerId) {
        if (!this.currentFrameEntityToPointers.has(entity.id)) {
            this.currentFrameEntityToPointers.set(entity.id, [pointerId]);
            return;
        }
        const pointers = this.currentFrameEntityToPointers.get(entity.id);
        this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));
    }
    update(_entities) {
        // Locate all the pointer/entity mappings
        this._processPointerToEntity(this._sortedEntities);
        // Dispatch pointer events on entities
        this._dispatchEvents(this._sortedEntities);
        // Clear last frame's events
        this._receiver.update();
        this.lastFrameEntityToPointers.clear();
        this.lastFrameEntityToPointers = new Map(this.currentFrameEntityToPointers);
        this.currentFrameEntityToPointers.clear();
        this._receiver.clear();
    }
    _processPointerToEntity(entities) {
        var _a;
        let transform;
        let collider;
        let graphics;
        let pointer;
        // TODO probably a spatial partition optimization here to quickly query bounds for pointer
        // doesn't seem to cause issues tho for perf
        // Pre-process find entities under pointers
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            pointer = (_a = entity.get(PointerComponent)) !== null && _a !== void 0 ? _a : new PointerComponent;
            // Check collider contains pointer
            collider = entity.get(ColliderComponent);
            if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {
                collider.update();
                const geom = collider.get();
                if (geom) {
                    for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
                        if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
                            this.addPointerToEntity(entity, pointerId);
                        }
                    }
                }
            }
            // Check graphics contains pointer
            graphics = entity.get(GraphicsComponent);
            if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {
                const graphicBounds = graphics.localBounds.transform(transform.get().matrix);
                for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
                    if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
                        this.addPointerToEntity(entity, pointerId);
                    }
                }
            }
        }
    }
    _processDownAndEmit(entity) {
        const lastDownPerPointer = new Map();
        // Loop through down and dispatch to entities
        for (const event of this._receiver.currentFrameDown) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointerdown', event);
                if (this._receiver.isDragStart(event.pointerId)) {
                    entity.events.emit('pointerdragstart', event);
                }
            }
            lastDownPerPointer.set(event.pointerId, event);
        }
        return lastDownPerPointer;
    }
    _processUpAndEmit(entity) {
        const lastUpPerPointer = new Map();
        // Loop through up and dispatch to entities
        for (const event of this._receiver.currentFrameUp) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointerup', event);
                if (this._receiver.isDragEnd(event.pointerId)) {
                    entity.events.emit('pointerdragend', event);
                }
            }
            lastUpPerPointer.set(event.pointerId, event);
        }
        return lastUpPerPointer;
    }
    _processMoveAndEmit(entity) {
        const lastMovePerPointer = new Map();
        // Loop through move and dispatch to entities
        for (const event of this._receiver.currentFrameMove) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                // move
                entity.events.emit('pointermove', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragmove', event);
                }
            }
            lastMovePerPointer.set(event.pointerId, event);
        }
        return lastMovePerPointer;
    }
    _processEnterLeaveAndEmit(entity, lastUpDownMoveEvents) {
        // up, down, and move are considered for enter and leave
        for (const event of lastUpDownMoveEvents) {
            // enter
            if (event.active && entity.active && this.entered(entity, event.pointerId)) {
                entity.events.emit('pointerenter', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragenter', event);
                }
                break;
            }
            if (event.active && entity.active &&
                // leave can happen on move
                (this.left(entity, event.pointerId) ||
                    // or leave can happen on pointer up
                    (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {
                entity.events.emit('pointerleave', event);
                if (this._receiver.isDragging(event.pointerId)) {
                    entity.events.emit('pointerdragleave', event);
                }
                break;
            }
        }
    }
    _processCancelAndEmit(entity) {
        // cancel
        for (const event of this._receiver.currentFrameCancel) {
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
                entity.events.emit('pointercancel', event);
            }
        }
    }
    _processWheelAndEmit(entity) {
        // wheel
        for (const event of this._receiver.currentFrameWheel) {
            // Currently the wheel only fires under the primary pointer '0'
            if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {
                entity.events.emit('pointerwheel', event);
            }
        }
    }
    _dispatchEvents(entities) {
        const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());
        const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());
        // Filter preserves z order
        const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));
        let lastMovePerPointer;
        let lastUpPerPointer;
        let lastDownPerPointer;
        // Dispatch events in entity z order
        for (const entity of entitiesWithEvents) {
            lastDownPerPointer = this._processDownAndEmit(entity);
            lastUpPerPointer = this._processUpAndEmit(entity);
            lastMovePerPointer = this._processMoveAndEmit(entity);
            const lastUpDownMoveEvents = [
                ...lastMovePerPointer.values(),
                ...lastDownPerPointer.values(),
                ...lastUpPerPointer.values()
            ];
            this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);
            this._processCancelAndEmit(entity);
            this._processWheelAndEmit(entity);
        }
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts


class ActionsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.actions'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._actions = [];
    }
    notify(entityAddedOrRemoved) {
        if (isAddedSystemEntity(entityAddedOrRemoved)) {
            const action = entityAddedOrRemoved.data.get(ActionsComponent);
            this._actions.push(action);
        }
        else {
            const action = entityAddedOrRemoved.data.get(ActionsComponent);
            const index = this._actions.indexOf(action);
            if (index > -1) {
                this._actions.splice(index, 1);
            }
        }
    }
    update(_entities, delta) {
        for (const actions of this._actions) {
            actions.update(delta);
        }
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricEntityComponent.ts

class IsometricEntityComponent extends Component {
    /**
     * Specify the isometric map to use to position this entity's z-index
     * @param map
     */
    constructor(map) {
        super();
        this.type = 'ex.isometricentity';
        /**
         * Vertical "height" in the isometric world
         */
        this.elevation = 0;
        this.map = map;
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricEntitySystem.ts



class IsometricEntitySystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.isometricentity'];
        this.systemType = SystemType.Update;
        this.priority = 99;
    }
    update(entities, _delta) {
        let transform;
        let iso;
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            iso = entity.get(IsometricEntityComponent);
            const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);
            const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;
            transform.z = newZ;
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/OffscreenSystem.ts







class OffscreenSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._camera = scene.camera;
    }
    update(entities) {
        let transform;
        let graphics;
        let maybeParallax;
        for (const entity of entities) {
            graphics = entity.get(GraphicsComponent);
            transform = entity.get(TransformComponent);
            maybeParallax = entity.get(ParallaxComponent);
            let parallaxOffset;
            if (maybeParallax) {
                // We use the Tiled formula
                // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor
                // cameraPos * (1 - parallaxFactor)
                const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
                parallaxOffset = this._camera.pos.scale(oneMinusFactor);
            }
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
            if (entityOffscreen && !entity.hasTag('ex.offscreen')) {
                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addTag('ex.offscreen');
            }
            if (!entityOffscreen && entity.hasTag('ex.offscreen')) {
                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeTag('ex.offscreen');
            }
        }
    }
    _isOffscreen(transform, graphics, parallaxOffset) {
        if (transform.coordPlane === CoordPlane.World) {
            let bounds = graphics.localBounds;
            if (parallaxOffset) {
                bounds = bounds.translate(parallaxOffset);
            }
            const transformedBounds = bounds.transform(transform.get().matrix);
            const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);
            return graphicsOffscreen;
        }
        else {
            // TODO screen coordinates
            return false;
        }
    }
}

;// CONCATENATED MODULE: ./Scene.ts





















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends Class {
    constructor() {
        super();
        this._logger = Logger.getInstance();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new World(this);
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // Initialize systems
        // Update
        this.world.add(new ActionsSystem());
        this.world.add(new MotionSystem());
        this.world.add(new CollisionSystem());
        this.world.add(new PointerSystem());
        this.world.add(new IsometricEntitySystem());
        // Draw
        this.world.add(new OffscreenSystem());
        this.world.add(new GraphicsSystem());
        this.world.add(new DebugSystem());
    }
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Trigger;
        });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof TileMap;
        });
    }
    get timers() {
        return this._timers;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_context) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_context) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     *
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     *
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            // Initialize camera first
            this.camera._initialize(engine);
            this.world.systemManager.initialize();
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(context) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(context) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        this.world.update(SystemType.Update, delta);
        // Camera last keeps renders smooth that are based on entity/actor
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        this._collectActorStats(engine);
        this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     *
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        var _a;
        this._predraw(ctx, delta);
        this.world.update(SystemType.Draw, delta);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof Timer) {
            if (!contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.emit('entityremoved', { target: entity });
            this.world.remove(entity);
        }
        if (entity instanceof Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
     *
     * By default entities use deferred removal
     * @param deferred
     */
    clear(deferred = true) {
        for (const entity of this.entities) {
            this.world.remove(entity, deferred);
        }
        for (const timer of this.timers) {
            this.removeTimer(timer);
        }
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const screenElements = this.actors.filter((a) => a instanceof ScreenElement);
        for (const _ui of screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (isScreenElement(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessMode.ts
var ColorBlindnessMode;
(function (ColorBlindnessMode) {
    ColorBlindnessMode["Protanope"] = "Protanope";
    ColorBlindnessMode["Deuteranope"] = "Deuteranope";
    ColorBlindnessMode["Tritanope"] = "Tritanope";
})(ColorBlindnessMode || (ColorBlindnessMode = {}));

;// CONCATENATED MODULE: ./Graphics/PostProcessor/color-blind-fragment.glsl
/* harmony default export */ const color_blind_fragment = ("#version 300 es\r\nprecision mediump float;\r\n// our texture\r\nuniform sampler2D u_image;\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// color blind type\r\nuniform int u_type;\r\n\r\n// simulation?\r\nuniform bool u_simulate;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec4 o =  texture(u_image, v_texcoord);\r\n  // RGB to LMS matrix conversion\r\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\r\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\r\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\r\n  // Simulate color blindness\r\n  float l;\r\n  float m;\r\n  float s;\r\n  //MODE CODE//\r\n  if (u_type == 0) {\r\n    // Protanope\r\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\r\n  } else if (u_type == 1) {\r\n    // Deuteranope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\r\n  } else if (u_type == 2) {\r\n    // Tritanope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\r\n  }\r\n\r\n  // LMS to RGB matrix conversion\r\n  vec4 error; // simulate the colors\r\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\r\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\r\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\r\n  error.a = 1.0;\r\n  vec4 diff = o - error;\r\n  vec4 correction; // correct the colors\r\n  correction.r = 0.0;\r\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\r\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\r\n  correction = o + correction;\r\n  correction.a = o.a;\r\n  //SIMULATE//\r\n\r\n  // sim \r\n  if (u_simulate) {\r\n    fragColor = error.rgba;\r\n  } else {\r\n    fragColor = correction.rgba;\r\n  }\r\n}");
;// CONCATENATED MODULE: ./Graphics/PostProcessor/ScreenShader.ts



/**
 * Helper that defines a whole screen renderer, just provide a fragment source!
 *
 * Currently supports 1 varying
 * - vec2 a_texcoord between 0-1 which corresponds to screen position
 */
class ScreenShader {
    constructor(fragmentSource) {
        this._shader = new Shader({
            vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_texcoord;
      out vec2 v_texcoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_texcoord;
      }`,
            fragmentSource: fragmentSource
        });
        this._shader.compile();
        // Setup memory layout
        this._buffer = new VertexBuffer({
            type: 'static',
            // clip space quad + uv since we don't need a camera
            data: new Float32Array([
                -1, -1, 0, 0,
                -1, 1, 0, 1,
                1, -1, 1, 0,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                1, 1, 1, 1
            ])
        });
        this._layout = new VertexLayout({
            shader: this._shader,
            vertexBuffer: this._buffer,
            attributes: [
                ['a_position', 2],
                ['a_texcoord', 2]
            ]
        });
        this._buffer.upload();
    }
    getShader() {
        return this._shader;
    }
    getLayout() {
        return this._layout;
    }
}

;// CONCATENATED MODULE: ./Graphics/PostProcessor/ColorBlindnessPostProcessor.ts



class ColorBlindnessPostProcessor {
    constructor(_colorBlindnessMode, simulate = false) {
        this._colorBlindnessMode = _colorBlindnessMode;
        this._simulate = false;
        this._simulate = simulate;
    }
    initialize(_gl) {
        this._shader = new ScreenShader(color_blind_fragment);
        this.simulate = this._simulate;
        this.colorBlindnessMode = this._colorBlindnessMode;
    }
    getShader() {
        return this._shader.getShader();
    }
    getLayout() {
        return this._shader.getLayout();
    }
    set colorBlindnessMode(colorBlindMode) {
        this._colorBlindnessMode = colorBlindMode;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {
                shader.setUniformInt('u_type', 0);
            }
            else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {
                shader.setUniformInt('u_type', 1);
            }
            else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {
                shader.setUniformInt('u_type', 2);
            }
        }
    }
    get colorBlindnessMode() {
        return this._colorBlindnessMode;
    }
    set simulate(value) {
        this._simulate = value;
        if (this._shader) {
            const shader = this._shader.getShader();
            shader.use();
            shader.setUniformBoolean('u_simulate', value);
        }
    }
    get simulate() {
        return this._simulate;
    }
}

;// CONCATENATED MODULE: ./Debug/DebugFlags.ts



class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
        this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);
    }
    /**
     * Correct colors for a specified color blindness
     * @param colorBlindness
     */
    correct(colorBlindness) {
        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = false;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Simulate colors for a specified color blindness
     * @param colorBlindness
     */
    simulate(colorBlindness) {
        if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
            this.clear();
            this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
            this._colorBlindPostProcessor.simulate = true;
            this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
        }
    }
    /**
     * Remove color blindness post processor
     */
    clear() {
        this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
    }
}

;// CONCATENATED MODULE: ./Debug/Debug.ts


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: true,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            showPosition: false,
            showPositionLabel: false,
            positionColor: Color.Yellow,
            showZIndex: false,
            showScale: false,
            scaleColor: Color.Green,
            showRotation: false,
            rotationColor: Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: Color.Green
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: Color.Cyan,
            showCollisionContacts: true,
            collisionContactColor: Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: Color.Yellow,
            showAcceleration: false,
            accelerationColor: Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: Color.Red,
            showZoom: false
        };
        this._engine = engine;
        this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
    /**
     * Switch the current excalibur clock with the [[TestClock]] and return
     * it in the same running state.
     *
     * This is useful when you need to debug frame by frame.
     */
    useTestClock() {
        const clock = this._engine.clock;
        const wasRunning = clock.isRunning();
        clock.stop();
        const testClock = clock.toTestClock();
        if (wasRunning) {
            testClock.start();
        }
        this._engine.clock = testClock;
        return testClock;
    }
    /**
     * Switch the current excalibur clock with the [[StandardClock]] and
     * return it in the same running state.
     *
     * This is useful when you need to switch back to normal mode after
     * debugging.
     */
    useStandardClock() {
        const currentClock = this._engine.clock;
        const wasRunning = currentClock.isRunning();
        currentClock.stop();
        const standardClock = currentClock.toStandardClock();
        if (wasRunning) {
            standardClock.start();
        }
        this._engine.clock = standardClock;
        return standardClock;
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}

;// CONCATENATED MODULE: ./Input/PointerScope.ts
/**
 * Determines the scope of handling mouse/touch events.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));

;// CONCATENATED MODULE: ./Input/Keyboard.ts



/**
 * Enum representing physical input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    Keys["ControlLeft"] = "ControlLeft";
    Keys["ControlRight"] = "ControlRight";
    Keys["MetaLeft"] = "MetaLeft";
    Keys["MetaRight"] = "MetaRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // FUNCTION KEYS
    Keys["F1"] = "F1";
    Keys["F2"] = "F2";
    Keys["F3"] = "F3";
    Keys["F4"] = "F4";
    Keys["F5"] = "F5";
    Keys["F6"] = "F6";
    Keys["F7"] = "F7";
    Keys["F8"] = "F8";
    Keys["F9"] = "F9";
    Keys["F10"] = "F10";
    Keys["F11"] = "F11";
    Keys["F12"] = "F12";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Backspace"] = "Backspace";
    Keys["Delete"] = "Delete";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
    Keys["Enter"] = "Enter";
    Keys["NumpadEnter"] = "NumpadEnter";
    Keys["ContextMenu"] = "ContextMenu";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends Class {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
        this._handleKeyDown = (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        };
        this._handleKeyUp = (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        };
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', this._handleKeyUp);
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', this._handleKeyDown);
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
    /**
     * Trigger a manual key event
     * @param type
     * @param key
     * @param character
     */
    triggerEvent(type, key, character) {
        if (type === 'down') {
            this._handleKeyDown(new KeyboardEvent('keydown', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
        if (type === 'up') {
            this._handleKeyUp(new KeyboardEvent('keyup', {
                code: key,
                key: character !== null && character !== void 0 ? character : null
            }));
        }
    }
}

;// CONCATENATED MODULE: ./Input/Gamepad.ts


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends Class {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends Class {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));

;// CONCATENATED MODULE: ./Util/Browser.ts
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}

;// CONCATENATED MODULE: ./Math/global-coordinates.ts

class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}

;// CONCATENATED MODULE: ./Input/PointerEvent.ts
class PointerEvent {
    constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {
        this.type = type;
        this.pointerId = pointerId;
        this.button = button;
        this.pointerType = pointerType;
        this.coordinates = coordinates;
        this.nativeEvent = nativeEvent;
        this.active = true;
    }
    cancel() {
        this.active = false;
    }
    get pagePos() {
        return this.coordinates.pagePos;
    }
    get screenPos() {
        return this.coordinates.screenPos;
    }
    get worldPos() {
        return this.coordinates.worldPos;
    }
    ;
}

;// CONCATENATED MODULE: ./Input/WheelEvent.ts
class WheelEvent {
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this.active = true;
    }
    cancel() {
        this.active = false;
    }
}

;// CONCATENATED MODULE: ./Input/PointerAbstraction.ts


class PointerAbstraction extends Class {
    constructor() {
        super();
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = Vector.Zero;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = Vector.Zero;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = Vector.Zero;
        this._onPointerMove = (ev) => {
            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this._onPointerDown = (ev) => {
            this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
            this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
            this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        };
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
}

;// CONCATENATED MODULE: ./Input/WheelDeltaMode.ts
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));

;// CONCATENATED MODULE: ./Input/NativePointerButton.ts
/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));

;// CONCATENATED MODULE: ./Input/PointerButton.ts
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));

;// CONCATENATED MODULE: ./Input/PointerType.ts
/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));

;// CONCATENATED MODULE: ./Input/PointerEventReceiver.ts













/**
 * Is this event a native touch event?
 */
function isTouchEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;
}
/**
 * Is this event a native pointer event
 */
function isPointerEvent(value) {
    // Guard for Safari <= 13.1
    return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;
}
/**
 * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates
 */
class PointerEventReceiver extends Class {
    constructor(target, engine) {
        super();
        this.target = target;
        this.engine = engine;
        this.primary = new PointerAbstraction();
        this._activeNativePointerIdsToNormalized = new Map();
        this.lastFramePointerCoords = new Map();
        this.currentFramePointerCoords = new Map();
        this.currentFramePointerDown = new Map();
        this.lastFramePointerDown = new Map();
        this.currentFrameDown = [];
        this.currentFrameUp = [];
        this.currentFrameMove = [];
        this.currentFrameCancel = [];
        this.currentFrameWheel = [];
        this._pointers = [this.primary];
        this._boundHandle = this._handle.bind(this);
        this._boundWheel = this._handleWheel.bind(this);
    }
    /**
     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
     * handlers.
     * @param target
     * @param engine
     */
    recreate(target, engine) {
        const eventReceiver = new PointerEventReceiver(target, engine);
        eventReceiver.primary = this.primary;
        eventReceiver._pointers = this._pointers;
        return eventReceiver;
    }
    /**
     * Locates a specific pointer by id, creates it if it doesn't exist
     * @param index
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new PointerAbstraction());
            }
        }
        return this._pointers[index];
    }
    /**
     * The number of pointers currently being tracked by excalibur
     */
    count() {
        return this._pointers.length;
    }
    /**
     * Is the specified pointer id down this frame
     * @param pointerId
     */
    isDown(pointerId) {
        var _a;
        return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Was the specified pointer id down last frame
     * @param pointerId
     */
    wasDown(pointerId) {
        var _a;
        return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    isDragging(pointerId) {
        return this.isDown(pointerId);
    }
    /**
     * Whether the Pointer just started dragging.
     */
    isDragStart(pointerId) {
        return this.isDown(pointerId) && !this.wasDown(pointerId);
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    isDragEnd(pointerId) {
        return !this.isDown(pointerId) && this.wasDown(pointerId);
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Called internally by excalibur
     *
     * Updates the current frame pointer info and emits raw pointer events
     *
     * This does not emit events to entities, see PointerSystem
     */
    update() {
        this.lastFramePointerDown = new Map(this.currentFramePointerDown);
        this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
        for (const event of this.currentFrameDown) {
            this.emit('down', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('down', event);
            this.primary.emit('pointerdown', event);
        }
        for (const event of this.currentFrameUp) {
            this.emit('up', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('up', event);
        }
        for (const event of this.currentFrameMove) {
            this.emit('move', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('move', event);
        }
        for (const event of this.currentFrameCancel) {
            this.emit('cancel', event);
            const pointer = this.at(event.pointerId);
            pointer.emit('cancel', event);
        }
        for (const event of this.currentFrameWheel) {
            this.emit('wheel', event);
            this.primary.emit('pointerwheel', event);
        }
    }
    /**
     * Clears the current frame event and pointer data
     */
    clear() {
        for (const event of this.currentFrameUp) {
            this.currentFramePointerCoords.delete(event.pointerId);
            const ids = this._activeNativePointerIdsToNormalized.entries();
            for (const [native, normalized] of ids) {
                if (normalized === event.pointerId) {
                    this._activeNativePointerIdsToNormalized.delete(native);
                }
            }
        }
        this.currentFrameDown.length = 0;
        this.currentFrameUp.length = 0;
        this.currentFrameMove.length = 0;
        this.currentFrameCancel.length = 0;
        this.currentFrameWheel.length = 0;
    }
    /**
     * Initializes the pointer event receiver so that it can start listening to native
     * browser events.
     */
    init() {
        // Disabling the touch action avoids browser/platform gestures from firing on the canvas
        // It is important on mobile to have touch action 'none'
        // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not
        if (this.target === this.engine.canvas) {
            this.engine.canvas.style.touchAction = 'none';
        }
        else {
            document.body.style.touchAction = 'none';
        }
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.addEventListener('pointerdown', this._boundHandle);
            this.target.addEventListener('pointerup', this._boundHandle);
            this.target.addEventListener('pointermove', this._boundHandle);
            this.target.addEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.addEventListener('touchstart', this._boundHandle);
            this.target.addEventListener('touchend', this._boundHandle);
            this.target.addEventListener('touchmove', this._boundHandle);
            this.target.addEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.addEventListener('mousedown', this._boundHandle);
            this.target.addEventListener('mouseup', this._boundHandle);
            this.target.addEventListener('mousemove', this._boundHandle);
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.addEventListener('wheel', this._boundWheel, wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);
        }
    }
    detach() {
        // Preferred pointer events
        if (window.PointerEvent) {
            this.target.removeEventListener('pointerdown', this._boundHandle);
            this.target.removeEventListener('pointerup', this._boundHandle);
            this.target.removeEventListener('pointermove', this._boundHandle);
            this.target.removeEventListener('pointercancel', this._boundHandle);
        }
        else {
            // Touch Events
            this.target.removeEventListener('touchstart', this._boundHandle);
            this.target.removeEventListener('touchend', this._boundHandle);
            this.target.removeEventListener('touchmove', this._boundHandle);
            this.target.removeEventListener('touchcancel', this._boundHandle);
            // Mouse Events
            this.target.removeEventListener('mousedown', this._boundHandle);
            this.target.removeEventListener('mouseup', this._boundHandle);
            this.target.removeEventListener('mousemove', this._boundHandle);
        }
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            this.target.removeEventListener('wheel', this._boundWheel);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            this.target.addEventListener('mousewheel', this._boundWheel);
        }
        else {
            // Remaining browser and older Firefox
            this.target.addEventListener('MozMousePixelScroll', this._boundWheel);
        }
    }
    /**
     * Take native pointer id and map it to index in active pointers
     * @param nativePointerId
     */
    _normalizePointerId(nativePointerId) {
        // Add to the the native pointer set id
        this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);
        // Native pointer ids in ascending order
        const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);
        // The index into sorted ids will be the new id, will always have an id
        const id = currentPointerIds.findIndex(p => p === nativePointerId);
        // Save the mapping so we can reverse it later
        this._activeNativePointerIdsToNormalized.set(nativePointerId, id);
        // ignore pointer because game isn't watching
        return id;
    }
    /**
     * Responsible for handling and parsing pointer events
     */
    _handle(ev) {
        ev.preventDefault();
        const eventCoords = new Map();
        let button;
        let pointerType;
        if (isTouchEvent(ev)) {
            button = PointerButton.Unknown;
            pointerType = PointerType.Touch;
            // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches[i];
                const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);
                const nativePointerId = i + 1;
                const pointerId = this._normalizePointerId(nativePointerId);
                this.currentFramePointerCoords.set(pointerId, coordinates);
                eventCoords.set(pointerId, coordinates);
            }
        }
        else {
            button = this._nativeButtonToPointerButton(ev.button);
            pointerType = PointerType.Mouse;
            const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);
            let nativePointerId = 1;
            if (isPointerEvent(ev)) {
                nativePointerId = ev.pointerId;
                pointerType = this._stringToPointerType(ev.pointerType);
            }
            const pointerId = this._normalizePointerId(nativePointerId);
            this.currentFramePointerCoords.set(pointerId, coordinates);
            eventCoords.set(pointerId, coordinates);
        }
        for (const [pointerId, coord] of eventCoords.entries()) {
            switch (ev.type) {
                case 'mousedown':
                case 'pointerdown':
                case 'touchstart':
                    this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, true);
                    break;
                case 'mouseup':
                case 'pointerup':
                case 'touchend':
                    this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));
                    this.currentFramePointerDown.set(pointerId, false);
                    break;
                case 'mousemove':
                case 'pointermove':
                case 'touchmove':
                    this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));
                    break;
                case 'touchcancel':
                case 'pointercancel':
                    this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));
                    break;
            }
        }
    }
    _handleWheel(ev) {
        // Should we prevent page scroll because of this event
        if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
            (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)) {
            ev.preventDefault();
        }
        const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));
        const world = this.engine.screen.screenToWorldCoordinates(screen);
        /**
         * A constant used to normalize wheel events across different browsers
         *
         * This normalization factor is pulled from
         * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
         */
        const ScrollWheelNormalizationFactor = -1 / 40;
        const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
        const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;
        const deltaZ = ev.deltaZ || 0;
        let deltaMode = WheelDeltaMode.Pixel;
        if (ev.deltaMode) {
            if (ev.deltaMode === 1) {
                deltaMode = WheelDeltaMode.Line;
            }
            else if (ev.deltaMode === 2) {
                deltaMode = WheelDeltaMode.Page;
            }
        }
        const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);
        this.currentFrameWheel.push(we);
    }
    /**
     * Triggers an excalibur pointer event in a world space pos
     *
     * Useful for testing pointers in excalibur
     * @param type
     * @param pos
     */
    triggerEvent(type, pos) {
        const page = this.engine.screen.worldToPageCoordinates(pos);
        // Send an event to the event receiver
        if (window.PointerEvent) {
            this._handle(new window.PointerEvent('pointer' + type, {
                pointerId: 0,
                clientX: page.x,
                clientY: page.y
            }));
        }
        else {
            // Safari hack
            this._handle(new window.MouseEvent('mouse' + type, {
                clientX: page.x,
                clientY: page.y
            }));
        }
        // Force update pointer system
        const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);
        const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);
        pointerSystem.preupdate();
        pointerSystem.update(transformEntities.getEntities());
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case NativePointerButton.NoButton:
                return PointerButton.NoButton;
            case NativePointerButton.Left:
                return PointerButton.Left;
            case NativePointerButton.Middle:
                return PointerButton.Middle;
            case NativePointerButton.Right:
                return PointerButton.Right;
            case NativePointerButton.Unknown:
                return PointerButton.Unknown;
            default:
                return fail(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return PointerType.Touch;
            case 'mouse':
                return PointerType.Mouse;
            case 'pen':
                return PointerType.Pen;
            default:
                return PointerType.Unknown;
        }
    }
}

;// CONCATENATED MODULE: ./Util/Fps.ts
class FpsSampler {
    constructor(options) {
        var _a;
        this._samplePeriod = 100;
        this._currentFrameTime = 0;
        this._frames = 0;
        this._previousSampleTime = 0;
        this._beginFrameTime = 0;
        this._fps = options.initialFps;
        this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;
        this._currentFrameTime = 1000 / options.initialFps;
        this._nowFn = options.nowFn;
        this._previousSampleTime = this._nowFn();
    }
    /**
     * Start of code block to sample FPS for
     */
    start() {
        this._beginFrameTime = this._nowFn();
    }
    /**
     * End of code block to sample FPS for
     */
    end() {
        this._frames++;
        const time = this._nowFn();
        this._currentFrameTime = time - this._beginFrameTime;
        if (time >= this._previousSampleTime + this._samplePeriod) {
            this._fps = (this._frames * 1000) / (time - this._previousSampleTime);
            this._previousSampleTime = time;
            this._frames = 0;
        }
    }
    /**
     * Return the currently sampled fps over the last sample period, by default every 100ms
     */
    get fps() {
        return this._fps;
    }
    /**
     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
     */
    get instant() {
        return 1000 / this._currentFrameTime;
    }
}

;// CONCATENATED MODULE: ./Util/Clock.ts


/**
 * Abstract Clock is the base type of all Clocks
 *
 * It has a few opinions
 * 1. It manages the calculation of what "elapsed" time means and thus maximum fps
 * 2. The default timing api is implemented in now()
 *
 * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever
 * method is unique to your clock implementation.
 */
class Clock {
    constructor(options) {
        var _a, _b, _c;
        this._onFatalException = () => { };
        this._maxFps = Infinity;
        this._lastTime = 0;
        this._elapsed = 1;
        this._scheduledCbs = [];
        this._totalElapsed = 0;
        this._options = options;
        this.tick = options.tick;
        this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;
        this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;
        this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;
        this.fpsSampler = new FpsSampler({
            initialFps: 60,
            nowFn: () => this.now()
        });
    }
    /**
     * Get the elapsed time for the last completed frame
     */
    elapsed() {
        return this._elapsed;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        return performance.now();
    }
    toTestClock() {
        const testClock = new TestClock({
            ...this._options,
            defaultUpdateMs: 16.6
        });
        return testClock;
    }
    toStandardClock() {
        const clock = new StandardClock({
            ...this._options
        });
        return clock;
    }
    setFatalExceptionHandler(handler) {
        this._onFatalException = handler;
    }
    /**
     * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]
     *
     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
     * stopped or paused.
     *
     * @param cb callback to fire
     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
     */
    schedule(cb, timeoutMs = 0) {
        // Scheduled based on internal elapsed time
        const scheduledTime = this._totalElapsed + timeoutMs;
        this._scheduledCbs.push([cb, scheduledTime]);
    }
    _runScheduledCbs() {
        // walk backwards to delete items as we loop
        for (let i = this._scheduledCbs.length - 1; i > -1; i--) {
            if (this._scheduledCbs[i][1] <= this._totalElapsed) {
                this._scheduledCbs[i][0]();
                this._scheduledCbs.splice(i, 1);
            }
        }
    }
    update(overrideUpdateMs) {
        try {
            this.fpsSampler.start();
            // Get the time to calculate time-elapsed
            const now = this.now();
            let elapsed = now - this._lastTime || 1; // first frame
            // Constrain fps
            const fpsInterval = (1000 / this._maxFps);
            // only run frame if enough time has elapsed
            if (elapsed >= fpsInterval) {
                let leftover = 0;
                if (fpsInterval !== 0) {
                    leftover = (elapsed % fpsInterval);
                    elapsed = elapsed - leftover; // shift elapsed to be "in phase" with the current loop fps
                }
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                // tick the mainloop and run scheduled callbacks
                this._elapsed = overrideUpdateMs || elapsed;
                this._totalElapsed += this._elapsed;
                this._runScheduledCbs();
                this.tick(overrideUpdateMs || elapsed);
                if (fpsInterval !== 0) {
                    this._lastTime = now - leftover;
                }
                else {
                    this._lastTime = now;
                }
                this.fpsSampler.end();
            }
        }
        catch (e) {
            this._onFatalException(e);
            this.stop();
        }
    }
}
/**
 * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()
 */
class StandardClock extends Clock {
    constructor(options) {
        super(options);
        this._running = false;
    }
    isRunning() {
        return this._running;
    }
    start() {
        if (this._running) {
            return;
        }
        this._running = true;
        const mainloop = () => {
            // stop the loop
            if (!this._running) {
                return;
            }
            try {
                // request next loop
                this._requestId = window.requestAnimationFrame(mainloop);
                this.update();
            }
            catch (e) {
                window.cancelAnimationFrame(this._requestId);
                throw e;
            }
        };
        // begin the first frame
        mainloop();
    }
    stop() {
        this._running = false;
    }
}
/**
 * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test
 */
class TestClock extends Clock {
    constructor(options) {
        super({
            ...options
        });
        this._logger = Logger.getInstance();
        this._running = false;
        this._currentTime = 0;
        this._updateMs = options.defaultUpdateMs;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
        var _a;
        return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    isRunning() {
        return this._running;
    }
    start() {
        this._running = true;
    }
    stop() {
        this._running = false;
    }
    /**
     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
     * @param overrideUpdateMs
     */
    step(overrideUpdateMs) {
        const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;
        if (this._running) {
            // to be comparable to RAF this needs to be a full blown Task
            // For example, images cannot decode synchronously in a single step
            this.update(time);
            this._currentTime += time;
        }
        else {
            this._logger.warn('The clock is not running, no step will be performed');
        }
    }
    /**
     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
     * @param numberOfSteps
     * @param overrideUpdateMs
     */
    run(numberOfSteps, overrideUpdateMs) {
        for (let i = 0; i < numberOfSteps; i++) {
            this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);
        }
    }
}

// EXTERNAL MODULE: ./Util/Toaster.css
var Util_Toaster = __nested_webpack_require_62364__(7379);
;// CONCATENATED MODULE: ./Util/Toaster.ts

/**
 * The Toaster is only meant to be called from inside Excalibur to display messages to players
 */
class Toaster {
    constructor() {
        this._toasterCss = Util_Toaster/* default.toString */.Z.toString();
        this._isInitialized = false;
    }
    _initialize() {
        if (!this._isInitialized) {
            this._container = document.createElement('div');
            this._container.id = 'ex-toast-container';
            document.body.appendChild(this._container);
            this._isInitialized = true;
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._toasterCss;
            document.head.appendChild(this._styleBlock);
        }
    }
    dispose() {
        this._container.parentElement.removeChild(this._container);
        this._styleBlock.parentElement.removeChild(this._styleBlock);
        this._isInitialized = false;
    }
    _createFragment(message) {
        const toastMessage = document.createElement('span');
        toastMessage.innerText = message;
        return toastMessage;
    }
    /**
     * Display a toast message to a player
     * @param message Text of the message, messages may have a single "[LINK]" to influence placement
     * @param linkTarget Optionally specify a link location
     * @param linkName Optionally specify a name for that link location
     */
    toast(message, linkTarget, linkName) {
        this._initialize();
        const toast = document.createElement('div');
        toast.className = 'ex-toast-message';
        const messageFragments = message.split('[LINK]').map(message => this._createFragment(message));
        if (linkTarget) {
            const link = document.createElement('a');
            link.href = linkTarget;
            if (linkName) {
                link.innerText = linkName;
            }
            else {
                link.innerText = linkTarget;
            }
            messageFragments.splice(1, 0, link);
        }
        // Assembly message
        const finalMessage = document.createElement('div');
        messageFragments.forEach(message => {
            finalMessage.appendChild(message);
        });
        toast.appendChild(finalMessage);
        // Dismiss button
        const dismissBtn = document.createElement('button');
        dismissBtn.innerText = 'x';
        dismissBtn.addEventListener('click', () => {
            this._container.removeChild(toast);
        });
        toast.appendChild(dismissBtn);
        // Escape to dismiss
        const keydownHandler = (evt) => {
            if (evt.key === 'Escape') {
                try {
                    this._container.removeChild(toast);
                }
                catch (_a) {
                    // pass
                }
            }
            document.removeEventListener('keydown', keydownHandler);
        };
        document.addEventListener('keydown', keydownHandler);
        // Insert into container
        const first = this._container.firstChild;
        this._container.insertBefore(toast, first);
    }
}

;// CONCATENATED MODULE: ./Engine.ts



polyfill();


















/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends Class {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        super();
        /**
         * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.
         *
         * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than
         * one that bounces between 30fps and 60fps
         */
        this.maxFps = Number.POSITIVE_INFINITY;
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            Logger.getInstance().fatal(e);
        };
        this._toaster = new Toaster();
        this._timescale = 1.0;
        this._isInitialized = false;
        this._deferredGoTo = null;
        this._originalOptions = {};
        this._performanceThresholdTriggered = false;
        this._fpsSamples = [];
        this._loadingComplete = false;
        this._isReady = false;
        this._isReadyPromise = new Promise(resolve => {
            this._isReadyResolve = resolve;
        });
        /**
         * Returns the current frames elapsed milliseconds
         */
        this.currentFrameElapsedMs = 0;
        /**
         * Returns the current frame lag when in fixed update mode
         */
        this.currentFrameLagMs = 0;
        this._lagMs = 0;
        this._screenShotRequests = [];
        options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };
        this._originalOptions = options;
        Flags.freeze();
        // Initialize browser events facade
        this.browser = new BrowserEvents(window, document);
        // Check compatibility
        const detector = new Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = DisplayMode.FitScreen;
        }
        this._originalDisplayMode = displayMode;
        // Canvas 2D fallback can be flagged on
        let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');
        if (!useCanvasGraphicsContext) {
            // Attempt webgl first
            try {
                this.graphicsContext = new ExcaliburGraphicsContextWebGL({
                    canvasElement: this.canvas,
                    enableTransparency: this.enableCanvasTransparency,
                    smoothing: options.antialiasing,
                    backgroundColor: options.backgroundColor,
                    snapToPixel: options.snapToPixel,
                    useDrawSorting: options.useDrawSorting
                });
            }
            catch (e) {
                this._logger.warn(`Excalibur could not load webgl for some reason (${e.message}) and loaded a Canvas 2D fallback. ` +
                    `Some features of Excalibur will not work in this mode. \n\n` +
                    'Read more about this issue at https://excaliburjs.com/docs/webgl');
                // fallback to canvas in case of failure
                useCanvasGraphicsContext = true;
            }
        }
        if (useCanvasGraphicsContext) {
            this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel,
                useDrawSorting: options.useDrawSorting
            });
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_d = options.pixelRatio) !== null && _d !== void 0 ? _d : null)
        });
        // Set default filtering based on antialiasing
        TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.maxFps = (_e = options.maxFps) !== null && _e !== void 0 ? _e : this.maxFps;
        this.fixedUpdateFps = (_f = options.fixedUpdateFps) !== null && _f !== void 0 ? _f : this.fixedUpdateFps;
        this.clock = new StandardClock({
            maxFps: this.maxFps,
            tick: this._mainloop.bind(this),
            onFatalException: (e) => this.onFatalException(e)
        });
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new Loader();
        this._loader.wireEngine(this);
        this.debug = new Debug(this);
        this._initialize(options);
        this.rootScene = this.currentScene = new Scene();
        this.addScene('root', this.rootScene);
        window.___EXCALIBUR_DEVTOOL = this;
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    /**
     * Hints the graphics context to truncate fractional world space coordinates
     */
    get snapToPixel() {
        return this.graphicsContext.snapToPixel;
    }
    ;
    set snapToPixel(shouldSnapToPixel) {
        this.graphicsContext.snapToPixel = shouldSnapToPixel;
    }
    ;
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    _monitorPerformanceThresholdAndTriggerFallback() {
        const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;
        let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;
        if (threshold === undefined) {
            threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;
        }
        if (showPlayerMessage === undefined) {
            showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;
        }
        if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {
            // Calculate Average fps for last X number of frames after start
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                this._fpsSamples.splice(0, 1);
            }
            this._fpsSamples.push(this.clock.fpsSampler.fps);
            let total = 0;
            for (let i = 0; i < this._fpsSamples.length; i++) {
                total += this._fpsSamples[i];
            }
            const average = total / this._fpsSamples.length;
            if (this._fpsSamples.length === threshold.numberOfFrames) {
                if (average <= threshold.fps) {
                    this._performanceThresholdTriggered = true;
                    this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\n` +
                        'this might mean your browser doesn\'t have webgl enabled or hardware acceleration is unavailable.\n\n' +
                        'If in Chrome:\n' +
                        '  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.\n' +
                        '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"\n' +
                        'If in Firefox, visit about:config\n' +
                        '  * Ensure webgl.disabled = false\n' +
                        '  * Ensure webgl.force-enabled = true\n' +
                        '  * Ensure layers.acceleration.force-enabled = true\n\n' +
                        'Read more about this issue at https://excaliburjs.com/docs/performance');
                    if (showPlayerMessage) {
                        this._toaster.toast('Excalibur is encountering performance issues. ' +
                            'It\'s possible that your browser doesn\'t have hardware acceleration enabled. ' +
                            'Visit [LINK] for more information and potential solutions.', 'https://excaliburjs.com/docs/performance');
                    }
                    this.useCanvas2DFallback();
                    this.emit('fallbackgraphicscontext', this.graphicsContext);
                }
            }
        }
    }
    /**
     * Switches the engine's graphics context to the 2D Canvas.
     * @warning Some features of Excalibur will not work in this mode.
     */
    useCanvas2DFallback() {
        var _a, _b, _c;
        // Swap out the canvas
        const newCanvas = this.canvas.cloneNode(false);
        this.canvas.parentNode.replaceChild(newCanvas, this.canvas);
        this.canvas = newCanvas;
        const options = this._originalOptions;
        const displayMode = this._originalDisplayMode;
        // New graphics context
        this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
            canvasElement: this.canvas,
            enableTransparency: this.enableCanvasTransparency,
            smoothing: options.antialiasing,
            backgroundColor: options.backgroundColor,
            snapToPixel: options.snapToPixel,
            useDrawSorting: options.useDrawSorting
        });
        // Reset screen
        if (this.screen) {
            this.screen.dispose();
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,
            browser: this.browser,
            viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            pixelRatio: options.suppressHiDPIScaling ? 1 : ((_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null)
        });
        this.screen.setCurrentCamera(this.currentScene.camera);
        // Reset pointers
        this.input.pointers.detach();
        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
        this.input.pointers = this.input.pointers.recreate(pointerTarget, this);
        this.input.pointers.init();
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof Scene) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
            return;
        }
        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
            this.scenes[this._deferredGoTo].add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof Scene) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     * @param data Optional data to send to the scene's onActivate method
     */
    goToScene(key, data) {
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoTo = key;
            return;
        }
        if (this.scenes[key]) {
            const previousScene = this.currentScene;
            const nextScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                const context = { engine: this, previousScene, nextScene };
                this.currentScene._deactivate.apply(this.currentScene, [context, nextScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(context, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = nextScene;
            this.screen.setCurrentCamera(nextScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            const context = { engine: this, previousScene, nextScene, data };
            this.currentScene._activate.apply(this.currentScene, [context, nextScene]);
            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(context, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
        this.input = {
            keyboard: new Keyboard(),
            pointers: new PointerEventReceiver(pointerTarget, this),
            gamepads: new Gamepads()
        };
        this.input.keyboard.init();
        this.input.pointers.init();
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
            if (this._deferredGoTo) {
                const deferredScene = this._deferredGoTo;
                this._deferredGoTo = null;
                this.goToScene(deferredScene);
            }
            else {
                this.goToScene('root');
            }
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (!this.ready) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.gamepads.update();
            return;
        }
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // Publish update event
        this._postupdate(delta);
        // Update input listeners
        this.input.keyboard.update();
        this.input.gamepads.update();
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new PreUpdateEvent(this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new PostUpdateEvent(this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        this.graphicsContext.beginDrawLifecycle();
        this.graphicsContext.clear();
        this._predraw(this.graphicsContext, delta);
        // Drawing nothing else while loading
        if (!this._isReady) {
            this._loader.canvas.draw(this.graphicsContext, 0, 0);
            this.graphicsContext.flush();
            return;
        }
        this.graphicsContext.backgroundColor = this.backgroundColor;
        this.currentScene.draw(this.graphicsContext, delta);
        this._postdraw(this.graphicsContext, delta);
        // Flush any pending drawings
        this.graphicsContext.flush();
        this.graphicsContext.endDrawLifecycle();
        this._checkForScreenShots();
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return this._loadingComplete;
    }
    get ready() {
        return this._isReady;
    }
    isReady() {
        return this._isReadyPromise;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     *
     * Note: start() only resolves AFTER the user has clicked the play button
     */
    async start(loader) {
        if (!this._compatible) {
            throw new Error('Excalibur is incompatible with your browser');
        }
        // Wire loader if we have it
        if (loader) {
            // Push the current user entered resolution/viewport
            this.screen.pushResolutionAndViewport();
            // Configure resolution for loader, it expects resolution === viewport
            this.screen.resolution = this.screen.viewport;
            this.screen.applyResolutionAndViewport();
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
        }
        // Start the excalibur clock which drives the mainloop
        // has started is a slight misnomer, it's really mainloop started
        this._logger.debug('Starting game clock...');
        this.browser.resume();
        this.clock.start();
        this._logger.debug('Game clock started');
        if (loader) {
            await this.load(this._loader);
            this._loadingComplete = true;
            // reset back to previous user resolution/viewport
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
        }
        this._loadingComplete = true;
        // Initialize before ready
        this._overrideInitialize(this);
        this._isReady = true;
        this._isReadyResolve();
        this.emit('start', new GameStartEvent(this));
        return this._isReadyPromise;
    }
    _mainloop(elapsed) {
        this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));
        const delta = elapsed * this.timescale;
        this.currentFrameElapsedMs = delta;
        // reset frame stats (reuse existing instances)
        const frameId = this.stats.prevFrame.id + 1;
        this.stats.currFrame.reset();
        this.stats.currFrame.id = frameId;
        this.stats.currFrame.delta = delta;
        this.stats.currFrame.fps = this.clock.fpsSampler.fps;
        GraphicsDiagnostics.clear();
        const beforeUpdate = this.clock.now();
        const fixedTimestepMs = 1000 / this.fixedUpdateFps;
        if (this.fixedUpdateFps) {
            this._lagMs += delta;
            while (this._lagMs >= fixedTimestepMs) {
                this._update(fixedTimestepMs);
                this._lagMs -= fixedTimestepMs;
            }
        }
        else {
            this._update(delta);
        }
        const afterUpdate = this.clock.now();
        this.currentFrameLagMs = this._lagMs;
        this._draw(delta);
        const afterDraw = this.clock.now();
        this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
        this.stats.currFrame.duration.draw = afterDraw - afterUpdate;
        this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
        this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));
        this.stats.prevFrame.reset(this.stats.currFrame);
        this._monitorPerformanceThresholdAndTriggerFallback();
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this.clock.isRunning()) {
            this.emit('stop', new GameStopEvent(this));
            this.browser.pause();
            this.clock.stop();
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's running status, Useful for checking whether engine is running or paused.
     */
    isRunning() {
        return this.clock.isRunning();
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
     */
    screenshot(preserveHiDPIResolution = false) {
        const screenShotPromise = new Promise((resolve) => {
            this._screenShotRequests.push({ preserveHiDPIResolution, resolve });
        });
        return screenShotPromise;
    }
    _checkForScreenShots() {
        // We must grab the draw buffer before we yield to the browser
        // the draw buffer is cleared after compositing
        // the reason for the asynchrony is setting `preserveDrawingBuffer: true`
        // forces the browser to copy buffers which can have a mass perf impact on mobile
        for (const request of this._screenShotRequests) {
            const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;
            const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;
            const screenshot = document.createElement('canvas');
            screenshot.width = finalWidth;
            screenshot.height = finalHeight;
            const ctx = screenshot.getContext('2d');
            ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);
            const result = new Image();
            const raw = screenshot.toDataURL('image/png');
            result.src = raw;
            request.resolve(result);
        }
        // Reset state
        this._screenShotRequests.length = 0;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    async load(loader) {
        try {
            await loader.load();
        }
        catch (e) {
            this._logger.error('Error loading resources, things may not behave properly', e);
            await Promise.resolve();
        }
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    useDrawSorting: true,
    configurePerformanceCanvas2DFallback: {
        allow: true,
        showPlayerMessage: false,
        threshold: { fps: 20, numberOfFrames: 100 }
    },
    canvasElementId: '',
    canvasElement: undefined,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue
};

;// CONCATENATED MODULE: ./Math/Index.ts













;// CONCATENATED MODULE: ./Debug/index.ts




;// CONCATENATED MODULE: ./Label.ts





/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label extends Actor {
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this._font = new Font();
        this._text = new Text({ text: '', font: this._font });
        const { text, pos, x, y, spriteFont, font, color } = options;
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this._text.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(GraphicsComponent);
        gfx.anchor = Vector.Zero;
        gfx.use(this._text);
    }
    get font() {
        return this._font;
    }
    set font(newFont) {
        this._font = newFont;
        this._text.font = newFont;
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        if (this._text) {
            this._text.color = color;
        }
    }
    get opacity() {
        return this._text.opacity;
    }
    set opacity(opacity) {
        this._text.opacity = opacity;
    }
    /**
     * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.
     */
    get spriteFont() {
        return this._spriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
}

;// CONCATENATED MODULE: ./TileMap/IsometricMap.ts





class IsometricTile extends Entity {
    /**
     * Construct a new IsometricTile
     * @param x tile coordinate in x (not world position)
     * @param y tile coordinate in y (not world position)
     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
     * @param map reference to owning IsometricMap
     */
    constructor(x, y, graphicsOffset, map) {
        super([
            new TransformComponent(),
            new GraphicsComponent({
                offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : Vector.Zero,
                onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)
            }),
            new IsometricEntityComponent(map)
        ]);
        /**
         * Indicates whether this tile is solid
         */
        this.solid = false;
        this._tileBounds = new BoundingBox();
        this._graphics = [];
        /**
         * Tile colliders
         */
        this._colliders = [];
        this.x = x;
        this.y = y;
        this.map = map;
        this._transform = this.get(TransformComponent);
        this._isometricEntityComponent = this.get(IsometricEntityComponent);
        const halfTileWidth = this.map.tileWidth / 2;
        const halfTileHeight = this.map.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        // The x position shifts left with every y step
        const xPos = (this.x - this.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (this.x + this.y) * halfTileHeight;
        this._transform.pos = vec(xPos, yPos);
        this._isometricEntityComponent.elevation = 0;
        this._gfx = this.get(GraphicsComponent);
        this._gfx.visible = false; // start not visible
        const totalWidth = this.map.tileWidth;
        const totalHeight = this.map.tileHeight;
        // initial guess at gfx bounds based on the tile
        const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));
        this._gfx.localBounds = this._tileBounds = new BoundingBox({
            left: -totalWidth / 2,
            top: -totalHeight,
            right: totalWidth / 2,
            bottom: totalHeight
        }).translate(offset);
    }
    getGraphics() {
        return this._graphics;
    }
    /**
     * Tile graphics
     */
    addGraphic(graphic) {
        this._graphics.push(graphic);
        this._gfx.visible = true;
        this._gfx.localBounds = this._recalculateBounds();
    }
    _recalculateBounds() {
        let bounds = this._tileBounds.clone();
        for (const graphic of this._graphics) {
            const offset = vec(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));
            bounds = bounds.combine(graphic.localBounds.translate(offset));
        }
        return bounds;
    }
    removeGraphic(graphic) {
        const index = this._graphics.indexOf(graphic);
        if (index > -1) {
            this._graphics.splice(index, 1);
        }
        this._gfx.localBounds = this._recalculateBounds();
    }
    clearGraphics() {
        this._graphics.length = 0;
        this._gfx.visible = false;
        this._gfx.localBounds = this._recalculateBounds();
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Adds a collider to the IsometricTile
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
        this._colliders.push(collider);
        this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the IsometricTile
     * @param collider
     */
    removeCollider(collider) {
        const index = this._colliders.indexOf(collider);
        if (index > -1) {
            this._colliders.splice(index, 1);
        }
        this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the IsometricTile
     */
    clearColliders() {
        this._colliders.length = 0;
        this.map.flagCollidersDirty();
    }
    /**
     * Returns the top left corner of the [[IsometricTile]] in world space
     */
    get pos() {
        return this.map.tileToWorld(vec(this.x, this.y));
    }
    /**
     * Returns the center of the [[IsometricTile]]
     */
    get center() {
        return this.pos.add(vec(0, this.map.tileHeight / 2));
    }
    draw(gfx, _elapsed) {
        const halfTileWidth = this.map.tileWidth / 2;
        gfx.save();
        // shift left origin to corner of map, not the left corner of the first sprite
        gfx.translate(-halfTileWidth, 0);
        for (const graphic of this._graphics) {
            graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));
        }
        gfx.restore();
    }
}
/**
 * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur
 *
 * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.
 * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.
 *
 * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given
 * your art assets.
 */
class IsometricMap extends Entity {
    constructor(options) {
        super([
            new TransformComponent(),
            new BodyComponent({
                type: CollisionType.Fixed
            }),
            new ColliderComponent(),
            new DebugGraphicsComponent((ctx) => this.debug(ctx), false)
        ], options.name);
        /**
         * Render the tile graphic from the top instead of the bottom
         *
         * default is `false` meaning rendering from the bottom
         */
        this.renderFromTopOfGraphic = false;
        this.graphicsOffset = vec(0, 0);
        this._collidersDirty = false;
        this._originalOffsets = new WeakMap();
        const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;
        this.transform = this.get(TransformComponent);
        if (pos) {
            this.transform.pos = pos;
        }
        this.collider = this.get(ColliderComponent);
        if (this.collider) {
            this.collider.set(this._composite = new CompositeCollider([]));
        }
        this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;
        this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
        this.columns = width;
        this.rows = height;
        this.tiles = new Array(width * height);
        // build up tile representation
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const tile = new IsometricTile(x, y, this.graphicsOffset, this);
                this.tiles[x + y * width] = tile;
                this.addChild(tile);
                // TODO row/columns helpers
            }
        }
    }
    update() {
        if (this._collidersDirty) {
            this.updateColliders();
            this._collidersDirty = false;
        }
    }
    flagCollidersDirty() {
        this._collidersDirty = true;
    }
    _getOrSetColliderOriginalOffset(collider) {
        if (!this._originalOffsets.has(collider)) {
            const originalOffset = collider.offset;
            this._originalOffsets.set(collider, originalOffset);
            return originalOffset;
        }
        else {
            return this._originalOffsets.get(collider);
        }
    }
    updateColliders() {
        this._composite.clearColliders();
        const pos = this.get(TransformComponent).pos;
        for (const tile of this.tiles) {
            if (tile.solid) {
                for (const collider of tile.getColliders()) {
                    const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                    collider.offset = this.tileToWorld(vec(tile.x, tile.y))
                        .sub(pos)
                        .add(originalOffset)
                        .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing
                    collider.owner = this;
                    this._composite.addCollider(collider);
                }
            }
        }
        this.collider.update();
    }
    /**
     * Convert world space coordinates to the tile x, y coordinate
     * @param worldCoordinate
     */
    worldToTile(worldCoordinate) {
        worldCoordinate = worldCoordinate.sub(this.transform.globalPos);
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // See https://clintbellanger.net/articles/isometric_math/ for formula
        return vec(~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2), ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));
    }
    /**
     * Given a tile coordinate, return the top left corner in world space
     * @param tileCoordinate
     */
    tileToWorld(tileCoordinate) {
        const halfTileWidth = this.tileWidth / 2;
        const halfTileHeight = this.tileHeight / 2;
        // The x position shifts left with every y step
        const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;
        // The y position needs to go down with every x step
        const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;
        return vec(xPos, yPos).add(this.transform.pos);
    }
    /**
     * Returns the [[IsometricTile]] by its x and y coordinates
     */
    getTile(x, y) {
        if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {
            return null;
        }
        return this.tiles[x + y * this.columns];
    }
    /**
     * Returns the [[IsometricTile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point) {
        const tileCoord = this.worldToTile(point);
        const tile = this.getTile(tileCoord.x, tileCoord.y);
        return tile;
    }
    _getMaxZIndex() {
        let maxZ = Number.NEGATIVE_INFINITY;
        for (const tile of this.tiles) {
            const currentZ = tile.get(TransformComponent).z;
            if (currentZ > maxZ) {
                maxZ = currentZ;
            }
        }
        return maxZ;
    }
    /**
     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
     * @param gfx
     */
    debug(gfx) {
        gfx.save();
        gfx.z = this._getMaxZIndex() + 0.5;
        for (let y = 0; y < this.rows + 1; y++) {
            const left = this.tileToWorld(vec(0, y));
            const right = this.tileToWorld(vec(this.columns, y));
            gfx.drawLine(left, right, Color.Red, 2);
        }
        for (let x = 0; x < this.columns + 1; x++) {
            const top = this.tileToWorld(vec(x, 0));
            const bottom = this.tileToWorld(vec(x, this.rows));
            gfx.drawLine(top, bottom, Color.Red, 2);
        }
        for (const tile of this.tiles) {
            gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);
        }
        gfx.restore();
    }
}

;// CONCATENATED MODULE: ./TileMap/index.ts





;// CONCATENATED MODULE: ./Actions/Action/ActionSequence.ts

/**
 * Action that can represent a sequence of actions, this can be useful in conjunction with
 * [[ParallelActions]] to run multiple sequences in parallel.
 */
class ActionSequence {
    constructor(entity, actionBuilder) {
        this._stopped = false;
        this._sequenceBuilder = actionBuilder;
        this._sequenceContext = new ActionContext(entity);
        this._actionQueue = this._sequenceContext.getQueue();
        this._sequenceBuilder(this._sequenceContext);
    }
    update(delta) {
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || this._actionQueue.isComplete();
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._stopped = false;
        this._actionQueue.reset();
    }
    clone(entity) {
        return new ActionSequence(entity, this._sequenceBuilder);
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ParallelActions.ts
/**
 * Action that can run multiple [[Action]]s or [[ActionSequence]]s at the same time
 */
class ParallelActions {
    constructor(parallelActions) {
        this._actions = parallelActions;
    }
    update(delta) {
        for (let i = 0; i < this._actions.length; i++) {
            this._actions[i].update(delta);
        }
    }
    isComplete(entity) {
        return this._actions.every(a => a.isComplete(entity));
    }
    reset() {
        this._actions.forEach(a => a.reset());
    }
    stop() {
        this._actions.forEach(a => a.stop());
    }
}

;// CONCATENATED MODULE: ./Actions/Index.ts


























;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();

;// CONCATENATED MODULE: ./Collision/Index.ts





























;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}

;// CONCATENATED MODULE: ./Interfaces/Index.ts








;// CONCATENATED MODULE: ./Resources/Sound/Index.ts




;// CONCATENATED MODULE: ./Resources/Gif.ts






/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = Color.Magenta, bustCache = true) {
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._resource = new Resource(path, 'arraybuffer', bustCache);
        this._transparentColor = color;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    async load() {
        const arraybuffer = await this._resource.load();
        this._stream = new Stream(arraybuffer);
        this._gif = new ParseGif(this._stream, this._transparentColor);
        const images = this._gif.images.map(i => new ImageSource(i.src, false));
        // Load all textures
        await Promise.all(images.map(t => t.load()));
        return this.data = this._textures = images;
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        const sprite = this._textures[id].toSprite();
        return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._textures.map((image) => {
            return image.toSprite();
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
        const spriteSheet = this.toSpriteSheet();
        const length = spriteSheet.sprites.length;
        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = Color.Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}

;// CONCATENATED MODULE: ./Resources/Index.ts




;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts











;// CONCATENATED MODULE: ./Graphics/Line.ts



class Line extends Graphic {
    constructor(options) {
        super();
        this.color = Color.Black;
        this.thickness = 1;
        const { start, end, color, thickness } = options;
        this.start = start;
        this.end = end;
        this.color = color !== null && color !== void 0 ? color : this.color;
        this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;
        const { width, height } = BoundingBox.fromPoints([start, end]);
        this.width = width;
        this.height = height;
    }
    _drawImage(ctx, _x, _y) {
        ctx.drawLine(this.start, this.end, this.color, this.thickness);
    }
    clone() {
        return new Line({
            start: this.start,
            end: this.end,
            color: this.color,
            thickness: this.thickness
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Polygon.ts



/**
 * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]
 *
 * Polygons default to [[ImageFiltering.Blended]]
 */
class Polygon extends Raster {
    constructor(options) {
        super(options);
        this.points = options.points;
        this.filtering = ImageFiltering.Blended;
        this.rasterize();
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return vec(minX, minY);
    }
    clone() {
        return new Polygon({
            points: this.points.map((p) => p.clone()),
            ...this.cloneGraphicOptions(),
            ...this.cloneRasterOptions()
        });
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/index.ts
// Graphics







// Graphics ECS





// Raster graphics













// Post Processor






// Rendering





// Util



;// CONCATENATED MODULE: ./Input/Index.ts
/**
 * @module
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */















;// CONCATENATED MODULE: ./Util/Index.ts







;// CONCATENATED MODULE: ./Util/Semaphore.ts

class AsyncWaitQueue {
    constructor() {
        // Code from StephenCleary https://gist.github.com/StephenCleary/ba50b2da419c03b9cba1d20cb4654d5e
        this._queue = [];
    }
    get length() {
        return this._queue.length;
    }
    enqueue() {
        const future = new Future();
        this._queue.push(future);
        return future.promise;
    }
    dequeue(value) {
        const future = this._queue.shift();
        future.resolve(value);
    }
}
/**
 * Semaphore allows you to limit the amount of async calls happening between `enter()` and `exit()`
 *
 * This can be useful when limiting the number of http calls, browser api calls, etc either for performance or to work
 * around browser limitations like max Image.decode() calls in chromium being 256.
 */
class Semaphore {
    constructor(_count) {
        this._count = _count;
        this._waitQueue = new AsyncWaitQueue();
    }
    get count() {
        return this._count;
    }
    get waiting() {
        return this._waitQueue.length;
    }
    async enter() {
        if (this._count !== 0) {
            this._count--;
            return Promise.resolve();
        }
        return this._waitQueue.enqueue();
    }
    exit(count = 1) {
        if (count === 0) {
            return;
        }
        while (count !== 0 && this._waitQueue.length !== 0) {
            this._waitQueue.dequeue(null);
            count--;
        }
        this._count += count;
    }
}

;// CONCATENATED MODULE: ./index.ts
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.27.0";

polyfill();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.






























// ex.Events namespace


// ex.Input namespace




// ex.Util namespaces
















// ex.Deprecated
// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';

})();

var __webpack_exports__ActionContext = __webpack_exports__.fWn;
var __webpack_exports__ActionQueue = __webpack_exports__.Ia8;
var __webpack_exports__ActionSequence = __webpack_exports__.rqv;
var __webpack_exports__ActionsComponent = __webpack_exports__.hLI;
var __webpack_exports__ActionsSystem = __webpack_exports__.yyv;
var __webpack_exports__ActivateEvent = __webpack_exports__.tX5;
var __webpack_exports__Actor = __webpack_exports__.vtX;
var __webpack_exports__AddedComponent = __webpack_exports__.r7K;
var __webpack_exports__AddedEntity = __webpack_exports__.lCh;
var __webpack_exports__AffineMatrix = __webpack_exports__.cE4;
var __webpack_exports__Animation = __webpack_exports__.fwF;
var __webpack_exports__AnimationDirection = __webpack_exports__.sce;
var __webpack_exports__AnimationStrategy = __webpack_exports__._c7;
var __webpack_exports__ArcadeSolver = __webpack_exports__.KUs;
var __webpack_exports__AudioContextFactory = __webpack_exports__.Ajp;
var __webpack_exports__Axis = __webpack_exports__.RDh;
var __webpack_exports__BaseAlign = __webpack_exports__._H9;
var __webpack_exports__Blink = __webpack_exports__.mxs;
var __webpack_exports__BodyComponent = __webpack_exports__.OmD;
var __webpack_exports__BoundingBox = __webpack_exports__.kBf;
var __webpack_exports__BroadphaseStrategy = __webpack_exports__.C4F;
var __webpack_exports__BrowserComponent = __webpack_exports__.NQt;
var __webpack_exports__BrowserEvents = __webpack_exports__.JjN;
var __webpack_exports__Camera = __webpack_exports__.V1s;
var __webpack_exports__Canvas = __webpack_exports__.Xz7;
var __webpack_exports__Circle = __webpack_exports__.Cdc;
var __webpack_exports__CircleCollider = __webpack_exports__.FKn;
var __webpack_exports__Class = __webpack_exports__.wTW;
var __webpack_exports__Clock = __webpack_exports__.SUY;
var __webpack_exports__ClosestLine = __webpack_exports__.ab2;
var __webpack_exports__ClosestLineJumpTable = __webpack_exports__.GfZ;
var __webpack_exports__Collider = __webpack_exports__.YMS;
var __webpack_exports__ColliderComponent = __webpack_exports__.oyv;
var __webpack_exports__CollisionContact = __webpack_exports__.aUb;
var __webpack_exports__CollisionEndEvent = __webpack_exports__.SdD;
var __webpack_exports__CollisionGroup = __webpack_exports__.JUv;
var __webpack_exports__CollisionGroupManager = __webpack_exports__.jEj;
var __webpack_exports__CollisionJumpTable = __webpack_exports__.TFq;
var __webpack_exports__CollisionPostSolveEvent = __webpack_exports__.HDU;
var __webpack_exports__CollisionPreSolveEvent = __webpack_exports__.R_y;
var __webpack_exports__CollisionResolutionStrategy = __webpack_exports__.ydN;
var __webpack_exports__CollisionStartEvent = __webpack_exports__.t50;
var __webpack_exports__CollisionSystem = __webpack_exports__.s$$;
var __webpack_exports__CollisionType = __webpack_exports__.v2G;
var __webpack_exports__Color = __webpack_exports__.Ilk;
var __webpack_exports__ColorBlindFlags = __webpack_exports__.s9i;
var __webpack_exports__ColorBlindnessMode = __webpack_exports__.dxL;
var __webpack_exports__ColorBlindnessPostProcessor = __webpack_exports__.LLX;
var __webpack_exports__Component = __webpack_exports__.wA2;
var __webpack_exports__CompositeCollider = __webpack_exports__.R_p;
var __webpack_exports__Configurable = __webpack_exports__.IQ$;
var __webpack_exports__ConsoleAppender = __webpack_exports__.I5F;
var __webpack_exports__ContactConstraintPoint = __webpack_exports__.X8$;
var __webpack_exports__ContactEndEvent = __webpack_exports__.FR6;
var __webpack_exports__ContactStartEvent = __webpack_exports__.U8o;
var __webpack_exports__CoordPlane = __webpack_exports__.kbG;
var __webpack_exports__DeactivateEvent = __webpack_exports__.iS_;
var __webpack_exports__Debug = __webpack_exports__.cGG;
var __webpack_exports__DebugGraphicsComponent = __webpack_exports__.RPN;
var __webpack_exports__DebugSystem = __webpack_exports__.skb;
var __webpack_exports__DebugText = __webpack_exports__.SLU;
var __webpack_exports__DegreeOfFreedom = __webpack_exports__.RdJ;
var __webpack_exports__Delay = __webpack_exports__.cNu;
var __webpack_exports__Detector = __webpack_exports__.gU7;
var __webpack_exports__Die = __webpack_exports__.LSk;
var __webpack_exports__Direction = __webpack_exports__.Nmp;
var __webpack_exports__DisplayMode = __webpack_exports__.d1Y;
var __webpack_exports__DynamicTree = __webpack_exports__.xrL;
var __webpack_exports__DynamicTreeCollisionProcessor = __webpack_exports__.sRW;
var __webpack_exports__EX_VERSION = __webpack_exports__.cmV;
var __webpack_exports__EaseBy = __webpack_exports__.qWz;
var __webpack_exports__EaseTo = __webpack_exports__.N0Q;
var __webpack_exports__EasingFunctions = __webpack_exports__.q8b;
var __webpack_exports__EdgeCollider = __webpack_exports__.ynB;
var __webpack_exports__ElasticToActorStrategy = __webpack_exports__.jT9;
var __webpack_exports__EmitterType = __webpack_exports__.wAz;
var __webpack_exports__Engine = __webpack_exports__.D4V;
var __webpack_exports__EnterTriggerEvent = __webpack_exports__.N6H;
var __webpack_exports__EnterViewPortEvent = __webpack_exports__.W1A;
var __webpack_exports__Entity = __webpack_exports__.JHW;
var __webpack_exports__EntityManager = __webpack_exports__.v2K;
var __webpack_exports__EventDispatcher = __webpack_exports__.pBf;
var __webpack_exports__EventTypes = __webpack_exports__.GMl;
var __webpack_exports__Events = __webpack_exports__.zW2;
var __webpack_exports__ExResponse = __webpack_exports__.B0K;
var __webpack_exports__ExcaliburGraphicsContext2DCanvas = __webpack_exports__.Nv7;
var __webpack_exports__ExcaliburGraphicsContextWebGL = __webpack_exports__.C_p;
var __webpack_exports__ExcaliburWebGLContextAccessor = __webpack_exports__.iqw;
var __webpack_exports__ExitTriggerEvent = __webpack_exports__.MUA;
var __webpack_exports__ExitViewPortEvent = __webpack_exports__.xqU;
var __webpack_exports__Fade = __webpack_exports__.pTp;
var __webpack_exports__Flags = __webpack_exports__.vUK;
var __webpack_exports__Follow = __webpack_exports__.j9l;
var __webpack_exports__Font = __webpack_exports__.Zxw;
var __webpack_exports__FontStyle = __webpack_exports__.Hdx;
var __webpack_exports__FontUnit = __webpack_exports__.Z$d;
var __webpack_exports__FpsSampler = __webpack_exports__.iqV;
var __webpack_exports__FrameStats = __webpack_exports__.o$7;
var __webpack_exports__Future = __webpack_exports__.olM;
var __webpack_exports__GameEvent = __webpack_exports__.Zm$;
var __webpack_exports__GameStartEvent = __webpack_exports__.$QH;
var __webpack_exports__GameStopEvent = __webpack_exports__.i78;
var __webpack_exports__GamepadAxisEvent = __webpack_exports__.h6u;
var __webpack_exports__GamepadButtonEvent = __webpack_exports__.hts;
var __webpack_exports__GamepadConnectEvent = __webpack_exports__.j88;
var __webpack_exports__GamepadDisconnectEvent = __webpack_exports__.VME;
var __webpack_exports__Gif = __webpack_exports__.nt;
var __webpack_exports__GlobalCoordinates = __webpack_exports__.Ukr;
var __webpack_exports__Graphic = __webpack_exports__.zsu;
var __webpack_exports__GraphicsComponent = __webpack_exports__.oA6;
var __webpack_exports__GraphicsGroup = __webpack_exports__.TVh;
var __webpack_exports__GraphicsLayer = __webpack_exports__.TwZ;
var __webpack_exports__GraphicsLayers = __webpack_exports__.GTT;
var __webpack_exports__GraphicsSystem = __webpack_exports__.xxj;
var __webpack_exports__HiddenEvent = __webpack_exports__.XdK;
var __webpack_exports__ImageFiltering = __webpack_exports__.Jmb;
var __webpack_exports__ImageSource = __webpack_exports__.cXo;
var __webpack_exports__InitializeEvent = __webpack_exports__.Dm5;
var __webpack_exports__Input = __webpack_exports__.IIB;
var __webpack_exports__Integrator = __webpack_exports__.zI0;
var __webpack_exports__IsometricEntityComponent = __webpack_exports__.LYD;
var __webpack_exports__IsometricEntitySystem = __webpack_exports__.cEG;
var __webpack_exports__IsometricMap = __webpack_exports__.SEl;
var __webpack_exports__IsometricTile = __webpack_exports__.t9V;
var __webpack_exports__KillEvent = __webpack_exports__.SKZ;
var __webpack_exports__Label = __webpack_exports__.__J;
var __webpack_exports__LimitCameraBoundsStrategy = __webpack_exports__.RI$;
var __webpack_exports__Line = __webpack_exports__.x12;
var __webpack_exports__LineSegment = __webpack_exports__.ccz;
var __webpack_exports__Loader = __webpack_exports__.aNw;
var __webpack_exports__LockCameraToActorAxisStrategy = __webpack_exports__.xwn;
var __webpack_exports__LockCameraToActorStrategy = __webpack_exports__.dNK;
var __webpack_exports__LogLevel = __webpack_exports__.ini;
var __webpack_exports__Logger = __webpack_exports__.YdH;
var __webpack_exports__Matrix = __webpack_exports__.y3G;
var __webpack_exports__MatrixLocations = __webpack_exports__.l57;
var __webpack_exports__MediaEvent = __webpack_exports__.xn0;
var __webpack_exports__Meet = __webpack_exports__.t2V;
var __webpack_exports__MotionComponent = __webpack_exports__.uxB;
var __webpack_exports__MotionSystem = __webpack_exports__.cpd;
var __webpack_exports__MoveBy = __webpack_exports__.fiy;
var __webpack_exports__MoveTo = __webpack_exports__.$XZ;
var __webpack_exports__NativeSoundEvent = __webpack_exports__.uqK;
var __webpack_exports__NativeSoundProcessedEvent = __webpack_exports__.STE;
var __webpack_exports__Observable = __webpack_exports__.y$z;
var __webpack_exports__OffscreenSystem = __webpack_exports__.mAD;
var __webpack_exports__Pair = __webpack_exports__.sOq;
var __webpack_exports__ParallaxComponent = __webpack_exports__.hUw;
var __webpack_exports__ParallelActions = __webpack_exports__._0G;
var __webpack_exports__ParseGif = __webpack_exports__.Sqs;
var __webpack_exports__Particle = __webpack_exports__.hpZ;
var __webpack_exports__ParticleEmitter = __webpack_exports__.Vol;
var __webpack_exports__Physics = __webpack_exports__.wIZ;
var __webpack_exports__PhysicsStats = __webpack_exports__.cBi;
var __webpack_exports__PointerComponent = __webpack_exports__.RFv;
var __webpack_exports__PointerSystem = __webpack_exports__.kfC;
var __webpack_exports__Polygon = __webpack_exports__.mgq;
var __webpack_exports__PolygonCollider = __webpack_exports__.YVA;
var __webpack_exports__Pool = __webpack_exports__.Kgp;
var __webpack_exports__PostCollisionEvent = __webpack_exports__.HH$;
var __webpack_exports__PostDebugDrawEvent = __webpack_exports__.M_d;
var __webpack_exports__PostDrawEvent = __webpack_exports__.rgh;
var __webpack_exports__PostFrameEvent = __webpack_exports__.Ra6;
var __webpack_exports__PostKillEvent = __webpack_exports__.KhR;
var __webpack_exports__PostUpdateEvent = __webpack_exports__.BS5;
var __webpack_exports__PreCollisionEvent = __webpack_exports__.xhz;
var __webpack_exports__PreDebugDrawEvent = __webpack_exports__.xOq;
var __webpack_exports__PreDrawEvent = __webpack_exports__.a9j;
var __webpack_exports__PreFrameEvent = __webpack_exports__.bHk;
var __webpack_exports__PreKillEvent = __webpack_exports__.CgK;
var __webpack_exports__PreUpdateEvent = __webpack_exports__.cuY;
var __webpack_exports__Projection = __webpack_exports__.kvE;
var __webpack_exports__QuadIndexBuffer = __webpack_exports__.SBu;
var __webpack_exports__Query = __webpack_exports__.AE_;
var __webpack_exports__QueryManager = __webpack_exports__.ctO;
var __webpack_exports__RadiusAroundActorStrategy = __webpack_exports__.OLH;
var __webpack_exports__Random = __webpack_exports__.kky;
var __webpack_exports__Raster = __webpack_exports__.nSF;
var __webpack_exports__Ray = __webpack_exports__.zHn;
var __webpack_exports__RealisticSolver = __webpack_exports__.zwx;
var __webpack_exports__Rectangle = __webpack_exports__.AeJ;
var __webpack_exports__RemovedComponent = __webpack_exports__.hLz;
var __webpack_exports__RemovedEntity = __webpack_exports__.D9g;
var __webpack_exports__Repeat = __webpack_exports__.wA;
var __webpack_exports__RepeatForever = __webpack_exports__.jhr;
var __webpack_exports__Resolution = __webpack_exports__.GVs;
var __webpack_exports__Resource = __webpack_exports__._zO;
var __webpack_exports__RotateBy = __webpack_exports__.w6$;
var __webpack_exports__RotateTo = __webpack_exports__.mhV;
var __webpack_exports__RotationType = __webpack_exports__.MOD;
var __webpack_exports__ScaleBy = __webpack_exports__.kwd;
var __webpack_exports__ScaleTo = __webpack_exports__.Lmr;
var __webpack_exports__Scene = __webpack_exports__.xsS;
var __webpack_exports__Screen = __webpack_exports__.lLr;
var __webpack_exports__ScreenAppender = __webpack_exports__.Z$r;
var __webpack_exports__ScreenElement = __webpack_exports__.IXb;
var __webpack_exports__ScreenShader = __webpack_exports__.SGH;
var __webpack_exports__ScrollPreventionMode = __webpack_exports__.SMj;
var __webpack_exports__Semaphore = __webpack_exports__.L34;
var __webpack_exports__Shader = __webpack_exports__.exe;
var __webpack_exports__Shape = __webpack_exports__.bnF;
var __webpack_exports__Side = __webpack_exports__.MFA;
var __webpack_exports__Sound = __webpack_exports__.$uU;
var __webpack_exports__Sprite = __webpack_exports__.jyi;
var __webpack_exports__SpriteFont = __webpack_exports__.E03;
var __webpack_exports__SpriteSheet = __webpack_exports__.V6q;
var __webpack_exports__StandardClock = __webpack_exports__.rg2;
var __webpack_exports__StateMachine = __webpack_exports__.DVW;
var __webpack_exports__StrategyContainer = __webpack_exports__.nVo;
var __webpack_exports__Stream = __webpack_exports__.F6N;
var __webpack_exports__System = __webpack_exports__.xP7;
var __webpack_exports__SystemManager = __webpack_exports__.Odq;
var __webpack_exports__SystemType = __webpack_exports__.Zif;
var __webpack_exports__TagComponent = __webpack_exports__.ZGJ;
var __webpack_exports__TestClock = __webpack_exports__.MJk;
var __webpack_exports__Text = __webpack_exports__.xvT;
var __webpack_exports__TextAlign = __webpack_exports__.PHM;
var __webpack_exports__TextureLoader = __webpack_exports__.dpR;
var __webpack_exports__Tile = __webpack_exports__.n9L;
var __webpack_exports__TileMap = __webpack_exports__.KwO;
var __webpack_exports__Timer = __webpack_exports__.B7y;
var __webpack_exports__Toaster = __webpack_exports__.x7r;
var __webpack_exports__Transform = __webpack_exports__.wx7;
var __webpack_exports__TransformComponent = __webpack_exports__.Uvn;
var __webpack_exports__TreeNode = __webpack_exports__.OFT;
var __webpack_exports__Trigger = __webpack_exports__.xzN;
var __webpack_exports__TwoPI = __webpack_exports__.M5Z;
var __webpack_exports__Util = __webpack_exports__.ZrN;
var __webpack_exports__Vector = __webpack_exports__.OWs;
var __webpack_exports__VectorView = __webpack_exports__.dF9;
var __webpack_exports__VertexBuffer = __webpack_exports__.oZy;
var __webpack_exports__VertexLayout = __webpack_exports__.rD2;
var __webpack_exports__VisibleEvent = __webpack_exports__.VHo;
var __webpack_exports__WebAudio = __webpack_exports__.ohE;
var __webpack_exports__WebAudioInstance = __webpack_exports__.R$E;
var __webpack_exports__World = __webpack_exports__.q3I;
var __webpack_exports__canonicalizeAngle = __webpack_exports__.Pab;
var __webpack_exports__clamp = __webpack_exports__.uZ5;
var __webpack_exports__createId = __webpack_exports__.McK;
var __webpack_exports__frac = __webpack_exports__.F9c;
var __webpack_exports__hasGraphicsTick = __webpack_exports__.k0b;
var __webpack_exports__hasOnInitialize = __webpack_exports__.hnT;
var __webpack_exports__hasOnPostUpdate = __webpack_exports__.RSJ;
var __webpack_exports__hasOnPreUpdate = __webpack_exports__.Mku;
var __webpack_exports__hasPostDraw = __webpack_exports__.h90;
var __webpack_exports__hasPreDraw = __webpack_exports__.rms;
var __webpack_exports__has_initialize = __webpack_exports__.ErP;
var __webpack_exports__has_postupdate = __webpack_exports__.aVg;
var __webpack_exports__has_preupdate = __webpack_exports__.lPc;
var __webpack_exports__isAddedComponent = __webpack_exports__.Z8E;
var __webpack_exports__isAddedSystemEntity = __webpack_exports__._N2;
var __webpack_exports__isRemoveSystemEntity = __webpack_exports__.yFn;
var __webpack_exports__isRemovedComponent = __webpack_exports__.lNv;
var __webpack_exports__isScreenElement = __webpack_exports__.cu9;
var __webpack_exports__maxMessages = __webpack_exports__.MZQ;
var __webpack_exports__obsolete = __webpack_exports__.FUM;
var __webpack_exports__pixelSnapEpsilon = __webpack_exports__.BxR;
var __webpack_exports__randomInRange = __webpack_exports__.vdf;
var __webpack_exports__randomIntInRange = __webpack_exports__.iaL;
var __webpack_exports__range = __webpack_exports__.w6H;
var __webpack_exports__resetObsoleteCounter = __webpack_exports__.Q4c;
var __webpack_exports__sign = __webpack_exports__.Xxe;
var __webpack_exports__toDegrees = __webpack_exports__.Uxb;
var __webpack_exports__toRadians = __webpack_exports__.Yr5;
var __webpack_exports__vec = __webpack_exports__.Bhw;
var __webpack_exports__webgl = __webpack_exports__.yOA;


//# sourceMappingURL=excalibur.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZXhjYWxpYnVyX2J1aWxkX2VzbV9leGNhbGlidXJfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDhCQUFtQjs7QUFFN0QsOEJBQW1CO0FBQ25CLGtCQUFrQiw4QkFBbUI7O0FBRXJDOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLDhCQUFtQjs7QUFFN0QsOEJBQW1CO0FBQ25CLFdBQVcsOEJBQW1COztBQUU5Qjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyw4QkFBbUI7O0FBRTdELGlCQUFpQiw4QkFBbUI7QUFDcEMsa0JBQWtCLDhCQUFtQjs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELGVBQWUsK0JBQW1COztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxzQkFBc0IsK0JBQW1CO0FBQ3pDLHNCQUFzQiwrQkFBbUI7QUFDekMsd0JBQXdCLCtCQUFtQjs7QUFFM0Msc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7O0FBRzdELFlBQVksK0JBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELHNCQUFzQiwrQkFBbUI7QUFDekMsd0JBQXdCLCtCQUFtQjtBQUMzQyxxQkFBcUIsK0JBQW1COztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxpQkFBaUIsK0JBQW1COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0Qsa0JBQWtCLCtCQUFtQjs7QUFFckMsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELDRCQUE0QiwrQkFBbUI7QUFDL0MsaUJBQWlCLCtCQUFtQjtBQUNwQyxpQkFBaUIsK0JBQW1CO0FBQ3BDLHNCQUFzQiwrQkFBbUI7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsbUJBQW1COztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxhQUFhLCtCQUFtQjtBQUNoQyxjQUFjLCtCQUFtQjtBQUNqQyxxQ0FBcUMsK0JBQW1CO0FBQ3hELDJCQUEyQiwrQkFBbUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxrQkFBa0IsK0JBQW1CO0FBQ3JDLDJCQUEyQiwrQkFBbUI7QUFDOUMsK0JBQStCLCtCQUFtQjs7QUFFbEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7O0FBRzdELG9CQUFvQiwrQkFBbUI7QUFDdkMsMkJBQTJCLCtCQUFtQjtBQUM5QywrQkFBK0IsK0JBQW1COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsaUJBQWlCLCtCQUFtQjtBQUNwQywyQkFBMkIsK0JBQW1CO0FBQzlDLGtCQUFrQiwrQkFBbUI7QUFDckMsMkJBQTJCLCtCQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsYUFBYSwrQkFBbUI7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxrREFBa0Q7QUFDcEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7O0FBRzdELGtCQUFrQiwrQkFBbUI7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQzs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFNBQVMsZ0NBQW1COztBQUU1Qjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7O0FBRXBDOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsZ0JBQWdCLGdDQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZ0JBQWdCLGdDQUFtQjs7QUFFbkM7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxrQkFBa0IsZ0NBQW1COztBQUVyQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGdDQUFnQyxnQ0FBbUI7QUFDbkQsa0NBQWtDLGdDQUFtQjtBQUNyRCxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLDJCQUEyQixnQ0FBbUI7QUFDOUMsZ0NBQWdDLGdDQUFtQjtBQUNuRCxlQUFlLGdDQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOERBQThEO0FBQzlELElBQUk7QUFDSixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1COztBQUUvQjtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1COztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGFBQWEsZ0NBQW1COztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1COztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsaUJBQWlCLGdDQUFtQjs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQW1CLGtCQUFrQixnQ0FBbUI7QUFDdkU7QUFDQSxpQkFBaUIsY0FBYzs7O0FBRy9CLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGVBQWUsZ0NBQW1COztBQUVsQyxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxZQUFZLGdDQUFtQjtBQUMvQixvQkFBb0IsZ0NBQW1COztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0gsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsWUFBWSxnQ0FBbUI7QUFDL0IsY0FBYyxnQ0FBbUI7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7OztBQUdGLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGlCQUFpQixnQ0FBbUI7QUFDcEMsWUFBWSxnQ0FBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELHNCQUFzQixnQ0FBbUI7QUFDekMsYUFBYSxnQ0FBbUI7QUFDaEMsa0JBQWtCLGdDQUFtQjtBQUNyQyxlQUFlLGdDQUFtQjtBQUNsQyxrQ0FBa0MsZ0NBQW1CO0FBQ3JELGFBQWEsZ0NBQW1CO0FBQ2hDLGFBQWEsZ0NBQW1CO0FBQ2hDLGdCQUFnQixnQ0FBbUI7QUFDbkMsaUJBQWlCLGdDQUFtQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1CO0FBQy9CLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsaUJBQWlCLGdDQUFtQjtBQUNwQyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLHdCQUF3QixnQ0FBbUI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxZQUFZLGdDQUFtQjtBQUMvQixpQkFBaUIsZ0NBQW1CO0FBQ3BDLGFBQWEsZ0NBQW1CO0FBQ2hDLGtCQUFrQixnQ0FBbUI7QUFDckMsa0NBQWtDLGdDQUFtQjtBQUNyRCxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLDBCQUEwQixnQ0FBbUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGFBQWEsY0FBYyxVQUFVO0FBQzNFLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBLE1BQU07QUFDTixJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0EsaUJBQWlCLGdDQUFtQjtBQUNwQyxZQUFZLGdDQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxpQkFBaUIsZ0NBQW1CO0FBQ3BDLG9CQUFvQixnQ0FBbUI7O0FBRXZDOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxxQkFBcUIsZ0NBQW1CO0FBQ3hDLDhCQUE4QixnQ0FBbUI7QUFDakQsZUFBZSxnQ0FBbUI7QUFDbEMsb0JBQW9CLGdDQUFtQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxXQUFXLGdDQUFtQjtBQUM5QixpQ0FBaUMsZ0NBQW1CO0FBQ3BELCtCQUErQixnQ0FBbUI7QUFDbEQsc0JBQXNCLGdDQUFtQjtBQUN6QyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLGFBQWEsZ0NBQW1CO0FBQ2hDLHFCQUFxQixnQ0FBbUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QseUJBQXlCLGdDQUFtQjtBQUM1QyxrQkFBa0IsZ0NBQW1COztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjs7QUFFckMsK0JBQStCOzs7QUFHL0IsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsYUFBYSxnQ0FBbUI7QUFDaEMsc0JBQXNCLGdDQUFtQjtBQUN6QyxlQUFlLGdDQUFtQjtBQUNsQyxpQkFBaUIsZ0NBQW1COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCx5QkFBeUIsZ0NBQW1CO0FBQzVDLGtCQUFrQixnQ0FBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxNQUFNOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFdBQVcsZ0NBQW1CO0FBQzlCLGlCQUFpQixnQ0FBbUI7QUFDcEMsZUFBZSxnQ0FBbUI7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsa0JBQWtCLGdDQUFtQjtBQUNyQyxnQ0FBZ0MsZ0NBQW1CO0FBQ25ELGtDQUFrQyxnQ0FBbUI7QUFDckQsZUFBZSxnQ0FBbUI7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1COztBQUVoQzs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLFVBQVUsZ0NBQW1COztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQywyQkFBMkIsZ0NBQW1COztBQUU5QztBQUNBLDZEQUE2RDs7QUFFN0Q7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxjQUFjLGdDQUFtQjtBQUNqQyxZQUFZLGdDQUFtQjs7QUFFL0I7QUFDQSxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsMEJBQTBCLGdDQUFtQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Q7QUFDQSxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLDZCQUE2QixnQ0FBbUI7O0FBRWhEO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELDBCQUEwQixnQ0FBbUI7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELDZCQUE2QixnQ0FBbUI7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxXQUFXLGdDQUFtQjtBQUM5QixlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQyxnQkFBZ0IsZ0NBQW1CO0FBQ25DLDBCQUEwQixnQ0FBbUI7QUFDN0Msc0JBQXNCLGdDQUFtQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGVBQWUsZ0NBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxzQkFBc0IsZ0NBQW1COztBQUV6QztBQUNBOztBQUVBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsY0FBYyxnQ0FBbUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RDtBQUNBLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsWUFBWSxnQ0FBbUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsYUFBYSxnQ0FBbUI7QUFDaEMsYUFBYSxnQ0FBbUI7QUFDaEMsVUFBVSxnQ0FBbUI7QUFDN0Isb0JBQW9CLGdDQUFtQjtBQUN2Qyx3QkFBd0IsZ0NBQW1COztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwyREFBMkQsZ0NBQW1COzs7QUFHOUUsUUFBUSxnQ0FBbUI7QUFDM0Isa0JBQWtCLGdDQUFtQjtBQUNyQyxnQkFBZ0IsZ0NBQW1CO0FBQ25DLGVBQWUsZ0NBQW1CO0FBQ2xDLHdCQUF3QixnQ0FBbUI7QUFDM0MsNEJBQTRCLGdDQUFtQjtBQUMvQyxlQUFlLGdDQUFtQjtBQUNsQyxZQUFZLGdDQUFtQjtBQUMvQixtQkFBbUIsZ0NBQW1CO0FBQ3RDLDBCQUEwQixnQ0FBbUI7QUFDN0MsU0FBUyxnQ0FBbUI7QUFDNUIsaUJBQWlCLGdDQUFtQjtBQUNwQyxTQUFTLGdDQUFtQjtBQUM1QixhQUFhLGdDQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JELG1DQUFtQztBQUNuQztBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQSw4QkFBOEIsbUJBQW1COztBQUVqRCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBOEM7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDJEQUEyRCxnQ0FBbUI7O0FBRTlFLFFBQVEsZ0NBQW1CO0FBQzNCLGVBQWUsZ0NBQW1CO0FBQ2xDLGlCQUFpQixnQ0FBbUI7QUFDcEMsWUFBWSxnQ0FBbUI7O0FBRS9CLDhDQUE4QyxnQkFBZ0I7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJLDJEQUEyRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EscUNBQXFDLGdDQUFtQjs7QUFFeEQscUJBQXFCLGdDQUFtQjtBQUN4QztBQUNBLHNCQUFzQjtBQUN0Qiw0R0FBNEcsZ0NBQW1CO0FBQy9ILGlJQUFpSSxnQ0FBbUI7QUFDcEoscUdBQXFHLGdDQUFtQjtBQUN4SCwwSEFBMEgsZ0NBQW1CO0FBQzdJOzs7QUFHQTtBQUNBO0FBQ0EsbUdBQW1HLDRCQUE0Qix5QkFBeUIsbUJBQW1CLHlCQUF5QixtQkFBbUIsMEJBQTBCLDRCQUE0QixrQ0FBa0MsdUNBQXVDLGdCQUFnQiw0QkFBNEIsMEJBQTBCLHFCQUFxQiw4QkFBOEIsc0JBQXNCLDBCQUEwQixxQkFBcUIsc0JBQXNCLHlCQUF5QixxRUFBcUUsK0JBQStCLDRCQUE0Qiw0REFBNEQsMEZBQTBGLHNFQUFzRSwwRUFBMEUsaUVBQWlFLEtBQUsscUNBQXFDLG9CQUFvQixLQUFLLHVDQUF1Qyx5QkFBeUIsa0JBQWtCLHdCQUF3Qiw4REFBOEQsaUJBQWlCLGdCQUFnQixlQUFlLGdCQUFnQixLQUFLLHNDQUFzQyx5QkFBeUIsa0JBQWtCLHdCQUF3QixpQkFBaUIsZ0JBQWdCLDBCQUEwQixrQkFBa0IsbUJBQW1CLEtBQUsscUVBQXFFLDBCQUEwQixLQUFLLHFDQUFxQyw4QkFBOEIsMkJBQTJCLEtBQUssc0NBQXNDLDZCQUE2QixLQUFLLDRDQUE0QyxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyx1RUFBdUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssNkZBQTZGLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDJFQUEyRSxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyxxRUFBcUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssV0FBVyxxRkFBcUYsTUFBTSxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsTUFBTSxPQUFPLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsY0FBYyx5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsYUFBYSxPQUFPLE9BQU8sTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksV0FBVyxVQUFVLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLGtGQUFrRiw0QkFBNEIseUJBQXlCLG1CQUFtQix5QkFBeUIsbUJBQW1CLDBCQUEwQiw0QkFBNEIsa0NBQWtDLHVDQUF1QyxnQkFBZ0IsNEJBQTRCLDBCQUEwQixxQkFBcUIsOEJBQThCLHNCQUFzQiwwQkFBMEIscUJBQXFCLHNCQUFzQix5QkFBeUIscUVBQXFFLCtCQUErQiw0QkFBNEIsNERBQTRELDBGQUEwRixzRUFBc0UsMEVBQTBFLGlFQUFpRSxLQUFLLHFDQUFxQyxvQkFBb0IsS0FBSyx1Q0FBdUMseUJBQXlCLGtCQUFrQix3QkFBd0IsOERBQThELGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsS0FBSyxzQ0FBc0MseUJBQXlCLGtCQUFrQix3QkFBd0IsaUJBQWlCLGdCQUFnQiwwQkFBMEIsa0JBQWtCLG1CQUFtQixLQUFLLHFFQUFxRSwwQkFBMEIsS0FBSyxxQ0FBcUMsOEJBQThCLDJCQUEyQixLQUFLLHNDQUFzQyw2QkFBNkIsS0FBSyw0Q0FBNEMsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssdUVBQXVFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDZGQUE2RixZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSywyRUFBMkUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUsscUVBQXFFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLHVCQUF1QjtBQUNobk07QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLHFDQUFxQyxnQ0FBbUI7O0FBRXhELHFCQUFxQixnQ0FBbUI7QUFDeEM7QUFDQSxzQkFBc0I7QUFDdEIsNEdBQTRHLGdDQUFtQjtBQUMvSCxpSUFBaUksZ0NBQW1CO0FBQ3BKLHFHQUFxRyxnQ0FBbUI7QUFDeEgsMEhBQTBILGdDQUFtQjtBQUM3STs7O0FBR0E7QUFDQTtBQUNBLG1FQUFtRSx5QkFBeUIsZ0JBQWdCLHFCQUFxQixnQkFBZ0IsYUFBYSxLQUFLLDJCQUEyQixpQkFBaUIseUJBQXlCLG9CQUFvQixxQ0FBcUMsNEJBQTRCLHNCQUFzQixzQkFBc0IsOEJBQThCLHlCQUF5QixnQ0FBZ0MsMkNBQTJDLEtBQUssc0NBQXNDLDZCQUE2QixLQUFLLE9BQU8sK0VBQStFLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxjQUFjLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsUUFBUSxLQUFLLFlBQVksbURBQW1ELHlCQUF5QixnQkFBZ0IscUJBQXFCLGdCQUFnQixhQUFhLEtBQUssMkJBQTJCLGlCQUFpQix5QkFBeUIsb0JBQW9CLHFDQUFxQyw0QkFBNEIsc0JBQXNCLHNCQUFzQiw4QkFBOEIseUJBQXlCLGdDQUFnQywyQ0FBMkMsS0FBSyxzQ0FBc0MsNkJBQTZCLEtBQUssbUJBQW1CO0FBQ3g2QztBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVAsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFtQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFtQixhQUFhLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQW1CO0FBQzdCO0FBQ0EsZUFBZSxnQ0FBbUIsd0JBQXdCLGdDQUFtQjtBQUM3RSxtREFBbUQsd0NBQXdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdDQUFtQjtBQUNuQixnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdDQUFtQjtBQUNuQixnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdDQUFtQjtBQUNuQixnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxnQ0FBbUI7QUFDOUI7QUFDQSxXQUFXLGdDQUFtQjtBQUM5QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQixJQUFJLHNCQUFzQjtBQUN2RTtBQUNBLG1CQUFtQixPQUFPLElBQUksT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzNDO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9COztBQUVyQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjO0FBQ2pFLEdBQUcsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYztBQUNqRSxHQUFHLGNBQWMsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGNBQWM7QUFDbEUsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEUsb0RBQW9ELGdCQUFnQjtBQUNwRSxvREFBb0QsZ0JBQWdCO0FBQ3BFLG9EQUFvRCxnQkFBZ0I7QUFDcEUsMERBQTBELFVBQVU7QUFDcEUsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGFBQWE7QUFDaEQsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLHVGQUF1RjtBQUN2RixtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7O0FBRXpDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFLG9CQUFvQixnQ0FBZ0MsR0FBRyxnQ0FBZ0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsS0FBSztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVUsZ0JBQWdCLGNBQWM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxFQUFFLElBQUksRUFBRSxRQUFRLEdBQUcsMEJBQTBCLGlCQUFpQjtBQUN2STtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxHQUFHLDBCQUEwQixjQUFjO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlLGdEQUFnRCxhQUFhLHlCQUF5QjtBQUNySCxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLHdCQUF3QixVQUFVO0FBQ2xDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTyw0QkFBNEIsU0FBUztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxPQUFPLGNBQWMsWUFBWTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsaUVBQWlFO0FBQ2pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCx5RkFBeUYsb0JBQW9CLDhCQUE4Qiw4QkFBOEIscUJBQXFCLDZIQUE2SCw0REFBNEQsS0FBSztBQUM1WCxDQUFDO0FBQ0QsZ0dBQWdHLHlDQUF5QywyQkFBMkIscUJBQXFCLDBCQUEwQixLQUFLO0FBQ3hOLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksR0FBRyxLQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLEdBQUcsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsYUFBYSxVQUFVLEVBQUUsK0NBQStDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLDBCQUEwQixNQUFNLElBQUksU0FBUyxFQUFFLDJDQUEyQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLE9BQU8sYUFBYTtBQUN0RiwrREFBK0QsMEJBQTBCO0FBQ3pGO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYSxJQUFJLGFBQWE7QUFDMUcsMERBQTBELFlBQVksTUFBTSwwQkFBMEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQkFBb0I7QUFDaEYsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCwwRkFBMEYsb0JBQW9CLG9CQUFvQiwwQkFBMEIsMEJBQTBCLHFCQUFxQiwwREFBMEQsa0NBQWtDLHdCQUF3QixLQUFLO0FBQ3BVLENBQUM7QUFDRCxxR0FBcUcseUJBQXlCLDJCQUEyQixxQkFBcUIsOENBQThDLDJDQUEyQyx3QkFBd0IsNEJBQTRCLDREQUE0RCxzRUFBc0UsZ0NBQWdDLHNDQUFzQyx3QkFBd0IsS0FBSztBQUNoaUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsMkZBQTJGLDJCQUEyQix3QkFBd0IscUJBQXFCLCtDQUErQyxvRkFBb0YsS0FBSztBQUMzUyxDQUFDO0FBQ0Qsa0dBQWtHLG1FQUFtRSx1REFBdUQsMkJBQTJCLHFCQUFxQixrREFBa0QsS0FBSztBQUNuVSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsZUFBZSxvQkFBb0IsY0FBYztBQUNwSjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxzR0FBc0csMENBQTBDLHlEQUF5RCxtRkFBbUYseUNBQXlDLHVCQUF1QiwyQkFBMkIscUJBQXFCLDBRQUEwUSwwSkFBMEoscUNBQXFDLGtDQUFrQyxLQUFLO0FBQzUzQixDQUFDO0FBQ0QsaUdBQWlHLDBDQUEwQyx3QkFBd0IsK0NBQStDLHdCQUF3QiwwREFBMEQsa0NBQWtDLHVCQUF1QixvQkFBb0IsOEJBQThCLHFCQUFxQiw2SEFBNkgsMEZBQTBGLHlGQUF5Rix1R0FBdUcsc0RBQXNELEtBQUs7QUFDdDNCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBLGlFQUFpRSxFQUFFLEtBQUs7QUFDeEU7QUFDQTtBQUNBLHlFQUF5RSxFQUFFLEtBQUs7QUFDaEY7QUFDQSx3RUFBd0UsRUFBRSxlQUFlO0FBQ3pGLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCw4R0FBOEcsb0NBQW9DLHdCQUF3QiwrRUFBK0UsOERBQThELHdFQUF3RSxxREFBcUQsMkJBQTJCLHFCQUFxQix3SUFBd0kscUNBQXFDLGtEQUFrRCx1Q0FBdUMsa0RBQWtELHVDQUF1QyxrSEFBa0gsOEJBQThCLFVBQVUsTUFBTSxvQ0FBb0MsU0FBUyxpQ0FBaUMscUNBQXFDLHlFQUF5RSwwRUFBMEUsZ0RBQWdELDRDQUE0QywwSkFBMEosNEVBQTRFLDhEQUE4RCxZQUFZLGdLQUFnSyw0RUFBNEUsOERBQThELFlBQVksMkJBQTJCLHlNQUF5TSw0RUFBNEUsMk5BQTJOLCtGQUErRiwwRkFBMEYsWUFBWSxnREFBZ0QsNENBQTRDLHlDQUF5Qyx5RUFBeUUsbUNBQW1DLDRDQUE0QyxZQUFZLDBFQUEwRSxxRUFBcUUscUNBQXFDLEtBQUs7QUFDN2xHLENBQUM7QUFDRCxxR0FBcUcseUNBQXlDLGtCQUFrQix1QkFBdUIsb0JBQW9CLDBDQUEwQyx3QkFBd0Isd0JBQXdCLHFCQUFxQiw4QkFBOEIsMkJBQTJCLG1DQUFtQyxnQ0FBZ0MsOEJBQThCLHlCQUF5Qiw2SEFBNkgsdURBQXVELGtEQUFrRCxzRkFBc0YsZ0ZBQWdGLG1HQUFtRywrR0FBK0csS0FBSztBQUNobEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELHFHQUFxRyxvQ0FBb0MsbUVBQW1FLDhEQUE4RCx1RUFBdUUseUNBQXlDLDJCQUEyQixxQkFBcUIsd0VBQXdFLCtCQUErQix1Q0FBdUMsbUhBQW1ILG9DQUFvQyx3RUFBd0UsaURBQWlELGtIQUFrSCw0SkFBNEoseUNBQXlDLHVDQUF1QywyQ0FBMkMsMkJBQTJCLHdFQUF3RSxrREFBa0QsOENBQThDLDZCQUE2QixLQUFLO0FBQ3Q3QyxDQUFDO0FBQ0Qsa0dBQWtHLHlDQUF5QyxrQkFBa0IsMENBQTBDLHdCQUF3Qix3QkFBd0IscUJBQXFCLDhCQUE4QiwyQkFBMkIsbUNBQW1DLGdDQUFnQyw4QkFBOEIseUJBQXlCLDZIQUE2SCx1REFBdUQsc0ZBQXNGLGdGQUFnRixtR0FBbUcsK0dBQStHLEtBQUs7QUFDaC9CLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEUsc0RBQXNELGdCQUFnQjtBQUN0RSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGLHdFQUF3RSxnQkFBZ0I7QUFDeEYsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZGQUE2RjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsMENBQTBDO0FBQzFDLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkVBQTZFO0FBQzdGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix3QkFBd0I7QUFDdkg7QUFDQTtBQUNBLDZGQUE2RixZQUFZO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDLDBFQUEwRSxzQkFBc0IsR0FBRyx1QkFBdUIscUJBQXFCLGdCQUFnQjtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxrRUFBa0U7QUFDbEU7QUFDQSxlQUFlLGdDQUFtQjtBQUNsQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVcsMERBQTBELGdCQUFnQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLDZDQUE2QztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLDBEQUEwRDtBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0IsS0FBSyx3QkFBd0IsR0FBRyxVQUFVO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDBCQUEwQjtBQUMxRiwrREFBK0QsMEJBQTBCO0FBQ3pGO0FBQ0E7QUFDQSxnRUFBZ0UseUNBQXlDO0FBQ3pHLCtEQUErRCxnREFBZ0Q7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9DQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQixFQUFFLG1DQUFtQyxFQUFFLHlCQUF5QjtBQUNySCwyQkFBMkIsaUJBQWlCLHNCQUFzQixnQkFBZ0I7QUFDbEYsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Qsa0JBQWtCLE1BQWlDO0FBQ25EO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrRUFBa0U7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsVUFBVTtBQUM5QztBQUNBO0FBQ0EsdUJBQXVCLFVBQVUsR0FBRyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixnQkFBZ0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsZ0JBQWdCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJCQUEyQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyRkFBMkY7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxFQUFFLHlCQUF5QixFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsWUFBWTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFLQUFxSztBQUNyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUVBQXVFLDZCQUE2QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNFQUFzRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRywwQkFBMEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdJQUFnSTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNlJBQTZSLElBQUk7QUFDalQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25IO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUcsSUFBSSw4R0FBOEc7QUFDcEw7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usa0NBQWtDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxnQkFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLG1CQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw2Q0FBNkM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdUJBQXVCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcscUNBQXFDO0FBQ25KO0FBQ0EsaUZBQWlGLGtCQUFrQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxxQ0FBcUM7QUFDL0k7QUFDQSw2RUFBNkUsc0JBQXNCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx1REFBdUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxJQUFJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDs7QUFFakQsQ0FBQztBQUNELHVHQUF1RyxnREFBZ0QsNkVBQTZFLGtEQUFrRCxrREFBa0QsMkJBQTJCLHFCQUFxQiw2Q0FBNkMseUdBQXlHLG9FQUFvRSx1RUFBdUUsK0NBQStDLGNBQWMsY0FBYywyQ0FBMkMscUVBQXFFLHdDQUF3Qyx5Q0FBeUMsUUFBUSx1QkFBdUIsOERBQThELGlEQUFpRCx3Q0FBd0MsUUFBUSx1QkFBdUIsNERBQTRELHdDQUF3QyxtREFBbUQsT0FBTywyREFBMkQsa0dBQWtHLDhFQUE4RSxpRkFBaUYsb0JBQW9CLDRCQUE0Qix1QkFBdUIsOENBQThDLHNEQUFzRCxzREFBc0Qsa0NBQWtDLHlCQUF5QiwwREFBMEQsK0JBQStCLFFBQVEsTUFBTSxvQ0FBb0MsT0FBTyxLQUFLO0FBQ3ZnRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7O0FBRXpDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEOztBQUVuRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDOztBQUVuQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdDQUFtQjtBQUN0QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXLDBCQUEwQixjQUFjLG9CQUFvQixlQUFlLGtCQUFrQixrQkFBa0I7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFGQUFxRixVQUFVO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILCtDQUErQztBQUNuSztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILCtDQUErQztBQUNuSztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtDQUFrQztBQUM5RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUdBQW1HO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkU7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwd1o7O0FBRTF3WiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Y2FsaWJ1ci13ZWJwYWNrLy4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9idWlsZC9lc20vZXhjYWxpYnVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZXhjYWxpYnVyIC0gMC4yNy4wIC0gMjAyMi03LThcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcbiAqIENvcHlyaWdodCAoYykgMjAyMiBFeGNhbGlidXIuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvZ3JhcGhzL2NvbnRyaWJ1dG9ycz5cbiAqIExpY2Vuc2VkIEJTRC0yLUNsYXVzZVxuICogQHByZXNlcnZlXG4gKi9cbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDY2Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzNDMwKTtcbnZhciBlbnRyeVVuYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODc5MSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ3NvcnQnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODM0Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY5KTtcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mjc2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5rZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MTExOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MjEpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTA1KTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyMzEpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjQ2KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjAzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTc5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIzMSk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NDYpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzI0KTtcblxudmFyICRBcnJheSA9IEFycmF5O1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSAkQXJyYXkobWF4KGZpbiAtIGssIDApKTtcbiAgZm9yICh2YXIgbiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICByZXN1bHQubGVuZ3RoID0gbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM4Njc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBhcnJheVNsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nzk0KTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgYXJyYXksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UoYXJyYXksIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgY29tcGFyZWZuXG4gICk7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAoYXJyYXksIGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcblxuICB3aGlsZSAobGluZGV4IDwgbGxlbmd0aCB8fCByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgYXJyYXlbbGluZGV4ICsgcmluZGV4XSA9IChsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGgpXG4gICAgICA/IGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXVxuICAgICAgOiBsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK107XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZVNvcnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU4OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwMSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oNzA3OSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwODE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyNzApO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4MjYpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkzMyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3ODcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgZXhjZXB0aW9ucykge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTc2Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTc4Nyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzU4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNTg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzI0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzEwKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTc4Nyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzU4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzY4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3ODcpO1xudmFyIG1ha2VCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDM5KTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODQwMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5nbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZUdsb2JhbFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdGlvbnMudW5zYWZlKSBkZWxldGUgT1trZXldO1xuICAgICAgZWxzZSBpZiAoT1trZXldKSBzaW1wbGUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1NjM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODIxKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgaWYgKCFkZWxldGUgT1tQXSkgdGhyb3cgJFR5cGVFcnJvcignQ2Fubm90IGRlbGV0ZSBwcm9wZXJ0eSAnICsgdHJ5VG9TdHJpbmcoUCkgKyAnIG9mICcgKyB0cnlUb1N0cmluZyhPKSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjM1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjcxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTgpO1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1MDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBVQSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk4KTtcblxubW9kdWxlLmV4cG9ydHMgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMzMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MzU4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5OCk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODExOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTgpO1xuXG52YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IsIE1FVEhPRCkge1xuICByZXR1cm4gdW5jdXJyeVRoaXMoZ2xvYmFsW0NPTlNUUlVDVE9SXS5wcm90b3R5cGVbTUVUSE9EXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzODM3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxMDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MzMpLmYpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc2Mik7XG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDc2OCk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MDApO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODEpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTQxKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIyOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxODg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIyOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxuICB2YXIgdGVzdCA9IChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pLmJpbmQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiB0eXBlb2YgdGVzdCAhPSAnZnVuY3Rpb24nIHx8IHRlc3QuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTg4KTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE4MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjcwKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24oRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTIHx8IChERVNDUklQVE9SUyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk2ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIE5BVElWRV9CSU5EID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTg4KTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQgPSBGdW5jdGlvblByb3RvdHlwZS5iaW5kO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIHVuY3VycnlUaGlzID0gTkFUSVZFX0JJTkQgJiYgYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyhmbik7XG59IDogZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGwuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzMzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTMwMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzExMSk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTg1OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyA9PSAnb2JqZWN0JyAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MjcwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTkxKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5Nzc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Mzk0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MDApO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM1KTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDc5KTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogJE9iamVjdChpdCk7XG59IDogJE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUxMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1Myk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMoRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nKGl0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZS5pbnNwZWN0U291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NDA3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Njk0KTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzYyKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyNzApO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1Myk7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mzk5KTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTc3KTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHVuY3VycnlUaGlzKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzKHN0b3JlLmhhcyk7XG4gIHZhciB3bXNldCA9IHVuY3VycnlUaGlzKHN0b3JlLnNldCk7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzMzOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTQxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDUyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIzMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzOTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMzKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIxKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oNjk2OSk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2NDY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzNyk7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjAzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyNzApO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MDUpLkNPTkZJR1VSQUJMRSk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUxMSk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQwNyk7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24odmFsdWUsICduYW1lJykgfHwgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpKSB7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCB7IHZhbHVlOiBuYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZWxzZSB2YWx1ZS5uYW1lID0gbmFtZTtcbiAgfVxuICBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgaWYgKCFoYXNPd24oc3RhdGUsICdzb3VyY2UnKSkge1xuICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzgzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMteC9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzU4KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIyOSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODY5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUxMSk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE3ODc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzOTQpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTM3KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3Nik7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oOTMxMCk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xudmFyIFdSSVRBQkxFID0gJ3dyaXRhYmxlJztcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50W1dSSVRBQkxFXSkge1xuICAgICAgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICBBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgICAgICBlbnVtZXJhYmxlOiBFTlVNRVJBQkxFIGluIEF0dHJpYnV0ZXMgPyBBdHRyaWJ1dGVzW0VOVU1FUkFCTEVdIDogY3VycmVudFtFTlVNRVJBQkxFXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgJFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzkzMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjYpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTk1KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNTgpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTA1KTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzEwKTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyNzApO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mzk0KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzcpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTMyMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oODI3MCk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDUpO1xudmFyIGluZGV4T2YgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5NTQwKS5pbmRleE9mKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTc3KTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjMyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODM3KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTE5NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTE0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODI2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMzMyk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNTEpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODk0KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3Nik7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyNzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODg4NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDM5OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzAzNik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQxKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDAwKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgZGVmaW5lR2xvYmFsUHJvcGVydHkoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMwMzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjMxKTtcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1Myk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE0LTIwMjIgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4yMy4zL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjMxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMyOSk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM3KTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODg1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzMyOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRydW5jID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTcpO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzI5KTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4NSk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA2Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Nik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNTIpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mzk1KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzMDApO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MTQpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMxMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDY2KTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM5NSk7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjAxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzMyNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1ODkpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODIxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQ0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OTY5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxMzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG4vLyBWOCB+IENocm9tZSAzNi1cbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMzMzRcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT0gNDI7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzAzNik7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MjcwKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NDEpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzkpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTY5KTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wgJiYgU3ltYm9sWydmb3InXTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXNPd24oV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDMwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMDMpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxMTEpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTkxKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTY0Nik7XG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYzKTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMyNik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGludGVybmFsU29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMzg2Nyk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjAzOCk7XG52YXIgRkYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NzEpO1xudmFyIElFX09SX0VER0UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MDYpO1xudmFyIFY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzU4KTtcbnZhciBXRUJLSVQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MTEpO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIHVuJFNvcnQgPSB1bmN1cnJ5VGhpcyh0ZXN0LnNvcnQpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyh0ZXN0LnB1c2gpO1xuXG4vLyBJRTgtXG52YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7XG4vLyBPbGQgV2ViS2l0XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3NvcnQnKTtcblxudmFyIFNUQUJMRV9TT1JUID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gY2FuIGJlIHRvbyBzbG93LCBzbyBjaGVjayBlbmdpbmVzIHZlcnNpb25zXG4gIGlmIChWOCkgcmV0dXJuIFY4IDwgNzA7XG4gIGlmIChGRiAmJiBGRiA+IDMpIHJldHVybjtcbiAgaWYgKElFX09SX0VER0UpIHJldHVybiB0cnVlO1xuICBpZiAoV0VCS0lUKSByZXR1cm4gV0VCS0lUIDwgNjAzO1xuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNvZGUsIGNociwgdmFsdWUsIGluZGV4O1xuXG4gIC8vIGdlbmVyYXRlIGFuIGFycmF5IHdpdGggbW9yZSA1MTIgZWxlbWVudHMgKENoYWtyYSBhbmQgb2xkIFY4IGZhaWxzIG9ubHkgaW4gdGhpcyBjYXNlKVxuICBmb3IgKGNvZGUgPSA2NTsgY29kZSA8IDc2OyBjb2RlKyspIHtcbiAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIDY2OiBjYXNlIDY5OiBjYXNlIDcwOiBjYXNlIDcyOiB2YWx1ZSA9IDM7IGJyZWFrO1xuICAgICAgY2FzZSA2ODogY2FzZSA3MTogdmFsdWUgPSA0OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHZhbHVlID0gMjtcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0NzsgaW5kZXgrKykge1xuICAgICAgdGVzdC5wdXNoKHsgazogY2hyICsgaW5kZXgsIHY6IHZhbHVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRlc3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi52IC0gYS52OyB9KTtcblxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNociA9IHRlc3RbaW5kZXhdLmsuY2hhckF0KDApO1xuICAgIGlmIChyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSAhPT0gY2hyKSByZXN1bHQgKz0gY2hyO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gJ0RHQkVGSEFDSUpLJztcbn0pO1xuXG52YXIgRk9SQ0VEID0gRkFJTFNfT05fVU5ERUZJTkVEIHx8ICFGQUlMU19PTl9OVUxMIHx8ICFTVFJJQ1RfTUVUSE9EIHx8ICFTVEFCTEVfU09SVDtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgIHJldHVybiB0b1N0cmluZyh4KSA+IHRvU3RyaW5nKHkpID8gMSA6IC0xO1xuICB9O1xufTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSBhQ2FsbGFibGUoY29tcGFyZWZuKTtcblxuICAgIHZhciBhcnJheSA9IHRvT2JqZWN0KHRoaXMpO1xuXG4gICAgaWYgKFNUQUJMRV9TT1JUKSByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyB1biRTb3J0KGFycmF5KSA6IHVuJFNvcnQoYXJyYXksIGNvbXBhcmVmbik7XG5cbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgYXJyYXlMZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShhcnJheSk7XG4gICAgdmFyIGl0ZW1zTGVuZ3RoLCBpbmRleDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoaW5kZXggaW4gYXJyYXkpIHB1c2goaXRlbXMsIGFycmF5W2luZGV4XSk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxTb3J0KGl0ZW1zLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcblxuICAgIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChpbmRleCA8IGl0ZW1zTGVuZ3RoKSBhcnJheVtpbmRleF0gPSBpdGVtc1tpbmRleCsrXTtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheUxlbmd0aCkgZGVsZXRlUHJvcGVydHlPclRocm93KGFycmF5LCBpbmRleCsrKTtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3Njk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMDMpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTkxKTtcbnZhciBuYXRpdmVLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjMyKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIyOSk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVLZXlzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEzODg6XG4vKioqLyAoKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIlpcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9zb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9zb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9zb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vLyBJbXBvcnRzXG5cblxudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkoKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSkpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyogQnV0dG9ucyBzdHlsZXMgc3RhcnQgKi9cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXkge1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgei1pbmRleDogOTk5O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgLypib3JkZXI6IDNweCBzb2xpZDtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgYm94LXNoYWRvdzogMCAwIDEwcHggI2NjYzsqL1xcclxcbiAgcGFkZGluZzogMXJlbSAxLjVyZW0gMXJlbSA0cmVtO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgYmFja2dyb3VuZDogIzAwYjIzMztcXHJcXG4gIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDE7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDI1MG1zIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMTUwbXMgZWFzZTtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHJcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogU2FmYXJpLCBDaHJvbWUgYW5kIE9wZXJhID4gMTIuMSAqL1xcclxcbiAgLW1vei1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBGaXJlZm94IDwgMTYgKi9cXHJcXG4gIC1tcy1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBJbnRlcm5ldCBFeHBsb3JlciAqL1xcclxcbiAgLW8tYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogT3BlcmEgPCAxMi4xICovXFxyXFxuICBhbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheSB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbn0qL1xcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTphZnRlciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGJvcmRlcjogOHB4IHNvbGlkO1xcclxcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB3aGl0ZTtcXHJcXG4gIGxlZnQ6IDM1cHg7XFxyXFxuICB0b3A6IDI0cHg7XFxyXFxuICB3aWR0aDogMDtcXHJcXG4gIGhlaWdodDogMDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmJlZm9yZSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGJvcmRlcjogM3B4IHNvbGlkO1xcclxcbiAgbGVmdDogMTlweDtcXHJcXG4gIHRvcDogMTRweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICB3aWR0aDogMzBweDtcXHJcXG4gIGhlaWdodDogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmhvdmVyLFxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpmb2N1cyB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDA5ODJjO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6Zm9jdXMge1xcclxcbiAgb3V0bGluZTogMXB4IHNvbGlkICNmZmY7XFxyXFxuICBvdXRsaW5lLW9mZnNldDogLTRweDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmFjdGl2ZSB7XFxyXFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOTkpO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBGaXJlZm94IDwgMTYgKi9cXHJcXG5ALW1vei1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIFNhZmFyaSwgQ2hyb21lIGFuZCBPcGVyYSA+IDEyLjEgKi9cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIEludGVybmV0IEV4cGxvcmVyICovXFxyXFxuQC1tcy1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIE9wZXJhIDwgMTIuMSAqL1xcclxcbkAtby1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL0xvYWRlci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEseUJBQXlCOztBQUV6QjtFQUNFLHFCQUFxQjtFQUNyQixrQkFBa0I7RUFDbEIsWUFBWTtFQUNaLGtCQUFrQjtFQUNsQixZQUFZO0VBQ1o7OytCQUU2QjtFQUM3Qiw4QkFBOEI7RUFDOUIsU0FBUztFQUNULHFCQUFxQjtFQUNyQixtQkFBbUI7RUFDbkIsY0FBYztFQUNkLHVCQUF1QjtFQUN2QixlQUFlO0VBQ2YsbUJBQW1CO0VBQ25CLGNBQWM7RUFDZCxlQUFlO0VBQ2Ysa0JBQWtCO0VBQ2xCLDhEQUE4RDtFQUM5RCx3QkFBd0I7RUFDeEIscUJBQXFCOztFQUVyQixnREFBZ0QsRUFBRSxvQ0FBb0M7RUFDdEYsNkNBQTZDLEVBQUUsaUJBQWlCO0VBQ2hFLDRDQUE0QyxFQUFFLHNCQUFzQjtFQUNwRSwyQ0FBMkMsRUFBRSxpQkFBaUI7RUFDOUQsd0NBQXdDO0FBQzFDOztBQUVBOzs7RUFHRTs7QUFFRjtFQUNFLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsaUJBQWlCO0VBQ2pCLHVEQUF1RDtFQUN2RCxVQUFVO0VBQ1YsU0FBUztFQUNULFFBQVE7RUFDUixTQUFTO0FBQ1g7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsV0FBVztFQUNYLGlCQUFpQjtFQUNqQixVQUFVO0VBQ1YsU0FBUztFQUNULG1CQUFtQjtFQUNuQixXQUFXO0VBQ1gsWUFBWTtBQUNkOztBQUVBOztFQUVFLG1CQUFtQjtBQUNyQjs7QUFFQTtFQUNFLHVCQUF1QjtFQUN2QixvQkFBb0I7QUFDdEI7O0FBRUE7RUFDRSxzQkFBc0I7QUFDeEI7O0FBRUE7RUFDRTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsVUFBVTtFQUNaO0FBQ0Y7O0FBRUEsaUJBQWlCO0FBQ2pCO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLFVBQVU7RUFDWjtBQUNGOztBQUVBLG9DQUFvQztBQUNwQztFQUNFO0lBQ0UsVUFBVTtFQUNaO0VBQ0E7SUFDRSxVQUFVO0VBQ1o7QUFDRjs7QUFFQSxzQkFBc0I7QUFDdEI7RUFDRTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsVUFBVTtFQUNaO0FBQ0Y7O0FBRUEsaUJBQWlCO0FBQ2pCO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLFVBQVU7RUFDWjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIEJ1dHRvbnMgc3R5bGVzIHN0YXJ0ICovXFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5IHtcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHotaW5kZXg6IDk5OTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIC8qYm9yZGVyOiAzcHggc29saWQ7XFxyXFxuICAgIGJvcmRlci1jb2xvcjogd2hpdGU7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4ICNjY2M7Ki9cXHJcXG4gIHBhZGRpbmc6IDFyZW0gMS41cmVtIDFyZW0gNHJlbTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJhY2tncm91bmQ6ICMwMGIyMzM7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbiAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAyNTBtcyBlYXNlLWluLW91dCwgdHJhbnNmb3JtIDE1MG1zIGVhc2U7XFxyXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuXFxyXFxuICAtd2Via2l0LWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIFNhZmFyaSwgQ2hyb21lIGFuZCBPcGVyYSA+IDEyLjEgKi9cXHJcXG4gIC1tb3otYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogRmlyZWZveCA8IDE2ICovXFxyXFxuICAtbXMtYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogSW50ZXJuZXQgRXhwbG9yZXIgKi9cXHJcXG4gIC1vLWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIE9wZXJhIDwgMTIuMSAqL1xcclxcbiAgYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtcztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXkge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG59Ki9cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YWZ0ZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBib3JkZXI6IDhweCBzb2xpZDtcXHJcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgd2hpdGU7XFxyXFxuICBsZWZ0OiAzNXB4O1xcclxcbiAgdG9wOiAyNHB4O1xcclxcbiAgd2lkdGg6IDA7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpiZWZvcmUge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBib3JkZXI6IDNweCBzb2xpZDtcXHJcXG4gIGxlZnQ6IDE5cHg7XFxyXFxuICB0b3A6IDE0cHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgd2lkdGg6IDMwcHg7XFxyXFxuICBoZWlnaHQ6IDMwcHg7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpob3ZlcixcXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6Zm9jdXMge1xcclxcbiAgYmFja2dyb3VuZDogIzAwOTgyYztcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmZvY3VzIHtcXHJcXG4gIG91dGxpbmU6IDFweCBzb2xpZCAjZmZmO1xcclxcbiAgb3V0bGluZS1vZmZzZXQ6IC00cHg7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTphY3RpdmUge1xcclxcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjk5KTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogRmlyZWZveCA8IDE2ICovXFxyXFxuQC1tb3ota2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBTYWZhcmksIENocm9tZSBhbmQgT3BlcmEgPiAxMi4xICovXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBJbnRlcm5ldCBFeHBsb3JlciAqL1xcclxcbkAtbXMta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBPcGVyYSA8IDEyLjEgKi9cXHJcXG5ALW8ta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoX19fQ1NTX0xPQURFUl9FWFBPUlRfX18pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Mzc5OlxuLyoqKi8gKChtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJaXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjA5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLy8gSW1wb3J0c1xuXG5cbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKChfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX3NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkpKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcclxcbiNleC10b2FzdC1jb250YWluZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgaGVpZ2h0OiAwO1xcclxcbiAgbWluLXdpZHRoOiA1MCU7XFxyXFxuICBsZWZ0OiA1MCU7XFxyXFxuICB0b3A6IDA7XFxyXFxufVxcclxcblxcclxcbi5leC10b2FzdC1tZXNzYWdlIHtcXHJcXG4gIGxlZnQ6IC01MCU7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcblxcclxcblxcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIG1hcmdpbi10b3A6IDVweDtcXHJcXG4gIGZvbnQtc2l6ZTogMThweDtcXHJcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgYm9yZGVyOiAzcHggc29saWQgI2I3Yjc3OTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTMsIDI1MywgMTkyKTtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLmV4LXRvYXN0LW1lc3NhZ2UgYnV0dG9uIHtcXHJcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxyXFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL1V0aWwvVG9hc3Rlci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxjQUFjO0VBQ2QsU0FBUztFQUNULE1BQU07QUFDUjs7QUFFQTtFQUNFLFVBQVU7RUFDVixrQkFBa0I7RUFDbEIsYUFBYTtFQUNiLDhCQUE4Qjs7O0VBRzlCLGFBQWE7RUFDYixlQUFlO0VBQ2YsZUFBZTtFQUNmLHVCQUF1QjtFQUN2QixrQkFBa0I7RUFDbEIseUJBQXlCO0VBQ3pCLG9DQUFvQztBQUN0Qzs7O0FBR0E7RUFDRSxzQkFBc0I7QUFDeEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxyXFxuI2V4LXRvYXN0LWNvbnRhaW5lciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxuICBtaW4td2lkdGg6IDUwJTtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRvcDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmV4LXRvYXN0LW1lc3NhZ2Uge1xcclxcbiAgbGVmdDogLTUwJTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuXFxyXFxuXFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgbWFyZ2luLXRvcDogNXB4O1xcclxcbiAgZm9udC1zaXplOiAxOHB4O1xcclxcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICBib3JkZXI6IDNweCBzb2xpZCAjYjdiNzc5O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1MywgMjUzLCAxOTIpO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4uZXgtdG9hc3QtbWVzc2FnZSBidXR0b24ge1xcclxcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcXHJcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKF9fX0NTU19MT0FERVJfRVhQT1JUX19fKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYwOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIFxuLyoqKioqKi8gXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcbi8qKioqKiovIFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gfVxuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuKCgpID0+IHtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJmV25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjdGlvbkNvbnRleHQpLFxuICBcIklhOFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uUXVldWUpLFxuICBcInJxdlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uU2VxdWVuY2UpLFxuICBcImhMSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uc0NvbXBvbmVudCksXG4gIFwieXl2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY3Rpb25zU3lzdGVtKSxcbiAgXCJ0WDVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjdGl2YXRlRXZlbnQpLFxuICBcInZ0WFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0b3IpLFxuICBcInI3S1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWRkZWRDb21wb25lbnQpLFxuICBcImxDaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWRkZWRFbnRpdHkpLFxuICBcImNFNFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWZmaW5lTWF0cml4KSxcbiAgXCJmd0ZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFuaW1hdGlvbiksXG4gIFwic2NlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbmltYXRpb25EaXJlY3Rpb24pLFxuICBcIl9jN1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5pbWF0aW9uU3RyYXRlZ3kpLFxuICBcIktVc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQXJjYWRlU29sdmVyKSxcbiAgXCJBanBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEF1ZGlvQ29udGV4dEZhY3RvcnkpLFxuICBcIlJEaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQXhpcyksXG4gIFwiX0g5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCYXNlQWxpZ24pLFxuICBcIm14c1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQmxpbmspLFxuICBcIk9tRFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQm9keUNvbXBvbmVudCksXG4gIFwia0JmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCb3VuZGluZ0JveCksXG4gIFwiQzRGXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCcm9hZHBoYXNlU3RyYXRlZ3kpLFxuICBcIk5RdFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQnJvd3NlckNvbXBvbmVudCksXG4gIFwiSmpOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCcm93c2VyRXZlbnRzKSxcbiAgXCJWMXNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENhbWVyYSksXG4gIFwiWHo3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDYW52YXMpLFxuICBcIkNkY1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2lyY2xlKSxcbiAgXCJGS25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENpcmNsZUNvbGxpZGVyKSxcbiAgXCJ3VFdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsYXNzKSxcbiAgXCJTVVlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsb2NrKSxcbiAgXCJhYjJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsb3Nlc3RMaW5lKSxcbiAgXCJHZlpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsb3Nlc3RMaW5lSnVtcFRhYmxlKSxcbiAgXCJZTVNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpZGVyKSxcbiAgXCJveXZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpZGVyQ29tcG9uZW50KSxcbiAgXCJhVWJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkNvbnRhY3QpLFxuICBcIlNkRFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uRW5kRXZlbnQpLFxuICBcIkpVdlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uR3JvdXApLFxuICBcImpFalwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uR3JvdXBNYW5hZ2VyKSxcbiAgXCJURnFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkp1bXBUYWJsZSksXG4gIFwiSERVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudCksXG4gIFwiUl95XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50KSxcbiAgXCJ5ZE5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSksXG4gIFwidDUwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25TdGFydEV2ZW50KSxcbiAgXCJzJCRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvblN5c3RlbSksXG4gIFwidjJHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25UeXBlKSxcbiAgXCJJbGtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbG9yKSxcbiAgXCJzOWlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbG9yQmxpbmRGbGFncyksXG4gIFwiZHhMXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvckJsaW5kbmVzc01vZGUpLFxuICBcIkxMWFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JCbGluZG5lc3NQb3N0UHJvY2Vzc29yKSxcbiAgXCJ3QTJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbXBvbmVudCksXG4gIFwiUl9wXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb21wb3NpdGVDb2xsaWRlciksXG4gIFwiSVEkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb25maWd1cmFibGUpLFxuICBcIkk1RlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29uc29sZUFwcGVuZGVyKSxcbiAgXCJYOCRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbnRhY3RDb25zdHJhaW50UG9pbnQpLFxuICBcIkZSNlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29udGFjdEVuZEV2ZW50KSxcbiAgXCJVOG9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbnRhY3RTdGFydEV2ZW50KSxcbiAgXCJrYkdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvb3JkUGxhbmUpLFxuICBcImlTX1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVhY3RpdmF0ZUV2ZW50KSxcbiAgXCJjR0dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYnVnKSxcbiAgXCJSUE5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYnVnR3JhcGhpY3NDb21wb25lbnQpLFxuICBcInNrYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVidWdTeXN0ZW0pLFxuICBcIlNMVVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVidWdUZXh0KSxcbiAgXCJSZEpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlZ3JlZU9mRnJlZWRvbSksXG4gIFwiY051XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZWxheSksXG4gIFwiZ1U3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZXRlY3RvciksXG4gIFwiTFNrXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEaWUpLFxuICBcIk5tcFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGlyZWN0aW9uKSxcbiAgXCJkMVlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERpc3BsYXlNb2RlKSxcbiAgXCJ4ckxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIER5bmFtaWNUcmVlKSxcbiAgXCJzUldcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yKSxcbiAgXCJjbVZcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRVhfVkVSU0lPTiksXG4gIFwicVd6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFYXNlQnkpLFxuICBcIk4wUVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRWFzZVRvKSxcbiAgXCJxOGJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVhc2luZ0Z1bmN0aW9ucyksXG4gIFwieW5CXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFZGdlQ29sbGlkZXIpLFxuICBcImpUOVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRWxhc3RpY1RvQWN0b3JTdHJhdGVneSksXG4gIFwid0F6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbWl0dGVyVHlwZSksXG4gIFwiRDRWXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbmdpbmUpLFxuICBcIk42SFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW50ZXJUcmlnZ2VyRXZlbnQpLFxuICBcIlcxQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW50ZXJWaWV3UG9ydEV2ZW50KSxcbiAgXCJKSFdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudGl0eSksXG4gIFwidjJLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnRpdHlNYW5hZ2VyKSxcbiAgXCJwQmZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50RGlzcGF0Y2hlciksXG4gIFwiR01sXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFdmVudFR5cGVzKSxcbiAgXCJ6VzJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50c19uYW1lc3BhY2VPYmplY3QpLFxuICBcIkIwS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXhSZXNwb25zZSksXG4gIFwiTnY3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyksXG4gIFwiQ19wXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCksXG4gIFwiaXF3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3NvciksXG4gIFwiTVVBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGl0VHJpZ2dlckV2ZW50KSxcbiAgXCJ4cVVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV4aXRWaWV3UG9ydEV2ZW50KSxcbiAgXCJwVHBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZhZGUpLFxuICBcInZVS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmxhZ3MpLFxuICBcImo5bFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRm9sbG93KSxcbiAgXCJaeHdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbnQpLFxuICBcIkhkeFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRm9udFN0eWxlKSxcbiAgXCJaJGRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbnRVbml0KSxcbiAgXCJpcVZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZwc1NhbXBsZXIpLFxuICBcIm8kN1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRnJhbWVTdGF0cyksXG4gIFwib2xNXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGdXR1cmUpLFxuICBcIlptJFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZUV2ZW50KSxcbiAgXCIkUUhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVTdGFydEV2ZW50KSxcbiAgXCJpNzhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVTdG9wRXZlbnQpLFxuICBcImg2dVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZEF4aXNFdmVudCksXG4gIFwiaHRzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lcGFkQnV0dG9uRXZlbnQpLFxuICBcImo4OFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZENvbm5lY3RFdmVudCksXG4gIFwiVk1FXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KSxcbiAgXCJudFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2lmKSxcbiAgXCJVa3JcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdsb2JhbENvb3JkaW5hdGVzKSxcbiAgXCJ6c3VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWMpLFxuICBcIm9BNlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR3JhcGhpY3NDb21wb25lbnQpLFxuICBcIlRWaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR3JhcGhpY3NHcm91cCksXG4gIFwiVHdaXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHcmFwaGljc0xheWVyKSxcbiAgXCJHVFRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzTGF5ZXJzKSxcbiAgXCJ4eGpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzU3lzdGVtKSxcbiAgXCJYZEtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEhpZGRlbkV2ZW50KSxcbiAgXCJKbWJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEltYWdlRmlsdGVyaW5nKSxcbiAgXCJjWG9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEltYWdlU291cmNlKSxcbiAgXCJEbTVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEluaXRpYWxpemVFdmVudCksXG4gIFwiSUlCXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QpLFxuICBcInpJMFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW50ZWdyYXRvciksXG4gIFwiTFlEXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJc29tZXRyaWNFbnRpdHlDb21wb25lbnQpLFxuICBcImNFR1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSXNvbWV0cmljRW50aXR5U3lzdGVtKSxcbiAgXCJTRWxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIElzb21ldHJpY01hcCksXG4gIFwidDlWXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJc29tZXRyaWNUaWxlKSxcbiAgXCJTS1pcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEtpbGxFdmVudCksXG4gIFwiX19KXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMYWJlbCksXG4gIFwiUkkkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5KSxcbiAgXCJ4MTJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExpbmUpLFxuICBcImNjelwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGluZVNlZ21lbnQpLFxuICBcImFOd1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9hZGVyKSxcbiAgXCJ4d25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KSxcbiAgXCJkTktcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kpLFxuICBcImluaVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nTGV2ZWwpLFxuICBcIllkSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nZ2VyKSxcbiAgXCJ5M0dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1hdHJpeCksXG4gIFwibDU3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNYXRyaXhMb2NhdGlvbnMpLFxuICBcInhuMFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWVkaWFFdmVudCksXG4gIFwidDJWXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNZWV0KSxcbiAgXCJ1eEJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1vdGlvbkNvbXBvbmVudCksXG4gIFwiY3BkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNb3Rpb25TeXN0ZW0pLFxuICBcImZpeVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTW92ZUJ5KSxcbiAgXCIkWFpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1vdmVUbyksXG4gIFwidXFLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBOYXRpdmVTb3VuZEV2ZW50KSxcbiAgXCJTVEVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE5hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQpLFxuICBcInkkelwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gT2JzZXJ2YWJsZSksXG4gIFwibUFEXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPZmZzY3JlZW5TeXN0ZW0pLFxuICBcInNPcVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFpciksXG4gIFwiaFV3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJhbGxheENvbXBvbmVudCksXG4gIFwiXzBHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJhbGxlbEFjdGlvbnMpLFxuICBcIlNxc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFyc2VHaWYpLFxuICBcImhwWlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFydGljbGUpLFxuICBcIlZvbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFydGljbGVFbWl0dGVyKSxcbiAgXCJ3SVpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBoeXNpY3MpLFxuICBcImNCaVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGh5c2ljc1N0YXRzKSxcbiAgXCJSRnZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvaW50ZXJDb21wb25lbnQpLFxuICBcImtmQ1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9pbnRlclN5c3RlbSksXG4gIFwibWdxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb2x5Z29uKSxcbiAgXCJZVkFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvbHlnb25Db2xsaWRlciksXG4gIFwiS2dwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb29sKSxcbiAgXCJISCRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvc3RDb2xsaXNpb25FdmVudCksXG4gIFwiTV9kXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0RGVidWdEcmF3RXZlbnQpLFxuICBcInJnaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9zdERyYXdFdmVudCksXG4gIFwiUmE2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0RnJhbWVFdmVudCksXG4gIFwiS2hSXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0S2lsbEV2ZW50KSxcbiAgXCJCUzVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvc3RVcGRhdGVFdmVudCksXG4gIFwieGh6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVDb2xsaXNpb25FdmVudCksXG4gIFwieE9xXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVEZWJ1Z0RyYXdFdmVudCksXG4gIFwiYTlqXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVEcmF3RXZlbnQpLFxuICBcImJIa1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlRnJhbWVFdmVudCksXG4gIFwiQ2dLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVLaWxsRXZlbnQpLFxuICBcImN1WVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlVXBkYXRlRXZlbnQpLFxuICBcImt2RVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJvamVjdGlvbiksXG4gIFwiU0J1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBRdWFkSW5kZXhCdWZmZXIpLFxuICBcIkFFX1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUXVlcnkpLFxuICBcImN0T1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUXVlcnlNYW5hZ2VyKSxcbiAgXCJPTEhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kpLFxuICBcImtreVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmFuZG9tKSxcbiAgXCJuU0ZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJhc3RlciksXG4gIFwiekhuXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSYXkpLFxuICBcInp3eFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVhbGlzdGljU29sdmVyKSxcbiAgXCJBZUpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlY3RhbmdsZSksXG4gIFwiaEx6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZW1vdmVkQ29tcG9uZW50KSxcbiAgXCJEOWdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbW92ZWRFbnRpdHkpLFxuICBcIndBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZXBlYXQpLFxuICBcImpoclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVwZWF0Rm9yZXZlciksXG4gIFwiR1ZzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZXNvbHV0aW9uKSxcbiAgXCJfek9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlc291cmNlKSxcbiAgXCJ3NiRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0ZUJ5KSxcbiAgXCJtaFZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0ZVRvKSxcbiAgXCJNT0RcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0aW9uVHlwZSksXG4gIFwia3dkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTY2FsZUJ5KSxcbiAgXCJMbXJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjYWxlVG8pLFxuICBcInhzU1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NlbmUpLFxuICBcImxMclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NyZWVuKSxcbiAgXCJaJHJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcmVlbkFwcGVuZGVyKSxcbiAgXCJJWGJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcmVlbkVsZW1lbnQpLFxuICBcIlNHSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NyZWVuU2hhZGVyKSxcbiAgXCJTTWpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcm9sbFByZXZlbnRpb25Nb2RlKSxcbiAgXCJMMzRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNlbWFwaG9yZSksXG4gIFwiZXhlXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTaGFkZXIpLFxuICBcImJuRlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2hhcGUpLFxuICBcIk1GQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2lkZSksXG4gIFwiJHVVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTb3VuZCksXG4gIFwianlpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTcHJpdGUpLFxuICBcIkUwM1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3ByaXRlRm9udCksXG4gIFwiVjZxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTcHJpdGVTaGVldCksXG4gIFwicmcyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdGFuZGFyZENsb2NrKSxcbiAgXCJEVldcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN0YXRlTWFjaGluZSksXG4gIFwiblZvXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdHJhdGVneUNvbnRhaW5lciksXG4gIFwiRjZOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdHJlYW0pLFxuICBcInhQN1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3lzdGVtKSxcbiAgXCJPZHFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN5c3RlbU1hbmFnZXIpLFxuICBcIlppZlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3lzdGVtVHlwZSksXG4gIFwiWkdKXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUYWdDb21wb25lbnQpLFxuICBcIk1Ka1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGVzdENsb2NrKSxcbiAgXCJ4dlRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHQpLFxuICBcIlBITVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGV4dEFsaWduKSxcbiAgXCJkcFJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHR1cmVMb2FkZXIpLFxuICBcIm45TFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGlsZSksXG4gIFwiS3dPXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUaWxlTWFwKSxcbiAgXCJCN3lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRpbWVyKSxcbiAgXCJ4N3JcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRvYXN0ZXIpLFxuICBcInd4N1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVHJhbnNmb3JtKSxcbiAgXCJVdm5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyYW5zZm9ybUNvbXBvbmVudCksXG4gIFwiT0ZUXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmVlTm9kZSksXG4gIFwieHpOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmlnZ2VyKSxcbiAgXCJNNVpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFR3b1BJKSxcbiAgXCJack5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFV0aWxfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJPV3NcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZlY3RvciksXG4gIFwiZEY5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZWN0b3JWaWV3KSxcbiAgXCJvWnlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZlcnRleEJ1ZmZlciksXG4gIFwickQyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZXJ0ZXhMYXlvdXQpLFxuICBcIlZIb1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVmlzaWJsZUV2ZW50KSxcbiAgXCJvaEVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFdlYkF1ZGlvKSxcbiAgXCJSJEVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFdlYkF1ZGlvSW5zdGFuY2UpLFxuICBcInEzSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gV29ybGQpLFxuICBcIlBhYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gY2Fub25pY2FsaXplQW5nbGUpLFxuICBcInVaNVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gY2xhbXApLFxuICBcIk1jS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gY3JlYXRlSWQpLFxuICBcIkY5Y1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZnJhYyksXG4gIFwiazBiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNHcmFwaGljc1RpY2spLFxuICBcImhuVFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzT25Jbml0aWFsaXplKSxcbiAgXCJSU0pcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc09uUG9zdFVwZGF0ZSksXG4gIFwiTWt1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNPblByZVVwZGF0ZSksXG4gIFwiaDkwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNQb3N0RHJhdyksXG4gIFwicm1zXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNQcmVEcmF3KSxcbiAgXCJFclBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19pbml0aWFsaXplKSxcbiAgXCJhVmdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19wb3N0dXBkYXRlKSxcbiAgXCJsUGNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19wcmV1cGRhdGUpLFxuICBcIlo4RVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNBZGRlZENvbXBvbmVudCksXG4gIFwiX04yXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc0FkZGVkU3lzdGVtRW50aXR5KSxcbiAgXCJ5Rm5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGlzUmVtb3ZlU3lzdGVtRW50aXR5KSxcbiAgXCJsTnZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGlzUmVtb3ZlZENvbXBvbmVudCksXG4gIFwiY3U5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc1NjcmVlbkVsZW1lbnQpLFxuICBcIk1aUVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbWF4TWVzc2FnZXMpLFxuICBcIkZVTVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gb2Jzb2xldGUpLFxuICBcIkJ4UlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcGl4ZWxTbmFwRXBzaWxvbiksXG4gIFwidmRmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyByYW5kb21JblJhbmdlKSxcbiAgXCJpYUxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHJhbmRvbUludEluUmFuZ2UpLFxuICBcInc2SFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcmFuZ2UpLFxuICBcIlE0Y1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcmVzZXRPYnNvbGV0ZUNvdW50ZXIpLFxuICBcIlh4ZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gc2lnbiksXG4gIFwiVXhiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB0b0RlZ3JlZXMpLFxuICBcIllyNVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdG9SYWRpYW5zKSxcbiAgXCJCaHdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHZlYyksXG4gIFwieU9BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB3ZWJnbF91dGlsX25hbWVzcGFjZU9iamVjdClcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL0V2ZW50cy50c1xudmFyIEV2ZW50c19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihFdmVudHNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChFdmVudHNfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiQWN0aXZhdGVFdmVudFwiOiAoKSA9PiAoQWN0aXZhdGVFdmVudCksXG4gIFwiQ29sbGlzaW9uRW5kRXZlbnRcIjogKCkgPT4gKENvbGxpc2lvbkVuZEV2ZW50KSxcbiAgXCJDb2xsaXNpb25Qb3N0U29sdmVFdmVudFwiOiAoKSA9PiAoQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQpLFxuICBcIkNvbGxpc2lvblByZVNvbHZlRXZlbnRcIjogKCkgPT4gKENvbGxpc2lvblByZVNvbHZlRXZlbnQpLFxuICBcIkNvbGxpc2lvblN0YXJ0RXZlbnRcIjogKCkgPT4gKENvbGxpc2lvblN0YXJ0RXZlbnQpLFxuICBcIkNvbnRhY3RFbmRFdmVudFwiOiAoKSA9PiAoQ29udGFjdEVuZEV2ZW50KSxcbiAgXCJDb250YWN0U3RhcnRFdmVudFwiOiAoKSA9PiAoQ29udGFjdFN0YXJ0RXZlbnQpLFxuICBcIkRlYWN0aXZhdGVFdmVudFwiOiAoKSA9PiAoRGVhY3RpdmF0ZUV2ZW50KSxcbiAgXCJFbnRlclRyaWdnZXJFdmVudFwiOiAoKSA9PiAoRW50ZXJUcmlnZ2VyRXZlbnQpLFxuICBcIkVudGVyVmlld1BvcnRFdmVudFwiOiAoKSA9PiAoRW50ZXJWaWV3UG9ydEV2ZW50KSxcbiAgXCJFdmVudFR5cGVzXCI6ICgpID0+IChFdmVudFR5cGVzKSxcbiAgXCJFeGl0VHJpZ2dlckV2ZW50XCI6ICgpID0+IChFeGl0VHJpZ2dlckV2ZW50KSxcbiAgXCJFeGl0Vmlld1BvcnRFdmVudFwiOiAoKSA9PiAoRXhpdFZpZXdQb3J0RXZlbnQpLFxuICBcIkdhbWVFdmVudFwiOiAoKSA9PiAoR2FtZUV2ZW50KSxcbiAgXCJHYW1lU3RhcnRFdmVudFwiOiAoKSA9PiAoR2FtZVN0YXJ0RXZlbnQpLFxuICBcIkdhbWVTdG9wRXZlbnRcIjogKCkgPT4gKEdhbWVTdG9wRXZlbnQpLFxuICBcIkdhbWVwYWRBeGlzRXZlbnRcIjogKCkgPT4gKEdhbWVwYWRBeGlzRXZlbnQpLFxuICBcIkdhbWVwYWRCdXR0b25FdmVudFwiOiAoKSA9PiAoR2FtZXBhZEJ1dHRvbkV2ZW50KSxcbiAgXCJHYW1lcGFkQ29ubmVjdEV2ZW50XCI6ICgpID0+IChHYW1lcGFkQ29ubmVjdEV2ZW50KSxcbiAgXCJHYW1lcGFkRGlzY29ubmVjdEV2ZW50XCI6ICgpID0+IChHYW1lcGFkRGlzY29ubmVjdEV2ZW50KSxcbiAgXCJIaWRkZW5FdmVudFwiOiAoKSA9PiAoSGlkZGVuRXZlbnQpLFxuICBcIkluaXRpYWxpemVFdmVudFwiOiAoKSA9PiAoSW5pdGlhbGl6ZUV2ZW50KSxcbiAgXCJLaWxsRXZlbnRcIjogKCkgPT4gKEtpbGxFdmVudCksXG4gIFwiUG9zdENvbGxpc2lvbkV2ZW50XCI6ICgpID0+IChQb3N0Q29sbGlzaW9uRXZlbnQpLFxuICBcIlBvc3REZWJ1Z0RyYXdFdmVudFwiOiAoKSA9PiAoUG9zdERlYnVnRHJhd0V2ZW50KSxcbiAgXCJQb3N0RHJhd0V2ZW50XCI6ICgpID0+IChQb3N0RHJhd0V2ZW50KSxcbiAgXCJQb3N0RnJhbWVFdmVudFwiOiAoKSA9PiAoUG9zdEZyYW1lRXZlbnQpLFxuICBcIlBvc3RLaWxsRXZlbnRcIjogKCkgPT4gKFBvc3RLaWxsRXZlbnQpLFxuICBcIlBvc3RVcGRhdGVFdmVudFwiOiAoKSA9PiAoUG9zdFVwZGF0ZUV2ZW50KSxcbiAgXCJQcmVDb2xsaXNpb25FdmVudFwiOiAoKSA9PiAoUHJlQ29sbGlzaW9uRXZlbnQpLFxuICBcIlByZURlYnVnRHJhd0V2ZW50XCI6ICgpID0+IChQcmVEZWJ1Z0RyYXdFdmVudCksXG4gIFwiUHJlRHJhd0V2ZW50XCI6ICgpID0+IChQcmVEcmF3RXZlbnQpLFxuICBcIlByZUZyYW1lRXZlbnRcIjogKCkgPT4gKFByZUZyYW1lRXZlbnQpLFxuICBcIlByZUtpbGxFdmVudFwiOiAoKSA9PiAoUHJlS2lsbEV2ZW50KSxcbiAgXCJQcmVVcGRhdGVFdmVudFwiOiAoKSA9PiAoUHJlVXBkYXRlRXZlbnQpLFxuICBcIlZpc2libGVFdmVudFwiOiAoKSA9PiAoVmlzaWJsZUV2ZW50KVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vR3JhcGhpY3MvQ29udGV4dC93ZWJnbC11dGlsLnRzXG52YXIgd2ViZ2xfdXRpbF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucih3ZWJnbF91dGlsX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQod2ViZ2xfdXRpbF9uYW1lc3BhY2VPYmplY3QsIHtcbiAgXCJnZXRBdHRyaWJ1dGVDb21wb25lbnRTaXplXCI6ICgpID0+IChnZXRBdHRyaWJ1dGVDb21wb25lbnRTaXplKSxcbiAgXCJnZXRBdHRyaWJ1dGVQb2ludGVyVHlwZVwiOiAoKSA9PiAoZ2V0QXR0cmlidXRlUG9pbnRlclR5cGUpLFxuICBcImdldEdsVHlwZVNpemVCeXRlc1wiOiAoKSA9PiAoZ2V0R2xUeXBlU2l6ZUJ5dGVzKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vVXRpbC9EcmF3VXRpbC50c1xudmFyIERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoRHJhd1V0aWxfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiY2lyY2xlXCI6ICgpID0+IChjaXJjbGUpLFxuICBcImxpbmVcIjogKCkgPT4gKGxpbmUpLFxuICBcInBvaW50XCI6ICgpID0+IChwb2ludCksXG4gIFwicm91bmRSZWN0XCI6ICgpID0+IChyb3VuZFJlY3QpLFxuICBcInZlY3RvclwiOiAoKSA9PiAodmVjdG9yKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vSW5wdXQvSW5kZXgudHNcbnZhciBJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKElucHV0X0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkF4ZXNcIjogKCkgPT4gKEF4ZXMpLFxuICBcIkJ1dHRvbnNcIjogKCkgPT4gKEJ1dHRvbnMpLFxuICBcIkdhbWVwYWRcIjogKCkgPT4gKEdhbWVwYWQpLFxuICBcIkdhbWVwYWRzXCI6ICgpID0+IChHYW1lcGFkcyksXG4gIFwiS2V5RXZlbnRcIjogKCkgPT4gKEtleUV2ZW50KSxcbiAgXCJLZXlib2FyZFwiOiAoKSA9PiAoS2V5Ym9hcmQpLFxuICBcIktleXNcIjogKCkgPT4gKEtleXMpLFxuICBcIk5hdGl2ZVBvaW50ZXJCdXR0b25cIjogKCkgPT4gKE5hdGl2ZVBvaW50ZXJCdXR0b24pLFxuICBcIlBvaW50ZXJCdXR0b25cIjogKCkgPT4gKFBvaW50ZXJCdXR0b24pLFxuICBcIlBvaW50ZXJDb21wb25lbnRcIjogKCkgPT4gKFBvaW50ZXJDb21wb25lbnQpLFxuICBcIlBvaW50ZXJFdmVudFwiOiAoKSA9PiAoUG9pbnRlckV2ZW50KSxcbiAgXCJQb2ludGVyRXZlbnRSZWNlaXZlclwiOiAoKSA9PiAoUG9pbnRlckV2ZW50UmVjZWl2ZXIpLFxuICBcIlBvaW50ZXJTY29wZVwiOiAoKSA9PiAoUG9pbnRlclNjb3BlKSxcbiAgXCJQb2ludGVyU3lzdGVtXCI6ICgpID0+IChQb2ludGVyU3lzdGVtKSxcbiAgXCJQb2ludGVyVHlwZVwiOiAoKSA9PiAoUG9pbnRlclR5cGUpLFxuICBcIldoZWVsRGVsdGFNb2RlXCI6ICgpID0+IChXaGVlbERlbHRhTW9kZSksXG4gIFwiV2hlZWxFdmVudFwiOiAoKSA9PiAoV2hlZWxFdmVudClcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL1V0aWwvSW5kZXgudHNcbnZhciBVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKFV0aWxfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkNvbnNvbGVBcHBlbmRlclwiOiAoKSA9PiAoQ29uc29sZUFwcGVuZGVyKSxcbiAgXCJEcmF3VXRpbFwiOiAoKSA9PiAoRHJhd1V0aWxfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJFYXNpbmdGdW5jdGlvbnNcIjogKCkgPT4gKEVhc2luZ0Z1bmN0aW9ucyksXG4gIFwiTG9nTGV2ZWxcIjogKCkgPT4gKExvZ0xldmVsKSxcbiAgXCJMb2dnZXJcIjogKCkgPT4gKExvZ2dlciksXG4gIFwiT2JzZXJ2YWJsZVwiOiAoKSA9PiAoT2JzZXJ2YWJsZSksXG4gIFwiU2NyZWVuQXBwZW5kZXJcIjogKCkgPT4gKFNjcmVlbkFwcGVuZGVyKSxcbiAgXCJhZGRJdGVtVG9BcnJheVwiOiAoKSA9PiAoYWRkSXRlbVRvQXJyYXkpLFxuICBcImNvbnRhaW5zXCI6ICgpID0+IChjb250YWlucyksXG4gIFwiZGVsYXlcIjogKCkgPT4gKGRlbGF5KSxcbiAgXCJmYWlsXCI6ICgpID0+IChmYWlsKSxcbiAgXCJnZXRQb3NpdGlvblwiOiAoKSA9PiAoZ2V0UG9zaXRpb24pLFxuICBcInJlbW92ZUl0ZW1Gcm9tQXJyYXlcIjogKCkgPT4gKHJlbW92ZUl0ZW1Gcm9tQXJyYXkpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9hcnJheS9zb3J0LmpzXG52YXIgc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oNDY2Mik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9rZXlzLmpzXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODM0Myk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Qb2x5ZmlsbC50c1xuXHJcblxyXG4vKipcclxuICogUG9seWZpbGwgYWRkaW5nIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3aW5kb3cgPSB7XHJcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICBpZiAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCByZXBsYWNlTWUgPSBjdHgucHJvdG90eXBlLmRlY29kZUF1ZGlvRGF0YTtcclxuICAgICAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VNZS5jYWxsKHRoaXMsIGFycmF5QnVmZmVyLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPVxyXG4gICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5vQXVkaW9Db250ZXh0O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcclxuICAgICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9GbGFncy50c1xuLyoqXHJcbiAqIEZsYWdzIGlzIGEgZmVhdHVyZSBmbGFnIGltcGxlbWVudGF0aW9uIGZvciBFeGNhbGlidXIuIFRoZXkgY2FuIG9ubHkgYmUgb3BlcmF0ZWQgKipiZWZvcmUgW1tFbmdpbmVdXSBjb25zdHJ1Y3Rpb24qKlxyXG4gKiBhZnRlciB3aGljaCB0aGV5IGFyZSBmcm96ZW4gYW5kIGFyZSByZWFkLW9ubHkuXHJcbiAqXHJcbiAqIEZsYWdzIGFyZSB1c2VkIHRvIGVuYWJsZSBleHBlcmltZW50YWwgb3IgcHJldmlldyBmZWF0dXJlcyBpbiBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBGbGFncyB7XHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlIGV4Y2FsaWJ1ciB0byBsb2FkIHRoZSBDYW52YXMgMkQgZ3JhcGhpY3MgY29udGV4dCBmYWxsYmFja1xyXG4gICAgICpcclxuICAgICAqIEB3YXJuaW5nIG5vdCBhbGwgZmVhdHVyZXMgb2YgZXhjYWxpYnVyIGFyZSBzdXBwb3J0ZWQgaW4gdGhlIENhbnZhcyAyRCBmYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlQ2FudmFzR3JhcGhpY3NDb250ZXh0KCkge1xyXG4gICAgICAgIEZsYWdzLmVuYWJsZSgndXNlLWNhbnZhcy1jb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZyZWV6ZSBhbGwgZmxhZyBtb2RpZmljYXRpb25zIG1ha2luZyB0aGVtIHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcmVlemUoKSB7XHJcbiAgICAgICAgRmxhZ3MuX0ZST1pFTiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBpbnRlcm5hbCBmbGFnIHN0YXRlLCBub3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHVzZXJzLiBPbmx5IHVzZWQgZm9yIHRlc3RpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbGluZyB0aGlzIGluIHlvdXIgZ2FtZSBpcyBVTlNVUFBPUlRFRFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfcmVzZXQoKSB7XHJcbiAgICAgICAgRmxhZ3MuX0ZST1pFTiA9IGZhbHNlO1xyXG4gICAgICAgIEZsYWdzLl9GTEFHUyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgYSBzcGVjaWZpYyBmZWF0dXJlIGZsYWcgYnkgbmFtZS4gKipOb3RlOiBjYW4gb25seSBiZSBzZXQgYmVmb3JlIFtbRW5naW5lXV0gY29uc3RydWN0b3IgdGltZSoqXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVuYWJsZShmbGFnTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9GUk9aRU4pIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZlYXR1cmUgZmxhZ3MgY2FuIG9ubHkgYmUgZW5hYmxlZCBiZWZvcmUgRW5naW5lIGNvbnN0cnVjdG9yIHRpbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRmxhZ3MuX0ZMQUdTW2ZsYWdOYW1lXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgYSBzcGVjaWZpYyBmZWF0dXJlIGZsYWcgYnkgbmFtZS4gKipOb3RlOiBjYW4gb25seSBiZSBzZXQgYmVmb3JlIFtbRW5naW5lXV0gY29uc3RydWN0b3IgdGltZSoqXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRpc2FibGUoZmxhZ05hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fRlJPWkVOKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdGZWF0dXJlIGZsYWdzIGNhbiBvbmx5IGJlIGRpc2FibGVkIGJlZm9yZSBFbmdpbmUgY29uc3RydWN0b3IgdGltZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGbGFncy5fRkxBR1NbZmxhZ05hbWVdID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgZmxhZyBpcyBlbmFibGVkLiBJZiB0aGUgZmxhZyBpcyBkaXNhYmxlZCBvciBkb2VzIG5vdCBleGlzdCBgZmFsc2VgIGlzIHJldHVybmVkXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW5hYmxlZChmbGFnTmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhIUZsYWdzLl9GTEFHU1tmbGFnTmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgYSBsaXN0IG9mIGN1cnJlbnRseSBrbm93biBmbGFnc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2hvdygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoRmxhZ3MuX0ZMQUdTKTtcclxuICAgIH1cclxufVxyXG5GbGFncy5fRlJPWkVOID0gZmFsc2U7XHJcbkZsYWdzLl9GTEFHUyA9IHt9O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lkLnRzXG4vKipcclxuICogQ3JlYXRlIGEgYnJhbmRlZCBJRCB0eXBlIGZyb20gYSBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUlkKHR5cGUsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlLCB2YWx1ZSB9O1xyXG59XHJcbjtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL1JhbmRvbS50c1xuLyoqXHJcbiAqIEBtb2R1bGVcclxuICogUHNldWRvLVJhbmRvbSBVdGlsaXR5XHJcbiAqXHJcbiAqIEEgcHNldWRvLXJhbmRvbSB1dGlsaXR5IHRvIGFkZCBzZWVkZWQgcmFuZG9tIHN1cHBvcnQgZm9yIGhlbHAgaW5cclxuICogZ2VuZXJhdGluZyB0aGluZ3MgbGlrZSB0ZXJyYWluIG9yIHJlcHJvZHVjaWJsZSByYW5kb21uZXNzLiBVc2VzIHRoZVxyXG4gKiBbTWVyc2VubmUgVHdpc3Rlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyc2VubmVfVHdpc3RlcikgYWxnb3JpdGhtLlxyXG4gKi9cclxuLyoqXHJcbiAqIDMyLWJpdCBtYXNrXHJcbiAqL1xyXG5jb25zdCBCSVRNQVNLMzIgPSAweGZmZmZmZmZmO1xyXG4vKipcclxuICogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZvbGxvd2luZyB0aGUgTWVyc2VubmVfVHdpc3RlciBhbGdvcml0aG0uIEdpdmVuIGEgc2VlZCB0aGlzIGdlbmVyYXRvciB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgc2VxdWVuY2VcclxuICogb2YgbnVtYmVycyBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxyXG4gKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVyc2VubmVfVHdpc3RlciBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKiBVc2VzIHRoZSBNVDE5OTM3LTMyICgyMDAyKSBpbXBsZW1lbnRhdGlvbiBkb2N1bWVudGVkIGhlcmUgaHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvTVQyMDAyL2VtdDE5OTM3YXIuaHRtbFxyXG4gKlxyXG4gKiBBcGkgaW5zcGlyZWQgYnkgaHR0cDovL2NoYW5jZWpzLmNvbS8jIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFuY2Vqcy9jaGFuY2Vqc1xyXG4gKi9cclxuY2xhc3MgUmFuZG9tIHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgbm8gc2VlZCBpcyBzcGVjaWZpZWQsIHRoZSBEYXRlLm5vdygpIGlzIHVzZWRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xyXG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XHJcbiAgICAgICAgLy8gU2VwYXJhdGlvbiBwb2ludCBvZiBvbmUgb25lIHdvcmQsIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgbG93ZXIgYml0bWFzayAwIDw9IHIgPD0gdy0xXHJcbiAgICAgICAgdGhpcy5fbG93ZXJNYXNrID0gMHg3ZmZmZmZmZjsgLy8gMzEgYml0cyBzYW1lIGFzIF9yXHJcbiAgICAgICAgdGhpcy5fdXBwZXJNYXNrID0gMHg4MDAwMDAwMDsgLy8gMzQgaGlnaCBiaXRzXHJcbiAgICAgICAgLy8gV29yZCBzaXplLCA2NCBiaXRzXHJcbiAgICAgICAgdGhpcy5fdyA9IDMyO1xyXG4gICAgICAgIC8vIERlZ3JlZSBvZiByZWN1cnJlbmNlXHJcbiAgICAgICAgdGhpcy5fbiA9IDYyNDtcclxuICAgICAgICAvLyBNaWRkbGUgd29yZCwgYW4gb2Zmc2V0IHVzZWQgaW4gdGhlIHJlY3VycmVuY2UgZGVmaW5pbmcgdGhlIHNlcmllcyB4LCAxPD1tPG5cclxuICAgICAgICB0aGlzLl9tID0gMzk3O1xyXG4gICAgICAgIC8vIGNvZWZmaWNpZW50cyBvZiB0ZWggcmF0aW9uYWwgbm9ybWFsIGZvcm0gdHdpc3QgbWF0cml4XHJcbiAgICAgICAgdGhpcy5fYSA9IDB4OTkwOGIwZGY7XHJcbiAgICAgICAgLy8gdGVtcGVyaW5nIGJpdCBzaGlmdHMgYW5kIG1hc2tzXHJcbiAgICAgICAgdGhpcy5fdSA9IDExO1xyXG4gICAgICAgIHRoaXMuX3MgPSA3O1xyXG4gICAgICAgIHRoaXMuX2IgPSAweDlkMmM1NjgwO1xyXG4gICAgICAgIHRoaXMuX3QgPSAxNTtcclxuICAgICAgICB0aGlzLl9jID0gMHhlZmM2MDAwMDtcclxuICAgICAgICB0aGlzLl9sID0gMTg7XHJcbiAgICAgICAgdGhpcy5fZiA9IDE4MTI0MzMyNTM7XHJcbiAgICAgICAgdGhpcy5fbXQgPSBuZXcgQXJyYXkodGhpcy5fbik7XHJcbiAgICAgICAgLy8gbmVlZCB0byBtYXNrIHRvIHN1cHBvcnQgaGlnaGVyIGJpdCBtYWNoaW5lc1xyXG4gICAgICAgIHRoaXMuX210WzBdID0gKHNlZWQgfHwgRGF0ZS5ub3coKSkgPj4+IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9uOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMuX210W2kgLSAxXSBeICh0aGlzLl9tdFtpIC0gMV0gPj4+ICh0aGlzLl93IC0gMikpO1xyXG4gICAgICAgICAgICAvLyBudW1iZXJzIGFyZSBiaWdnZXIgdGhhbiB0aGUgSlMgbWF4IHNhZmUgaW50LCBhZGQgaW4gMTYtYml0IGNodW5rcyB0byBwcmV2ZW50IElFRUUgcm91bmRpbmcgZXJyb3JzIG9uIGhpZ2ggYml0c1xyXG4gICAgICAgICAgICB0aGlzLl9tdFtpXSA9ICgoKHRoaXMuX2YgKiAoKHMgJiAweGZmZmYwMDAwKSA+Pj4gMTYpKSA8PCAxNikgKyB0aGlzLl9mICogKHMgJiAweGZmZmYpICsgaSkgPj4+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdGhlIHR3aXN0XHJcbiAgICAgKi9cclxuICAgIF90d2lzdCgpIHtcclxuICAgICAgICBjb25zdCBtYWcwMSA9IFsweDAsIHRoaXMuX2FdO1xyXG4gICAgICAgIGxldCB5ID0gMCwgaSA9IDA7XHJcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLl9uIC0gdGhpcy5fbTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbaV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210W2kgKyAxXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX210W2ldID0gdGhpcy5fbXRbaSArIHRoaXMuX21dIF4gKHkgPj4+IDEpIF4gKG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLl9uIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHkgPSAodGhpcy5fbXRbaV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210W2kgKyAxXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX210W2ldID0gdGhpcy5fbXRbaSArICh0aGlzLl9tIC0gdGhpcy5fbildIF4gKHkgPj4+IDEpIF4gKG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeSA9ICh0aGlzLl9tdFt0aGlzLl9uIC0gMV0gJiB0aGlzLl91cHBlck1hc2spIHwgKHRoaXMuX210WzBdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICB0aGlzLl9tdFt0aGlzLl9uIC0gMV0gPSB0aGlzLl9tdFt0aGlzLl9tIC0gMV0gXiAoeSA+Pj4gMSkgXiAobWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzIpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIG5leHQgMzIgYml0IGludGVnZXIgbnVtYmVyIGluIHNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIG5leHRJbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHdpc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHkgPSB0aGlzLl9tdFt0aGlzLl9pbmRleCsrXTtcclxuICAgICAgICB5IF49IHkgPj4+IHRoaXMuX3U7XHJcbiAgICAgICAgeSBePSAoeSA8PCB0aGlzLl9zKSAmIHRoaXMuX2I7XHJcbiAgICAgICAgeSBePSAoeSA8PCB0aGlzLl90KSAmIHRoaXMuX2M7XHJcbiAgICAgICAgeSBePSB5ID4+PiB0aGlzLl9sO1xyXG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gWzAsIDEpXHJcbiAgICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEludCgpICogKDEuMCAvIDQyOTQ5NjcyOTYuMCk7IC8vIGRpdmlkZWQgYnkgMl4zMlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgaW4gcmFuZ2UgW21pbiwgbWF4KSBtaW4gaXMgaW5jbHVkZWQsIG1heCBpcyBub3QgaW5jbHVkZWRcclxuICAgICAqL1xyXG4gICAgZmxvYXRpbmcobWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gKG1heCAtIG1pbikgKiB0aGlzLm5leHQoKSArIG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgaW4gcmFuZ2UgW21pbiwgbWF4XSBtaW4gaXMgaW5jbHVkZWQsIG1heCBpcyBpbmNsdWRlZC5cclxuICAgICAqIEltcGxlbWVudGVkIHdpdGggcmVqZWN0aW9uIHNhbXBsaW5nLCBzZWUgaHR0cHM6Ly9tZWRpdW0uY29tL0BiZXRhYmxlL3RpZnUtYnktdXNpbmctbWF0aC1yYW5kb20tZjFjMzA4YzRmZDlkIy5pMTN0ZGl1NWFcclxuICAgICAqL1xyXG4gICAgaW50ZWdlcihtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChtYXggLSBtaW4gKyAxKSAqIHRoaXMubmV4dCgpICsgbWluKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHJhbmRvbWx5IHdpdGggNTAvNTAgb2RkcyBieSBkZWZhdWx0LlxyXG4gICAgICogQnkgZGVmYXVsdCB0aGUgbGlrZWxpaG9vZCBvZiByZXR1cm5pbmcgYSB0cnVlIGlzIC41ICg1MCUpLlxyXG4gICAgICogQHBhcmFtIGxpa2VsaWhvb2QgdGFrZXMgdmFsdWVzIGJldHdlZW4gWzAsIDFdXHJcbiAgICAgKi9cclxuICAgIGJvb2wobGlrZWxpaG9vZCA9IDAuNSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKSA8PSBsaWtlbGlob29kO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG9uZSBlbGVtZW50IGZyb20gYW4gYXJyYXkgYXQgcmFuZG9tXHJcbiAgICAgKi9cclxuICAgIHBpY2tPbmUoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlbdGhpcy5pbnRlZ2VyKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb20gcGlja2luZyBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHBhcmFtIGFycmF5IE9yaWdpbmFsIGFycmF5IHRvIHBpY2sgZnJvbVxyXG4gICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0gYWxsb3dEdXBsaWNhdGVzIGluZGljYXRlcyB3aGV0aGVyIHRoZSByZXR1cm5lZCBzZXQgaXMgYWxsb3dlZCBkdXBsaWNhdGVzIChpdCBkb2VzIG5vdCBtZWFuIHRoZXJlIHdpbGwgYWx3YXlzIGJlIGR1cGxpY2F0ZXNcclxuICAgICAqIGp1c3QgdGhhdCBpdCBpcyBwb3NzaWJsZSlcclxuICAgICAqL1xyXG4gICAgcGlja1NldChhcnJheSwgbnVtUGlja3MsIGFsbG93RHVwbGljYXRlcyA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKGFsbG93RHVwbGljYXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGlja1NldFdpdGhEdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGlja1NldFdpdGhvdXREdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbWx5IHBpY2tpbmcgZWxlbWVudHMgaW4gdGhlIG9yaWdpbmFsIChub3QgcmV1c2VkKVxyXG4gICAgICogQHBhcmFtIGFycmF5IEFycmF5IHRvIHBpY2sgZWxlbWVudHMgb3V0IG9mXHJcbiAgICAgKiBAcGFyYW0gbnVtUGlja3MgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIF9waWNrU2V0V2l0aG91dER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKSB7XHJcbiAgICAgICAgaWYgKG51bVBpY2tzID4gYXJyYXkubGVuZ3RoIHx8IG51bVBpY2tzIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBpY2ssIG11c3QgcGljayBhIHZhbHVlIDAgPCBuIDw9IGxlbmd0aCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnVtUGlja3MgPT09IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShudW1QaWNrcyk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQaWNrID0gMDtcclxuICAgICAgICBjb25zdCB0ZW1wQXJyYXkgPSBhcnJheS5zbGljZSgwKTtcclxuICAgICAgICB3aGlsZSAoY3VycmVudFBpY2sgPCBudW1QaWNrcykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW50ZWdlcigwLCB0ZW1wQXJyYXkubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW50UGljaysrXSA9IHRlbXBBcnJheVtpbmRleF07XHJcbiAgICAgICAgICAgIHRlbXBBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbSBwaWNraW5nIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsIGFsbG93aW5nIGR1cGxpY2F0ZXNcclxuICAgICAqIEBwYXJhbSBhcnJheSBBcnJheSB0byBwaWNrIGVsZW1lbnRzIG91dCBvZlxyXG4gICAgICogQHBhcmFtIG51bVBpY2tzIGNhbiBiZSBhbnkgcG9zaXRpdmUgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIF9waWNrU2V0V2l0aER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKSB7XHJcbiAgICAgICAgLy8gVHlwZXNjcmlwdCBudW1iZXJzIGFyZSBhbGwgZmxvYXRpbmcgcG9pbnQsIHNvIGRvIHdlIGFkZCBjaGVjayBmb3IgaW50PyAob3IgZmxvb3IgdGhlIGlucHV0PylcclxuICAgICAgICBpZiAobnVtUGlja3MgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGljaywgbXVzdCBwaWNrIGEgdmFsdWUgMCA8PSBuIDwgTUFYX0lOVCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobnVtUGlja3MpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGlja3M7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLnBpY2tPbmUoYXJyYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHRoYXQgaGFzIGl0cyBlbGVtZW50cyBzaHVmZmxlZC4gVXNpbmcgdGhlIEZpc2hlci9ZYXRlcyBtZXRob2RcclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlciVFMiU4MCU5M1lhdGVzX3NodWZmbGVcclxuICAgICAqL1xyXG4gICAgc2h1ZmZsZShhcnJheSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXBBcnJheSA9IGFycmF5LnNsaWNlKDApO1xyXG4gICAgICAgIGxldCBzd2FwID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBBcnJheS5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSB0aGlzLmludGVnZXIoaSwgdGVtcEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBzd2FwID0gdGVtcEFycmF5W2ldO1xyXG4gICAgICAgICAgICB0ZW1wQXJyYXlbaV0gPSB0ZW1wQXJyYXlbcmFuZG9tSW5kZXhdO1xyXG4gICAgICAgICAgICB0ZW1wQXJyYXlbcmFuZG9tSW5kZXhdID0gc3dhcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlbXBBcnJheTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSBsaXN0IG9mIHJhbmRvbSBpbnRlZ2VyIG51bWJlcnNcclxuICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgZmluYWwgYXJyYXlcclxuICAgICAqIEBwYXJhbSBtaW4gdGhlIG1pbmltdW0gaW50ZWdlciBudW1iZXIgdG8gZ2VuZXJhdGUgaW5jbHVzaXZlXHJcbiAgICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGludGVnZXIgbnVtYmVyIHRvIGdlbmVyYXRlIGluY2x1c2l2ZVxyXG4gICAgICovXHJcbiAgICByYW5nZShsZW5ndGgsIG1pbiwgbWF4KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLmludGVnZXIobWluLCBtYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkNCBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDYgZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQ2KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgNik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ4IGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkOCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMTAgZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQxMCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDEwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDEyIGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkMTIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAxMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQyMCBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDIwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMjApO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC91dGlsLnRzXG5cclxuLyoqXHJcbiAqIFR3byBQSSBjb25zdGFudFxyXG4gKi9cclxuY29uc3QgVHdvUEkgPSBNYXRoLlBJICogMjtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiBhIG51bWJlclxyXG4gKiBAcGFyYW0geFxyXG4gKi9cclxuZnVuY3Rpb24gZnJhYyh4KSB7XHJcbiAgICBpZiAoeCA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmNlaWwoeCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXIsIGlmIDAgcmV0dXJucyAwXHJcbiAqL1xyXG5mdW5jdGlvbiBzaWduKHZhbCkge1xyXG4gICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbCA8IDAgPyAtMSA6IDE7XHJcbn1cclxuO1xyXG4vKipcclxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsKSwgbWF4KTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBhbiBhbmdsZSB0byBiZSB0aGUgZXF1aXZhbGVudCBpbiB0aGUgcmFuZ2UgWzAsIDJQSV1cclxuICovXHJcbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKSB7XHJcbiAgICBsZXQgdG1wQW5nbGUgPSBhbmdsZTtcclxuICAgIGlmIChhbmdsZSA+IFR3b1BJKSB7XHJcbiAgICAgICAgd2hpbGUgKHRtcEFuZ2xlID4gVHdvUEkpIHtcclxuICAgICAgICAgICAgdG1wQW5nbGUgLT0gVHdvUEk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFuZ2xlIDwgMCkge1xyXG4gICAgICAgIHdoaWxlICh0bXBBbmdsZSA8IDApIHtcclxuICAgICAgICAgICAgdG1wQW5nbGUgKz0gVHdvUEk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRtcEFuZ2xlO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xyXG4gKi9cclxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcclxuICAgIHJldHVybiAoMTgwIC8gTWF0aC5QSSkgKiByYWRpYW5zO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xyXG4gKi9cclxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcclxuICAgIHJldHVybiAoZGVncmVlcyAvIDE4MCkgKiBNYXRoLlBJO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHJhbmdlIG9mIG51bWJlcnNcclxuICogRm9yIGV4YW1wbGU6IHJhbmdlKDAsIDUpIC0+IFswLCAxLCAyLCAzLCA0LCA1XVxyXG4gKiBAcGFyYW0gZnJvbSBpbmNsdXNpdmVcclxuICogQHBhcmFtIHRvIGluY2x1c2l2ZVxyXG4gKi9cclxuY29uc3QgcmFuZ2UgPSAoZnJvbSwgdG8pID0+IEFycmF5LmZyb20obmV3IEFycmF5KHRvIC0gZnJvbSArIDEpLCAoX3gsIGkpID0+IGkgKyBmcm9tKTtcclxuLyoqXHJcbiAqIEZpbmQgYSByYW5kb20gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIHJhbmdlXHJcbiAqL1xyXG5mdW5jdGlvbiByYW5kb21JblJhbmdlKG1pbiwgbWF4LCByYW5kb20gPSBuZXcgUmFuZG9tKCkpIHtcclxuICAgIHJldHVybiByYW5kb20gPyByYW5kb20uZmxvYXRpbmcobWluLCBtYXgpIDogbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kIGEgcmFuZG9tIGludGVnZXIgaW4gYSByYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShtaW4sIG1heCwgcmFuZG9tID0gbmV3IFJhbmRvbSgpKSB7XHJcbiAgICByZXR1cm4gcmFuZG9tID8gcmFuZG9tLmludGVnZXIobWluLCBtYXgpIDogTWF0aC5yb3VuZChyYW5kb21JblJhbmdlKG1pbiwgbWF4KSk7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3ZlY3Rvci50c1xuXHJcbi8qKlxyXG4gKiBBIDJEIHZlY3RvciBvbiBhIHBsYW5lLlxyXG4gKi9cclxuY2xhc3MgVmVjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHggIFggY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcclxuICAgICAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcclxuICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICB0aGlzLl95ID0gMDtcclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSAoMCwgMCkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgWmVybygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSAoMSwgMSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgT25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDEsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBICgwLjUsIDAuNSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgSGFsZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLjUsIDAuNSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdXAgKDAsIC0xKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFVwKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIC0xKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyBkb3duICgwLCAxKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERvd24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgbGVmdCAoLTEsIDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgTGVmdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigtMSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgcmlnaHQgKDEsIDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgUmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdW5pdCBsZW5ndGggaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGFuZ2xlIGluIFJhZGlhbnMuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIGdlbmVyYXRlIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21BbmdsZShhbmdsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHZlY3RvciBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBvciBpZiBhbnkgb2YgaXRzIGNvbXBvbmVudHMgYXJlIE5hTiBvciBJbmZpbml0eS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVmFsaWQodmVjKSB7XHJcbiAgICAgICAgaWYgKHZlYyA9PT0gbnVsbCB8fCB2ZWMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTih2ZWMueCkgfHwgaXNOYU4odmVjLnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlYy54ID09PSBJbmZpbml0eSB8fCB2ZWMueSA9PT0gSW5maW5pdHkgfHwgdmVjLnggPT09IC1JbmZpbml0eSB8fCB2ZWMueSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgZGlzdGFuY2UgYmV0d2VlbiB0d28gVmVjdG9yc1xyXG4gICAgICogQHBhcmFtIHZlYzFcclxuICAgICAqIEBwYXJhbSB2ZWMyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkaXN0YW5jZSh2ZWMxLCB2ZWMyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2ZWMxLnggLSB2ZWMyLngsIDIpICsgTWF0aC5wb3codmVjMS55IC0gdmVjMi55LCAyKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWluKHZlYzEsIHZlYzIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLm1pbih2ZWMxLngsIHZlYzIueCksIE1hdGgubWluKHZlYzEueSwgdmVjMi55KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF4KHZlYzEsIHZlYzIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLm1heCh2ZWMxLngsIHZlYzIueCksIE1hdGgubWF4KHZlYzEueSwgdmVjMi55KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB4IGNvbXBvbmVudCwgVEhJUyBNVVRBVEVTIHRoZSBjdXJyZW50IHZlY3Rvci4gSXQgaXMgdXN1YWxseSBiZXR0ZXIgdG8gY3JlYXRlIGEgbmV3IHZlY3Rvci5cclxuICAgICAqIEB3YXJuaW5nICoqQmUgdmVyeSBjYXJlZnVsIHNldHRpbmcgY29tcG9uZW50cyBvbiBzaGFyZWQgdmVjdG9ycywgbXV0YXRpbmcgc2hhcmVkIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzKipcclxuICAgICAqL1xyXG4gICAgc2V0IHgodmFsKSB7XHJcbiAgICAgICAgdGhpcy5feCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHkgY29tcG9uZW50LCBUSElTIE1VVEFURVMgdGhlIGN1cnJlbnQgdmVjdG9yLiBJdCBpcyB1c3VhbGx5IGJldHRlciB0byBjcmVhdGUgYSBuZXcgdmVjdG9yLlxyXG4gICAgICogQHdhcm5pbmcgKipCZSB2ZXJ5IGNhcmVmdWwgc2V0dGluZyBjb21wb25lbnRzIG9uIHNoYXJlZCB2ZWN0b3JzLCBtdXRhdGluZyBzaGFyZWQgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3MqKlxyXG4gICAgICovXHJcbiAgICBzZXQgeSh2YWwpIHtcclxuICAgICAgICB0aGlzLl95ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB4IGFuZCB5IGNvbXBvbmVudHMgYXQgb25jZSwgVEhJUyBNVVRBVEVTIHRoZSBjdXJyZW50IHZlY3Rvci4gSXQgaXMgdXN1YWxseSBiZXR0ZXIgdG8gY3JlYXRlIGEgbmV3IHZlY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAd2FybmluZyAqKkJlIHZlcnkgY2FyZWZ1bCB1c2luZyB0aGlzLCBtdXRhdGluZyB2ZWN0b3JzIGNhbiBjYXVzZSBoYXJkIHRvIGZpbmQgYnVncyoqXHJcbiAgICAgKi9cclxuICAgIHNldFRvKHgsIHkpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgcG9pbnQgYWdhaW5zdCBhbm90aGVyIGFuZCB0ZXN0cyBmb3IgZXF1YWxpdHlcclxuICAgICAqIEBwYXJhbSB2ZWN0b3IgVGhlIG90aGVyIHBvaW50IHRvIGNvbXBhcmUgdG9cclxuICAgICAqIEBwYXJhbSB0b2xlcmFuY2UgQW1vdW50IG9mIGV1Y2xpZGVhbiBkaXN0YW5jZSBvZmYgd2UgYXJlIHdpbGxpbmcgdG8gdG9sZXJhdGVcclxuICAgICAqL1xyXG4gICAgZXF1YWxzKHZlY3RvciwgdG9sZXJhbmNlID0gMC4wMDEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdmVjdG9yLngpIDw9IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh0aGlzLnkgLSB2ZWN0b3IueSkgPD0gdG9sZXJhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciB2ZWN0b3IuIElmIG5vIG90aGVyIFZlY3RvciBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCByZXR1cm4gdGhlIFtbbWFnbml0dWRlXV0uXHJcbiAgICAgKiBAcGFyYW0gdiAgVGhlIG90aGVyIHZlY3Rvci4gTGVhdmUgYmxhbmsgdG8gdXNlIG9yaWdpbiB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlKHYpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLnggLSB2Lng7XHJcbiAgICAgICAgY29uc3QgZGVsdGFZID0gdGhpcy55IC0gdi55O1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcclxuICAgIH1cclxuICAgIHNxdWFyZURpc3RhbmNlKHYpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgdiA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLnggLSB2Lng7XHJcbiAgICAgICAgY29uc3QgZGVsdGFZID0gdGhpcy55IC0gdi55O1xyXG4gICAgICAgIHJldHVybiBkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgY3VycmVudCB2ZWN0b3IncyBtYWduaXR1ZGUgbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSBtYWduaXR1ZGVcclxuICAgICAqL1xyXG4gICAgY2xhbXBNYWduaXR1ZGUobWFnbml0dWRlKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcclxuICAgICAgICBjb25zdCBuZXdTaXplID0gY2xhbXAoc2l6ZSwgMCwgbWFnbml0dWRlKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2l6ZSAobWFnbml0dWRlKSBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgdGhlIHNpemUgbXV0YXRlcyB0aGUgY3VycmVudCB2ZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAd2FybmluZyBDYW4gYmUgdXNlZCB0byBzZXQgdGhlIHNpemUgb2YgdGhlIHZlY3RvciwgKipiZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3MqKlxyXG4gICAgICovXHJcbiAgICBzZXQgc2l6ZShuZXdMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCB2ID0gdGhpcy5ub3JtYWxpemUoKS5zY2FsZShuZXdMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuc2V0VG8odi54LCB2LnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cclxuICAgICAqL1xyXG4gICAgbm9ybWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGQsIHRoaXMueSAvIGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIChtaWRwb2ludCkgYmV0d2VlbiB0aGUgY3VycmVudCBwb2ludCBhbmQgdGhlIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBhdmVyYWdlKHZlYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh2ZWMpLnNjYWxlKDAuNSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZShzaXplT3JTY2FsZSwgZGVzdCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlc3QgfHwgbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICBpZiAoc2l6ZU9yU2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnggPSB0aGlzLnggKiBzaXplT3JTY2FsZS54O1xyXG4gICAgICAgICAgICByZXN1bHQueSA9IHRoaXMueSAqIHNpemVPclNjYWxlLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQueCA9IHRoaXMueCAqIHNpemVPclNjYWxlO1xyXG4gICAgICAgICAgICByZXN1bHQueSA9IHRoaXMueSAqIHNpemVPclNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gYW5vdGhlclxyXG4gICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBhZGRcclxuICAgICAqIEBwYXJhbSBkZXN0IE9wdGlvbmFsbHkgY29weSB0aGUgcmVzdWx0IGludG8gYSBwcm92aWRlZCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgYWRkKHYsIGRlc3QpIHtcclxuICAgICAgICBpZiAoZGVzdCkge1xyXG4gICAgICAgICAgICBkZXN0LnggPSB0aGlzLnggKyB2Lng7XHJcbiAgICAgICAgICAgIGRlc3QueSA9IHRoaXMueSArIHYueTtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciwgaWYgeW91IHN1YnRyYWN0IHZlY3RvciBgQi5zdWIoQSlgIHRoZSByZXN1bHRpbmcgdmVjdG9yIHBvaW50cyBmcm9tIEEgLT4gQlxyXG4gICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICovXHJcbiAgICBzdWIodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYWRkXHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgYWRkRXF1YWwodikge1xyXG4gICAgICAgIHRoaXMuc2V0VG8odGhpcy54ICsgdi54LCB0aGlzLnkgKyB2LnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSB0aGlzIG9uZSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgc3ViRXF1YWwodikge1xyXG4gICAgICAgIHRoaXMuc2V0VG8odGhpcy54IC0gdi54LCB0aGlzLnkgLSB2LnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhpcyB2ZWN0b3IgYnkgYSBmYWN0b3Igb2Ygc2l6ZSBhbmQgbW9kaWZpZXMgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgc2NhbGVFcXVhbChzaXplKSB7XHJcbiAgICAgICAgdGhpcy5zZXRUbyh0aGlzLnggKiBzaXplLCB0aGlzLnkgKiBzaXplKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBkb3QgcHJvZHVjdCB3aXRoIGFub3RoZXIgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0gdiAgVGhlIHZlY3RvciB0byBkb3RcclxuICAgICAqL1xyXG4gICAgZG90KHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG4gICAgfVxyXG4gICAgY3Jvc3Modikge1xyXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih2ICogdGhpcy55LCAtdiAqIHRoaXMueCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyb3NzKG51bSwgdmVjKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLW51bSAqIHZlYy55LCBudW0gKiB2ZWMueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIHRoaXMgb25lXHJcbiAgICAgKi9cclxuICAgIHBlcnBlbmRpY3VsYXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy55LCAtdGhpcy54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZSwgc2FtZSBhcyB0aGUgcGVycGVuZGljdWxhciBvZiBsZW5ndGggMVxyXG4gICAgICovXHJcbiAgICBub3JtYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVycGVuZGljdWxhcigpLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGUgdGhlIGN1cnJlbnQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIG5lZ2F0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgtMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICB0b0FuZ2xlKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGUgY3VycmVudCB2ZWN0b3IgYXJvdW5kIGEgcG9pbnQgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxyXG4gICAgICogZGVncmVlcyBpbiByYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XHJcbiAgICAgICAgaWYgKCFhbmNob3IpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgeCA9IGNvc0FuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSAtIHNpbkFuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci54O1xyXG4gICAgICAgIGNvbnN0IHkgPSBzaW5BbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgKyBjb3NBbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCB5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgcHJldmlvdXMuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKGRlc3QpIHtcclxuICAgICAgICBjb25zdCB2ID0gZGVzdCAhPT0gbnVsbCAmJiBkZXN0ICE9PSB2b2lkIDAgPyBkZXN0IDogbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB2LnggPSB0aGlzLng7XHJcbiAgICAgICAgdi55ID0gdGhpcy55O1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKGZpeGVkKSB7XHJcbiAgICAgICAgaWYgKGZpeGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgKCR7dGhpcy54LnRvRml4ZWQoZml4ZWQpfSwgJHt0aGlzLnkudG9GaXhlZChmaXhlZCl9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgKCR7dGhpcy54fSwgJHt0aGlzLnl9KWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNob3J0aGFuZCBmb3IgY3JlYXRpbmcgbmV3IFZlY3RvcnMgLSByZXR1cm5zIGEgbmV3IFZlY3RvciBpbnN0YW5jZSB3aXRoIHRoZVxyXG4gKiBwcm92aWRlZCBYIGFuZCBZIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB4ICBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiB2ZWMoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSk7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0xvZy50c1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4vKipcclxuICogTG9nZ2luZyBsZXZlbCB0aGF0IEV4Y2FsaWJ1ciB3aWxsIHRhZ1xyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMF0gPSBcIkRlYnVnXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuXCJdID0gMl0gPSBcIldhcm5cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuLyoqXHJcbiAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXHJcbiAqIEV4Y2FsaWJ1ciBjb21lcyBidWlsdC1pbiB3aXRoIGEgW1tDb25zb2xlQXBwZW5kZXJdXSBhbmQgW1tTY3JlZW5BcHBlbmRlcl1dLlxyXG4gKiBEZXJpdmUgZnJvbSBbW0FwcGVuZGVyXV0gdG8gY3JlYXRlIHlvdXIgb3duIGxvZ2dpbmcgYXBwZW5kZXJzLlxyXG4gKi9cclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLiBFeGNhbGlidXIgd2lsbCBvbmx5IGxvZ1xyXG4gICAgICAgICAqIG1lc3NhZ2VzIGlmIGVxdWFsIHRvIG9yIGFib3ZlIHRoaXMgbGV2ZWwuIERlZmF1bHQ6IFtbTG9nTGV2ZWwuSW5mb11dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgPSBMb2dMZXZlbC5JbmZvO1xyXG4gICAgICAgIGlmIChMb2dnZXIuX0lOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIGlzIGEgc2luZ2xldG9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExvZ2dlci5fSU5TVEFOQ0UgPSB0aGlzO1xyXG4gICAgICAgIC8vIERlZmF1bHQgY29uc29sZSBhcHBlbmRlclxyXG4gICAgICAgIExvZ2dlci5fSU5TVEFOQ0UuYWRkQXBwZW5kZXIobmV3IENvbnNvbGVBcHBlbmRlcigpKTtcclxuICAgICAgICByZXR1cm4gTG9nZ2VyLl9JTlNUQU5DRTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aWMgaW5zdGFuY2Ugb2YgTG9nZ2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoTG9nZ2VyLl9JTlNUQU5DRSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5fSU5TVEFOQ0UgPSBuZXcgTG9nZ2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBMb2dnZXIuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFtbQXBwZW5kZXJdXSB0byB0aGUgbGlzdCBvZiBhcHBlbmRlcnMgdG8gd3JpdGUgdG9cclxuICAgICAqL1xyXG4gICAgYWRkQXBwZW5kZXIoYXBwZW5kZXIpIHtcclxuICAgICAgICB0aGlzLl9hcHBlbmRlcnMucHVzaChhcHBlbmRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgYXBwZW5kZXJzIGZyb20gdGhlIGxvZ2dlclxyXG4gICAgICovXHJcbiAgICBjbGVhckFwcGVuZGVycygpIHtcclxuICAgICAgICB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBMb2dMZXZlbFxyXG4gICAgICogQHBhcmFtIGxldmVsICBUaGUgTG9nTGV2ZWxgdG8gbG9nIHRoZSBtZXNzYWdlIGF0XHJcbiAgICAgKiBAcGFyYW0gYXJncyAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byB3cml0ZSB0byBhbiBhcHBlbmRlclxyXG4gICAgICovXHJcbiAgICBfbG9nKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmRlZmF1bHRMZXZlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYXBwZW5kZXJzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSB0aGlzLmRlZmF1bHRMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzW2ldLmxvZyhsZXZlbCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkRlYnVnXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRGVidWcsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5JbmZvXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5JbmZvLCBhcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuV2Fybl1dIGxldmVsXHJcbiAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuV2FybiwgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkVycm9yXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGVycm9yKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRXJyb3IsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5GYXRhbF1dIGxldmVsXHJcbiAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBmYXRhbCguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkZhdGFsLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5Mb2dnZXIuX0lOU1RBTkNFID0gbnVsbDtcclxuLyoqXHJcbiAqIENvbnNvbGUgYXBwZW5kZXIgZm9yIGJyb3dzZXJzIChpLmUuIGBjb25zb2xlLmxvZ2ApXHJcbiAqL1xyXG5jbGFzcyBDb25zb2xlQXBwZW5kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgKi9cclxuICAgIGxvZyhsZXZlbCwgYXJncykge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBjb25zb2xlIHN1cHBvcnRcclxuICAgICAgICBpZiAoIWNvbnNvbGUgJiYgIWNvbnNvbGUubG9nICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XHJcbiAgICAgICAgY29uc3QgY29uc29sZUFyZ3MgPSBbXTtcclxuICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0LmFwcGx5KGNvbnNvbGVBcmdzLCBhcmdzKTtcclxuICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyk7XHJcbiAgICAgICAgaWYgKGxldmVsIDwgTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICAvLyBDYWxsIC5sb2cgZm9yIERlYnVnL0luZm9cclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIG9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGFwcGx5IG9uIGNvbnNvbGUubG9nIDooXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxldmVsIDwgTG9nTGV2ZWwuRXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ2FsbCAud2FybiBmb3IgV2FyblxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS53YXJuLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgLmVycm9yIGZvciBFcnJvci9GYXRhbFxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvci5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE9uLXNjcmVlbiAoY2FudmFzKSBhcHBlbmRlclxyXG4gKi9cclxuY2xhc3MgU2NyZWVuQXBwZW5kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggICBXaWR0aCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xyXG4gICAgICogQHBhcmFtIGhlaWdodCAgSGVpZ2h0IG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAvLyBAdG9kbyBDbGVhbiB0aGlzIHVwXHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgKi9cclxuICAgIGxvZyhsZXZlbCwgYXJncykge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzLmpvaW4oJywnKTtcclxuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMudW5zaGlmdCgnWycgKyBMb2dMZXZlbFtsZXZlbF0gKyAnXSA6ICcgKyBtZXNzYWdlKTtcclxuICAgICAgICBsZXQgcG9zID0gMTA7XHJcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIG9wYWNpdHkudG9GaXhlZCgyKSArICcpJztcclxuICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHRoaXMuX21lc3NhZ2VzW2ldLCAyMDAsIHBvcyk7XHJcbiAgICAgICAgICAgIHBvcyArPSAxMDtcclxuICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgPiAwID8gb3BhY2l0eSAtIDAuMDUgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbG9yLnRzXG4vKipcclxuICogUHJvdmlkZXMgc3RhbmRhcmQgY29sb3JzIChlLmcuIFtbQ29sb3IuQmxhY2tdXSlcclxuICogYnV0IHlvdSBjYW4gYWxzbyBjcmVhdGUgY3VzdG9tIGNvbG9ycyB1c2luZyBSR0IsIEhTTCwgb3IgSGV4LiBBbHNvIHByb3ZpZGVzXHJcbiAqIHVzZWZ1bCBjb2xvciBvcGVyYXRpb25zIGxpa2UgW1tDb2xvci5saWdodGVuXV0sIFtbQ29sb3IuZGFya2VuXV0sIGFuZCBtb3JlLlxyXG4gKi9cclxuY2xhc3MgQ29sb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByICBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gZyAgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gYiAgVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBhICBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IociwgZywgYiwgYSkge1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYSA9IGEgIT0gbnVsbCA/IGEgOiAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByICBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gZyAgVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gYiAgVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBhICBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21SR0IociwgZywgYiwgYSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhIHJnYiBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyaW5nICBDU1MgY29sb3Igc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMSkgb3IgcmdiKDI1NSwgMjU1LCAyNTUpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUkdCU3RyaW5nKHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHJnYmFSZWdFeCA9IC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKS9pO1xyXG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XHJcbiAgICAgICAgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaChyZ2JhUmVnRXgpKSkge1xyXG4gICAgICAgICAgICBjb25zdCByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApO1xyXG4gICAgICAgICAgICBsZXQgYSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmdiL2Egc3RyaW5nOiAnICsgc3RyaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhIGhleCBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaGV4ICBDU1MgY29sb3Igc3RyaW5nIG9mIHRoZSBmb3JtICNmZmZmZmYsIHRoZSBhbHBoYSBjb21wb25lbnQgaXMgb3B0aW9uYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XHJcbiAgICAgICAgY29uc3QgaGV4UmVnRXggPSAvXiM/KFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KT8kL2k7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcclxuICAgICAgICBpZiAoKG1hdGNoID0gaGV4Lm1hdGNoKGhleFJlZ0V4KSkpIHtcclxuICAgICAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTYpO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcclxuICAgICAgICAgICAgbGV0IGEgPSAxO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChtYXRjaFs0XSwgMTYpIC8gMjU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZzogJyArIGhleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gaHNsYSB2YWx1ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaCAgSHVlIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgKiBAcGFyYW0gcyAgU2F0dXJhdGlvbiBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICogQHBhcmFtIGwgIEx1bWluYW5jZSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICogQHBhcmFtIGEgIEFscGhhIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSFNMKGgsIHMsIGwsIGEgPSAxLjApIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWdodGVucyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGxpZ2h0ZW4gYnkgWzAtMV1cclxuICAgICAqL1xyXG4gICAgbGlnaHRlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0ZW1wLmwgKz0gKDEgLSB0ZW1wLmwpICogZmFjdG9yO1xyXG4gICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEYXJrZW5zIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gZGFya2VuIGJ5IFswLTFdXHJcbiAgICAgKi9cclxuICAgIGRhcmtlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0ZW1wLmwgLT0gdGVtcC5sICogZmFjdG9yO1xyXG4gICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXR1cmF0ZXMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBzYXR1cmF0ZSBieSBbMC0xXVxyXG4gICAgICovXHJcbiAgICBzYXR1cmF0ZShmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0ZW1wLnMgKz0gdGVtcC5zICogZmFjdG9yO1xyXG4gICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNhdHVyYXRlcyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGRlc2F0dXJhdGUgYnkgWzAtMV1cclxuICAgICAqL1xyXG4gICAgZGVzYXR1cmF0ZShmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICBjb25zdCB0ZW1wID0gSFNMQ29sb3IuZnJvbVJHQkEodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgICAgICB0ZW1wLnMgLT0gdGVtcC5zICogZmFjdG9yO1xyXG4gICAgICAgIHJldHVybiB0ZW1wLnRvUkdCQSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIGEgY29sb3IgYnkgYW5vdGhlciwgcmVzdWx0cyBpbiBhIGRhcmtlciBjb2xvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIG11bHRpcGx5KGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UiA9ICgoKGNvbG9yLnIgLyAyNTUpICogdGhpcy5yKSAvIDI1NSkgKiAyNTU7XHJcbiAgICAgICAgY29uc3QgbmV3RyA9ICgoKGNvbG9yLmcgLyAyNTUpICogdGhpcy5nKSAvIDI1NSkgKiAyNTU7XHJcbiAgICAgICAgY29uc3QgbmV3QiA9ICgoKGNvbG9yLmIgLyAyNTUpICogdGhpcy5iKSAvIDI1NSkgKiAyNTU7XHJcbiAgICAgICAgY29uc3QgbmV3QSA9IGNvbG9yLmEgKiB0aGlzLmE7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXdSLCBuZXdHLCBuZXdCLCBuZXdBKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NyZWVucyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBsaWdodGVyIGNvbG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAqL1xyXG4gICAgc2NyZWVuKGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29sb3IxID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgY29uc3QgY29sb3IyID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yMS5tdWx0aXBseShjb2xvcjIpLmludmVydCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnRzIHRoZSBjdXJyZW50IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGludmVydCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKDI1NSAtIHRoaXMuciwgMjU1IC0gdGhpcy5nLCAyNTUgLSB0aGlzLmIsIDEuMCAtIHRoaXMuYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF2ZXJhZ2VzIHRoZSBjdXJyZW50IGNvbG9yIHdpdGggYW5vdGhlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGF2ZXJhZ2UoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBuZXdSID0gKGNvbG9yLnIgKyB0aGlzLnIpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdHID0gKGNvbG9yLmcgKyB0aGlzLmcpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdCID0gKGNvbG9yLmIgKyB0aGlzLmIpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdBID0gKGNvbG9yLmEgKyB0aGlzLmEpIC8gMjtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ld1IsIG5ld0csIG5ld0IsIG5ld0EpO1xyXG4gICAgfVxyXG4gICAgZXF1YWwoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpID09PSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb3JtYXQgQ29sb3IgcmVwcmVzZW50YXRpb24sIGFjY2VwdHM6IHJnYiwgaHNsLCBvciBoZXhcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoZm9ybWF0ID0gJ3JnYicpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SR0JBKCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hTTEEoKTtcclxuICAgICAgICAgICAgY2FzZSAnaGV4JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ29sb3IgZm9ybWF0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIEhleCBWYWx1ZSBvZiBhIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIGMgY29sb3IgY29tcG9uZW50XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYlxyXG4gICAgICovXHJcbiAgICBfY29tcG9uZW50VG9IZXgoYykge1xyXG4gICAgICAgIGNvbnN0IGhleCA9IGMudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gSGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHRvSGV4KCkge1xyXG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLnIpICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5nKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuYik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBSR0JBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHRvUkdCQSgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBTdHJpbmcodGhpcy5yLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmcudG9GaXhlZCgwKSkgKyAnLCAnICsgU3RyaW5nKHRoaXMuYi50b0ZpeGVkKDApKTtcclxuICAgICAgICBpZiAodGhpcy5hICE9PSB1bmRlZmluZWQgfHwgdGhpcy5hICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmVzdWx0ICsgJywgJyArIFN0cmluZyh0aGlzLmEpICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ3JnYignICsgcmVzdWx0ICsgJyknO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gSFNMQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICB0b0hTTEEoKSB7XHJcbiAgICAgICAgcmV0dXJuIEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSkudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgZmlsbFN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBjb2xvci5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCbGFjayAoIzAwMDAwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBCbGFjaygpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwMDAwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGl0ZSAoI0ZGRkZGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBXaGl0ZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmF5ICgjODA4MDgwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEdyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTGlnaHQgZ3JheSAoI0QzRDNEMylcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBMaWdodEdyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNEM0QzRDMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGFyayBncmF5ICgjQTlBOUE5KVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERhcmtHcmF5KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjQTlBOUE5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFllbGxvdyAoI0ZGRkYwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBZZWxsb3coKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRkZGMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3JhbmdlICgjRkZBNTAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IE9yYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGQTUwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWQgKCNGRjAwMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgUmVkKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkYwMDAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZlcm1pbGlvbiAoI0ZGNUIzMSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBWZXJtaWxpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRjVCMzEnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm9zZSAoI0ZGMDA3RilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBSb3NlKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkYwMDdGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1hZ2VudGEgKCNGRjAwRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgTWFnZW50YSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGMDBGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWaW9sZXQgKCM3RjAwRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVmlvbGV0KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjN0YwMEZGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJsdWUgKCMwMDAwRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQmx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwMDBGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBenVyZSAoIzAwN0ZGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBBenVyZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwN0ZGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDeWFuICgjMDBGRkZGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEN5YW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMwMEZGRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmlyaWRpYW4gKCM1OTk3OEYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVmlyaWRpYW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyM1OTk3OEYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR3JlZW4gKCMwMEZGMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgR3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMwMEZGMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhcnRyZXVzZSAoIzdGRkYwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBDaGFydHJldXNlKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjN0ZGRjAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zcGFyZW50ICgjRkZGRkZGMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVHJhbnNwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRkZGRkYwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGNhbGlidXJCbHVlICgjMTc2QkFBKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEV4Y2FsaWJ1ckJsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMxNzZCQUEnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW50ZXJuYWwgSFNMIENvbG9yIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcclxuICogaHR0cDovL2F4b25mbHV4LmNvbS9oYW5keS1yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNcclxuICovXHJcbmNsYXNzIEhTTENvbG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICB0aGlzLmggPSBoO1xyXG4gICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgdGhpcy5sID0gbDtcclxuICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGh1ZTJyZ2IocCwgcSwgdCkge1xyXG4gICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgICAgICB0IC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMiAvIDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUkdCQShyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgciAvPSAyNTU7XHJcbiAgICAgICAgZyAvPSAyNTU7XHJcbiAgICAgICAgYiAvPSAyNTU7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgIGxldCBoLCBzO1xyXG4gICAgICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaCAvPSA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgfVxyXG4gICAgdG9SR0JBKCkge1xyXG4gICAgICAgIGxldCByLCBnLCBiO1xyXG4gICAgICAgIGlmICh0aGlzLnMgPT09IDApIHtcclxuICAgICAgICAgICAgciA9IGcgPSBiID0gdGhpcy5sOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy5sIDwgMC41ID8gdGhpcy5sICogKDEgKyB0aGlzLnMpIDogdGhpcy5sICsgdGhpcy5zIC0gdGhpcy5sICogdGhpcy5zO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gMiAqIHRoaXMubCAtIHE7XHJcbiAgICAgICAgICAgIHIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCArIDEgLyAzKTtcclxuICAgICAgICAgICAgZyA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oKTtcclxuICAgICAgICAgICAgYiA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oIC0gMSAvIDMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIHRoaXMuYSk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBjb25zdCBoID0gdGhpcy5oLnRvRml4ZWQoMCksIHMgPSB0aGlzLnMudG9GaXhlZCgwKSwgbCA9IHRoaXMubC50b0ZpeGVkKDApLCBhID0gdGhpcy5hLnRvRml4ZWQoMCk7XHJcbiAgICAgICAgcmV0dXJuIGBoc2xhKCR7aH0sICR7c30sICR7bH0sICR7YX0pYDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9TaWRlLnRzXG5cclxuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHNpZGVzIG9mIGFuIGF4aXMgYWxpZ25lZCBib3ggZm9yIGNvbGxpc2lvblxyXG4gKi9cclxudmFyIFNpZGU7XHJcbihmdW5jdGlvbiAoU2lkZSkge1xyXG4gICAgU2lkZVtcIk5vbmVcIl0gPSBcIk5vbmVcIjtcclxuICAgIFNpZGVbXCJUb3BcIl0gPSBcIlRvcFwiO1xyXG4gICAgU2lkZVtcIkJvdHRvbVwiXSA9IFwiQm90dG9tXCI7XHJcbiAgICBTaWRlW1wiTGVmdFwiXSA9IFwiTGVmdFwiO1xyXG4gICAgU2lkZVtcIlJpZ2h0XCJdID0gXCJSaWdodFwiO1xyXG59KShTaWRlIHx8IChTaWRlID0ge30pKTtcclxuKGZ1bmN0aW9uIChTaWRlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9wcG9zaXRlIHNpZGUgZnJvbSB0aGUgY3VycmVudFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZShzaWRlKSB7XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuVG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLkJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuQm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLlRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuTGVmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZS5SaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuUmlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGUuTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuTm9uZTtcclxuICAgIH1cclxuICAgIFNpZGUuZ2V0T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSB2ZWN0b3IsIHJldHVybiB0aGUgU2lkZSBtb3N0IGluIHRoYXQgZGlyZWN0aW9uICh2aWEgZG90IHByb2R1Y3QpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9ucyA9IFtWZWN0b3IuTGVmdCwgVmVjdG9yLlJpZ2h0LCBWZWN0b3IuVXAsIFZlY3Rvci5Eb3duXTtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb25FbnVtID0gW1NpZGUuTGVmdCwgU2lkZS5SaWdodCwgU2lkZS5Ub3AsIFNpZGUuQm90dG9tXTtcclxuICAgICAgICBsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1heEluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25FbnVtW21heEluZGV4XTtcclxuICAgIH1cclxuICAgIFNpZGUuZnJvbURpcmVjdGlvbiA9IGZyb21EaXJlY3Rpb247XHJcbn0pKFNpZGUgfHwgKFNpZGUgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Cb3VuZGluZ0JveC50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIEF4aXMgQWxpZ25lZCBjb2xsaXNpb24gcHJpbWl0aXZlIGZvciBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBCb3VuZGluZ0JveCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yIGFsbG93cyBwYXNzaW5nIG9mIGVpdGhlciBhbiBvYmplY3Qgd2l0aCBhbGwgY29vcmRpbmF0ZSBjb21wb25lbnRzLFxyXG4gICAgICogb3IgdGhlIGNvb3JkaW5hdGUgY29tcG9uZW50cyBwYXNzZWQgc2VwYXJhdGVseS5cclxuICAgICAqIEBwYXJhbSBsZWZ0T3JPcHRpb25zICAgIEVpdGhlciB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZSBvciBhbiBvcHRpb25zIG9iamVjdFxyXG4gICAgICogY29udGFpbmluZyB0aGUgZm91ciBjb29yZGluYXRlIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcGFyYW0gdG9wICAgICB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlXHJcbiAgICAgKiBAcGFyYW0gcmlnaHQgICB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGVkZ2VcclxuICAgICAqIEBwYXJhbSBib3R0b20gIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobGVmdE9yT3B0aW9ucyA9IDAsIHRvcCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdE9yT3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnRvcCA9IGxlZnRPck9wdGlvbnMudG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbGVmdE9yT3B0aW9ucy5yaWdodDtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBsZWZ0T3JPcHRpb25zLmJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxlZnRPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnRPck9wdGlvbnM7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBbW0JvdW5kaW5nQm94XV0gdGhhdCBpcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGJvdW5kaW5nIGJveCBBICYgQiwgcmV0dXJucyB0aGUgc2lkZSByZWxhdGl2ZSB0byBBIHdoZW4gaW50ZXJzZWN0aW9uIGlzIHBlcmZvcm1lZC5cclxuICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gSW50ZXJzZWN0aW9uIHZlY3RvciBiZXR3ZWVuIDIgYm91bmRpbmcgYm94ZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNpZGVGcm9tSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbikge1xyXG4gICAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLk5vbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGludGVyc2VjdGlvbi54KSA+IE1hdGguYWJzKGludGVyc2VjdGlvbi55KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlLlJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpZGUuTGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24ueSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZS5Cb3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lkZS5Ub3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuTm9uZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5YID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50c1tpXS54ID4gbWF4WCkge1xyXG4gICAgICAgICAgICAgICAgbWF4WCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA8IG1pblkpIHtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLnkgPiBtYXhZKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhZID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tRGltZW5zaW9uKHdpZHRoLCBoZWlnaHQsIGFuY2hvciA9IFZlY3Rvci5IYWxmLCBwb3MgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goLXdpZHRoICogYW5jaG9yLnggKyBwb3MueCwgLWhlaWdodCAqIGFuY2hvci55ICsgcG9zLnksIHdpZHRoIC0gd2lkdGggKiBhbmNob3IueCArIHBvcy54LCBoZWlnaHQgLSBoZWlnaHQgKiBhbmNob3IueSArIHBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gd2hldGhlciB0aGUgYm91bmRpbmcgYm94IGhhcyB6ZXJvIGRpbWVuc2lvbnMgaW4gaGVpZ2h0LHdpZHRoIG9yIGJvdGhcclxuICAgICAqL1xyXG4gICAgaGFzWmVyb0RpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoKHRoaXMubGVmdCArIHRoaXMucmlnaHQpIC8gMiwgKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMik7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLmxlZnQgKyBwb3MueCwgdGhpcy50b3AgKyBwb3MueSwgdGhpcy5yaWdodCArIHBvcy54LCB0aGlzLmJvdHRvbSArIHBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyBhIGJvdW5kaW5nIGJveCBieSBhbmQgYW5nbGUgYW5kIGFyb3VuZCBhIHBvaW50LCBpZiBubyBwb2ludCBpcyBzcGVjaWZpZWQgKDAsIDApIGlzIHVzZWQgYnkgZGVmYXVsdC4gVGhlIHJlc3VsdGluZyBib3VuZGluZ1xyXG4gICAgICogYm94IGlzIGFsc28gYXhpcy1hbGlnbi4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG5ldyBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGlzIG5lZWRlZCBmb3Igcm90YXRlZCBnZW9tZXRyeS5cclxuICAgICAqL1xyXG4gICAgcm90YXRlKGFuZ2xlLCBwb2ludCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKS5tYXAoKHApID0+IHAucm90YXRlKGFuZ2xlLCBwb2ludCkpO1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlIGEgYm91bmRpbmcgYm94IGJ5IGEgc2NhbGUgZmFjdG9yLCBvcHRpb25hbGx5IHByb3ZpZGUgYSBwb2ludFxyXG4gICAgICogQHBhcmFtIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgc2NhbGUoc2NhbGUsIHBvaW50ID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBzaGlmdGVkID0gdGhpcy50cmFuc2xhdGUocG9pbnQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goc2hpZnRlZC5sZWZ0ICogc2NhbGUueCwgc2hpZnRlZC50b3AgKiBzY2FsZS55LCBzaGlmdGVkLnJpZ2h0ICogc2NhbGUueCwgc2hpZnRlZC5ib3R0b20gKiBzY2FsZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGJ5IGEgW1tNYXRyaXhdXSwgcHJvZHVjaW5nIGEgbmV3IGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3hcclxuICAgICAqIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdHJhbnNmb3JtKG1hdHJpeCkge1xyXG4gICAgICAgIC8vIGlubGluZWQgdGhlc2UgY2FsY3VsYXRpb25zIHRvIG5vdCB1c2UgdmVjdG9ycyB3b3VsZCBzcGVlZCBpdCB1cCBzbGlnaHRseVxyXG4gICAgICAgIC8vIGNvbnN0IG1hdEZpcnN0Q29sdW1uID0gdmVjKG1hdHJpeC5kYXRhWzBdLCBtYXRyaXguZGF0YVsxXSk7XHJcbiAgICAgICAgLy8gY29uc3QgeGEgPSBtYXRGaXJzdENvbHVtbi5zY2FsZSh0aGlzLmxlZnQpO1xyXG4gICAgICAgIGNvbnN0IHhhMSA9IG1hdHJpeC5kYXRhWzBdICogdGhpcy5sZWZ0O1xyXG4gICAgICAgIGNvbnN0IHhhMiA9IG1hdHJpeC5kYXRhWzFdICogdGhpcy5sZWZ0O1xyXG4gICAgICAgIC8vIGNvbnN0IHhiID0gbWF0Rmlyc3RDb2x1bW4uc2NhbGUodGhpcy5yaWdodCk7XHJcbiAgICAgICAgY29uc3QgeGIxID0gbWF0cml4LmRhdGFbMF0gKiB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHhiMiA9IG1hdHJpeC5kYXRhWzFdICogdGhpcy5yaWdodDtcclxuICAgICAgICAvLyBjb25zdCBtYXRTZWNvbmRDb2x1bW4gPSB2ZWMobWF0cml4LmRhdGFbMl0sIG1hdHJpeC5kYXRhWzNdKTtcclxuICAgICAgICAvLyBjb25zdCB5YSA9IG1hdFNlY29uZENvbHVtbi5zY2FsZSh0aGlzLnRvcCk7XHJcbiAgICAgICAgY29uc3QgeWExID0gbWF0cml4LmRhdGFbMl0gKiB0aGlzLnRvcDtcclxuICAgICAgICBjb25zdCB5YTIgPSBtYXRyaXguZGF0YVszXSAqIHRoaXMudG9wO1xyXG4gICAgICAgIC8vIGNvbnN0IHliID0gbWF0U2Vjb25kQ29sdW1uLnNjYWxlKHRoaXMuYm90dG9tKTtcclxuICAgICAgICBjb25zdCB5YjEgPSBtYXRyaXguZGF0YVsyXSAqIHRoaXMuYm90dG9tO1xyXG4gICAgICAgIGNvbnN0IHliMiA9IG1hdHJpeC5kYXRhWzNdICogdGhpcy5ib3R0b207XHJcbiAgICAgICAgY29uc3QgbWF0cml4UG9zID0gbWF0cml4LmdldFBvc2l0aW9uKCk7XHJcbiAgICAgICAgLy8gY29uc3QgdG9wTGVmdCA9IFZlY3Rvci5taW4oeGEsIHhiKS5hZGQoVmVjdG9yLm1pbih5YSwgeWIpKS5hZGQobWF0cml4UG9zKTtcclxuICAgICAgICAvLyBjb25zdCBib3R0b21SaWdodCA9IFZlY3Rvci5tYXgoeGEsIHhiKS5hZGQoVmVjdG9yLm1heCh5YSwgeWIpKS5hZGQobWF0cml4UG9zKTtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeGExLCB4YjEpICsgTWF0aC5taW4oeWExLCB5YjEpICsgbWF0cml4UG9zLng7XHJcbiAgICAgICAgY29uc3QgdG9wID0gTWF0aC5taW4oeGEyLCB4YjIpICsgTWF0aC5taW4oeWEyLCB5YjIpICsgbWF0cml4UG9zLnk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heCh4YTEsIHhiMSkgKyBNYXRoLm1heCh5YTEsIHliMSkgKyBtYXRyaXhQb3MueDtcclxuICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heCh4YTIsIHhiMikgKyBNYXRoLm1heCh5YTIsIHliMikgKyBtYXRyaXhQb3MueTtcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHtcclxuICAgICAgICAgICAgbGVmdCxcclxuICAgICAgICAgICAgdG9wLFxyXG4gICAgICAgICAgICByaWdodCxcclxuICAgICAgICAgICAgYm90dG9tIC8vOiBib3R0b21SaWdodC55XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldFBlcmltZXRlcigpIHtcclxuICAgICAgICBjb25zdCB3eCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgY29uc3Qgd3kgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcclxuICAgIH1cclxuICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChuZXcgVmVjdG9yKHRoaXMucmlnaHQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICByZXN1bHRzLnB1c2gobmV3IFZlY3Rvcih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHJheSBpbnRlcnNlY3RzIHdpdGggYSBib3VuZGluZyBib3hcclxuICAgICAqL1xyXG4gICAgcmF5Q2FzdChyYXksIGZhckNsaXBEaXN0YW5jZSA9IEluZmluaXR5KSB7XHJcbiAgICAgICAgLy8gYWxnb3JpdGhtIGZyb20gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS9mYXN0LWJyYW5jaGxlc3MtcmF5Ym91bmRpbmctYm94LWludGVyc2VjdGlvbnMvXHJcbiAgICAgICAgbGV0IHRtaW4gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IHRtYXggPSArSW5maW5pdHk7XHJcbiAgICAgICAgY29uc3QgeGludiA9IHJheS5kaXIueCA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAxIC8gcmF5LmRpci54O1xyXG4gICAgICAgIGNvbnN0IHlpbnYgPSByYXkuZGlyLnkgPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogMSAvIHJheS5kaXIueTtcclxuICAgICAgICBjb25zdCB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgY29uc3QgdHgyID0gKHRoaXMucmlnaHQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgIHRtYXggPSBNYXRoLm1heCh0eDEsIHR4Mik7XHJcbiAgICAgICAgY29uc3QgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgY29uc3QgdHkyID0gKHRoaXMuYm90dG9tIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRtYXggPj0gTWF0aC5tYXgoMCwgdG1pbikgJiYgdG1pbiA8IGZhckNsaXBEaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHJheUNhc3RUaW1lKHJheSwgZmFyQ2xpcERpc3RhbmNlID0gSW5maW5pdHkpIHtcclxuICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy9cclxuICAgICAgICBsZXQgdG1pbiA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICBjb25zdCB4aW52ID0gcmF5LmRpci54ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IDEgLyByYXkuZGlyLng7XHJcbiAgICAgICAgY29uc3QgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAxIC8gcmF5LmRpci55O1xyXG4gICAgICAgIGNvbnN0IHR4MSA9ICh0aGlzLmxlZnQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICBjb25zdCB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgIHRtaW4gPSBNYXRoLm1pbih0eDEsIHR4Mik7XHJcbiAgICAgICAgdG1heCA9IE1hdGgubWF4KHR4MSwgdHgyKTtcclxuICAgICAgICBjb25zdCB0eTEgPSAodGhpcy50b3AgLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICBjb25zdCB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcclxuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcclxuICAgICAgICBpZiAodG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0bWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBjb250YWlucyh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgPD0gdmFsLnggJiYgdGhpcy50b3AgPD0gdmFsLnkgJiYgdGhpcy5ib3R0b20gPj0gdmFsLnkgJiYgdGhpcy5yaWdodCA+PSB2YWwueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA8PSB2YWwubGVmdCAmJiB0aGlzLnRvcCA8PSB2YWwudG9wICYmIHZhbC5ib3R0b20gPD0gdGhpcy5ib3R0b20gJiYgdmFsLnJpZ2h0IDw9IHRoaXMucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lcyB0aGlzIGJvdW5kaW5nIGJveCBhbmQgYW5vdGhlciB0b2dldGhlciByZXR1cm5pbmcgYSBuZXcgYm91bmRpbmcgYm94XHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgIFRoZSBib3VuZGluZyBib3ggdG8gY29tYmluZVxyXG4gICAgICovXHJcbiAgICBjb21iaW5lKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9zaXRlQkIgPSBuZXcgQm91bmRpbmdCb3goTWF0aC5taW4odGhpcy5sZWZ0LCBvdGhlci5sZWZ0KSwgTWF0aC5taW4odGhpcy50b3AsIG90aGVyLnRvcCksIE1hdGgubWF4KHRoaXMucmlnaHQsIG90aGVyLnJpZ2h0KSwgTWF0aC5tYXgodGhpcy5ib3R0b20sIG90aGVyLmJvdHRvbSkpO1xyXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVCQjtcclxuICAgIH1cclxuICAgIGdldCBkaW1lbnNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBib3VuZGluZyBib3hlcyBvdmVybGFwLlxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKiBAcGFyYW0gZXBzaWxvbiBPcHRpb25hbGx5IHNwZWNpZnkgYSBzbWFsbCBlcHNpbG9uIChkZWZhdWx0IDApIGFzIGFtb3VudCBvZiBvdmVybGFwIHRvIGlnbm9yZSBhcyBvdmVybGFwLlxyXG4gICAgICogVGhpcyBlcHNpbG9uIGlzIHVzZWZ1bCBpbiBzdGFibGUgY29sbGlzaW9uIHNpbXVsYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBvdmVybGFwcyhvdGhlciwgZXBzaWxvbikge1xyXG4gICAgICAgIGNvbnN0IGUgPSBlcHNpbG9uIHx8IDA7XHJcbiAgICAgICAgaWYgKG90aGVyLmhhc1plcm9EaW1lbnNpb25zKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oYXNaZXJvRGltZW5zaW9ucygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5jb250YWlucyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG90YWxCb3VuZGluZ0JveCA9IHRoaXMuY29tYmluZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsQm91bmRpbmdCb3gud2lkdGggKyBlIDwgb3RoZXIud2lkdGggKyB0aGlzLndpZHRoICYmXHJcbiAgICAgICAgICAgIHRvdGFsQm91bmRpbmdCb3guaGVpZ2h0ICsgZSA8IG90aGVyLmhlaWdodCArIHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdldGhlciB0aGlzIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciByZXR1cm5pbmdcclxuICAgICAqIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY29sbGlzaW9uLiBJZiB0aGVyZVxyXG4gICAgICogaXMgbm8gaW50ZXJzZWN0aW9uIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyICBPdGhlciBbW0JvdW5kaW5nQm94XV0gdG8gdGVzdCBpbnRlcnNlY3Rpb24gd2l0aFxyXG4gICAgICogQHJldHVybnMgQSBWZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCBCb3VuZGluZ0JveCwgdGhpcyA8LSBvdGhlclxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcclxuICAgICAgICBjb25zdCB0b3RhbEJvdW5kaW5nQm94ID0gdGhpcy5jb21iaW5lKG90aGVyKTtcclxuICAgICAgICAvLyBJZiB0aGUgdG90YWwgYm91bmRpbmcgYm94IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3VtIG9mIHRoZSAyIGJvdW5kcyB0aGVuIHRoZXJlIGlzIGNvbGxpc2lvblxyXG4gICAgICAgIGlmICh0b3RhbEJvdW5kaW5nQm94LndpZHRoIDwgb3RoZXIud2lkdGggKyB0aGlzLndpZHRoICYmXHJcbiAgICAgICAgICAgIHRvdGFsQm91bmRpbmdCb3guaGVpZ2h0IDwgb3RoZXIuaGVpZ2h0ICsgdGhpcy5oZWlnaHQgJiZcclxuICAgICAgICAgICAgIXRvdGFsQm91bmRpbmdCb3guZGltZW5zaW9ucy5lcXVhbHMob3RoZXIuZGltZW5zaW9ucykgJiZcclxuICAgICAgICAgICAgIXRvdGFsQm91bmRpbmdCb3guZGltZW5zaW9ucy5lcXVhbHModGhpcy5kaW1lbnNpb25zKSkge1xyXG4gICAgICAgICAgICAvLyBjb2xsaXNpb25cclxuICAgICAgICAgICAgbGV0IG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgLy8gcmlnaHQgZWRnZSBpcyBiZXR3ZWVuIHRoZSBvdGhlcidzIGxlZnQgYW5kIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqICAgICArLXRoaXMtK1xyXG4gICAgICAgICAgICAgKiAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICogICAgIHwgICAgKy1vdGhlci0rXHJcbiAgICAgICAgICAgICAqICAgICArLS0tLXwtKyAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB8ICAgICAgIHxcclxuICAgICAgICAgICAgICogICAgICAgICAgKy0tLS0tLS0rXHJcbiAgICAgICAgICAgICAqICAgICAgICAgPC0tLVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBeIG92ZXJsYXBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5yaWdodCA8PSBvdGhlci5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGVkZ2UgaXMgcGFzdCB0aGUgb3RoZXIncyByaWdodCBlZGdlXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqICAgICArLW90aGVyLStcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICAgIHxcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICstdGhpcy0rXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgKy0tLS18LS0rICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICstLS0tLS0rXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAtLS0+XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBeIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFkgPSAwO1xyXG4gICAgICAgICAgICAvLyB0b3AgZWRnZSBpcyBiZXR3ZWVuIHRoZSBvdGhlcidzIHRvcCBhbmQgYm90dG9tIGVkZ2VcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqICAgICArLW90aGVyLStcclxuICAgICAgICAgICAgICogICAgIHwgICAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgfCAgICArLXRoaXMtKyAgIHwgPC0gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgKiAgICAgKy0tLS18LS0rICAgfCAgIHxcclxuICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgIHwgIFxcIC9cclxuICAgICAgICAgICAgICogICAgICAgICAgKy0tLS0tLSsgICAnXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy50b3AgPD0gb3RoZXIuYm90dG9tICYmIHRoaXMudG9wID49IG90aGVyLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgIC8vIHRvcCBlZGdlIGlzIGFib3ZlIHRoZSBvdGhlciB0b3AgZWRnZVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgKy10aGlzLSsgICAgICAgICAuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgfCAgICAgIHwgICAgICAgIC8gXFxcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICstb3RoZXItKyAgIHwgPC0gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICogICAgICstLS0tfC0rICAgICB8ICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICArLS0tLS0tLStcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci50b3AgLSB0aGlzLmJvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmxhcFgpIDwgTWF0aC5hYnMob3ZlcmxhcFkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihvdmVybGFwWCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCBvdmVybGFwWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2FzZSBvZiB0b3RhbCBjb250YWlubWVudCBvZiBvbmUgYm91bmRpbmcgYm94IGJ5IGFub3RoZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG90YWxCb3VuZGluZ0JveC5kaW1lbnNpb25zLmVxdWFscyhvdGhlci5kaW1lbnNpb25zKSB8fCB0b3RhbEJvdW5kaW5nQm94LmRpbWVuc2lvbnMuZXF1YWxzKHRoaXMuZGltZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgbGV0IG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB3aWRlciB0aGFuIHRoZSBvdGhlclxyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAtIG90aGVyLndpZHRoID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmlnaHQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgcmlnaHQgZWRnZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgLSBvdGhlci5yaWdodCA8PSBvdGhlci5sZWZ0IC0gdGhpcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxlZnQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgbGVmdCBlZGdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgaXMgd2lkZXIgdGhhbiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJpZ2h0IGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5yaWdodCAtIHRoaXMucmlnaHQgPD0gdGhpcy5sZWZ0IC0gb3RoZXIubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gdGhpcy5sZWZ0IC0gb3RoZXIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsZWZ0IGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIGxlZnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSB0aGlzLnJpZ2h0IC0gb3RoZXIubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFkgPSAwO1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRhbGxlciB0aGFuIG90aGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAtIG90aGVyLmhlaWdodCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm90dG9tIGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIGJvdHRvbSBlZGdlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3R0b20gLSBvdGhlci5ib3R0b20gPD0gb3RoZXIudG9wIC0gdGhpcy50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLnRvcCAtIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIGlzIHRhbGxlciB0aGFuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBib3R0b20gZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgYm90dG9tIGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5ib3R0b20gLSB0aGlzLmJvdHRvbSA8PSB0aGlzLnRvcCAtIG90aGVyLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gdGhpcy50b3AgLSBvdGhlci5ib3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IHRoaXMuYm90dG9tIC0gb3RoZXIudG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG92ZXJsYXBYLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIG92ZXJsYXBZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGJvdW5kaW5nIGJveCBoYXMgaW50ZXJzZWN0ZWQgd2l0aCBhbm90aGVyIGJvdW5kaW5nIGJveCwgcmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY3VycmVudCBiYiB0aGF0IGludGVyc2VjdGVkLlxyXG4gICAgICogQHBhcmFtIGJiIFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFdpdGhTaWRlKGJiKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5pbnRlcnNlY3QoYmIpO1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5nZXRTaWRlRnJvbUludGVyc2VjdGlvbihpbnRlcnNlY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGVidWcgYm91bmRpbmcgYm94XHJcbiAgICAgKiBAcGFyYW0gZXhcclxuICAgICAqIEBwYXJhbSBjb2xvclxyXG4gICAgICovXHJcbiAgICBkcmF3KGV4LCBjb2xvciA9IENvbG9yLlllbGxvdykge1xyXG4gICAgICAgIGV4LmRlYnVnLmRyYXdSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB7IGNvbG9yIH0pO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9GdXR1cmUudHNcbi8qKlxyXG4gKiBGdXR1cmUgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIG5hdGl2ZSBicm93c2VyIFByb21pc2UgdG8gYWxsb3cgcmVzb2x2aW5nL3JlamVjdGluZyBhdCBhbnkgdGltZVxyXG4gKi9cclxuY2xhc3MgRnV0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdGVyID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ29tcGxldGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbXBsZXRlZDtcclxuICAgIH1cclxuICAgIHJlc29sdmUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNDb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZXIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVqZWN0KGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQ29tcGxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNDb21wbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3JlamVjdGVyKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvVXRpbC50c1xuXHJcblxyXG4vKipcclxuICogRmluZCB0aGUgc2NyZWVuIHBvc2l0aW9uIG9mIGFuIEhUTUwgZWxlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuICAgIGxldCBvTGVmdCA9IDAsIG9Ub3AgPSAwO1xyXG4gICAgY29uc3QgY2FsY09mZnNldExlZnQgPSAocGFyZW50KSA9PiB7XHJcbiAgICAgICAgb0xlZnQgKz0gcGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgY2FsY09mZnNldExlZnQocGFyZW50Lm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNhbGNPZmZzZXRUb3AgPSAocGFyZW50KSA9PiB7XHJcbiAgICAgICAgb1RvcCArPSBwYXJlbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AocGFyZW50Lm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNhbGNPZmZzZXRMZWZ0KGVsKTtcclxuICAgIGNhbGNPZmZzZXRUb3AoZWwpO1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3Iob0xlZnQsIG9Ub3ApO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gaXRlbSB0byBhbiBhcnJheSBsaXN0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC4gUmV0dXJucyB0cnVlIGlmIGFkZGVkLCBmYWxzZSBpZiBub3QgYW5kIGFscmVhZHkgZXhpc3RzIGluIHRoZSBhcnJheS5cclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmZ1bmN0aW9uIGFkZEl0ZW1Ub0FycmF5KGl0ZW0sIGFycmF5KSB7XHJcbiAgICBpZiAoYXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcclxuICAgICAgICBhcnJheS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGxpc3RcclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgaWYgKChpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSkpID4gLTEpIHtcclxuICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBTZWUgaWYgYW4gYXJyYXkgY29udGFpbnMgc29tZXRoaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWlucyhhcnJheSwgb2JqKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIGZvciBleGhhdXN0aXZlIGNoZWNrcyBhdCBjb21waWxlIHRpbWVcclxuICovXHJcbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgYSBjZXJ0YWluIG51bWJlciBvZiBtaWxsaXNlY29uZHNcclxuICpcclxuICogSXQgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQgeW91IHBhc3MgdGhlIGV4Y2FsaWJ1ciBjbG9jayBzbyBkZWxheXMgYXJlIGJvdW5kIHRvIHRoZVxyXG4gKiBleGNhbGlidXIgY2xvY2sgd2hpY2ggd291bGQgYmUgdW5hZmZlY3RlZCBieSBzdG9wL3BhdXNlLlxyXG4gKiBAcGFyYW0gbWlsbGlzZWNvbmRzXHJcbiAqIEBwYXJhbSBjbG9ja1xyXG4gKi9cclxuZnVuY3Rpb24gZGVsYXkobWlsbGlzZWNvbmRzLCBjbG9jaykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgY29uc3Qgc2NoZWR1bGUgPSAoX2EgPSBjbG9jayA9PT0gbnVsbCB8fCBjbG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvY2suc2NoZWR1bGUuYmluZChjbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNldFRpbWVvdXQ7XHJcbiAgICBzY2hlZHVsZSgoKSA9PiB7XHJcbiAgICAgICAgZnV0dXJlLnJlc29sdmUoKTtcclxuICAgIH0sIG1pbGxpc2Vjb25kcyk7XHJcbiAgICByZXR1cm4gZnV0dXJlLnByb21pc2U7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL21hdHJpeC50c1xuXHJcblxyXG5cclxudmFyIE1hdHJpeExvY2F0aW9ucztcclxuKGZ1bmN0aW9uIChNYXRyaXhMb2NhdGlvbnMpIHtcclxuICAgIE1hdHJpeExvY2F0aW9uc1tNYXRyaXhMb2NhdGlvbnNbXCJYXCJdID0gMTJdID0gXCJYXCI7XHJcbiAgICBNYXRyaXhMb2NhdGlvbnNbTWF0cml4TG9jYXRpb25zW1wiWVwiXSA9IDEzXSA9IFwiWVwiO1xyXG59KShNYXRyaXhMb2NhdGlvbnMgfHwgKE1hdHJpeExvY2F0aW9ucyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgTWF0cml4IGhlbHBlciBmb3IgNHg0IG1hdHJpY2VzXHJcbiAqXHJcbiAqIFVzZWZ1bCBmb3Igd2ViZ2wgNHg0IG1hdHJpY2VzXHJcbiAqL1xyXG5jbGFzcyBNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIDR4NCBtYXRyaXggaW4gY29sdW1uIG1ham9yIG9yZGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB8ICAgICAgICAgfCAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICB8XHJcbiAgICAgICAgICogfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0gfFxyXG4gICAgICAgICAqIHwgZGF0YVswXSB8IGRhdGFbNF0gfCBkYXRhWzhdICB8IGRhdGFbMTJdIHxcclxuICAgICAgICAgKiB8IGRhdGFbMV0gfCBkYXRhWzVdIHwgZGF0YVs5XSAgfCBkYXRhWzEzXSB8XHJcbiAgICAgICAgICogfCBkYXRhWzJdIHwgZGF0YVs2XSB8IGRhdGFbMTBdIHwgZGF0YVsxNF0gfFxyXG4gICAgICAgICAqIHwgZGF0YVszXSB8IGRhdGFbN10gfCBkYXRhWzExXSB8IGRhdGFbMTVdIHxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlWCA9IDE7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVTaWduWCA9IDE7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVZID0gMTtcclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25ZID0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvcnRob2dyYXBoaWMgKGZsYXQgbm9uLXBlcnNwZWN0aXZlKSBwcm9qZWN0aW9uXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcnRob2dyYXBoaWNfcHJvamVjdGlvblxyXG4gICAgICogQHBhcmFtIGxlZnRcclxuICAgICAqIEBwYXJhbSByaWdodFxyXG4gICAgICogQHBhcmFtIGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHRvcFxyXG4gICAgICogQHBhcmFtIG5lYXJcclxuICAgICAqIEBwYXJhbSBmYXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDIgLyAodG9wIC0gYm90dG9tKTtcclxuICAgICAgICBtYXQuZGF0YVs2XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbN10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzhdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs5XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTBdID0gLTIgLyAoZmFyIC0gbmVhcik7XHJcbiAgICAgICAgbWF0LmRhdGFbMTFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSAtKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcclxuICAgICAgICBtYXQuZGF0YVsxM10gPSAtKHRvcCArIGJvdHRvbSkgLyAodG9wIC0gYm90dG9tKTtcclxuICAgICAgICBtYXQuZGF0YVsxNF0gPSAtKGZhciArIG5lYXIpIC8gKGZhciAtIG5lYXIpO1xyXG4gICAgICAgIG1hdC5kYXRhWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXRyaXggd2l0aCB0aGUgc2FtZSBkYXRhIGFzIHRoZSBjdXJyZW50IDR4NFxyXG4gICAgICovXHJcbiAgICBjbG9uZShkZXN0KSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gZGVzdCB8fCBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgbWF0LmRhdGFbMV0gPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgbWF0LmRhdGFbMl0gPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgbWF0LmRhdGFbNl0gPSB0aGlzLmRhdGFbNl07XHJcbiAgICAgICAgbWF0LmRhdGFbN10gPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgbWF0LmRhdGFbOF0gPSB0aGlzLmRhdGFbOF07XHJcbiAgICAgICAgbWF0LmRhdGFbOV0gPSB0aGlzLmRhdGFbOV07XHJcbiAgICAgICAgbWF0LmRhdGFbMTBdID0gdGhpcy5kYXRhWzEwXTtcclxuICAgICAgICBtYXQuZGF0YVsxMV0gPSB0aGlzLmRhdGFbMTFdO1xyXG4gICAgICAgIG1hdC5kYXRhWzEyXSA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgbWF0LmRhdGFbMTNdID0gdGhpcy5kYXRhWzEzXTtcclxuICAgICAgICBtYXQuZGF0YVsxNF0gPSB0aGlzLmRhdGFbMTRdO1xyXG4gICAgICAgIG1hdC5kYXRhWzE1XSA9IHRoaXMuZGF0YVsxNV07XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgbWF0cml4IGludG8gYSBET01NYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdvcmtpbmcgd2l0aCB0aGUgYnJvd3NlciBDYW52YXMgY29udGV4dFxyXG4gICAgICogQHJldHVybnMge0RPTU1hdHJpeH0gRE9NTWF0cml4XHJcbiAgICAgKi9cclxuICAgIHRvRE9NTWF0cml4KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRE9NTWF0cml4KFsuLi50aGlzLmRhdGFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tRmxvYXQzMkFycmF5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgbWF0cml4LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0cml4IChhIG1hdHJpeCB0aGF0IHdoZW4gYXBwbGllZCBkb2VzIG5vdGhpbmcpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpZGVudGl0eSgpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbNl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzddID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs4XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEwXSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbMTFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgbXV0YXRpbmcgaXRcclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IEN1cnJlbnQgbWF0cml4IGFzIGlkZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IHRoaXM7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbNl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzddID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs4XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEwXSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbMTFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBicmFuZCBuZXcgdHJhbnNsYXRpb24gbWF0cml4IGF0IHRoZSBzcGVjaWZpZWQgM2QgcG9pbnRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNsYXRpb24oeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzEyXSA9IHg7XHJcbiAgICAgICAgbWF0LmRhdGFbMTNdID0geTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYnJhbmQgbmV3IHNjYWxpbmcgbWF0cml4IHdpdGggdGhlIHNwZWNpZmllZCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICogQHBhcmFtIHN4XHJcbiAgICAgKiBAcGFyYW0gc3lcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNjYWxlKHN4LCBzeSkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gc3g7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSBzeTtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGJyYW5kIG5ldyByb3RhdGlvbiBtYXRyaXggd2l0aCB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByb3RhdGlvbihhbmdsZVJhZGlhbnMpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSAtTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICBtdWx0aXBseSh2ZWN0b3JPck1hdHJpeCwgZGVzdCkge1xyXG4gICAgICAgIGlmICh2ZWN0b3JPck1hdHJpeCBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IHZlY3Rvck9yTWF0cml4O1xyXG4gICAgICAgICAgICAvLyB0aGVzZSBzaGVuYW5pZ2FucyBhcmUgdG8gYWxsb3cgZGVzdCBhbmQgdmVjdG9yIHRvIGJlIHRoZSBzYW1lIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFggPSB2ZWN0b3IueCAqIHRoaXMuZGF0YVswXSArIHZlY3Rvci55ICogdGhpcy5kYXRhWzRdICsgdGhpcy5kYXRhWzEyXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0WSA9IHZlY3Rvci54ICogdGhpcy5kYXRhWzFdICsgdmVjdG9yLnkgKiB0aGlzLmRhdGFbNV0gKyB0aGlzLmRhdGFbMTNdO1xyXG4gICAgICAgICAgICByZXN1bHQueCA9IHJlc3VsdFg7XHJcbiAgICAgICAgICAgIHJlc3VsdC55ID0gcmVzdWx0WTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlc3QgfHwgbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IHZlY3Rvck9yTWF0cml4O1xyXG4gICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgICAgICBjb25zdCBhNDEgPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmRhdGFbNl07XHJcbiAgICAgICAgICAgIGNvbnN0IGE0MiA9IHRoaXMuZGF0YVs3XTtcclxuICAgICAgICAgICAgY29uc3QgYTEzID0gdGhpcy5kYXRhWzhdO1xyXG4gICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmRhdGFbOV07XHJcbiAgICAgICAgICAgIGNvbnN0IGEzMyA9IHRoaXMuZGF0YVsxMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGE0MyA9IHRoaXMuZGF0YVsxMV07XHJcbiAgICAgICAgICAgIGNvbnN0IGExNCA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGEyNCA9IHRoaXMuZGF0YVsxM107XHJcbiAgICAgICAgICAgIGNvbnN0IGEzNCA9IHRoaXMuZGF0YVsxNF07XHJcbiAgICAgICAgICAgIGNvbnN0IGE0NCA9IHRoaXMuZGF0YVsxNV07XHJcbiAgICAgICAgICAgIGNvbnN0IGIxMSA9IG90aGVyLmRhdGFbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIyMSA9IG90aGVyLmRhdGFbMV07XHJcbiAgICAgICAgICAgIGNvbnN0IGIzMSA9IG90aGVyLmRhdGFbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGI0MSA9IG90aGVyLmRhdGFbM107XHJcbiAgICAgICAgICAgIGNvbnN0IGIxMiA9IG90aGVyLmRhdGFbNF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIyMiA9IG90aGVyLmRhdGFbNV07XHJcbiAgICAgICAgICAgIGNvbnN0IGIzMiA9IG90aGVyLmRhdGFbNl07XHJcbiAgICAgICAgICAgIGNvbnN0IGI0MiA9IG90aGVyLmRhdGFbN107XHJcbiAgICAgICAgICAgIGNvbnN0IGIxMyA9IG90aGVyLmRhdGFbOF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIyMyA9IG90aGVyLmRhdGFbOV07XHJcbiAgICAgICAgICAgIGNvbnN0IGIzMyA9IG90aGVyLmRhdGFbMTBdO1xyXG4gICAgICAgICAgICBjb25zdCBiNDMgPSBvdGhlci5kYXRhWzExXTtcclxuICAgICAgICAgICAgY29uc3QgYjE0ID0gb3RoZXIuZGF0YVsxMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGIyNCA9IG90aGVyLmRhdGFbMTNdO1xyXG4gICAgICAgICAgICBjb25zdCBiMzQgPSBvdGhlci5kYXRhWzE0XTtcclxuICAgICAgICAgICAgY29uc3QgYjQ0ID0gb3RoZXIuZGF0YVsxNV07XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVsxXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVs0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzZdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVs3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVsxM10gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzE0XSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbMTVdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5nZXRTY2FsZSgpO1xyXG4gICAgICAgICAgICByZXN1bHQuX3NjYWxlU2lnblggPSBzaWduKHMueCkgKiBzaWduKHJlc3VsdC5fc2NhbGVTaWduWCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5fc2NhbGVTaWduWSA9IHNpZ24ocy55KSAqIHNpZ24ocmVzdWx0Ll9zY2FsZVNpZ25ZKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGN1cnJlbnQgbWF0cml4IG11dGF0aW5nIGl0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHgsIHkpIHtcclxuICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYTIxID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuZGF0YVsyXTtcclxuICAgICAgICBjb25zdCBhNDEgPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgY29uc3QgYTEyID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmRhdGFbNl07XHJcbiAgICAgICAgY29uc3QgYTQyID0gdGhpcy5kYXRhWzddO1xyXG4gICAgICAgIGNvbnN0IGExMyA9IHRoaXMuZGF0YVs4XTtcclxuICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmRhdGFbOV07XHJcbiAgICAgICAgY29uc3QgYTMzID0gdGhpcy5kYXRhWzEwXTtcclxuICAgICAgICBjb25zdCBhNDMgPSB0aGlzLmRhdGFbMTFdO1xyXG4gICAgICAgIGNvbnN0IGExNCA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgY29uc3QgYTI0ID0gdGhpcy5kYXRhWzEzXTtcclxuICAgICAgICBjb25zdCBhMzQgPSB0aGlzLmRhdGFbMTRdO1xyXG4gICAgICAgIGNvbnN0IGE0NCA9IHRoaXMuZGF0YVsxNV07XHJcbiAgICAgICAgLy8gRG9lc24ndCBjaGFuZ2UgelxyXG4gICAgICAgIGNvbnN0IHogPSAwO1xyXG4gICAgICAgIGNvbnN0IHcgPSAxO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gPSBhMTEgKiB4ICsgYTEyICogeSArIGExMyAqIHogKyBhMTQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gPSBhMjEgKiB4ICsgYTIyICogeSArIGEyMyAqIHogKyBhMjQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxNF0gPSBhMzEgKiB4ICsgYTMyICogeSArIGEzMyAqIHogKyBhMzQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxNV0gPSBhNDEgKiB4ICsgYTQyICogeSArIGE0MyAqIHogKyBhNDQgKiB3O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0UG9zaXRpb24oeCwgeSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gPSB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gPSB5O1xyXG4gICAgfVxyXG4gICAgZ2V0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlYyh0aGlzLmRhdGFbMTJdLCB0aGlzLmRhdGFbMTNdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyByb3RhdGlvbiB0byB0aGUgY3VycmVudCBtYXRyaXggbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSBhbmdsZSBpbiBSYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGE0MSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBhNDIgPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgY29uc3Qgc2luZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBjb3NpbmUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gY29zaW5lICogYTExICsgc2luZSAqIGExMjtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSBjb3NpbmUgKiBhMjEgKyBzaW5lICogYTIyO1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IGNvc2luZSAqIGEzMSArIHNpbmUgKiBhMzI7XHJcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gY29zaW5lICogYTQxICsgc2luZSAqIGE0MjtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSBjb3NpbmUgKiBhMTIgLSBzaW5lICogYTExO1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IGNvc2luZSAqIGEyMiAtIHNpbmUgKiBhMjE7XHJcbiAgICAgICAgdGhpcy5kYXRhWzZdID0gY29zaW5lICogYTMyIC0gc2luZSAqIGEzMTtcclxuICAgICAgICB0aGlzLmRhdGFbN10gPSBjb3NpbmUgKiBhNDIgLSBzaW5lICogYTQxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHNjYWxpbmcgdG8gdGhlIGN1cnJlbnQgbWF0cml4IG11dGF0aW5nIGl0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGE0MSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBhNDIgPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gYTExICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSBhMjEgKiB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IGEzMSAqIHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gYTQxICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSBhMTIgKiB5O1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IGEyMiAqIHk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzZdID0gYTMyICogeTtcclxuICAgICAgICB0aGlzLmRhdGFbN10gPSBhNDIgKiB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0Um90YXRpb24oYW5nbGUpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XHJcbiAgICAgICAgY29uc3Qgc2luZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBjb3NpbmUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gY29zaW5lICogY3VycmVudFNjYWxlLng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzFdID0gc2luZSAqIGN1cnJlbnRTY2FsZS55O1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IC1zaW5lICogY3VycmVudFNjYWxlLng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gY29zaW5lICogY3VycmVudFNjYWxlLnk7XHJcbiAgICB9XHJcbiAgICBnZXRSb3RhdGlvbigpIHtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5kYXRhWzFdIC8gdGhpcy5nZXRTY2FsZVkoKSwgdGhpcy5kYXRhWzBdIC8gdGhpcy5nZXRTY2FsZVgoKSk7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKTtcclxuICAgIH1cclxuICAgIGdldFNjYWxlWCgpIHtcclxuICAgICAgICAvLyBhYnNvbHV0ZSBzY2FsZSBvZiB0aGUgbWF0cml4ICh3ZSBsb3NlIHNpZ24gc28gbmVlZCB0byBhZGQgaXQgYmFjaylcclxuICAgICAgICBjb25zdCB4c2NhbGUgPSB2ZWModGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbNF0pLnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlU2lnblggKiB4c2NhbGU7XHJcbiAgICB9XHJcbiAgICBnZXRTY2FsZVkoKSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGUgc2NhbGUgb2YgdGhlIG1hdHJpeCAod2UgbG9zZSBzaWduIHNvIG5lZWQgdG8gYWRkIGl0IGJhY2spXHJcbiAgICAgICAgY29uc3QgeXNjYWxlID0gdmVjKHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzVdKS5zaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVNpZ25ZICogeXNjYWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNjYWxlIG9mIHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgZ2V0U2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlYyh0aGlzLmdldFNjYWxlWCgpLCB0aGlzLmdldFNjYWxlWSgpKTtcclxuICAgIH1cclxuICAgIHNldFNjYWxlWCh2YWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2NhbGVYID09PSB2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25YID0gc2lnbih2YWwpO1xyXG4gICAgICAgIC8vIG5lZ2F0aXZlIHNjYWxlIGFjdHMgbGlrZSBhIDE4MCByb3RhdGlvbiwgc28gZmxpcFxyXG4gICAgICAgIGNvbnN0IHhzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMF0gKiB0aGlzLl9zY2FsZVNpZ25YLCB0aGlzLmRhdGFbNF0gKiB0aGlzLl9zY2FsZVNpZ25YKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4c2NhbGUueCAqIHZhbDtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSB4c2NhbGUueSAqIHZhbDtcclxuICAgICAgICB0aGlzLl9zY2FsZVggPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzZXRTY2FsZVkodmFsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlWSA9PT0gdmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2NhbGVTaWduWSA9IHNpZ24odmFsKTtcclxuICAgICAgICAvLyBuZWdhdGl2ZSBzY2FsZSBhY3RzIGxpa2UgYSAxODAgcm90YXRpb24sIHNvIGZsaXBcclxuICAgICAgICBjb25zdCB5c2NhbGUgPSB2ZWModGhpcy5kYXRhWzFdICogdGhpcy5fc2NhbGVTaWduWSwgdGhpcy5kYXRhWzVdICogdGhpcy5fc2NhbGVTaWduWSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzFdID0geXNjYWxlLnggKiB2YWw7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0geXNjYWxlLnkgKiB2YWw7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVZID0gdmFsO1xyXG4gICAgfVxyXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWChzY2FsZS54KTtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWShzY2FsZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5hbnQgb2YgdGhlIHVwcGVyIGxlZnQgMngyIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBnZXRCYXNpc0RldGVybWluYW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF0gKiB0aGlzLmRhdGFbNV0gLSB0aGlzLmRhdGFbMV0gKiB0aGlzLmRhdGFbNF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgYWZmaW5lIGludmVyc2UsIG9wdGlvbmFsbHkgc3RvcmUgaXQgaW4gYSB0YXJnZXQgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEl0J3MgcmVjb21tZW5kZWQgeW91IGNhbGwgLnJlc2V0KCkgdGhlIHRhcmdldCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmdcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgZ2V0QWZmaW5lSW52ZXJzZSh0YXJnZXQpIHtcclxuICAgICAgICAvLyBTZWUgaHR0cDovL25lZ2F0aXZlcHJvYmFiaWxpdHkuYmxvZ3Nwb3QuY29tLzIwMTEvMTEvYWZmaW5lLXRyYW5zZm9ybWF0aW9ucy1hbmQtdGhlaXIuaHRtbFxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5tYXRoc2lzZnVuLmNvbS9hbGdlYnJhL21hdHJpeC1pbnZlcnNlLmh0bWxcclxuICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgYWN0dWFsbHkgb25seSBkb2luZyAyRCB0cmFuc2Zvcm1hdGlvbnMgd2UgY2FuIHVzZSB0aGlzIGhhY2tcclxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIDNyZCBvciA0dGggZGltZW5zaW9uXHJcbiAgICAgICAgY29uc3QgZGV0ID0gdGhpcy5nZXRCYXNpc0RldGVybWluYW50KCk7XHJcbiAgICAgICAgY29uc3QgaW52ZXJzZURldCA9IDEgLyBkZXQ7IC8vIHRvZG8gemVybyBjaGVja1xyXG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBjID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgbSA9IHRhcmdldCB8fCBNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICAvLyBpbnZlcnRzIHJvdGF0aW9uIGFuZCBzY2FsZVxyXG4gICAgICAgIG0uZGF0YVswXSA9IGQgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIG0uZGF0YVsxXSA9IC1jICogaW52ZXJzZURldDtcclxuICAgICAgICBtLmRhdGFbNF0gPSAtYiAqIGludmVyc2VEZXQ7XHJcbiAgICAgICAgbS5kYXRhWzVdID0gYSAqIGludmVyc2VEZXQ7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLmRhdGFbMTJdO1xyXG4gICAgICAgIGNvbnN0IHR5ID0gdGhpcy5kYXRhWzEzXTtcclxuICAgICAgICAvLyBpbnZlcnQgdHJhbnNsYXRpb25cclxuICAgICAgICAvLyB0cmFuc2Zvcm0gdHJhbnNsYXRpb24gaW50byB0aGUgbWF0cml4IGJhc2lzIGNyZWF0ZWQgYnkgcm90L3NjYWxlXHJcbiAgICAgICAgbS5kYXRhWzEyXSA9IC0odHggKiBtLmRhdGFbMF0gKyB0eSAqIG0uZGF0YVs0XSk7XHJcbiAgICAgICAgbS5kYXRhWzEzXSA9IC0odHggKiBtLmRhdGFbMV0gKyB0eSAqIG0uZGF0YVs1XSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcbiAgICBpc0lkZW50aXR5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5kYXRhWzBdID09PSAxICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMl0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzNdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs0XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbNV0gPT09IDEgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzZdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs3XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbOF0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzldID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxMF0gPT09IDEgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzExXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTJdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxM10gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzE0XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTVdID09PSAxKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcblske3RoaXMuZGF0YVswXX0gJHt0aGlzLmRhdGFbNF19ICR7dGhpcy5kYXRhWzhdfSAke3RoaXMuZGF0YVsxMl19XVxyXG5bJHt0aGlzLmRhdGFbMV19ICR7dGhpcy5kYXRhWzVdfSAke3RoaXMuZGF0YVs5XX0gJHt0aGlzLmRhdGFbMTNdfV1cclxuWyR7dGhpcy5kYXRhWzJdfSAke3RoaXMuZGF0YVs2XX0gJHt0aGlzLmRhdGFbMTBdfSAke3RoaXMuZGF0YVsxNF19XVxyXG5bJHt0aGlzLmRhdGFbM119ICR7dGhpcy5kYXRhWzddfSAke3RoaXMuZGF0YVsxMV19ICR7dGhpcy5kYXRhWzE1XX1dXHJcbmA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL2FmZmluZS1tYXRyaXgudHNcblxyXG5cclxuXHJcbmNsYXNzIEFmZmluZU1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB8ICAgICAgICAgfCAgICAgICAgIHwgICAgICAgICAgfFxyXG4gICAgICAgICAqIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tLSB8XHJcbiAgICAgICAgICogfCBkYXRhWzBdIHwgZGF0YVsyXSB8IGRhdGFbNF0gIHxcclxuICAgICAgICAgKiB8IGRhdGFbMV0gfCBkYXRhWzNdIHwgZGF0YVs1XSAgfFxyXG4gICAgICAgICAqIHwgICAwICAgICB8ICAgIDAgICAgfCAgICAxICAgICB8XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0NjRBcnJheSg2KTtcclxuICAgICAgICB0aGlzLl9zY2FsZSA9IG5ldyBGbG9hdDY0QXJyYXkoWzEsIDFdKTtcclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25YID0gMTtcclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25ZID0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgbWF0cml4IGludG8gYSBET01NYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdvcmtpbmcgd2l0aCB0aGUgYnJvd3NlciBDYW52YXMgY29udGV4dFxyXG4gICAgICogQHJldHVybnMge0RPTU1hdHJpeH0gRE9NTWF0cml4XHJcbiAgICAgKi9cclxuICAgIHRvRE9NTWF0cml4KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRE9NTWF0cml4KFsuLi50aGlzLmRhdGFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpZGVudGl0eSgpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBuZXcgQWZmaW5lTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGJyYW5kIG5ldyB0cmFuc2xhdGlvbiBtYXRyaXggYXQgdGhlIHNwZWNpZmllZCAzZCBwb2ludFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2xhdGlvbih4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSB4O1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0geTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYnJhbmQgbmV3IHNjYWxpbmcgbWF0cml4IHdpdGggdGhlIHNwZWNpZmllZCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICogQHBhcmFtIHN4XHJcbiAgICAgKiBAcGFyYW0gc3lcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNjYWxlKHN4LCBzeSkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gc3g7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSBzeTtcclxuICAgICAgICBtYXQuX3NjYWxlWzBdID0gc3g7XHJcbiAgICAgICAgbWF0Ll9zY2FsZVsxXSA9IHN5O1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBicmFuZCBuZXcgcm90YXRpb24gbWF0cml4IHdpdGggdGhlIHNwZWNpZmllZCBhbmdsZVxyXG4gICAgICogQHBhcmFtIGFuZ2xlUmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcm90YXRpb24oYW5nbGVSYWRpYW5zKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IC1NYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIG1hdC5kYXRhWzNdID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgc2V0UG9zaXRpb24oeCwgeSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0geTtcclxuICAgIH1cclxuICAgIGdldFBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB2ZWModGhpcy5kYXRhWzRdLCB0aGlzLmRhdGFbNV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHJvdGF0aW9uIHRvIHRoZSBjdXJyZW50IG1hdHJpeCBtdXRhdGluZyBpdFxyXG4gICAgICogQHBhcmFtIGFuZ2xlIGluIFJhZGlhbnNcclxuICAgICAqL1xyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIGNvbnN0IHNpbmUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgY29zaW5lID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IGNvc2luZSAqIGExMSArIHNpbmUgKiBhMTI7XHJcbiAgICAgICAgdGhpcy5kYXRhWzFdID0gY29zaW5lICogYTIxICsgc2luZSAqIGEyMjtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSBjb3NpbmUgKiBhMTIgLSBzaW5lICogYTExO1xyXG4gICAgICAgIHRoaXMuZGF0YVszXSA9IGNvc2luZSAqIGEyMiAtIHNpbmUgKiBhMjE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGN1cnJlbnQgbWF0cml4IG11dGF0aW5nIGl0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHgsIHkpIHtcclxuICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYTIxID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIC8vIGNvbnN0IGEzMSA9IDA7XHJcbiAgICAgICAgY29uc3QgYTEyID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICAvLyBjb25zdCBhMzIgPSAwO1xyXG4gICAgICAgIGNvbnN0IGExMyA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgLy8gY29uc3QgYTMzID0gMTtcclxuICAgICAgICAvLyBEb2Vzbid0IGNoYW5nZSB6XHJcbiAgICAgICAgdGhpcy5kYXRhWzRdID0gYTExICogeCArIGExMiAqIHkgKyBhMTM7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gYTIxICogeCArIGEyMiAqIHkgKyBhMjM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgc2NhbGluZyB0byB0aGUgY3VycmVudCBtYXRyaXggbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IGExMSAqIHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzFdID0gYTIxICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSBhMTIgKiB5O1xyXG4gICAgICAgIHRoaXMuZGF0YVszXSA9IGEyMiAqIHk7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVbMF0gPSB4O1xyXG4gICAgICAgIHRoaXMuX3NjYWxlWzFdID0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRldGVybWluYW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF0gKiB0aGlzLmRhdGFbM10gLSB0aGlzLmRhdGFbMV0gKiB0aGlzLmRhdGFbMl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgYWZmaW5lIGludmVyc2UsIG9wdGlvbmFsbHkgc3RvcmUgaXQgaW4gYSB0YXJnZXQgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEl0J3MgcmVjb21tZW5kZWQgeW91IGNhbGwgLnJlc2V0KCkgdGhlIHRhcmdldCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmdcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgaW52ZXJzZSh0YXJnZXQpIHtcclxuICAgICAgICAvLyBTZWUgaHR0cDovL25lZ2F0aXZlcHJvYmFiaWxpdHkuYmxvZ3Nwb3QuY29tLzIwMTEvMTEvYWZmaW5lLXRyYW5zZm9ybWF0aW9ucy1hbmQtdGhlaXIuaHRtbFxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5tYXRoc2lzZnVuLmNvbS9hbGdlYnJhL21hdHJpeC1pbnZlcnNlLmh0bWxcclxuICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgYWN0dWFsbHkgb25seSBkb2luZyAyRCB0cmFuc2Zvcm1hdGlvbnMgd2UgY2FuIHVzZSB0aGlzIGhhY2tcclxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIDNyZCBvciA0dGggZGltZW5zaW9uXHJcbiAgICAgICAgY29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xyXG4gICAgICAgIGNvbnN0IGludmVyc2VEZXQgPSAxIC8gZGV0OyAvLyBUT0RPIHplcm8gY2hlY2tcclxuICAgICAgICBjb25zdCBhID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBkID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIGNvbnN0IG0gPSB0YXJnZXQgfHwgQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgLy8gaW52ZXJ0cyByb3RhdGlvbiBhbmQgc2NhbGVcclxuICAgICAgICBtLmRhdGFbMF0gPSBkICogaW52ZXJzZURldDtcclxuICAgICAgICBtLmRhdGFbMV0gPSAtYyAqIGludmVyc2VEZXQ7XHJcbiAgICAgICAgbS5kYXRhWzJdID0gLWIgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIG0uZGF0YVszXSA9IGEgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IHR5ID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIC8vIGludmVydCB0cmFuc2xhdGlvblxyXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0cmFuc2xhdGlvbiBpbnRvIHRoZSBtYXRyaXggYmFzaXMgY3JlYXRlZCBieSByb3Qvc2NhbGVcclxuICAgICAgICBtLmRhdGFbNF0gPSAtKHR4ICogbS5kYXRhWzBdICsgdHkgKiBtLmRhdGFbMl0pO1xyXG4gICAgICAgIG0uZGF0YVs1XSA9IC0odHggKiBtLmRhdGFbMV0gKyB0eSAqIG0uZGF0YVszXSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcbiAgICBtdWx0aXBseSh2ZWN0b3JPck1hdHJpeCwgZGVzdCkge1xyXG4gICAgICAgIGlmICh2ZWN0b3JPck1hdHJpeCBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IHZlY3Rvck9yTWF0cml4O1xyXG4gICAgICAgICAgICAvLyB0aGVzZSBzaGVuYW5pZ2FucyBhcmUgdG8gYWxsb3cgZGVzdCBhbmQgdmVjdG9yIHRvIGJlIHRoZSBzYW1lIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFggPSB2ZWN0b3IueCAqIHRoaXMuZGF0YVswXSArIHZlY3Rvci55ICogdGhpcy5kYXRhWzJdICsgdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRZID0gdmVjdG9yLnggKiB0aGlzLmRhdGFbMV0gKyB2ZWN0b3IueSAqIHRoaXMuZGF0YVszXSArIHRoaXMuZGF0YVs1XTtcclxuICAgICAgICAgICAgcmVzdWx0LnggPSByZXN1bHRYO1xyXG4gICAgICAgICAgICByZXN1bHQueSA9IHJlc3VsdFk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZXN0IHx8IG5ldyBBZmZpbmVNYXRyaXgoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSB2ZWN0b3JPck1hdHJpeDtcclxuICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgICAgIC8vICBjb25zdCBhMzEgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICAgICAgLy8gIGNvbnN0IGEzMiA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgICAgICAvLyAgY29uc3QgYTMzID0gMTtcclxuICAgICAgICAgICAgY29uc3QgYjExID0gb3RoZXIuZGF0YVswXTtcclxuICAgICAgICAgICAgY29uc3QgYjIxID0gb3RoZXIuZGF0YVsxXTtcclxuICAgICAgICAgICAgLy8gIGNvbnN0IGIzMSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGIxMiA9IG90aGVyLmRhdGFbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGIyMiA9IG90aGVyLmRhdGFbM107XHJcbiAgICAgICAgICAgIC8vICBjb25zdCBiMzIgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBiMTMgPSBvdGhlci5kYXRhWzRdO1xyXG4gICAgICAgICAgICBjb25zdCBiMjMgPSBvdGhlci5kYXRhWzVdO1xyXG4gICAgICAgICAgICAvLyAgY29uc3QgYjMzID0gMTtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjE7IC8vICsgYTEzICogYjMxOyAvLyB6ZXJvXHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzFdID0gYTIxICogYjExICsgYTIyICogYjIxOyAvLyArIGEyMyAqIGIzMTsgLy8gemVyb1xyXG4gICAgICAgICAgICByZXN1bHQuZGF0YVsyXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMjsgLy8gKyBhMTMgKiBiMzI7IC8vIHplcm9cclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbM10gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjI7IC8vICsgYTIzICogYjMyOyAvLyB6ZXJvXHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzRdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzOyAvLyAqIGIzMzsgLy8gb25lXHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhWzVdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzOyAvLyAqIGIzMzsgLy8gb25lXHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5fc2NhbGVTaWduWCA9IHNpZ24ocy54KSAqIHNpZ24ocmVzdWx0Ll9zY2FsZVNpZ25YKTtcclxuICAgICAgICAgICAgcmVzdWx0Ll9zY2FsZVNpZ25ZID0gc2lnbihzLnkpICogc2lnbihyZXN1bHQuX3NjYWxlU2lnblkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvNHg0KCkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIG1hdC5kYXRhWzZdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs3XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOF0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzldID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzExXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTJdID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBtYXQuZGF0YVsxNF0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIHNldFJvdGF0aW9uKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xyXG4gICAgICAgIGNvbnN0IHNpbmUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgY29zaW5lID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IGNvc2luZSAqIGN1cnJlbnRTY2FsZS54O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHNpbmUgKiBjdXJyZW50U2NhbGUueTtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSAtc2luZSAqIGN1cnJlbnRTY2FsZS54O1xyXG4gICAgICAgIHRoaXMuZGF0YVszXSA9IGNvc2luZSAqIGN1cnJlbnRTY2FsZS55O1xyXG4gICAgfVxyXG4gICAgZ2V0Um90YXRpb24oKSB7XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuZGF0YVsxXSAvIHRoaXMuZ2V0U2NhbGVZKCksIHRoaXMuZGF0YVswXSAvIHRoaXMuZ2V0U2NhbGVYKCkpO1xyXG4gICAgICAgIHJldHVybiBjYW5vbmljYWxpemVBbmdsZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICBnZXRTY2FsZVgoKSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGUgc2NhbGUgb2YgdGhlIG1hdHJpeCAod2UgbG9zZSBzaWduIHNvIG5lZWQgdG8gYWRkIGl0IGJhY2spXHJcbiAgICAgICAgY29uc3QgeHNjYWxlID0gdmVjKHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzJdKS5kaXN0YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVNpZ25YICogeHNjYWxlO1xyXG4gICAgfVxyXG4gICAgZ2V0U2NhbGVZKCkge1xyXG4gICAgICAgIC8vIGFic29sdXRlIHNjYWxlIG9mIHRoZSBtYXRyaXggKHdlIGxvc2Ugc2lnbiBzbyBuZWVkIHRvIGFkZCBpdCBiYWNrKVxyXG4gICAgICAgIGNvbnN0IHlzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVszXSkuZGlzdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVTaWduWSAqIHlzY2FsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzY2FsZSBvZiB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGdldFNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB2ZWModGhpcy5nZXRTY2FsZVgoKSwgdGhpcy5nZXRTY2FsZVkoKSk7XHJcbiAgICB9XHJcbiAgICBzZXRTY2FsZVgodmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5fc2NhbGVbMF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25YID0gc2lnbih2YWwpO1xyXG4gICAgICAgIC8vIG5lZ2F0aXZlIHNjYWxlIGFjdHMgbGlrZSBhIDE4MCByb3RhdGlvbiwgc28gZmxpcFxyXG4gICAgICAgIGNvbnN0IHhzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMF0gKiB0aGlzLl9zY2FsZVNpZ25YLCB0aGlzLmRhdGFbMl0gKiB0aGlzLl9zY2FsZVNpZ25YKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4c2NhbGUueCAqIHZhbDtcclxuICAgICAgICB0aGlzLmRhdGFbMl0gPSB4c2NhbGUueSAqIHZhbDtcclxuICAgICAgICB0aGlzLl9zY2FsZVswXSA9IHZhbDtcclxuICAgIH1cclxuICAgIHNldFNjYWxlWSh2YWwpIHtcclxuICAgICAgICBpZiAodmFsID09PSB0aGlzLl9zY2FsZVsxXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NjYWxlU2lnblkgPSBzaWduKHZhbCk7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgc2NhbGUgYWN0cyBsaWtlIGEgMTgwIHJvdGF0aW9uLCBzbyBmbGlwXHJcbiAgICAgICAgY29uc3QgeXNjYWxlID0gdmVjKHRoaXMuZGF0YVsxXSAqIHRoaXMuX3NjYWxlU2lnblksIHRoaXMuZGF0YVszXSAqIHRoaXMuX3NjYWxlU2lnblkpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHlzY2FsZS54ICogdmFsO1xyXG4gICAgICAgIHRoaXMuZGF0YVszXSA9IHlzY2FsZS55ICogdmFsO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlWzFdID0gdmFsO1xyXG4gICAgfVxyXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWChzY2FsZS54KTtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWShzY2FsZS55KTtcclxuICAgIH1cclxuICAgIGlzSWRlbnRpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGFbMF0gPT09IDEgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzFdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbM10gPT09IDEgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzRdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs1XSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBtYXRyaXggdG8gdGhlIGlkZW50aXR5IG1hdHJpeCwgbXV0YXRpbmcgaXRcclxuICAgICAqIEByZXR1cm5zIHtBZmZpbmVNYXRyaXh9IEN1cnJlbnQgbWF0cml4IGFzIGlkZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IHRoaXM7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXRyaXggd2l0aCB0aGUgc2FtZSBkYXRhIGFzIHRoZSBjdXJyZW50IDR4NFxyXG4gICAgICovXHJcbiAgICBjbG9uZShkZXN0KSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gZGVzdCB8fCBuZXcgQWZmaW5lTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgbWF0LmRhdGFbMV0gPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgbWF0LmRhdGFbMl0gPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgXHJcblske3RoaXMuZGF0YVswXX0gJHt0aGlzLmRhdGFbMl19ICR7dGhpcy5kYXRhWzRdfV1cclxuWyR7dGhpcy5kYXRhWzFdfSAke3RoaXMuZGF0YVszXX0gJHt0aGlzLmRhdGFbNV19XVxyXG5bMCAwIDFdXHJcbmA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3RyYW5zZm9ybS1zdGFjay50c1xuXHJcbmNsYXNzIFRyYW5zZm9ybVN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybS5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3Jtcy5wb3AoKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ucm90YXRlKGFuZ2xlKTtcclxuICAgIH1cclxuICAgIHNjYWxlKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zZm9ybS5zY2FsZSh4LCB5KTtcclxuICAgIH1cclxuICAgIHNldCBjdXJyZW50KG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICBnZXQgY3VycmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc3RhdGUtc3RhY2sudHNcblxyXG5jbGFzcyBTdGF0ZVN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX2dldERlZmF1bHRTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgX2dldERlZmF1bHRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICB6OiAwLFxyXG4gICAgICAgICAgICB0aW50OiBDb2xvci5XaGl0ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfY2xvbmVTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLl9jdXJyZW50U3RhdGUub3BhY2l0eSxcclxuICAgICAgICAgICAgejogdGhpcy5fY3VycmVudFN0YXRlLnosXHJcbiAgICAgICAgICAgIHRpbnQ6IHRoaXMuX2N1cnJlbnRTdGF0ZS50aW50LmNsb25lKClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZXMucHVzaCh0aGlzLl9jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX2Nsb25lU3RhdGUoKTtcclxuICAgIH1cclxuICAgIHJlc3RvcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGhpcy5fc3RhdGVzLnBvcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcclxuICAgIH1cclxuICAgIHNldCBjdXJyZW50KHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHZhbDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0V2ZW50cy50c1xudmFyIEV2ZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoRXZlbnRUeXBlcykge1xyXG4gICAgRXZlbnRUeXBlc1tcIktpbGxcIl0gPSBcImtpbGxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVLaWxsXCJdID0gXCJwcmVraWxsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdEtpbGxcIl0gPSBcInBvc3RraWxsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUHJlRHJhd1wiXSA9IFwicHJlZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3REcmF3XCJdID0gXCJwb3N0ZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZURlYnVnRHJhd1wiXSA9IFwicHJlZGVidWdkcmF3XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdERlYnVnRHJhd1wiXSA9IFwicG9zdGRlYnVnZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZVVwZGF0ZVwiXSA9IFwicHJldXBkYXRlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdFVwZGF0ZVwiXSA9IFwicG9zdHVwZGF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZUZyYW1lXCJdID0gXCJwcmVmcmFtZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RGcmFtZVwiXSA9IFwicG9zdGZyYW1lXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUHJlQ29sbGlzaW9uXCJdID0gXCJwcmVjb2xsaXNpb25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDb2xsaXNpb25TdGFydFwiXSA9IFwiY29sbGlzaW9uc3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDb2xsaXNpb25FbmRcIl0gPSBcImNvbGxpc2lvbmVuZFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RDb2xsaXNpb25cIl0gPSBcInBvc3Rjb2xsaXNpb25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJJbml0aWFsaXplXCJdID0gXCJpbml0aWFsaXplXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQWN0aXZhdGVcIl0gPSBcImFjdGl2YXRlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRGVhY3RpdmF0ZVwiXSA9IFwiZGVhY3RpdmF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkV4aXRWaWV3cG9ydFwiXSA9IFwiZXhpdHZpZXdwb3J0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJWaWV3cG9ydFwiXSA9IFwiZW50ZXJ2aWV3cG9ydFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkV4aXRUcmlnZ2VyXCJdID0gXCJleGl0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJUcmlnZ2VyXCJdID0gXCJlbnRlclwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkNvbm5lY3RcIl0gPSBcImNvbm5lY3RcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJEaXNjb25uZWN0XCJdID0gXCJkaXNjb25uZWN0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQnV0dG9uXCJdID0gXCJidXR0b25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJBeGlzXCJdID0gXCJheGlzXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiVmlzaWJsZVwiXSA9IFwidmlzaWJsZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkhpZGRlblwiXSA9IFwiaGlkZGVuXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiU3RhcnRcIl0gPSBcInN0YXJ0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiU3RvcFwiXSA9IFwic3RvcFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJVcFwiXSA9IFwicG9pbnRlcnVwXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRvd25cIl0gPSBcInBvaW50ZXJkb3duXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlck1vdmVcIl0gPSBcInBvaW50ZXJtb3ZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckVudGVyXCJdID0gXCJwb2ludGVyZW50ZXJcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyTGVhdmVcIl0gPSBcInBvaW50ZXJsZWF2ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJDYW5jZWxcIl0gPSBcInBvaW50ZXJjYW5jZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyV2hlZWxcIl0gPSBcInBvaW50ZXJ3aGVlbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlVwXCJdID0gXCJ1cFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkRvd25cIl0gPSBcImRvd25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJNb3ZlXCJdID0gXCJtb3ZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJcIl0gPSBcImVudGVyXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiTGVhdmVcIl0gPSBcImxlYXZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQ2FuY2VsXCJdID0gXCJjYW5jZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJXaGVlbFwiXSA9IFwid2hlZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVzc1wiXSA9IFwicHJlc3NcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJSZWxlYXNlXCJdID0gXCJyZWxlYXNlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiSG9sZFwiXSA9IFwiaG9sZFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnU3RhcnRcIl0gPSBcInBvaW50ZXJkcmFnc3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRHJhZ0VuZFwiXSA9IFwicG9pbnRlcmRyYWdlbmRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRHJhZ0VudGVyXCJdID0gXCJwb2ludGVyZHJhZ2VudGVyXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRyYWdMZWF2ZVwiXSA9IFwicG9pbnRlcmRyYWdsZWF2ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnTW92ZVwiXSA9IFwicG9pbnRlcmRyYWdtb3ZlXCI7XHJcbn0pKEV2ZW50VHlwZXMgfHwgKEV2ZW50VHlwZXMgPSB7fSkpO1xyXG4vKipcclxuICogQmFzZSBldmVudCB0eXBlIGluIEV4Y2FsaWJ1ciB0aGF0IGFsbCBvdGhlciBldmVudCB0eXBlcyBkZXJpdmUgZnJvbS4gTm90IGFsbCBldmVudCB0eXBlcyBhcmUgdGhyb3duIG9uIGFsbCBFeGNhbGlidXIgZ2FtZSBvYmplY3RzLFxyXG4gKiBzb21lIGV2ZW50cyBhcmUgdW5pcXVlIHRvIGEgdHlwZSwgb3RoZXJzIGFyZSBub3QuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fYnViYmxlcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byBmYWxzZSwgcHJldmVudHMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byBvdGhlciBhY3RvcnMuIElmIHRydWUgaXQgd2lsbCBiZSBwcm9wYWdhdGVkXHJcbiAgICAgKiB0byBhbGwgYWN0b3JzIHRoYXQgYXBwbHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBidWJibGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWJibGVzO1xyXG4gICAgfVxyXG4gICAgc2V0IGJ1YmJsZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9idWJibGVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXZlbnRzIGV2ZW50IGZyb20gYnViYmxpbmdcclxuICAgICAqL1xyXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYnViYmxlcyA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ2tpbGwnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzIHdoZW4gaXQgaXMga2lsbGVkLiBUaGUgdGFyZ2V0IGlzIHRoZSBhY3RvciB0aGF0IHdhcyBraWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBLaWxsRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmVraWxsJyBldmVudCBpcyBlbWl0dGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBhY3RvciBpcyBraWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBQcmVLaWxsRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0a2lsbCcgZXZlbnQgaXMgZW1pdHRlZCBkaXJlY3RseSBhZnRlciB0aGUgYWN0b3IgaXMga2lsbGVkLlxyXG4gKi9cclxuY2xhc3MgUG9zdEtpbGxFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3N0YXJ0JyBldmVudCBpcyBlbWl0dGVkIG9uIGVuZ2luZSB3aGVuIGhhcyBzdGFydGVkIGFuZCBpcyByZWFkeSBmb3IgaW50ZXJhY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBHYW1lU3RhcnRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3N0b3AnIGV2ZW50IGlzIGVtaXR0ZWQgb24gZW5naW5lIHdoZW4gaGFzIGJlZW4gc3RvcHBlZCBhbmQgd2lsbCBubyBsb25nZXIgdGFrZSBpbnB1dCwgdXBkYXRlIG9yIGRyYXcuXHJcbiAqL1xyXG5jbGFzcyBHYW1lU3RvcEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncHJlZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgZHJhd2luZyBzdGFydHMuIEFjdG9ycycgcHJlZHJhdyBoYXBwZW5zIGluc2lkZSB0aGVpciBncmFwaGljc1xyXG4gKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgUHJlRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3Bvc3RkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRyYXdpbmcgZmluaXNoZXMuIEFjdG9ycycgcG9zdGRyYXcgaGFwcGVucyBpbnNpZGUgdGhlaXIgZ3JhcGhpY3NcclxuICogdHJhbnNmb3JtIHNvIHRoYXQgYWxsIGRyYXdpbmcgdGFrZXMgcGxhY2Ugd2l0aCB0aGUgYWN0b3IgYXMgdGhlIG9yaWdpbi5cclxuICpcclxuICovXHJcbmNsYXNzIFBvc3REcmF3RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncHJlZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkZWJ1ZyBkcmF3aW5nIHN0YXJ0cy5cclxuICovXHJcbmNsYXNzIFByZURlYnVnRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0ZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gKi9cclxuY2xhc3MgUG9zdERlYnVnRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmV1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGNhbWVyYSwgYW5kIGVuZ2luZSBiZWZvcmUgdGhlIHVwZGF0ZSBzdGFydHMuXHJcbiAqL1xyXG5jbGFzcyBQcmVVcGRhdGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0dXBkYXRlJyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBjYW1lcmEsIGFuZCBlbmdpbmUgYWZ0ZXIgdGhlIHVwZGF0ZSBlbmRzLlxyXG4gKi9cclxuY2xhc3MgUG9zdFVwZGF0ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3ByZWZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGJlZm9yZSB0aGUgZnJhbWUgYmVnaW5zLlxyXG4gKi9cclxuY2xhc3MgUHJlRnJhbWVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIHByZXZTdGF0cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5wcmV2U3RhdHMgPSBwcmV2U3RhdHM7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBlbmdpbmU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncG9zdGZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGFmdGVyIGEgZnJhbWUgZW5kcy5cclxuICovXHJcbmNsYXNzIFBvc3RGcmFtZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgc3RhdHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgY29ubmVjdGVkIHRvIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkQ29ubmVjdEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHJlY2VpdmVkIHdoZW4gYSBnYW1lcGFkIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgYnV0dG9uIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkQnV0dG9uRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYnV0dG9uICBUaGUgR2FtZXBhZCBidXR0b25cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgIEEgbnVtZXJpYyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYnV0dG9uLCB2YWx1ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgYXhpcyBldmVudC4gU2VlIFtbR2FtZXBhZHNdXSBmb3IgaW5mb3JtYXRpb24gb24gcmVzcG9uZGluZyB0byBjb250cm9sbGVyIGlucHV0LiBbW0dhbWVwYWRdXSBpbnN0YW5jZXMgcmVjZWl2ZSB0aGlzIGV2ZW50O1xyXG4gKi9cclxuY2xhc3MgR2FtZXBhZEF4aXNFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBheGlzICBUaGUgR2FtZXBhZCBheGlzXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXhpcywgdmFsdWUsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBbW0VuZ2luZV1dIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHZpc2libGUgb24gYSBzY3JlZW4uXHJcbiAqL1xyXG5jbGFzcyBWaXNpYmxlRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIFtbRW5naW5lXV0gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgaGlkZGVuIGZyb20gYWxsIHNjcmVlbnMuXHJcbiAqL1xyXG5jbGFzcyBIaWRkZW5FdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3RvcnxhY3Rvcl1dIHdoZW4gYSBjb2xsaXNpb24gd2lsbCBvY2N1ciB0aGlzIGZyYW1lIGlmIGl0IHJlc29sdmVzXHJcbiAqL1xyXG5jbGFzcyBQcmVDb2xsaXNpb25FdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgIFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxyXG4gICAgICogQHBhcmFtIG90aGVyICAgICAgICAgVGhlIGFjdG9yIHRoYXQgd2lsbCBjb2xsaWRlZCB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gc2lkZSAgICAgICAgICBUaGUgc2lkZSB0aGF0IHdpbGwgYmUgY29sbGlkZWQgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICogQHBhcmFtIGludGVyc2VjdGlvbiAgSW50ZXJzZWN0aW9uIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rvciwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3J8YWN0b3JdXSB3aGVuIGEgY29sbGlzaW9uIGhhcyBiZWVuIHJlc29sdmVkIChib2R5IHJlYWN0ZWQpIHRoaXMgZnJhbWVcclxuICovXHJcbmNsYXNzIFBvc3RDb2xsaXNpb25FdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhY3RvciAgICAgICAgIFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxyXG4gICAgICogQHBhcmFtIG90aGVyICAgICAgICAgVGhlIGFjdG9yIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICogQHBhcmFtIHNpZGUgICAgICAgICAgVGhlIHNpZGUgdGhhdCBkaWQgY29sbGlkZSB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0aW9uICBJbnRlcnNlY3Rpb24gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcclxuICAgIH1cclxuICAgIHNldCBhY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29udGFjdFN0YXJ0RXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvdGhlciwgY29udGFjdCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbnRhY3RFbmRFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbGxpc2lvblByZVNvbHZlRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uLCBjb250YWN0KSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24sIGNvbnRhY3QpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gdGhlIGZpcnN0IHRpbWUgYW4gW1tBY3RvcnxhY3Rvcl1dIGNvbGxpZGVzIHdpdGggYW5vdGhlciwgYWZ0ZXIgYW4gYWN0b3IgaXMgaW4gY29udGFjdCBub3JtYWwgY29sbGlzaW9uIGV2ZW50cyBhcmUgZmlyZWQuXHJcbiAqL1xyXG5jbGFzcyBDb2xsaXNpb25TdGFydEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3RvclxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKiBAcGFyYW0gY29udGFjdFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rvciwgb3RoZXIsIGNvbnRhY3QpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbiAgICBnZXQgYWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgc2V0IGFjdG9yKGFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIHdoZW4gdGhlIFtbQWN0b3J8YWN0b3JdXSBpcyBubyBsb25nZXIgY29sbGlkaW5nIHdpdGggYW5vdGhlclxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uRW5kRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rvciwgb3RoZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcclxuICAgIH1cclxuICAgIHNldCBhY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gYW5kIGEgW1tTY2VuZV1dIG9ubHkgb25jZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBjYWxsXHJcbiAqL1xyXG5jbGFzcyBJbml0aWFsaXplRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lICBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBhY3RpdmF0aW9uXHJcbiAqL1xyXG5jbGFzcyBBY3RpdmF0ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgIFRoZSBjb250ZXh0IGZvciB0aGUgc2NlbmUgYWN0aXZhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBkZWFjdGl2YXRpb25cclxuICovXHJcbmNsYXNzIERlYWN0aXZhdGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb250ZXh0ICBUaGUgY29udGV4dCBmb3IgdGhlIHNjZW5lIGRlYWN0aXZhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gKi9cclxuY2xhc3MgRXhpdFZpZXdQb3J0RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXHJcbiAqL1xyXG5jbGFzcyBFbnRlclZpZXdQb3J0RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFbnRlclRyaWdnZXJFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFjdG9yKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXhpdFRyaWdnZXJFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFjdG9yKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FdmVudERpc3BhdGNoZXIudHNcblxyXG5jbGFzcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9kZWZlcmVkSGFuZGxlclJlbW92YWxzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbnkgZXhpc3RpbmcgaGFuZGxlcnMgb3Igd2lyZWQgZXZlbnQgZGlzcGF0Y2hlcnMgb24gdGhpcyBldmVudCBkaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc0RlZmVycmVkSGFuZGxlclJlbW92YWxzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRIYW5kbGVyIG9mIHRoaXMuX2RlZmVyZWRIYW5kbGVyUmVtb3ZhbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSGFuZGxlcihldmVudEhhbmRsZXIubmFtZSwgZXZlbnRIYW5kbGVyLmhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZWZlcmVkSGFuZGxlclJlbW92YWxzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGZvciB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgICAgICBPcHRpb25hbGx5IHBhc3MgYW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gdGhlIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgZW1pdChldmVudE5hbWUsIGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0RlZmVycmVkSGFuZGxlclJlbW92YWxzKCk7XHJcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgLy8ga2V5IG5vdCBtYXBwZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEdhbWVFdmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaSwgbGVuO1xyXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1baV0oZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIGxlbiA9IHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzW2ldLmVtaXQoZXZlbnROYW1lLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlciB0byBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgbXVsdGlwbGUgaGFuZGxlcnMgcGVyIGV2ZW50IG5hbWUgYXJlIGFsbG93ZWQuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBUaGUgaGFuZGxlciBjYWxsYmFjayB0byBmaXJlIG9uIHRoaXMgZXZlbnRcclxuICAgICAqL1xyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0RlZmVycmVkSGFuZGxlclJlbW92YWxzKCk7XHJcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyKHMpIGZyb20gYW4gZXZlbnQuIElmIGEgc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICogaXMgc3BlY2lmaWVkIGZvciBhbiBldmVudCwgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSB1bnN1YnNjcmliZWQuXHJcbiAgICAgKiBPdGhlcndpc2UgYWxsIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGZvciB0aGF0IGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB1bnN1YnNjcmliZVxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICAgT3B0aW9uYWxseSB0aGUgc3BlY2lmaWMgaGFuZGxlciB0byB1bnN1YnNjcmliZVxyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZGVmZXJlZEhhbmRsZXJSZW1vdmFscy5wdXNoKHsgbmFtZTogZXZlbnROYW1lLCBoYW5kbGVyIH0pO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZUhhbmRsZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgLy8gaWYgbm8gZXhwbGljaXQgaGFuZGxlciBpcyBnaXZlIHdpdGggdGhlIGV2ZW50IG5hbWUgY2xlYXIgYWxsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgKi9cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0RlZmVycmVkSGFuZGxlclJlbW92YWxzKCk7XHJcbiAgICAgICAgY29uc3QgbWV0YUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXYgPSBldmVudCB8fCBuZXcgR2FtZUV2ZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbWV0YUhhbmRsZXIpO1xyXG4gICAgICAgICAgICBoYW5kbGVyKGV2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBtZXRhSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciB0byBhbHNvIHJlY2VpdmUgZXZlbnRzIGZyb20gYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB3aXJlKGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVud2lyZXMgdGhpcyBldmVudCBkaXNwYXRjaGVyIGZyb20gYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB1bndpcmUoZXZlbnREaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1Jlc291cmNlLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgW1tSZXNvdXJjZV1dIHR5cGUgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGdlbmVyaWMgcmVzb3VyY2VzLlxyXG4gKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBbW1Jlc291cmNlXV0gZm9yIHByZWxvYWRpbmcuXHJcbiAqL1xyXG5jbGFzcyBSZXNvdXJjZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoICAgICAgICAgIFBhdGggdG8gdGhlIHJlbW90ZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIHJlc3BvbnNlVHlwZSAgVGhlIHR5cGUgdG8gZXhwZWN0IGFzIGEgcmVzcG9uc2U6IFwiXCIgfCBcImFycmF5YnVmZmVyXCIgfCBcImJsb2JcIiB8IFwiZG9jdW1lbnRcIiB8IFwianNvblwiIHwgXCJ0ZXh0XCI7XHJcbiAgICAgKiBAcGFyYW0gYnVzdENhY2hlICAgICBXaGV0aGVyIG9yIG5vdCB0byBjYWNoZS1idXN0IHJlcXVlc3RzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIHJlc3BvbnNlVHlwZSwgYnVzdENhY2hlID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFJlc291cmNlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICogdG8gYmUgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBfY2FjaGVCdXN0KHVyaSkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gL1xcP1xcdyo9XFx3Ki87XHJcbiAgICAgICAgaWYgKHF1ZXJ5LnRlc3QodXJpKSkge1xyXG4gICAgICAgICAgICB1cmkgKz0gJyZfXz0nICsgRGF0ZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVyaSArPSAnP19fPScgKyBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbiBsb2FkaW5nIHRoZSByZXNvdXJjZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgYWxyZWFkeSBoYXZlIGRhdGFcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0FscmVhZHkgaGF2ZSBkYXRhIGZvciByZXNvdXJjZScsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjb21wbGV0ZScsIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMuYnVzdENhY2hlID8gdGhpcy5fY2FjaGVCdXN0KHRoaXMucGF0aCkgOiB0aGlzLnBhdGgsIHRydWUpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIChlKSA9PiB0aGlzLmV2ZW50cy5lbWl0KCdsb2Fkc3RhcnQnLCBlKSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZSkgPT4gdGhpcy5ldmVudHMuZW1pdCgncHJvZ3Jlc3MnLCBlKSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4gdGhpcy5ldmVudHMuZW1pdCgnZXJyb3InLCBlKSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKSA9PiB0aGlzLmV2ZW50cy5lbWl0KCdsb2FkJywgZSkpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBYSFIgb24gZmlsZTovLyBzdWNjZXNzIHN0YXR1cyBpcyAwLCBzdWNoIGFzIHdpdGggUGhhbnRvbUpTXHJcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCByZXNvdXJjZSAnLCB0aGlzLnBhdGgsICcgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGUnLCByZXF1ZXN0LnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnZXJyb3InLCByZXF1ZXN0LnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjb21wbGV0ZScsIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQ29tcGxldGVkIGxvYWRpbmcgcmVzb3VyY2UnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1dhdGNoLnRzXG4vKipcclxuICogV2F0Y2ggYW4gb2JqZWN0IHdpdGggYSBwcm94eSwgb25seSBmaXJlcyBpZiBwcm9wZXJ0eSB2YWx1ZSBpcyBkaWZmZXJlbnRcclxuICovXHJcbmZ1bmN0aW9uIHdhdGNoKHR5cGUsIGNoYW5nZSkge1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZS5fX2lzUHJveHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGV4cGFuZG8gaGFjayB0byBtYXJrIGEgcHJveHlcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHR5cGUsIHtcclxuICAgICAgICAgICAgc2V0OiAob2JqLCBwcm9wLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgdG8gc3RvcmUgdGhlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqW3Byb3BdICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdhdGNoaW5nIHByaXZhdGUganVua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ19faXNQcm94eScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcbi8qKlxyXG4gKiBXYXRjaCBhbiBvYmplY3Qgd2l0aCBhIHByb3h5LCBmaXJlcyBjaGFuZ2Ugb24gYW55IHByb3BlcnR5IHZhbHVlIGNoYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gd2F0Y2hBbnkodHlwZSwgY2hhbmdlKSB7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlLl9faXNQcm94eSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gZXhwYW5kbyBoYWNrIHRvIG1hcmsgYSBwcm94eVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodHlwZSwge1xyXG4gICAgICAgICAgICBzZXQ6IChvYmosIHByb3AsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciB0byBzdG9yZSB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2F0Y2hpbmcgcHJpdmF0ZSBqdW5rXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2Uob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ19faXNQcm94eScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvR3JhcGhpYy50c1xuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIEdyYXBoaWMgaXMgdGhlIGJhc2UgRXhjYWxpYnVyIHByaW1pdGl2ZSBmb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGRyYXduIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dLlxyXG4gKiBbW1Nwcml0ZV1dLCBbW0FuaW1hdGlvbl1dLCBbW0dyYXBoaWNzR3JvdXBdXSwgW1tDYW52YXNdXSwgW1tSZWN0YW5nbGVdXSwgW1tDaXJjbGVdXSwgYW5kIFtbUG9seWdvbl1dIGFsbCBkZXJpdmUgZnJvbSB0aGVcclxuICogW1tHcmFwaGljXV0gYWJzdHJhY3QgY2xhc3MuXHJcbiAqXHJcbiAqIEltcGxlbWVudG9ycyBvZiBhIEdyYXBoaWMgbXVzdCBvdmVycmlkZSB0aGUgYWJzdHJhY3QgW1tHcmFwaGljLl9kcmF3SW1hZ2VdXSBtZXRob2QgdG8gcmVuZGVyIGFuIGltYWdlIHRvIHRoZSBncmFwaGljcyBjb250ZXh0LiBHcmFwaGljXHJcbiAqIGhhbmRsZXMgYWxsIHRoZSBwb3NpdGlvbiwgcm90YXRpb24sIGFuZCBzY2FsZSB0cmFuc2Zvcm1hdGlvbnMgaW4gW1tHcmFwaGljLl9wcmVEcmF3XV0gYW5kIFtbR3JhcGhpYy5fcG9zdERyYXddXVxyXG4gKi9cclxuY2xhc3MgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgdGhpcy5pZCA9IEdyYXBoaWMuX0lEKys7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBBZmZpbmVNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICB0aGlzLnRpbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YWxlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgd2V0aGVyIHRvIHNob3cgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdyYXBoaWNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZmxpcFZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgZ3JhcGhpYywgMCBpcyB0cmFuc3BhcmVudCwgMSBpcyBzb2xpZCAob3BhcXVlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlID0gVmVjdG9yLk9uZTtcclxuICAgICAgICB0aGlzLl9vcmlnaW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gKF9hID0gb3B0aW9ucy5vcmlnaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMub3JpZ2luO1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gKF9iID0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5mbGlwSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSAoX2MgPSBvcHRpb25zLmZsaXBWZXJ0aWNhbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAoX2QgPSBvcHRpb25zLnJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAoX2UgPSBvcHRpb25zLm9wYWNpdHkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IChfZiA9IG9wdGlvbnMuc2NhbGUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNTdGFsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmxpcEhvcml6b250YWwsIHdoaWNoIHdpbGwgZmxpcCB0aGUgZ3JhcGhpYyBob3Jpem9udGFsbHkgKGFjcm9zcyB0aGUgeSBheGlzKVxyXG4gICAgICovXHJcbiAgICBnZXQgZmxpcEhvcml6b250YWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsaXBIb3Jpem9udGFsO1xyXG4gICAgfVxyXG4gICAgc2V0IGZsaXBIb3Jpem9udGFsKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZmxpcEhvcml6b250YWwgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmxpcFZlcnRpY2FsLCB3aGljaCB3aWxsIGZsaXAgdGhlIGdyYXBoaWMgdmVydGljYWxseSAoYWNyb3NzIHRoZSB4IGF4aXMpXHJcbiAgICAgKi9cclxuICAgIGdldCBmbGlwVmVydGljYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsaXBWZXJ0aWNhbDtcclxuICAgIH1cclxuICAgIHNldCBmbGlwVmVydGljYWwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mbGlwVmVydGljYWwgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGdyYXBoaWNcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhbGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNjYWxlIG9mIHRoZSBncmFwaGljLCB0aGlzIGFmZmVjdHMgdGhlIHdpZHRoIGFuZFxyXG4gICAgICovXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjYWxlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB3YXRjaCh2YWx1ZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhbGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9yaWdpbiBvZiB0aGUgZ3JhcGhpYywgaWYgbm90IHNldCB0aGUgY2VudGVyIG9mIHRoZSBncmFwaGljIGlzIHRoZSBvcmlnaW5cclxuICAgICAqL1xyXG4gICAgZ2V0IG9yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luO1xyXG4gICAgfVxyXG4gICAgc2V0IG9yaWdpbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29yaWdpbiA9IHdhdGNoKHZhbHVlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YWxlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjbG9uZUdyYXBoaWNPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4gPyB0aGlzLm9yaWdpbi5jbG9uZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgZmxpcEhvcml6b250YWw6IHRoaXMuZmxpcEhvcml6b250YWwsXHJcbiAgICAgICAgICAgIGZsaXBWZXJ0aWNhbDogdGhpcy5mbGlwVmVydGljYWwsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXHJcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlID8gdGhpcy5zY2FsZS5jbG9uZSgpIDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgd2lkdGggb2YgdGhlIGdyYXBoaWMgKGFsd2F5cyBwb3NpdGl2ZSlcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLl93aWR0aCAqIHRoaXMuc2NhbGUueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaGljIChhbHdheXMgcG9zaXRpdmUpXHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuX2hlaWdodCAqIHRoaXMuc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YWxlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBjb3B5IG9mIHRoZSBib3VuZHMgaW4gcGl4ZWxzIG9jY3VwaWVkIGJ5IHRoZSBncmFwaGljIG9uIHRoZSB0aGUgc2NyZWVuLiBUaGlzIGluY2x1ZGVzIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21EaW1lbnNpb24odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgd2hvbGUgZ3JhcGhpYyB0byB0aGUgY29udGV4dCBpbmNsdWRpbmcgdHJhbnNmb3JtXHJcbiAgICAgKiBAcGFyYW0gZXggVGhlIGV4Y2FsaWJ1ciBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgZHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3ByZURyYXcoZXgsIHgsIHkpO1xyXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZShleCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcG9zdERyYXcoZXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhZmZpbmUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBncmFwaGljcyBjb250ZXh0IHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoaWMgYmVmb3JlIFtbR3JhcGhpYy5fZHJhd0ltYWdlXV1cclxuICAgICAqIEBwYXJhbSBleFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIF9wcmVEcmF3KGV4LCB4LCB5KSB7XHJcbiAgICAgICAgZXguc2F2ZSgpO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtU3RhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUoTWF0aC5hYnModGhpcy5zY2FsZS54KSwgTWF0aC5hYnModGhpcy5zY2FsZS55KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0ZSh0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsaXAodGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1TdGFsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleC5tdWx0aXBseSh0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRvIG11bHRpcGx5IGFscGhhcyBzbyBncmFwaGljcyByZXNwZWN0IHRoZSBjdXJyZW50IGNvbnRleHRcclxuICAgICAgICBleC5vcGFjaXR5ID0gZXgub3BhY2l0eSAqIHRoaXMub3BhY2l0eTtcclxuICAgICAgICBpZiAodGhpcy50aW50KSB7XHJcbiAgICAgICAgICAgIGV4LnRpbnQgPSB0aGlzLnRpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JvdGF0ZShleCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzY2FsZURpclggPSB0aGlzLnNjYWxlLnggPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlRGlyWSA9IHRoaXMuc2NhbGUueSA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gKF9hID0gdGhpcy5vcmlnaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZlYyh0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICBleC50cmFuc2xhdGUob3JpZ2luLngsIG9yaWdpbi55KTtcclxuICAgICAgICBleC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgaGFuZGxpbmcgZGlyZWN0aW9uIGNoYW5nZXMgMSBvciAtMSwgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSBtaXNtYXRjaGVkIHRyYW5zbGF0ZXMoKVxyXG4gICAgICAgIGV4LnNjYWxlKHNjYWxlRGlyWCwgc2NhbGVEaXJZKTtcclxuICAgICAgICBleC50cmFuc2xhdGUoLW9yaWdpbi54LCAtb3JpZ2luLnkpO1xyXG4gICAgfVxyXG4gICAgX2ZsaXAoZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBleC50cmFuc2xhdGUodGhpcy53aWR0aCAvIHRoaXMuc2NhbGUueCwgMCk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSgwLCB0aGlzLmhlaWdodCAvIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGFueSBhZGRpdGlvbmFsIHdvcmsgYWZ0ZXIgW1tHcmFwaGljLl9kcmF3SW1hZ2VdXSBhbmQgcmVzdG9yZSB0aGUgY29udGV4dCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBleFxyXG4gICAgICovXHJcbiAgICBfcG9zdERyYXcoZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaG93RGVidWcpIHtcclxuICAgICAgICAgICAgZXguZGVidWcuZHJhd1JlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbn1cclxuR3JhcGhpYy5fSUQgPSAwO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Nwcml0ZS50c1xuXHJcblxyXG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9sb2dOb3RMb2FkZWRXYXJuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc291cmNlVmlldyA9IChfYSA9IG9wdGlvbnMuc291cmNlVmlldykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeyB4OiAwLCB5OiAwLCB3aWR0aDogd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogMCwgaGVpZ2h0OiBoZWlnaHQgIT09IG51bGwgJiYgaGVpZ2h0ICE9PSB2b2lkIDAgPyBoZWlnaHQgOiAwIH07XHJcbiAgICAgICAgdGhpcy5kZXN0U2l6ZSA9IChfYiA9IG9wdGlvbnMuZGVzdFNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHsgd2lkdGg6IHdpZHRoICE9PSBudWxsICYmIHdpZHRoICE9PSB2b2lkIDAgPyB3aWR0aCA6IDAsIGhlaWdodDogaGVpZ2h0ICE9PSBudWxsICYmIGhlaWdodCAhPT0gdm9pZCAwID8gaGVpZ2h0IDogMCB9O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICB0aGlzLmltYWdlLnJlYWR5LnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTcHJpdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbShpbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlKHtcclxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZGVzdFNpemUud2lkdGggKiB0aGlzLnNjYWxlLngpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5kZXN0U2l6ZS5oZWlnaHQgKiB0aGlzLnNjYWxlLnkpO1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKG5ld1dpZHRoKSB7XHJcbiAgICAgICAgbmV3V2lkdGggLz0gTWF0aC5hYnModGhpcy5zY2FsZS54KTtcclxuICAgICAgICB0aGlzLmRlc3RTaXplLndpZHRoID0gbmV3V2lkdGg7XHJcbiAgICAgICAgc3VwZXIud2lkdGggPSBNYXRoLmNlaWwodGhpcy5kZXN0U2l6ZS53aWR0aCk7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KG5ld0hlaWdodCkge1xyXG4gICAgICAgIG5ld0hlaWdodCAvPSBNYXRoLmFicyh0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgIHRoaXMuZGVzdFNpemUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG4gICAgICAgIHN1cGVyLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmRlc3RTaXplLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlU3ByaXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgICBjb25zdCB7IHdpZHRoOiBuYXRpdmVXaWR0aCwgaGVpZ2h0OiBuYXRpdmVIZWlnaHQgfSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgLy8gVGhpcyBjb2RlIHVzZXMgfHwgdG8gYXZvaWQgMCdzXHJcbiAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIG5hdGl2ZSBkaW1lbnNpb25cclxuICAgICAgICB0aGlzLnNvdXJjZVZpZXcud2lkdGggPSAoKF9hID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpIHx8IG5hdGl2ZVdpZHRoO1xyXG4gICAgICAgIHRoaXMuc291cmNlVmlldy5oZWlnaHQgPSAoKF9iID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCBuYXRpdmVIZWlnaHQ7XHJcbiAgICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgc291cmNlIGlmIHNwZWNpZmllZCwgdGhlbiBuYXRpdmVcclxuICAgICAgICB0aGlzLmRlc3RTaXplLndpZHRoID0gKChfYyA9IHRoaXMuZGVzdFNpemUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy53aWR0aCkgfHwgKChfZCA9IHRoaXMuc291cmNlVmlldykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpZHRoKSB8fCBuYXRpdmVXaWR0aDtcclxuICAgICAgICB0aGlzLmRlc3RTaXplLmhlaWdodCA9ICgoX2UgPSB0aGlzLmRlc3RTaXplKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaGVpZ2h0KSB8fCAoKF9mID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaGVpZ2h0KSB8fCBuYXRpdmVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLmRlc3RTaXplLndpZHRoKSAqIHRoaXMuc2NhbGUueDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmRlc3RTaXplLmhlaWdodCkgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICB9XHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmltYWdlLmlzTG9hZGVkKCkgJiYgdGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3ByaXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fcHJlRHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICBleC5kcmF3SW1hZ2UodGhpcy5pbWFnZS5pbWFnZSwgdGhpcy5zb3VyY2VWaWV3LngsIHRoaXMuc291cmNlVmlldy55LCB0aGlzLnNvdXJjZVZpZXcud2lkdGgsIHRoaXMuc291cmNlVmlldy5oZWlnaHQsIHgsIHksIHRoaXMuZGVzdFNpemUud2lkdGgsIHRoaXMuZGVzdFNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9nTm90TG9hZGVkV2FybmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYEltYWdlU291cmNlICR7dGhpcy5pbWFnZS5wYXRofWAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAgaXMgbm90IHlldCBsb2FkZWQgYW5kIHdvbid0IGJlIGRyYXduLiBQbGVhc2UgY2FsbCAubG9hZCgpIG9yIGluY2x1ZGUgaW4gYSBMb2FkZXIuXFxuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFJlYWQgaHR0cHM6Ly9leGNhbGlidXJqcy5jb20vZG9jcy9pbWFnZXNvdXJjZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dOb3RMb2FkZWRXYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZSh7XHJcbiAgICAgICAgICAgIGltYWdlOiB0aGlzLmltYWdlLFxyXG4gICAgICAgICAgICBzb3VyY2VWaWV3OiB7IC4uLnRoaXMuc291cmNlVmlldyB9LFxyXG4gICAgICAgICAgICBkZXN0U2l6ZTogeyAuLi50aGlzLmRlc3RTaXplIH0sXHJcbiAgICAgICAgICAgIC4uLnRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9GaWx0ZXJpbmcudHNcbi8qKlxyXG4gKiBEZXNjcmliZXMgdGhlIGRpZmZlcmVudCBpbWFnZSBmaWx0ZXJpbmcgbW9kZXNcclxuICovXHJcbnZhciBJbWFnZUZpbHRlcmluZztcclxuKGZ1bmN0aW9uIChJbWFnZUZpbHRlcmluZykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQaXhlbCBpcyB1c2VmdWwgd2hlbiB5b3UgZG8gbm90IHdhbnQgc21vb3RoaW5nIGFrYSBhbnRpYWxpYXNpbmcgYXBwbGllZCB0byB5b3VyIGdyYXBoaWNzLlxyXG4gICAgICpcclxuICAgICAqIFVzZWZ1bCBmb3IgUGl4ZWwgYXJ0IGFlc3RoZXRpY3MuXHJcbiAgICAgKi9cclxuICAgIEltYWdlRmlsdGVyaW5nW1wiUGl4ZWxcIl0gPSBcIlBpeGVsXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJsZW5kZWQgaXMgdXNlZnVsIHdoZW4geW91IGhhdmUgaGlnaCByZXNvbHV0aW9uIGFydHdvcmsgYW5kIHdvdWxkIGxpa2UgaXQgYmxlbmRlZCBhbmQgc21vb3RoZWRcclxuICAgICAqL1xyXG4gICAgSW1hZ2VGaWx0ZXJpbmdbXCJCbGVuZGVkXCJdID0gXCJCbGVuZGVkXCI7XHJcbn0pKEltYWdlRmlsdGVyaW5nIHx8IChJbWFnZUZpbHRlcmluZyA9IHt9KSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC90ZXh0dXJlLWxvYWRlci50c1xuXHJcblxyXG4vKipcclxuICogTWFuYWdlcyBsb2FkaW5nIGltYWdlIHNvdXJjZXMgaW50byB3ZWJnbCB0ZXh0dXJlcywgYSB1bmlxdWUgaWQgaXMgYXNzb2NpYXRlZCB3aXRoIGFsbCBzb3VyY2VzXHJcbiAqL1xyXG5jbGFzcyBUZXh0dXJlTG9hZGVyIHtcclxuICAgIHN0YXRpYyByZWdpc3Rlcihjb250ZXh0KSB7XHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5fR0wgPSBjb250ZXh0O1xyXG4gICAgICAgIFRleHR1cmVMb2FkZXIuX01BWF9URVhUVVJFX1NJWkUgPSBjb250ZXh0LmdldFBhcmFtZXRlcihjb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFdlYkdMIFRleHR1cmUgZnJvbSBhIHNvdXJjZSBpbWFnZVxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQoaW1hZ2UpIHtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZUxvYWRlci5fVEVYVFVSRV9NQVAuZ2V0KGltYWdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgc291cmNlIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBhcyBhIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSBpbWFnZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzKGltYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmVMb2FkZXIuX1RFWFRVUkVfTUFQLmhhcyhpbWFnZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ3JhcGhpYyBpbnRvIHdlYmdsIGFuZCByZXR1cm5zIGl0J3MgdGV4dHVyZSBpbmZvLCBhIHdlYmdsIGNvbnRleHQgbXVzdCBiZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWRcclxuICAgICAqIEBwYXJhbSBpbWFnZSBTb3VyY2UgZ3JhcGhpY1xyXG4gICAgICogQHBhcmFtIGZpbHRlcmluZyB7SW1hZ2VGaWx0ZXJpbmd9IFRoZSBJbWFnZUZpbHRlcmluZyBtb2RlIHRvIGFwcGx5IHRvIHRoZSBsb2FkZWQgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIGZvcmNlVXBkYXRlIE9wdGlvbmFsbHkgZm9yY2UgYSB0ZXh0dXJlIHRvIGJlIHJlbG9hZGVkLCB1c2VmdWwgaWYgdGhlIHNvdXJjZSBncmFwaGljIGhhcyBjaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsb2FkKGltYWdlLCBmaWx0ZXJpbmcsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBJZ25vcmUgbG9hZGluZyBpZiB3ZWJnbCBpcyBub3QgcmVnaXN0ZXJlZFxyXG4gICAgICAgIGNvbnN0IGdsID0gVGV4dHVyZUxvYWRlci5fR0w7XHJcbiAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRleCA9IG51bGw7XHJcbiAgICAgICAgLy8gSWYgcmV1c2UgdGhlIHRleHR1cmUgaWYgaXQncyBmcm9tIHRoZSBzYW1lIHNvdXJjZVxyXG4gICAgICAgIGlmIChUZXh0dXJlTG9hZGVyLmhhcyhpbWFnZSkpIHtcclxuICAgICAgICAgICAgdGV4ID0gVGV4dHVyZUxvYWRlci5nZXQoaW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgZXhpc3Rpbmcgd2ViZ2wgdGV4dHVyZSBhbmQgcmV0dXJuIGVhcmx5XHJcbiAgICAgICAgaWYgKHRleCkge1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBObyB0ZXh0dXJlIGV4aXN0cyBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICAgICAgdGV4ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIFRleHR1cmVMb2FkZXIuY2hlY2tJbWFnZVNpemVTdXBwb3J0ZWRBbmRMb2coaW1hZ2UpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAvLyBORUFSRVNUIGZvciBwaXhlbCBhcnQsIExJTkVBUiBmb3IgaGktcmVzXHJcbiAgICAgICAgY29uc3QgZmlsdGVyTW9kZSA9IGZpbHRlcmluZyAhPT0gbnVsbCAmJiBmaWx0ZXJpbmcgIT09IHZvaWQgMCA/IGZpbHRlcmluZyA6IFRleHR1cmVMb2FkZXIuZmlsdGVyaW5nO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJNb2RlID09PSBJbWFnZUZpbHRlcmluZy5QaXhlbCA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJNb2RlID09PSBJbWFnZUZpbHRlcmluZy5QaXhlbCA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xyXG4gICAgICAgIFRleHR1cmVMb2FkZXIuX1RFWFRVUkVfTUFQLnNldChpbWFnZSwgdGV4KTtcclxuICAgICAgICByZXR1cm4gdGV4O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlbGV0ZShpbWFnZSkge1xyXG4gICAgICAgIC8vIElnbm9yZSBsb2FkaW5nIGlmIHdlYmdsIGlzIG5vdCByZWdpc3RlcmVkXHJcbiAgICAgICAgY29uc3QgZ2wgPSBUZXh0dXJlTG9hZGVyLl9HTDtcclxuICAgICAgICBpZiAoIWdsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGV4ID0gbnVsbDtcclxuICAgICAgICBpZiAoVGV4dHVyZUxvYWRlci5oYXMoaW1hZ2UpKSB7XHJcbiAgICAgICAgICAgIHRleCA9IFRleHR1cmVMb2FkZXIuZ2V0KGltYWdlKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYW4gaW1hZ2UgYW5kIHJldHVybnMgaWYgaXQgbWVldHMgc2l6ZSBjcml0ZXJpYSBmb3IgaGFyZHdhcmVcclxuICAgICAqIEBwYXJhbSBpbWFnZVxyXG4gICAgICogQHJldHVybnMgaWYgdGhlIGltYWdlIHdpbGwgYmUgc3VwcG9ydGVkIGF0IHJ1bnRpbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrSW1hZ2VTaXplU3VwcG9ydGVkQW5kTG9nKGltYWdlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3JjID0gKF9hID0gaW1hZ2UuZGF0YXNldC5vcmlnaW5hbFNyYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2ludGVybmFsIGNhbnZhcyBiaXRtYXAnO1xyXG4gICAgICAgIGlmIChpbWFnZS53aWR0aCA+IFRleHR1cmVMb2FkZXIuX01BWF9URVhUVVJFX1NJWkUgfHwgaW1hZ2UuaGVpZ2h0ID4gVGV4dHVyZUxvYWRlci5fTUFYX1RFWFRVUkVfU0laRSkge1xyXG4gICAgICAgICAgICBUZXh0dXJlTG9hZGVyLl9MT0dHRVIuZXJyb3IoYFRoZSBpbWFnZSBbJHtvcmlnaW5hbFNyY31dIHByb3ZpZGVkIHRvIEV4Y2FsaWJ1ciBpcyB0b28gbGFyZ2UgZm9yIHRoZSBkZXZpY2UncyBtYXhpbXVtIHRleHR1cmUgc2l6ZSBvZiBgICtcclxuICAgICAgICAgICAgICAgIGAoJHtUZXh0dXJlTG9hZGVyLl9NQVhfVEVYVFVSRV9TSVpFfXgke1RleHR1cmVMb2FkZXIuX01BWF9URVhUVVJFX1NJWkV9KSBwbGVhc2UgcmVzaXplIHRvIGFuIGltYWdlIGBcclxuICAgICAgICAgICAgICAgICsgYGZvciBleGNhbGlidXIgdG8gcmVuZGVyIHByb3Blcmx5LlxcblxcbkltYWdlcyB3aWxsIGxpa2VseSByZW5kZXIgYXMgYmxhY2sgcmVjdGFuZ2xlcy5cXG5cXG5gICtcclxuICAgICAgICAgICAgICAgIGBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9XZWJHTF9iZXN0X3ByYWN0aWNlcyN1bmRlcnN0YW5kX3N5c3RlbV9saW1pdHNgKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbWFnZS53aWR0aCA+IDQwOTYgfHwgaW1hZ2UuaGVpZ2h0ID4gNDA5Nikge1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xfQVBJL1dlYkdMX2Jlc3RfcHJhY3RpY2VzI3VuZGVyc3RhbmRfc3lzdGVtX2xpbWl0c1xyXG4gICAgICAgICAgICBUZXh0dXJlTG9hZGVyLl9MT0dHRVIud2FybihgVGhlIGltYWdlIFske29yaWdpbmFsU3JjfV0gcHJvdmlkZWQgdG8gZXhjYWxpYnVyIGlzIHRvbyBsYXJnZSBtYXkgbm90IHdvcmsgb24gYWxsIG1vYmlsZSBkZXZpY2VzLCBgICtcclxuICAgICAgICAgICAgICAgIGBpdCBpcyByZWNvbW1lbmRlZCB5b3UgcmVzaXplIGltYWdlcyB0byBhIG1heGltdW0gKDQwOTZ4NDA5NikuXFxuXFxuYCArXHJcbiAgICAgICAgICAgICAgICBgSW1hZ2VzIHdpbGwgbGlrZWx5IHJlbmRlciBhcyBibGFjayByZWN0YW5nbGVzIG9uIHNvbWUgbW9iaWxlIHBsYXRmb3Jtcy5cXG5cXG5gICtcclxuICAgICAgICAgICAgICAgIGBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMX0FQSS9XZWJHTF9iZXN0X3ByYWN0aWNlcyN1bmRlcnN0YW5kX3N5c3RlbV9saW1pdHNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuVGV4dHVyZUxvYWRlci5fTE9HR0VSID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBkZWZhdWx0IGZpbHRlcmluZyBmb3IgdGhlIEV4Y2FsaWJ1ciB0ZXh0dXJlIGxvYWRlciwgZGVmYXVsdCBbW0ltYWdlRmlsdGVyaW5nLkJsZW5kZWRdXVxyXG4gKi9cclxuVGV4dHVyZUxvYWRlci5maWx0ZXJpbmcgPSBJbWFnZUZpbHRlcmluZy5CbGVuZGVkO1xyXG5UZXh0dXJlTG9hZGVyLl9URVhUVVJFX01BUCA9IG5ldyBNYXAoKTtcclxuVGV4dHVyZUxvYWRlci5fTUFYX1RFWFRVUkVfU0laRSA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvSW1hZ2VTb3VyY2UudHNcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgSW1hZ2VTb3VyY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgaW1hZ2UsIGNhbiBhbHNvIGJlIGEgZGF0YSB1cmwgbGlrZSAnZGF0YTppbWFnZS8nXHJcbiAgICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZSByZWxhdGl2ZSBmcm9tIHRoZSBIVE1MIGRvY3VtZW50IGhvc3RpbmcgdGhlIGdhbWUsIG9yIGFic29sdXRlXHJcbiAgICAgKiBAcGFyYW0gYnVzdENhY2hlIHtib29sZWFufSBTaG91bGQgZXhjYWxpYnVyIGFkZCBhIGNhY2hlIGJ1c3RpbmcgcXVlcnlzdHJpbmc/XHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyaW5nIHtJbWFnZUZpbHRlcmluZ30gT3B0aW9uYWxseSBvdmVycmlkZSB0aGUgaW1hZ2UgZmlsdGVyaW5nIHNldCBieSBbW0VuZ2luZU9wdGlvbnMuYW50aWFsaWFzaW5nXV1cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgYnVzdENhY2hlID0gZmFsc2UsIGZpbHRlcmluZykge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGh0bWwgaW1hZ2UgZWxlbWVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHRoaXMuX3JlYWR5RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb21pc2UgdGhlIHJlc29sdmVzIHdoZW4gdGhlIGltYWdlIGlzIGxvYWRlZCBhbmQgcmVhZHkgZm9yIHVzZSwgZG9lcyBub3QgaW5pdGlhdGUgbG9hZGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLl9yZWFkeUZ1dHVyZS5wcm9taXNlO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IFJlc291cmNlKHBhdGgsICdibG9iJywgYnVzdENhY2hlKTtcclxuICAgICAgICB0aGlzLl9maWx0ZXJpbmcgPSBmaWx0ZXJpbmc7XHJcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5zdmcnKSB8fCBwYXRoLmVuZHNXaXRoKCcuZ2lmJykpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYEltYWdlIHR5cGUgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCwgeW91IG1heSBoYXZlIG1peGVkIHJlc3VsdHMgJHtwYXRofS4gRnVsbHkgc3VwcG9ydGVkOiBqcGcsIGJtcCwgYW5kIHBuZ2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIHNvdXJjZSBpbWFnZSBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgc291cmNlIGltYWdlIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVGV4dHVyZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3NyYykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGJvb3N0cyBzcGVlZCBvZiBhY2Nlc3NcclxuICAgICAgICAgICAgdGhpcy5fc3JjID0gdGhpcy5kYXRhLnNyYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc3JjO1xyXG4gICAgfVxyXG4gICAgZ2V0IGltYWdlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSBpbWFnZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBpbWFnZSBpcyBsb2FkZWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIExvYWQgYmFzZTY0IG9yIGJsb2IgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGxldCB1cmw7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXRoLmluY2x1ZGVzKCdkYXRhOmltYWdlLycpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5fcmVzb3VyY2UubG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGltYWdlXHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIC8vIFVzZSBJbWFnZS5vbmxvYWQgb3ZlciBJbWFnZS5kZWNvZGUoKVxyXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDU1ODI4I2M3XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjaHJvbWUgd2lsbCB0aHJvdyBzdGlsbCBJbWFnZS5kZWNvZGUoKSBmYWlsdXJlcyBmb3IgbGFyZ2UgdGV4dHVyZXNcclxuICAgICAgICAgICAgY29uc3QgbG9hZGVkRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiBsb2FkZWRGdXR1cmUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1zcmMnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICBhd2FpdCBsb2FkZWRGdXR1cmUucHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gU2V0IHJlc3VsdHNcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBgRXJyb3IgbG9hZGluZyBJbWFnZVNvdXJjZSBmcm9tIHBhdGggJyR7dGhpcy5wYXRofScgd2l0aCBlcnJvciBbJHtlcnJvci5tZXNzYWdlfV1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUZXh0dXJlTG9hZGVyLmxvYWQodGhpcy5kYXRhLCB0aGlzLl9maWx0ZXJpbmcpO1xyXG4gICAgICAgIC8vIHRvZG8gZW1pdCBjb21wbGV0ZVxyXG4gICAgICAgIHRoaXMuX3JlYWR5RnV0dXJlLnJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBhIHNwcml0ZSBmcm9tIHRoaXMgSW1hZ2VTb3VyY2VcclxuICAgICAqL1xyXG4gICAgdG9TcHJpdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZS5mcm9tKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxvYWQgaW1hZ2VzIGZyb20gbWVtb3J5XHJcbiAgICAgKi9cclxuICAgIHVubG9hZCgpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Nwcml0ZVNoZWV0LnRzXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBzcHJpdGVzIGZyb20gYSBzb3VyY2UgaW1hZ2Ugd2l0aCBzb21lIG9yZ2FuaXphdGlvbiBpbiBhIGdyaWRcclxuICovXHJcbmNsYXNzIFNwcml0ZVNoZWV0IHtcclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYSBuZXcgc3ByaXRlIHNoZWV0IGZyb20gYSBsaXN0IG9mIHNwcml0ZXNcclxuICAgICAqXHJcbiAgICAgKiBVc2UgW1tTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2VdXSB0byBjcmVhdGUgYSBTcHJpdGVTaGVldCBmcm9tIGFuIFtbSW1hZ2VTb3VyY2VdXSBvcmdhbml6ZWQgaW4gYSBncmlkXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XHJcbiAgICAgICAgY29uc3QgeyBzcHJpdGVzLCByb3dzLCBjb2x1bW5zIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gcm93cyAhPT0gbnVsbCAmJiByb3dzICE9PSB2b2lkIDAgPyByb3dzIDogMTtcclxuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGEgc3ByaXRlIGJ5IHRoZWlyIHgveSBwb3NpdGlvbiBpbiB0aGUgU3ByaXRlU2hlZXQsIGZvciBleGFtcGxlIGBnZXRTcHJpdGUoMCwgMClgIGlzIHRoZSBbW1Nwcml0ZV1dIGluIHRoZSB0b3AtbGVmdFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIGdldFNwcml0ZSh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHggPj0gdGhpcy5jb2x1bW5zIHx8IHggPCAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBObyBzcHJpdGUgZXhpc3RzIGluIHRoZSBTcHJpdGVTaGVldCBhdCAoJHt4fSwgJHt5fSksIHg6ICR7eH0gc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLmNvbHVtbnMgLSAxfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPj0gdGhpcy5yb3dzIHx8IHkgPCAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBObyBzcHJpdGUgZXhpc3RzIGluIHRoZSBTcHJpdGVTaGVldCBhdCAoJHt4fSwgJHt5fSksIHk6ICR7eX0gc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgJHt0aGlzLnJvd3MgLSAxfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlSW5kZXggPSB4ICsgeSAqIHRoaXMuY29sdW1ucztcclxuICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzW3Nwcml0ZUluZGV4XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgc3ByaXRlIHNoZWV0IGZyb20gYSBzcGFyc2Ugc2V0IG9mIFtbU291cmNlVmlld11dIHJlY3RhbmdsZXNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSW1hZ2VTb3VyY2VXaXRoU291cmNlVmlld3Mob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBvcHRpb25zLnNvdXJjZVZpZXdzLm1hcChzb3VyY2VWaWV3ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoe1xyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IG9wdGlvbnMuaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VWaWV3XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlU2hlZXQoeyBzcHJpdGVzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBTcHJpdGVTaGVldCBmcm9tIGFuIFtbSW1hZ2VTb3VyY2VdXSBvcmdhbml6ZWQgaW4gYSBncmlkXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZTpcclxuICAgICAqIGBgYFxyXG4gICAgICogY29uc3Qgc3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2Uoe1xyXG4gICAgICogICBpbWFnZTogaW1hZ2VTb3VyY2UsXHJcbiAgICAgKiAgIGdyaWQ6IHtcclxuICAgICAqICAgICByb3dzOiA1LFxyXG4gICAgICogICAgIGNvbHVtbnM6IDIsXHJcbiAgICAgKiAgICAgc3ByaXRlV2lkdGg6IDMyLCAvLyBwaXhlbHNcclxuICAgICAqICAgICBzcHJpdGVIZWlnaHQ6IDMyIC8vIHBpeGVsc1xyXG4gICAgICogICB9LFxyXG4gICAgICogICAvLyBPcHRpb25hbGx5IHNwZWNpZnkgc3BhY2luZ1xyXG4gICAgICogICBzcGFjaW5nOiB7XHJcbiAgICAgKiAgICAgLy8gcGl4ZWxzIGZyb20gdGhlIHRvcCBsZWZ0IHRvIHN0YXJ0IHRoZSBzcHJpdGUgcGFyc2luZ1xyXG4gICAgICogICAgIG9yaWdpbk9mZnNldDoge1xyXG4gICAgICogICAgICAgeDogNSxcclxuICAgICAqICAgICAgIHk6IDVcclxuICAgICAqICAgICB9LFxyXG4gICAgICogICAgIC8vIHBpeGVscyBiZXR3ZWVuIGVhY2ggc3ByaXRlIHdoaWxlIHBhcnNpbmdcclxuICAgICAqICAgICBtYXJnaW46IHtcclxuICAgICAqICAgICAgIHg6IDEsXHJcbiAgICAgKiAgICAgICB5OiAxXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21JbWFnZVNvdXJjZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBbXTtcclxuICAgICAgICBvcHRpb25zLnNwYWNpbmcgPSAoX2EgPSBvcHRpb25zLnNwYWNpbmcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgICAgIGNvbnN0IHsgaW1hZ2UsIGdyaWQ6IHsgcm93cywgY29sdW1uczogY29scywgc3ByaXRlV2lkdGgsIHNwcml0ZUhlaWdodCB9LCBzcGFjaW5nOiB7IG9yaWdpbk9mZnNldCwgbWFyZ2luIH0gfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0RGVmYXVsdHMgPSB7IHg6IDAsIHk6IDAsIC4uLm9yaWdpbk9mZnNldCB9O1xyXG4gICAgICAgIGNvbnN0IG1hcmdpbkRlZmF1bHRzID0geyB4OiAwLCB5OiAwLCAuLi5tYXJnaW4gfTtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvbHM7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvd3M7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlc1t4ICsgeSAqIGNvbHNdID0gbmV3IFNwcml0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVZpZXc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCAqIHNwcml0ZVdpZHRoICsgbWFyZ2luRGVmYXVsdHMueCAqIHggKyBvZmZzZXREZWZhdWx0cy54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5ICogc3ByaXRlSGVpZ2h0ICsgbWFyZ2luRGVmYXVsdHMueSAqIHkgKyBvZmZzZXREZWZhdWx0cy55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc3ByaXRlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogc3ByaXRlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkZXN0U2l6ZTogeyBoZWlnaHQ6IHNwcml0ZUhlaWdodCwgd2lkdGg6IHNwcml0ZVdpZHRoIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlU2hlZXQoe1xyXG4gICAgICAgICAgICBzcHJpdGVzOiBzcHJpdGVzLFxyXG4gICAgICAgICAgICByb3dzOiByb3dzLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiBjb2xzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9TcHJpdGVGb250LnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgU3ByaXRlRm9udCBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSAnJztcclxuICAgICAgICB0aGlzLmFscGhhYmV0ID0gJyc7XHJcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gMDtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLl9hbHJlYWR5V2FybmVkQWxwaGFiZXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hbHJlYWR5V2FybmVkU3ByaXRlU2hlZXQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IGFscGhhYmV0LCBzcHJpdGVTaGVldCwgY2FzZUluc2Vuc2l0aXZlLCBzcGFjaW5nLCBzaGFkb3cgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0O1xyXG4gICAgICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcclxuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZSAhPT0gbnVsbCAmJiBjYXNlSW5zZW5zaXRpdmUgIT09IHZvaWQgMCA/IGNhc2VJbnNlbnNpdGl2ZSA6IHRoaXMuY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IHNwYWNpbmcgIT09IG51bGwgJiYgc3BhY2luZyAhPT0gdm9pZCAwID8gc3BhY2luZyA6IHRoaXMuc3BhY2luZztcclxuICAgICAgICB0aGlzLnNoYWRvdyA9IHNoYWRvdyAhPT0gbnVsbCAmJiBzaGFkb3cgIT09IHZvaWQgMCA/IHNoYWRvdyA6IHRoaXMuc2hhZG93O1xyXG4gICAgfVxyXG4gICAgX2dldENoYXJhY3RlclNwcml0ZXModGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAvLyBoYW5kbGUgY2FzZSBpbnNlbnNpdGl2ZVxyXG4gICAgICAgIGNvbnN0IHRleHRUb1JlbmRlciA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlID8gdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpIDogdGV4dDtcclxuICAgICAgICBjb25zdCBhbHBoYWJldCA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlID8gdGhpcy5hbHBoYWJldC50b0xvY2FsZUxvd2VyQ2FzZSgpIDogdGhpcy5hbHBoYWJldDtcclxuICAgICAgICAvLyBmb3IgZWFjaCBsZXR0ZXIgaW4gdGV4dFxyXG4gICAgICAgIGZvciAobGV0IGxldHRlckluZGV4ID0gMDsgbGV0dGVySW5kZXggPCB0ZXh0VG9SZW5kZXIubGVuZ3RoOyBsZXR0ZXJJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHNwcml0ZSBpbmRleCBpbiBhbHBoYWJldCAsIGlmIHRoZXJlIGlzIGFuIGVycm9yIHBpY2sgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IHRleHRUb1JlbmRlcltsZXR0ZXJJbmRleF07XHJcbiAgICAgICAgICAgIGxldCBzcHJpdGVJbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHJlYWR5V2FybmVkQWxwaGFiZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgU3ByaXRlRm9udCAtIENhbm5vdCBmaW5kIGxldHRlciAnJHtsZXR0ZXJ9JyBpbiBjb25maWd1cmVkIGFscGhhYmV0ICcke2FscGhhYmV0fScuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ1RoZXJlIG1heWJlIGJlIG1vcmUgaXNzdWVzIGluIHRoZSBTcHJpdGVGb250IGNvbmZpZ3VyYXRpb24uIE5vIGFkZGl0aW9uYWwgd2FybmluZ3Mgd2lsbCBiZSBsb2dnZWQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxyZWFkeVdhcm5lZEFscGhhYmV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsZXR0ZXJTcHJpdGUgPSB0aGlzLnNwcml0ZVNoZWV0LnNwcml0ZXNbc3ByaXRlSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAobGV0dGVyU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobGV0dGVyU3ByaXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWxyZWFkeVdhcm5lZFNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFNwcml0ZUZvbnQgLSBDYW5ub3QgZmluZCBzcHJpdGUgZm9yICcke2xldHRlcn0nIGF0IGluZGV4ICcke3Nwcml0ZUluZGV4fScgaW4gY29uZmlndXJlZCBTcHJpdGVTaGVldGApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdUaGVyZSBtYXliZSBiZSBtb3JlIGlzc3VlcyBpbiB0aGUgU3ByaXRlRm9udCBjb25maWd1cmF0aW9uLiBObyBhZGRpdGlvbmFsIHdhcm5pbmdzIHdpbGwgYmUgbG9nZ2VkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FscmVhZHlXYXJuZWRTcHJpdGVTaGVldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICBtZWFzdXJlVGV4dCh0ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcclxuICAgICAgICBjb25zdCBtYXhXaWR0aExpbmUgPSBsaW5lcy5yZWR1Y2UoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5fZ2V0Q2hhcmFjdGVyU3ByaXRlcyhtYXhXaWR0aExpbmUpO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBzcHJpdGUgb2Ygc3ByaXRlcykge1xyXG4gICAgICAgICAgICB3aWR0aCArPSBzcHJpdGUud2lkdGggKyB0aGlzLnNwYWNpbmc7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgc3ByaXRlLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tRGltZW5zaW9uKHdpZHRoLCBoZWlnaHQgKiBsaW5lcy5sZW5ndGgsIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBsZXQgeEN1cnNvciA9IDA7XHJcbiAgICAgICAgbGV0IHlDdXJzb3IgPSAwO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fdGV4dC5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ByaXRlIG9mIHRoaXMuX2dldENoYXJhY3RlclNwcml0ZXMobGluZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRyYXcgaXQgaW4gdGhlIHJpZ2h0IHNwb3QgYW5kIGluY3JlYXNlIHRoZSBjdXJzb3IgYnkgc3ByaXRlIHdpZHRoXHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuZHJhdyhleCwgeCArIHhDdXJzb3IsIHkgKyB5Q3Vyc29yKTtcclxuICAgICAgICAgICAgICAgIHhDdXJzb3IgKz0gc3ByaXRlLndpZHRoICsgdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBzcHJpdGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4Q3Vyc29yID0gMDtcclxuICAgICAgICAgICAgeUN1cnNvciArPSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKGV4LCB0ZXh0LCBfY29sb3IsIHgsIHkpIHtcclxuICAgICAgICAvLyBTcHJpdGVGb250IGRvZXNuJ3Qgc3VwcG9ydCBfY29sb3IsIHlldC4uLlxyXG4gICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGJvdW5kcy53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XHJcbiAgICAgICAgICAgIGV4LnNhdmUoKTtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKHRoaXMuc2hhZG93Lm9mZnNldC54LCB0aGlzLnNoYWRvdy5vZmZzZXQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhdyhleCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGV4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3KGV4LCB4LCB5KTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlRm9udCh7XHJcbiAgICAgICAgICAgIGFscGhhYmV0OiB0aGlzLmFscGhhYmV0LFxyXG4gICAgICAgICAgICBzcHJpdGVTaGVldDogdGhpcy5zcHJpdGVTaGVldCxcclxuICAgICAgICAgICAgc3BhY2luZzogdGhpcy5zcGFjaW5nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2RlYnVnLWZvbnQucG5nXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGRlYnVnX2ZvbnQgPSAoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVFBQUFBQXdDQVlBQUFEK2Y2Ui9BQUFBQVhOU1IwSUFyczRjNlFBQUJjSkpSRUZVZUp6dG5lbXU3Q2dNaEdFMDcvL0ttVDlOaHJBRlZ6a1FuZFFudFhSUDMvYkNaa3dDU1FoQ0NDR0VFRUlJSVlRUVFvZy9UUno5NTNFY3gvbkRHSWUvdmROaGxjOXRJejYwNUZrL1ptV2ZzTzFobjlHeHV2MUtIYnZiM2lML1ZOK2QxV09SYnlyN3lSLzViOU00dmpOZXFrbzZqUEpIcTV3R0hVMTUxbzlKMlVkc2U5aG5kQ3h1djBySDdyWTN5RC9XZHlmMTNNcm5RZURma1pJVVNHS000ZmYzY1dOODJwRVp1VHlRR1gySXhleVI2M3ZhLy84Vk5DWUNxKzF5RWtMdFd5YWdYdjFQMXIxSCsxMTBnUDNQelQ0Z1Q4dVcvbWRROG1VRzhFOURxT3o0TVM5SUNLR2JYcFMyQnBuSXJSelllUzk2Y2xsMDhJTmxDTWwyL2dsemRjZmF6dXVQcVFPMDNsbXFyQkhzZjI3MlE2Tk9EWGo2enpaSUpkL0xBSFlUZzNNYXlzNWdCaTdaUjI3Zk9nczB5ajhybTM2RExNRmlQZ2tBZFhIS093VVFlTUNRL2FkU2gvcUJRclQvdFB4YkF3QTkrRE9aRUlMUEFBVFN1SE1nVHY3K0F1ay9kZjJsSFBDWkx2TVNMSmUzNExrRVE5UHdYRjFTUlRsbE1ZZ3ZJYWZscXlWQWpMR2JzaUNEY09LNzZqZmx4WitzSU5QeVJPYzUwNzF5S1dLNUNKVFYzZE1wNit0Qmx5Q3RObGhBcS8rWGJXb0JEY1JOWFlCTXpENFZ2UXlnU3VQWUMyakdHYVNTT3hYZnkzZFRVRXNhbkl2TmVlcG0zOE4vaHNzU0FMVFBabkFYZndJWVJKbjJiN1VCY3cwRktYK25EZEFNcG0yajlXVm54clVhN1RYYVZBY2EvQitUZ2FBVmg2Ui9ySDBQLzVtMDFkdC9STFlWaUpuK3cvYmhWWDJQN2YvZHVxb201cWIwMnBSTENMR0lNZ0JVMXdDRUVOOUJBVUNJRDZNQUlNU0hVUUFRNHNNb0FBanhZUlFBaFBnd2QxdUIwZnVaN0gzY25uMlArOW1yL1BlNEI4L2VCL2Z3UDRlUnRjaS8wZjZPZlRDUHQvOW9Id0M2RzZ5MTlSSFpEdW14bXd6UjRlRS9zLzJUdGUvcS8rWExkYzlEZUoxOWRpZXNRYy9qN1o4ZkNlNHRBUzRDeFo3c3A3ZWlKaTdIaVptam1PVEdKcys5M0NiUzNuUDBYSVBIM3ZXOC9xejZRUG5YMlFkc1YvMXV3L2laWXZnOEFDZUhkMjhycFB6Zk5maEwrN3Zrdy80T3U5cytPbmhidjkxZWxwS1o0OERsNmJ6cHd3aWJIaWdSQXJmK1B0azkrTDNZMVE1T0I0TGdDZVNCdzFpdUIzR2VKaDEvSHJYL3pGMEE5TWsrdTQ1ek1rYzNyNHJXUG9tbWE1K3AvNTE0TEIrWm85M01FckoxSkh4WFB6QnlHYS9saWNSWVZLYnBlUUNvUTZROHl4dUN3SkY5SVBzb0RrSEFvLzNUeDI2Y3ZBNEV0Si9uMDR3OFFPcS9tclI3ZGRmTEFDNUJZRk5sVkkvMENuT1ZVZmxPcHZKVVFNeDlBSU1JVy9uV0RNNjcvcXcwKzk1djlnb0JxRDlqKzcydS9LRDlVODlJYm5RYk1JUjJaYm5laDV6VVk3SGRrN1hJUDNVZmZWYityK3dEWUFaTHErMW4xK0M3eTMvbnkycjdwNXllQnlERWg5SHpBSVFRSndvQVFud1lCUUFoUG93Q2dCQmpvTnUzaE54U0ZBQ0U2SU51S3ZQYWpQWjRFRkVBRUtJTmN5YkdZek9kMjQ3V0VkM1RnQTJqbG1qRXlyZCtqOWh2ZlZiRDJQV1EzWm1HbHUySHlPOG9nOGVCdU5Vdk5ZV29EZ01WcHdIVEpvTFdkejFZK1pZT3k1dUY3dDZQUHJ1WnhBTnJ1ZDFsUVhrUDBqc0d6L1l6K3ZHR011eWdGeWhTUGNKbmMxcE1uUVpFbGMrY1Jub0FseGRUdm9EdUs3cHVxRjd1Q1F5KzNmeUZNaUEwMi92SlFIaDdEUURvZ01QVFNHRk5BNTZIVHpiWjl5QWZCT2IxWnlvM3FHTTNNZk1aM2Y3Nmh1WGY2eGxtQUhrbk1sTE5Yc0JCQnZibGpJejlVeXo1WTVUeklCTFIvcXkvck55clo4K0wvMEJaMG0rdGdYRDBPSzVYWnhDLzlQN0kvZzRoVkZ2elhmMS82aTVBNyszQWxpak1QQkxNWmZDdnVBcDdBOXJZNTZBcEhpdG1MUWM3YzhiT3Y2ZnRBeGxNOVhwMzVua0VLN25KZXRCc2FNaHRBQUF1T0xRR1h3aGgyZFhRbm4xclovYTQyQkkzZEw3TCtqa0ZBYlFkZHdkQTlBaDM1eU1LaGdFZ1ZUNDZFRmg1RDRqeitPZ2F2Tkt4ZUJDZDF3RFNKLzk3b1I4ZW9Ka0xpOXQ5L0JEZ0RIVEo1TkU3RG56ZWNoaDkxNE9WdjlNMUs5UENxc2ZxYjg4WFZnOXFOOWxtNm5HMTc2VVB1K3puMTdHT3h1TzB2T1dFRUMvaitMRktUZ2dobHZFZllKYUxTK1NBMk8wQUFBQUFTVVZPUks1Q1lJST1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2RlYnVnLXRleHQudHNcblxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGRlYnVndGV4dCBoZWxwZXJcclxuICovXHJcbmNsYXNzIERlYnVnVGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBiYXNlNjQgZm9udFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZm9udFNoZWV0ID0gZGVidWdfZm9udDtcclxuICAgICAgICB0aGlzLnNpemUgPSAxNjtcclxuICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VTb3VyY2UgPSBuZXcgSW1hZ2VTb3VyY2UodGhpcy5mb250U2hlZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVNvdXJjZS5sb2FkKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlKHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLl9pbWFnZVNvdXJjZSxcclxuICAgICAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByb3dzOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IDE2LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZVdpZHRoOiAxNixcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVIZWlnaHQ6IDE2XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVGb250ID0gbmV3IFNwcml0ZUZvbnQoe1xyXG4gICAgICAgICAgICAgICAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVosIVxcJyYuXCI/LSgpKyAnLFxyXG4gICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlU2hlZXQ6IHRoaXMuX3Nwcml0ZVNoZWV0LFxyXG4gICAgICAgICAgICAgICAgc3BhY2luZzogLTZcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBkZWJ1ZyB0ZXh0IHVzaW5nIHRoZSBidWlsdCBpbiBzcHJpbnQgZm9udFxyXG4gICAgICogQHBhcmFtIGN0eFxyXG4gICAgICogQHBhcmFtIHRleHRcclxuICAgICAqIEBwYXJhbSBwb3NcclxuICAgICAqL1xyXG4gICAgd3JpdGUoY3R4LCB0ZXh0LCBwb3MpIHtcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VTb3VyY2UuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVGb250LnJlbmRlcihjdHgsIHRleHQsIG51bGwsIHBvcy54LCBwb3MueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9yZW5kZXItc291cmNlLnRzXG5jbGFzcyBSZW5kZXJTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3IoX2dsLCBfdGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gX2dsO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgIH1cclxuICAgIHVzZSgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgZGlzYWJsZSgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9yZW5kZXItdGFyZ2V0LnRzXG5cclxuY2xhc3MgUmVuZGVyVGFyZ2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2dsID0gb3B0aW9ucy5nbDtcclxuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lYnVmZmVyKCk7XHJcbiAgICB9XHJcbiAgICBzZXRSZXNvbHV0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9mcmFtZVRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZyYW1lQnVmZmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGdldCBmcmFtZVRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lVGV4dHVyZTtcclxuICAgIH1cclxuICAgIF9zZXR1cEZyYW1lYnVmZmVyKCkge1xyXG4gICAgICAgIC8vIEFsbG9jYXRlcyBmcmFtZSBidWZmZXJcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9mcmFtZVRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgICAgIC8vIHNldCB0aGUgZmlsdGVyaW5nIHNvIHdlIGRvbid0IG5lZWQgbWlwc1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgLy8gYXR0YWNoIHRoZSB0ZXh0dXJlIGFzIHRoZSBmaXJzdCBjb2xvciBhdHRhY2htZW50XHJcbiAgICAgICAgY29uc3QgYXR0YWNobWVudFBvaW50ID0gZ2wuQ09MT1JfQVRUQUNITUVOVDA7XHJcbiAgICAgICAgLy8gQWZ0ZXIgdGhpcyBiaW5kIGFsbCBkcmF3IGNhbGxzIHdpbGwgZHJhdyB0byB0aGlzIGZyYW1lYnVmZmVyIHRleHR1cmVcclxuICAgICAgICB0aGlzLl9mcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZnJhbWVUZXh0dXJlLCAwKTtcclxuICAgICAgICAvLyBSZXNldCBhZnRlciBpbml0aWFsaXplZFxyXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG4gICAgfVxyXG4gICAgdG9SZW5kZXJTb3VyY2UoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFJlbmRlclNvdXJjZSh0aGlzLl9nbCwgdGhpcy5fZnJhbWVUZXh0dXJlKTtcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGNhbGxlZCwgYWxsIGRyYXdpbmcgZ2V0cyByZWRpcmVjdGVkIHRvIHRoaXMgcmVuZGVyIHRhcmdldFxyXG4gICAgICovXHJcbiAgICB1c2UoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcclxuICAgICAgICAvLyB2ZXJ5IGltcG9ydGFudCB0byBzZXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBzaXplIG9mIHRoZSBmcmFtZWJ1ZmZlciB0ZXh0dXJlXHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGNhbGxlZCwgYWxsIGRyYXdpbmcgaXMgc2VudCBiYWNrIHRvIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgZGlzYWJsZSgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIC8vIHBhc3NpbmcgbnVsbCBzd2l0Y2hlcyByZW5kZXJpbmcgYmFjayB0byB0aGUgY2FudmFzXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvd2ViZ2wtYWRhcHRlci50c1xuLyoqXHJcbiAqIE11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgRW5naW5lIGNvbnN0cnVjdGlvbiB0aW1lIHRvIGVuc3VyZSB0aGUgY29udGV4dCBoYXMgYmVlbiBjcmVhdGVkXHJcbiAqL1xyXG5jbGFzcyBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3NvciB7XHJcbiAgICBzdGF0aWMgY2xlYXIoKSB7XHJcbiAgICAgICAgRXhjYWxpYnVyV2ViR0xDb250ZXh0QWNjZXNzb3IuX0dMID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyByZWdpc3RlcihnbCkge1xyXG4gICAgICAgIEV4Y2FsaWJ1cldlYkdMQ29udGV4dEFjY2Vzc29yLl9HTCA9IGdsO1xyXG4gICAgfVxyXG4gICAgLy8gY3VycmVudCB3ZWJnbCBjb250ZXh0XHJcbiAgICBzdGF0aWMgZ2V0IGdsKCkge1xyXG4gICAgICAgIGlmICghRXhjYWxpYnVyV2ViR0xDb250ZXh0QWNjZXNzb3IuX0dMKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBdHRlbXB0ZWQgZ2wgYWNjZXNzIGJlZm9yZSBpbml0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3Nvci5fR0w7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2xpbmUtcmVuZGVyZXIvbGluZS12ZXJ0ZXguZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBsaW5lX3ZlcnRleCA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbmluIHZlYzIgYV9wb3NpdGlvbjtcXHJcXG5pbiB2ZWM0IGFfY29sb3I7XFxyXFxuXFxyXFxub3V0IGxvd3AgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgLy8gU2V0IHRoZSB2ZXJ0ZXggcG9zaXRpb24gdXNpbmcgdGhlIG9ydGhvIHRyYW5zZm9ybSBtYXRyaXhcXHJcXG4gICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgLy8gUGFzc3Rocm91Z2ggdGhlIGNvbG9yXFxyXFxuICAgdl9jb2xvciA9IGFfY29sb3I7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvbGluZS1yZW5kZXJlci9saW5lLWZyYWdtZW50Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGluZV9mcmFnbWVudCA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbi8vIENvbG9yXFxyXFxuaW4gbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxub3V0IHZlYzQgZnJhZ0NvbG9yO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gIGZyYWdDb2xvciA9IHZfY29sb3I7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvd2ViZ2wtdXRpbC50c1xuLyoqXHJcbiAqIFJldHVybiB0aGUgc2l6ZSBvZiB0aGUgR2xUeXBlIGluIGJ5dGVzXHJcbiAqIEBwYXJhbSBnbFxyXG4gKiBAcGFyYW0gdHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2xUeXBlU2l6ZUJ5dGVzKGdsLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIGdsLkZMT0FUOlxyXG4gICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICBjYXNlIGdsLlNIT1JUOlxyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICBjYXNlIGdsLkJZVEU6XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgZ2wuVU5TSUdORURfQllURTpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2VkIG9uIHRoZSB0eXBlIHJldHVybiB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZSBjb21wb25lbnRzXHJcbiAqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvdmVydGV4QXR0cmliUG9pbnRlclxyXG4gKiBAcGFyYW0gZ2xcclxuICogQHBhcmFtIHR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUNvbXBvbmVudFNpemUoZ2wsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgZ2wuTE9XX0ZMT0FUOlxyXG4gICAgICAgIGNhc2UgZ2wuSElHSF9GTE9BVDpcclxuICAgICAgICBjYXNlIGdsLkZMT0FUOlxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBjYXNlIGdsLkZMT0FUX1ZFQzI6XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIGNhc2UgZ2wuRkxPQVRfVkVDMzpcclxuICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgY2FzZSBnbC5GTE9BVF9WRUM0OlxyXG4gICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICBjYXNlIGdsLkJZVEU6XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgZ2wuVU5TSUdORURfQllURTpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgY2FzZSBnbC5VTlNJR05FRF9TSE9SVDpcclxuICAgICAgICBjYXNlIGdsLlNIT1JUOlxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGF0dHJpYnV0ZSByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgc3VwcG9ydGVkIGF0dHJpYiBwb2ludGVyIHR5cGVcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC92ZXJ0ZXhBdHRyaWJQb2ludGVyXHJcbiAqXHJcbiAqIEBwYXJhbSBnbFxyXG4gKiBAcGFyYW0gdHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlUG9pbnRlclR5cGUoZ2wsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgZ2wuTE9XX0ZMT0FUOlxyXG4gICAgICAgIGNhc2UgZ2wuSElHSF9GTE9BVDpcclxuICAgICAgICBjYXNlIGdsLkZMT0FUOlxyXG4gICAgICAgIGNhc2UgZ2wuRkxPQVRfVkVDMjpcclxuICAgICAgICBjYXNlIGdsLkZMT0FUX1ZFQzM6XHJcbiAgICAgICAgY2FzZSBnbC5GTE9BVF9WRUM0OlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuRkxPQVQ7XHJcbiAgICAgICAgY2FzZSBnbC5CWVRFOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuQllURTtcclxuICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0JZVEU6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIGNhc2UgZ2wuU0hPUlQ6XHJcbiAgICAgICAgICAgIHJldHVybiBnbC5TSE9SVDtcclxuICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGdsLkZMT0FUO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9zaGFkZXIudHNcblxyXG5cclxuY2xhc3MgU2hhZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgc2hhZGVyIHByb2dyYW0gaW4gZXhjYWxpYnVyXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBzcGVjaWZ5IHNoYWRlciB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3Nvci5nbDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IHZlcnRleFNvdXJjZSwgZnJhZ21lbnRTb3VyY2UgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhTb3VyY2U7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbXBpbGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIHNoYWRlciBwcm9ncmFtXHJcbiAgICAgKi9cclxuICAgIHVzZSgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICBTaGFkZXIuX0FDVElWRV9TSEFERVJfSU5TVEFOQ0UgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNDdXJyZW50bHlCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gU2hhZGVyLl9BQ1RJVkVfU0hBREVSX0lOU1RBTkNFID09PSB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21waWxlIHRoZSBjdXJyZW50IHNoYWRlciBhZ2FpbnN0IGEgd2ViZ2wgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjb21waWxlKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5fY29tcGlsZVNoYWRlcihnbCwgdGhpcy52ZXJ0ZXhTb3VyY2UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5fY29tcGlsZVNoYWRlcihnbCwgdGhpcy5mcmFnbWVudFNvdXJjZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSB0aGlzLl9jcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZ2V0VW5pZm9ybXMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHVuaWZvcm0gb2YgdW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyYW07XHJcbiAgICB9XHJcbiAgICBnZXRVbmlmb3JtcygpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm1Db3VudCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSh0aGlzLnByb2dyYW0sIGkpO1xyXG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCB1bmlmb3JtLm5hbWUpO1xyXG4gICAgICAgICAgICB1bmlmb3Jtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHVuaWZvcm0ubmFtZSxcclxuICAgICAgICAgICAgICAgIGdsVHlwZTogdW5pZm9ybS50eXBlLFxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHVuaWZvcm1Mb2NhdGlvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuaWZvcm1zO1xyXG4gICAgfVxyXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdsLmdldEFjdGl2ZUF0dHJpYih0aGlzLnByb2dyYW0sIGkpO1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXR0cmlidXRlLm5hbWUpO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogYXR0cmlidXRlLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBnbFR5cGU6IGdldEF0dHJpYnV0ZVBvaW50ZXJUeXBlKGdsLCBhdHRyaWJ1dGUudHlwZSksXHJcbiAgICAgICAgICAgICAgICBzaXplOiBnZXRBdHRyaWJ1dGVDb21wb25lbnRTaXplKGdsLCBhdHRyaWJ1dGUudHlwZSksXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogYXR0cmlidXRlTG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHRleHR1cmUgaW4gYSBncHUgdGV4dHVyZSBzbG90XHJcbiAgICAgKiBAcGFyYW0gc2xvdE51bWJlclxyXG4gICAgICogQHBhcmFtIHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgc2V0VGV4dHVyZShzbG90TnVtYmVyLCB0ZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgc2xvdE51bWJlcik7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhbiBpbnRlZ2VyIHVuaWZvcm0gZm9yIHRoZSBjdXJyZW50IHNoYWRlclxyXG4gICAgICpcclxuICAgICAqICoqSW1wb3J0YW50KiogTXVzdCBjYWxsIGV4LlNoYWRlci51c2UoKSBiZWZvcmUgc2V0dGluZyBhIHVuaWZvcm0hXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXRVbmlmb3JtSW50KG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd1bmlmb3JtMWknLCBuYW1lLCB+fnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFuIGludGVnZXIgYXJyYXkgdW5pZm9ybSBmb3IgdGhlIGN1cnJlbnQgc2hhZGVyXHJcbiAgICAgKlxyXG4gICAgICogKipJbXBvcnRhbnQqKiBNdXN0IGNhbGwgZXguU2hhZGVyLnVzZSgpIGJlZm9yZSBzZXR0aW5nIGEgdW5pZm9ybSFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZVxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldFVuaWZvcm1JbnRBcnJheShuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybSgndW5pZm9ybTFpdicsIG5hbWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgYm9vbGVhbiB1bmlmb3JtIGZvciB0aGUgY3VycmVudCBzaGFkZXJcclxuICAgICAqXHJcbiAgICAgKiAqKkltcG9ydGFudCoqIE11c3QgY2FsbCBleC5TaGFkZXIudXNlKCkgYmVmb3JlIHNldHRpbmcgYSB1bmlmb3JtIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqL1xyXG4gICAgc2V0VW5pZm9ybUJvb2xlYW4obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ3VuaWZvcm0xaScsIG5hbWUsIHZhbHVlID8gMSA6IDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBmbG9hdCB1bmlmb3JtIGZvciB0aGUgY3VycmVudCBzaGFkZXJcclxuICAgICAqXHJcbiAgICAgKiAqKkltcG9ydGFudCoqIE11c3QgY2FsbCBleC5TaGFkZXIudXNlKCkgYmVmb3JlIHNldHRpbmcgYSB1bmlmb3JtIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqL1xyXG4gICAgc2V0VW5pZm9ybUZsb2F0KG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd1bmlmb3JtMWYnLCBuYW1lLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGZsb2F0IGFycmF5IHVuaWZvcm0gZm9yIHRoZSBjdXJyZW50IHNoYWRlclxyXG4gICAgICpcclxuICAgICAqICoqSW1wb3J0YW50KiogTXVzdCBjYWxsIGV4LlNoYWRlci51c2UoKSBiZWZvcmUgc2V0dGluZyBhIHVuaWZvcm0hXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXRVbmlmb3JtRmxvYXRBcnJheShuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybSgndW5pZm9ybTFmdicsIG5hbWUsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgW1tWZWN0b3JdXSB1bmlmb3JtIGZvciB0aGUgY3VycmVudCBzaGFkZXJcclxuICAgICAqXHJcbiAgICAgKiAqKkltcG9ydGFudCoqIE11c3QgY2FsbCBleC5TaGFkZXIudXNlKCkgYmVmb3JlIHNldHRpbmcgYSB1bmlmb3JtIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqL1xyXG4gICAgc2V0VW5pZm9ybUZsb2F0VmVjdG9yKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd1bmlmb3JtMmYnLCBuYW1lLCB2YWx1ZS54LCB2YWx1ZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFuIFtbTWF0cml4XV0gdW5pZm9ybSBmb3IgdGhlIGN1cnJlbnQgc2hhZGVyXHJcbiAgICAgKlxyXG4gICAgICogKipJbXBvcnRhbnQqKiBNdXN0IGNhbGwgZXguU2hhZGVyLnVzZSgpIGJlZm9yZSBzZXR0aW5nIGEgdW5pZm9ybSFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZVxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldFVuaWZvcm1NYXRyaXgobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ3VuaWZvcm1NYXRyaXg0ZnYnLCBuYW1lLCBmYWxzZSwgdmFsdWUuZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhbnkgYXZhaWxhYmxlIHVuaWZvcm0gdHlwZSBpbiB3ZWJnbFxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlIHNldFVuaWZvcm0oJ3VuaWZvcm1NYXRyaXgyZnYnLCAndV9teTJ4Ml9tYXRgLCAuLi4pO1xyXG4gICAgICovXHJcbiAgICBzZXRVbmlmb3JtKHVuaWZvcm1UeXBlLCBuYW1lLCAuLi52YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fY29tcGlsZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE11c3QgY29tcGlsZSBzaGFkZXIgYmVmb3JlIHNldHRpbmcgYSB1bmlmb3JtICR7dW5pZm9ybVR5cGV9OiR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5Qm91bmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ3VycmVudGx5IGFjY2Vzc2VkIHNoYWRlciBpbnN0YW5jZSBpcyBub3QgdGhlIGN1cnJlbnQgYWN0aXZlIHNoYWRlciBpbiBXZWJHTCwnICtcclxuICAgICAgICAgICAgICAgICcgbXVzdCBjYWxsIGBzaGFkZXIudXNlKClgIGJlZm9yZSBzZXR0aW5nIHVuaWZvcm1zJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtsb2NhdGlvbiwgLi4udmFsdWVdO1xyXG4gICAgICAgICAgICB0aGlzLl9nbFt1bmlmb3JtVHlwZV0uYXBwbHkodGhpcy5fZ2wsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuaWZvcm0gJHt1bmlmb3JtVHlwZX06JHtuYW1lfSBkb2VzblxcJ3QgZXhpc3Qgb3IgaXMgbm90IHVzZWQgaW4gdGhlIHNoYWRlciBzb3VyY2UgY29kZSxgICtcclxuICAgICAgICAgICAgICAgICcgdW51c2VkIHVuaWZvcm1zIGFyZSBvcHRpbWl6ZWQgYXdheSBieSBtb3N0IGJyb3dzZXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmIChwcm9ncmFtID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGdyYXBoaWNzIHNoYWRlciBwcm9ncmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF0dGFjaCB0aGUgc2hhZGVycy5cclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIC8vIGxpbmsgdGhlIHByb2dyYW0uXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGxpbmsgdGhlIHByb2dyYW06IFske2dsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICBfY29tcGlsZVNoYWRlcihnbCwgc291cmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBnbC5WRVJURVhfU0hBREVSID09PSB0eXBlID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnO1xyXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuICAgICAgICBpZiAoc2hhZGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgYnVpbGQgc2hhZGVyOiBbJHtzb3VyY2V9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgICBjb25zdCBzdWNjZXNzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xyXG4gICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvckluZm8gPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgY29tcGlsZSAke3R5cGVOYW1lfSBzaGFkZXI6XFxuXFxuJHtlcnJvckluZm99JHt0aGlzLl9wcm9jZXNzU291cmNlRm9yRXJyb3Ioc291cmNlLCBlcnJvckluZm8pfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3NTb3VyY2VGb3JFcnJvcihzb3VyY2UsIGVycm9ySW5mbykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICBjb25zdCBlcnJvckxpbmVTdGFydCA9IGVycm9ySW5mby5zZWFyY2goL1xcZDpcXGQvKTtcclxuICAgICAgICBjb25zdCBlcnJvckxpbmVFbmQgPSBlcnJvckluZm8uaW5kZXhPZignICcsIGVycm9yTGluZVN0YXJ0KTtcclxuICAgICAgICBjb25zdCBbXywgZXJyb3IyXSA9IGVycm9ySW5mby5zbGljZShlcnJvckxpbmVTdGFydCwgZXJyb3JMaW5lRW5kKS5zcGxpdCgnOicpLm1hcCh2ID0+IE51bWJlcih2KSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaW5lc1tpXSA9IGAke2kgKyAxfTogJHtsaW5lc1tpXX0ke2Vycm9yMiA9PT0gKGkgKyAxKSA/ICcgPC0tLS0tIEVSUk9SIScgOiAnJ31gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ1xcblxcblNvdXJjZTpcXG4nICsgbGluZXMuam9pbignXFxuJyk7XHJcbiAgICB9XHJcbn1cclxuU2hhZGVyLl9BQ1RJVkVfU0hBREVSX0lOU1RBTkNFID0gbnVsbDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3ZlcnRleC1idWZmZXIudHNcblxyXG4vKipcclxuICogSGVscGVyIGFyb3VuZCB2ZXJ0ZXggYnVmZmVyIHRvIHNpbXBsaWZ5IGNyZWF0aW5nIGFuZCB1cGxvYWRpbmcgZ2VvbWV0cnlcclxuICpcclxuICogVW5kZXIgdGhlIGhvb2QgdXNlcyBGbG9hdDMyQXJyYXlcclxuICovXHJcbmNsYXNzIFZlcnRleEJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3Nvci5nbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgdmVydGljZXMgbmV2ZXIgY2hhbmdlIHN3aXRjaGluZyAnc3RhdGljJyBjYW4gYmUgbW9yZSBlZmZpY2llbnQgb24gdGhlIGdwdVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRGVmYXVsdCBpcyAnZHluYW1pYydcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAnZHluYW1pYyc7XHJcbiAgICAgICAgY29uc3QgeyBzaXplLCB0eXBlLCBkYXRhIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgaWYgKCFkYXRhICYmICFzaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdNdXN0IGVpdGhlciBwcm92aWRlIGRhdGEgb3IgYSBzaXplIHRvIHRoZSBWZXJ0ZXhCdWZmZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHZvaWQgMCA/IHR5cGUgOiB0aGlzLnR5cGU7XHJcbiAgICAgICAgLy8gQWxsb2NhdGUgYnVmZmVyXHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlckRhdGEsIHRoaXMudHlwZSA9PT0gJ3N0YXRpYycgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmQgdGhpcyB2ZXJ0ZXggYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWQgdmVydGV4IGJ1ZmZlciBnZW9tZXRyeSB0byB0aGUgR1BVXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgICBpZiAoY291bnQpIHtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHRoaXMuYnVmZmVyRGF0YSwgMCwgY291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHdheXMgdXNlIGJ1ZmZlclN1YkRhdGE/IG5lZWQgdG8gcGVyZiB0ZXN0IGl0XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlckRhdGEsIHRoaXMudHlwZSA9PT0gJ3N0YXRpYycgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC92ZXJ0ZXgtbGF5b3V0LnRzXG5cclxuXHJcblxyXG4vKipcclxuICogSGVscGVyIGFyb3VuZCBjcmVhdGluZyB2ZXJ0ZXggYXR0cmlidXRlcyBpbiBhIGdpdmVuIFtbVmVydGV4QnVmZmVyXV0sIHRoaXMgaXMgdXNlZnVsIGZvciBkZXNjcmliaW5nXHJcbiAqIHRoZSBtZW1vcnkgbGF5b3V0IGZvciB5b3VyIHZlcnRpY2VzIGluc2lkZSBhIHBhcnRpY3VsYXIgYnVmZmVyXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgaGVscGVyIGFzc3VtZXMgaW50ZXJsZWF2ZWQgYXR0cmlidXRlcyBpbiBvbmUgW1tWZXJ0ZXhCdWZmZXJdXSwgbm90IG1hbnkuXHJcbiAqXHJcbiAqIFdvcmtpbmcgd2l0aCBgZ2wudmVydGV4QXR0cmliUG9pbnRlcmAgY2FuIGJlIHRyaWNreSwgYW5kIHRoaXMgYXR0ZW1wdHMgdG8gZG91YmxlIGNoZWNrIHlvdVxyXG4gKi9cclxuY2xhc3MgVmVydGV4TGF5b3V0IHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IEV4Y2FsaWJ1cldlYkdMQ29udGV4dEFjY2Vzc29yLmdsO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuX2xheW91dCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhUb3RhbFNpemVCeXRlcyA9IDA7XHJcbiAgICAgICAgY29uc3QgeyBzaGFkZXIsIHZlcnRleEJ1ZmZlciwgYXR0cmlidXRlcyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZlcnRleEJ1ZmZlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGV4QnVmZmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvdGFsIG51bWJlciBvZiBieXRlcyB0aGF0IHRoZSB2ZXJ0ZXggd2lsbCB0YWtlIHVwXHJcbiAgICAgKi9cclxuICAgIGdldCB0b3RhbFZlcnRleFNpemVCeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGV4VG90YWxTaXplQnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExheW91dHMgbmVlZCBzaGFkZXIgbG9jYXRpb25zIGFuZCBtdXN0IGJlIGJvdW5kIHRvIGEgc2hhZGVyXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zaGFkZXIuY29tcGlsZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1NoYWRlciBub3QgY29tcGlsZWQsIHNoYWRlciBtdXN0IGJlIGNvbXBpbGVkIGJlZm9yZSBkZWZpbmluZyBhIHZlcnRleCBsYXlvdXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyQXR0cmlidXRlcyA9IHRoaXMuX3NoYWRlci5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuX2F0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmliID0gc2hhZGVyQXR0cmlidXRlc1thdHRyaWJ1dGVbMF1dO1xyXG4gICAgICAgICAgICBpZiAoIWF0dHJpYikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBhdHRyaWJ1dGUgbmFtZWQ6ICR7YXR0cmlidXRlWzBdfSBzaXplICR7YXR0cmlidXRlWzFdfWAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAgbm90IGZvdW5kIGluIHRoZSBzaGFkZXIgc291cmNlIGNvZGU6XFxuICR7dGhpcy5fc2hhZGVyLnZlcnRleFNvdXJjZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXR0cmliLnNpemUgIT09IGF0dHJpYnV0ZVsxXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFZlcnRleExheW91dCBzaXplIGRlZmluaXRpb24gZm9yIGF0dHJpYnV0ZTogWyR7YXR0cmlidXRlWzBdfSwgJHthdHRyaWJ1dGVbMV19XSxgXHJcbiAgICAgICAgICAgICAgICAgICAgKyBgIGRvZXNudCBtYXRjaCBzaGFkZXIgc291cmNlIHNpemUgJHthdHRyaWIuc2l6ZX06XFxuICR7dGhpcy5fc2hhZGVyLnZlcnRleFNvdXJjZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQucHVzaChhdHRyaWIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxjIHNpemVcclxuICAgICAgICBsZXQgY29tcG9uZW50c1BlclZlcnRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0QXR0cmlidXRlIG9mIHRoaXMuX2xheW91dCkge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlU2l6ZSA9IGdldEdsVHlwZVNpemVCeXRlcyh0aGlzLl9nbCwgdmVydEF0dHJpYnV0ZS5nbFR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhUb3RhbFNpemVCeXRlcyArPSB0eXBlU2l6ZSAqIHZlcnRBdHRyaWJ1dGUuc2l6ZTtcclxuICAgICAgICAgICAgY29tcG9uZW50c1BlclZlcnRleCArPSB2ZXJ0QXR0cmlidXRlLnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl92ZXJ0ZXhCdWZmZXIuYnVmZmVyRGF0YS5sZW5ndGggJSBjb21wb25lbnRzUGVyVmVydGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBUaGUgdmVydGV4IGNvbXBvbmVudCBzaXplICgke2NvbXBvbmVudHNQZXJWZXJ0ZXh9KSAgZG9lcyBkaXZpZGUgZXZlbmx5IGludG8gdGhlIHNwZWNpZmllZCB2ZXJ0ZXggYnVmZmVyYFxyXG4gICAgICAgICAgICAgICAgKyBgICgke3RoaXMuX3ZlcnRleEJ1ZmZlci5idWZmZXJEYXRhLmxlbmd0aH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kIHRoaXMgbGF5b3V0IHdpdGggaXQncyBhc3NvY2lhdGVkIHZlcnRleCBidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXBsb2FkQnVmZmVyIE9wdGlvbmFsbHkgaW5kaWNhdGUgeW91IHdpc2ggdG8gdXBsb2FkIHRoZSBidWZmZXIgdG8gdGhlIEdQVSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXRcclxuICAgICAqL1xyXG4gICAgdXNlKHVwbG9hZEJ1ZmZlciA9IGZhbHNlLCBjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zaGFkZXIuaXNDdXJyZW50bHlCb3VuZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTaGFkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmVydGV4IGxheW91dCBpcyBub3QgYWN0aXZlISBDYWxsIHNoYWRlci51c2UoKSBiZWZvcmUgbGF5b3V0LnVzZSgpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgaWYgKHVwbG9hZEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIudXBsb2FkKGNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgLy8gVE9ETyBzd2l0Y2ggdG8gVkFPcyBpZiB0aGUgZXh0ZW5zaW9uIGlzXHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0IG9mIHRoaXMuX2xheW91dCkge1xyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnQubG9jYXRpb24sIHZlcnQuc2l6ZSwgdmVydC5nbFR5cGUsIHZlcnQubm9ybWFsaXplZCwgdGhpcy50b3RhbFZlcnRleFNpemVCeXRlcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydC5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBnZXRHbFR5cGVTaXplQnl0ZXMoZ2wsIHZlcnQuZ2xUeXBlKSAqIHZlcnQuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc0RpYWdub3N0aWNzLnRzXG5jbGFzcyBHcmFwaGljc0RpYWdub3N0aWNzIHtcclxuICAgIHN0YXRpYyBjbGVhcigpIHtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQgPSAwO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudCA9IDA7XHJcbiAgICB9XHJcbn1cclxuR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50ID0gMDtcclxuR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50ID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2xpbmUtcmVuZGVyZXIvbGluZS1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIExpbmVSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXgubGluZSc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbWF4TGluZXMgPSAxMDkyMjtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGluZUNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoZ2wsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3NoYWRlciA9IG5ldyBTaGFkZXIoe1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTb3VyY2U6IGxpbmVfdmVydGV4LFxyXG4gICAgICAgICAgICBmcmFnbWVudFNvdXJjZTogbGluZV9mcmFnbWVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5jb21waWxlKCk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHQub3J0aG8pO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoe1xyXG4gICAgICAgICAgICBzaXplOiA2ICogMiAqIHRoaXMuX21heExpbmVzLFxyXG4gICAgICAgICAgICB0eXBlOiAnZHluYW1pYydcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyOiB0aGlzLl92ZXJ0ZXhCdWZmZXIsXHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAgICBbJ2FfcG9zaXRpb24nLCAyXSxcclxuICAgICAgICAgICAgICAgIFsnYV9jb2xvcicsIDRdXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRyYXcoc3RhcnQsIGVuZCwgY29sb3IpIHtcclxuICAgICAgICAvLyBGb3JjZSBhIHJlbmRlciBpZiB0aGUgYmF0Y2ggaXMgZnVsbFxyXG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGwoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xpbmVDb3VudCsrO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX2NvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxTdGFydCA9IHRyYW5zZm9ybS5tdWx0aXBseShzdGFydCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxFbmQgPSB0cmFuc2Zvcm0ubXVsdGlwbHkoZW5kKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl92ZXJ0ZXhCdWZmZXIuYnVmZmVyRGF0YTtcclxuICAgICAgICAvLyBTdGFydFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGZpbmFsU3RhcnQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBmaW5hbFN0YXJ0Lnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYTtcclxuICAgICAgICAvLyBFbmRcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBmaW5hbEVuZC54O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGZpbmFsRW5kLnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYTtcclxuICAgIH1cclxuICAgIF9pc0Z1bGwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVDb3VudCA+PSB0aGlzLl9tYXhMaW5lcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaGFzUGVuZGluZ0RyYXdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lQ291bnQgIT09IDA7XHJcbiAgICB9XHJcbiAgICBmbHVzaCgpIHtcclxuICAgICAgICAvLyBub3RoaW5nIHRvIGRyYXcgZWFybHkgZXhpdFxyXG4gICAgICAgIGlmICh0aGlzLl9saW5lQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci51c2UoKTtcclxuICAgICAgICB0aGlzLl9sYXlvdXQudXNlKHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHQub3J0aG8pO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHRoaXMuX2xpbmVDb3VudCAqIDIpOyAvLyAyIHZlcnRzIHBlciBsaW5lXHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50ICs9IHRoaXMuX2xpbmVDb3VudDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQrKztcclxuICAgICAgICAvLyByZXNldFxyXG4gICAgICAgIHRoaXMuX3ZlcnRleEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9saW5lQ291bnQgPSAwO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9wb2ludC1yZW5kZXJlci9wb2ludC12ZXJ0ZXguZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBwb2ludF92ZXJ0ZXggPSAoXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5pbiB2ZWMyIGFfcG9zaXRpb247XFxyXFxuaW4gdmVjNCBhX2NvbG9yO1xcclxcbmluIGZsb2F0IGFfc2l6ZTtcXHJcXG5vdXQgbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcXHJcXG4gIGdsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIDIuMDtcXHJcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3BvaW50LXJlbmRlcmVyL3BvaW50LWZyYWdtZW50Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgcG9pbnRfZnJhZ21lbnQgPSAoXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5cXHJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5pbiBsb3dwIHZlYzQgdl9jb2xvcjtcXHJcXG5cXHJcXG5vdXQgdmVjNCBmcmFnQ29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZmxvYXQgciA9IDAuMCwgZGVsdGEgPSAwLjAsIGFscGhhID0gMS4wO1xcclxcbiAgdmVjMiBjeHkgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcclxcbiAgciA9IGRvdChjeHksIGN4eSk7XFxyXFxuXFxyXFxuICBkZWx0YSA9IGZ3aWR0aChyKTtcXHJcXG4gIGFscGhhID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHIpO1xcclxcbiAgLy8gXFxcInByZW11bHRpcGx5XFxcIiB0aGUgY29sb3IgYnkgYWxwaGFcXHJcXG4gIHZlYzQgY29sb3IgPSB2X2NvbG9yO1xcclxcbiAgY29sb3IuYSA9IGNvbG9yLmEgKiBhbHBoYTtcXHJcXG4gIGNvbG9yLnJnYiA9IGNvbG9yLnJnYiAqIGNvbG9yLmE7XFxyXFxuICBmcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9wb2ludC1yZW5kZXJlci9wb2ludC1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFBvaW50UmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LnBvaW50JztcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl9tYXhQb2ludHMgPSAxMDkyMjtcclxuICAgICAgICB0aGlzLl9wb2ludENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGdsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2hhZGVyKHtcclxuICAgICAgICAgICAgdmVydGV4U291cmNlOiBwb2ludF92ZXJ0ZXgsXHJcbiAgICAgICAgICAgIGZyYWdtZW50U291cmNlOiBwb2ludF9mcmFnbWVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5jb21waWxlKCk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHQub3J0aG8pO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoe1xyXG4gICAgICAgICAgICBzaXplOiA3ICogdGhpcy5fbWF4UG9pbnRzLFxyXG4gICAgICAgICAgICB0eXBlOiAnZHluYW1pYydcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KHtcclxuICAgICAgICAgICAgc2hhZGVyOiB0aGlzLl9zaGFkZXIsXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcjogdGhpcy5fYnVmZmVyLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAgICBbJ2FfcG9zaXRpb24nLCAyXSxcclxuICAgICAgICAgICAgICAgIFsnYV9jb2xvcicsIDRdLFxyXG4gICAgICAgICAgICAgICAgWydhX3NpemUnLCAxXVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkcmF3KHBvaW50LCBjb2xvciwgc2l6ZSkge1xyXG4gICAgICAgIC8vIEZvcmNlIGEgcmVuZGVyIGlmIHRoZSBiYXRjaCBpcyBmdWxsXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRnVsbCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9pbnRDb3VudCsrO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX2NvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuX2NvbnRleHQub3BhY2l0eTtcclxuICAgICAgICBjb25zdCBzbmFwVG9QaXhlbCA9IHRoaXMuX2NvbnRleHQuc25hcFRvUGl4ZWw7XHJcbiAgICAgICAgY29uc3QgZmluYWxQb2ludCA9IHRyYW5zZm9ybS5tdWx0aXBseShwb2ludCk7XHJcbiAgICAgICAgaWYgKHNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmFsUG9pbnQueCA9IH5+KGZpbmFsUG9pbnQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBmaW5hbFBvaW50LnkgPSB+fihmaW5hbFBvaW50LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fYnVmZmVyLmJ1ZmZlckRhdGE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gZmluYWxQb2ludC54O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGZpbmFsUG9pbnQueTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hICogb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzaXplICogTWF0aC5tYXgodHJhbnNmb3JtLmdldFNjYWxlWCgpLCB0cmFuc2Zvcm0uZ2V0U2NhbGVZKCkpO1xyXG4gICAgfVxyXG4gICAgX2lzRnVsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcG9pbnRDb3VudCA+PSB0aGlzLl9tYXhQb2ludHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGhhc1BlbmRpbmdEcmF3cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRDb3VudCAhPT0gMDtcclxuICAgIH1cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZHJhdyBlYXJseSBleGl0XHJcbiAgICAgICAgaWYgKHRoaXMuX3BvaW50Q291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci51c2UoKTtcclxuICAgICAgICB0aGlzLl9sYXlvdXQudXNlKHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHQub3J0aG8pO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB0aGlzLl9wb2ludENvdW50KTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgKz0gdGhpcy5fcG9pbnRDb3VudDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQrKztcclxuICAgICAgICB0aGlzLl9wb2ludENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NjcmVlbi1wYXNzLXBhaW50ZXIvc2NyZWVuLXZlcnRleC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNjcmVlbl92ZXJ0ZXggPSAoXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5pbiB2ZWMyIGFfcG9zaXRpb247XFxyXFxuXFxyXFxuaW4gdmVjMiBhX3RleGNvb3JkO1xcclxcbm91dCB2ZWMyIHZfdGV4Y29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gIC8vIFBhc3MgdGhlIHRleGNvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXIuXFxyXFxuICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9zY3JlZW4tcGFzcy1wYWludGVyL3NjcmVlbi1mcmFnbWVudC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNjcmVlbl9mcmFnbWVudCA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbi8vIFBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLlxcclxcbmluIHZlYzIgdl90ZXhjb29yZDtcXHJcXG5cXHJcXG4vLyBUaGUgdGV4dHVyZS5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxyXFxuXFxyXFxub3V0IHZlYzQgZnJhZ0NvbG9yO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gICBmcmFnQ29sb3IgPSB0ZXh0dXJlKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2NyZWVuLXBhc3MtcGFpbnRlci9zY3JlZW4tcGFzcy1wYWludGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHJlc3BvbnNpYmxlIGZvciBwYWludGluZyB0aGUgZW50aXJlIHNjcmVlbiBkdXJpbmcgdGhlIHJlbmRlciBwYXNzZXNcclxuICovXHJcbmNsYXNzIFNjcmVlblBhc3NQYWludGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2hhZGVyKHtcclxuICAgICAgICAgICAgdmVydGV4U291cmNlOiBzY3JlZW5fdmVydGV4LFxyXG4gICAgICAgICAgICBmcmFnbWVudFNvdXJjZTogc2NyZWVuX2ZyYWdtZW50XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAvLyBTZXR1cCBtZW1vcnkgbGF5b3V0XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzdGF0aWMnLFxyXG4gICAgICAgICAgICAvLyBjbGlwIHNwYWNlIHF1YWQgKyB1diBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgY2FtZXJhXHJcbiAgICAgICAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLTEsIC0xLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDEsXHJcbiAgICAgICAgICAgICAgICAxLCAtMSwgMSwgMCxcclxuICAgICAgICAgICAgICAgIDEsIC0xLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDEsXHJcbiAgICAgICAgICAgICAgICAxLCAxLCAxLCAxXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFZlcnRleExheW91dCh7XHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRoaXMuX2J1ZmZlcixcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgWydhX3Bvc2l0aW9uJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdGV4Y29vcmQnLCAyXVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyLnVwbG9hZCgpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyV2l0aFBvc3RQcm9jZXNzb3IocG9zdHByb2Nlc3Nvcikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcG9zdHByb2Nlc3Nvci5nZXRTaGFkZXIoKS51c2UoKTtcclxuICAgICAgICBwb3N0cHJvY2Vzc29yLmdldExheW91dCgpLnVzZSgpO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuICAgIH1cclxuICAgIHJlbmRlclRvU2NyZWVuKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgIHRoaXMuX2xheW91dC51c2UoKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3F1YWQtaW5kZXgtYnVmZmVyLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdGhhdCBkZWZpbmVzIGFuZCBpbmRleCBidWZmZXIgZm9yIHF1YWQgZ2VvbWV0cnlcclxuICpcclxuICogSW5kZXggYnVmZmVycyBhbGxvdyB5b3UgdG8gc2F2ZSBzcGFjZSBpbiB2ZXJ0ZXggYnVmZmVycyB3aGVuIHlvdSBzaGFyZSB2ZXJ0aWNlcyBpbiBnZW9tZXRyeVxyXG4gKiBpdCBpcyBhbG1vc3QgYWx3YXlzIHdvcnRoIGl0IGluIHRlcm1zIG9mIHBlcmZvcm1hbmNlIHRvIHVzZSBhbiBpbmRleCBidWZmZXIuXHJcbiAqL1xyXG5jbGFzcyBRdWFkSW5kZXhCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbnVtYmVyT2ZRdWFkcyBTcGVjaWZ5IHRoZSBtYXggbnVtYmVyIG9mIHF1YWRzIHlvdSB3YW50IHRvIGRyYXdcclxuICAgICAqIEBwYXJhbSB1c2VVaW50MTYgT3B0aW9uYWxseSBmb3JjZSBhIHVpbnQxNiBidWZmZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobnVtYmVyT2ZRdWFkcywgdXNlVWludDE2KSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBFeGNhbGlidXJXZWJHTENvbnRleHRBY2Nlc3Nvci5nbDtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsVmVydGljZXMgPSBudW1iZXJPZlF1YWRzICogNjtcclxuICAgICAgICBpZiAoIXVzZVVpbnQxNikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckRhdGEgPSBuZXcgVWludDMyQXJyYXkodG90YWxWZXJ0aWNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdXNpbmcgZ2wuVU5TSUdORURfU0hPUlQgb3IgdGVsbCB0aGUgdXNlciB0aGV5IGFyZSBvdXQgb2YgbHVja1xyXG4gICAgICAgICAgICBjb25zdCBtYXhVaW50MTYgPSA2NTUzNTtcclxuICAgICAgICAgICAgY29uc3QgbWF4VWludDE2SW5kZXggPSBNYXRoLmZsb29yKChtYXhVaW50MTYgLSAxKSAvIDQpOyAvLyBtYXggcXVhZHNcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJHbFR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhID0gbmV3IFVpbnQxNkFycmF5KHRvdGFsVmVydGljZXMpO1xyXG4gICAgICAgICAgICAvLyBUT0RPIFNob3VsZCB3ZSBlcnJvciBpZiB0aGlzIGhhcHBlbnM/PyBtYXliZSBub3QgbWlnaHQgY3Jhc2ggbWlkIGdhbWVcclxuICAgICAgICAgICAgaWYgKG51bWJlck9mUXVhZHMgPiBtYXhVaW50MTZJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFRvdGFsIHF1YWRzIGV4Y2VlZHMgaGFyZHdhcmUgaW5kZXggYnVmZmVyIGxpbWl0ICh1aW50MTYpLCBtYXgoJHttYXhVaW50MTZJbmRleH0pIHJlcXVlc3RlZCBxdWFkcygke251bWJlck9mUXVhZHN9KWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyZW50UXVhZCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFZlcnRpY2VzOyBpICs9IDYpIHtcclxuICAgICAgICAgICAgLy8gZmlyc3QgdHJpYW5nbGVcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhW2kgKyAwXSA9IGN1cnJlbnRRdWFkICsgMDtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhW2kgKyAxXSA9IGN1cnJlbnRRdWFkICsgMTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJEYXRhW2kgKyAyXSA9IGN1cnJlbnRRdWFkICsgMjtcclxuICAgICAgICAgICAgLy8gc2Vjb25kIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YVtpICsgM10gPSBjdXJyZW50UXVhZCArIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YVtpICsgNF0gPSBjdXJyZW50UXVhZCArIDE7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyRGF0YVtpICsgNV0gPSBjdXJyZW50UXVhZCArIDM7XHJcbiAgICAgICAgICAgIGN1cnJlbnRRdWFkICs9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyRGF0YS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZCBkYXRhIHRvIHRoZSBHUFVcclxuICAgICAqL1xyXG4gICAgdXBsb2FkKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kIHRoaXMgaW5kZXggYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2ltYWdlLXJlbmRlcmVyL2ltYWdlLXJlbmRlcmVyLmZyYWcuZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBpbWFnZV9yZW5kZXJlcl9mcmFnID0gKFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxuXFxyXFxuLy8gVVYgY29vcmRcXHJcXG5pbiB2ZWMyIHZfdGV4Y29vcmQ7XFxyXFxuXFxyXFxuLy8gVGV4dHVyZSBpbmRleFxcclxcbmluIGxvd3AgZmxvYXQgdl90ZXh0dXJlSW5kZXg7XFxyXFxuXFxyXFxuLy8gVGV4dHVyZXMgaW4gdGhlIGN1cnJlbnQgZHJhd1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZXNbJSVjb3VudCUlXTtcXHJcXG5cXHJcXG4vLyBPcGFjaXR5XFxyXFxuaW4gZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbmluIHZlYzQgdl90aW50O1xcclxcblxcclxcbm91dCB2ZWM0IGZyYWdDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCB0aGUgbW9zdCBlZmZpY2llbnQgc3ByaXRlIGJhdGNoaW5nLCB3ZSBoYXZlIG11bHRpcGxlXFxyXFxuICAgLy8gdGV4dHVyZXMgbG9hZGVkIGludG8gdGhlIGdwdSAodXN1YWxseSA4KSB0aGlzIHBpY2tlciBsb2dpYyBza2lwcyBvdmVyIHRleHR1cmVzXFxyXFxuICAgLy8gdGhhdCBkbyBub3QgYXBwbHkgdG8gYSBwYXJ0aWN1bGFyIHNwcml0ZS5cXHJcXG5cXHJcXG4gICB2ZWM0IGNvbG9yID0gdmVjNCgxLjAsIDAsIDAsIDEuMCk7XFxyXFxuXFxyXFxuICAgLy8gR0xTTCBpcyB0ZW1wbGF0ZWQgb3V0IHRvIHBpY2sgdGhlIHJpZ2h0IHRleHR1cmUgYW5kIHNldCB0aGUgdmVjNCBjb2xvclxcclxcbiAgICUldGV4dHVyZV9waWNrZXIlJVxcclxcblxcclxcbiAgIGNvbG9yLnJnYiA9IGNvbG9yLnJnYiAqIHZfb3BhY2l0eTtcXHJcXG4gICBjb2xvci5hID0gY29sb3IuYSAqIHZfb3BhY2l0eTtcXHJcXG4gICBmcmFnQ29sb3IgPSBjb2xvciAqIHZfdGludDtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9pbWFnZS1yZW5kZXJlci9pbWFnZS1yZW5kZXJlci52ZXJ0Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgaW1hZ2VfcmVuZGVyZXJfdmVydCA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbmluIHZlYzIgYV9wb3NpdGlvbjtcXHJcXG5cXHJcXG4vLyBPcGFjaXR5IFxcclxcbmluIGZsb2F0IGFfb3BhY2l0eTtcXHJcXG5vdXQgZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbi8vIFVWIGNvb3JkaW5hdGVcXHJcXG5pbiB2ZWMyIGFfdGV4Y29vcmQ7XFxyXFxub3V0IHZlYzIgdl90ZXhjb29yZDtcXHJcXG5cXHJcXG4vLyBUZXh0dXJlIG51bWJlclxcclxcbmluIGxvd3AgZmxvYXQgYV90ZXh0dXJlSW5kZXg7XFxyXFxub3V0IGxvd3AgZmxvYXQgdl90ZXh0dXJlSW5kZXg7XFxyXFxuXFxyXFxuaW4gdmVjNCBhX3RpbnQ7XFxyXFxub3V0IHZlYzQgdl90aW50O1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgLy8gU2V0IHRoZSB2ZXJ0ZXggcG9zaXRpb24gdXNpbmcgdGhlIG9ydGhvIHRyYW5zZm9ybSBtYXRyaXhcXHJcXG4gICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBPcGFjaXR5IHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X29wYWNpdHkgPSBhX29wYWNpdHk7XFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBVViBjb29yZCB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIHRoZSB0ZXh0dXJlIG51bWJlciB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl90ZXh0dXJlSW5kZXggPSBhX3RleHR1cmVJbmRleDtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIHRpbnRcXHJcXG4gICB2X3RpbnQgPSBhX3RpbnQ7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvaW1hZ2UtcmVuZGVyZXIvaW1hZ2UtcmVuZGVyZXIudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBJbWFnZVJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5pbWFnZSc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbWF4SW1hZ2VzID0gMTA5MjI7IC8vIG1heCh1aW50MTYpIC8gNiB2ZXJ0c1xyXG4gICAgICAgIHRoaXMuX21heFRleHR1cmVzID0gMDtcclxuICAgICAgICAvLyBQZXIgZmx1c2ggdmFyc1xyXG4gICAgICAgIHRoaXMuX2ltYWdlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5fdmVydGV4SW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShnbCwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIHNoYWRlciBzb3VyY2VcclxuICAgICAgICAvLyBGSVhNRTogUElYRUwgNiBjb21wbGFpbnMgYEVSUk9SOiBFeHByZXNzaW9uIHRvbyBjb21wbGV4LmAgaWYgd2UgdXNlIGl0J3MgcmVwb3J0ZWQgbWF4IHRleHR1cmUgdW5pdHMsIDEyNSBzZWVtcyB0byB3b3JrIGZvciBub3cuLi5cclxuICAgICAgICB0aGlzLl9tYXhUZXh0dXJlcyA9IE1hdGgubWluKGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksIDEyNSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRGcmFnID0gdGhpcy5fdHJhbnNmb3JtRnJhZ21lbnRTb3VyY2UoaW1hZ2VfcmVuZGVyZXJfZnJhZywgdGhpcy5fbWF4VGV4dHVyZXMpO1xyXG4gICAgICAgIC8vIENvbXBpbGUgc2hhZGVyXHJcbiAgICAgICAgdGhpcy5fc2hhZGVyID0gbmV3IFNoYWRlcih7XHJcbiAgICAgICAgICAgIGZyYWdtZW50U291cmNlOiB0cmFuc2Zvcm1lZEZyYWcsXHJcbiAgICAgICAgICAgIHZlcnRleFNvdXJjZTogaW1hZ2VfcmVuZGVyZXJfdmVydFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci5jb21waWxlKCk7XHJcbiAgICAgICAgLy8gc2V0dXAgdW5pZm9ybXNcclxuICAgICAgICB0aGlzLl9zaGFkZXIudXNlKCk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnNldFVuaWZvcm1NYXRyaXgoJ3VfbWF0cml4JywgY29udGV4dC5vcnRobyk7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0ZXh0dXJlIHNsb3RzIHRvIFswLCAxLCAyLCAzLCA0LCAuLi4uIG1heEdQVVRleHR1cmVzXVxyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtSW50QXJyYXkoJ3VfdGV4dHVyZXMnLCBbLi4uQXJyYXkodGhpcy5fbWF4VGV4dHVyZXMpXS5tYXAoKF8sIGkpID0+IGkpKTtcclxuICAgICAgICAvLyBTZXR1cCBtZW1vcnkgbGF5b3V0XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHNpemU6IDEwICogNCAqIHRoaXMuX21heEltYWdlcyxcclxuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFZlcnRleExheW91dCh7XHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRoaXMuX2J1ZmZlcixcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgWydhX3Bvc2l0aW9uJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2Ffb3BhY2l0eScsIDFdLFxyXG4gICAgICAgICAgICAgICAgWydhX3RleGNvb3JkJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdGV4dHVyZUluZGV4JywgMV0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdGludCcsIDRdXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTZXR1cCBpbmRleCBidWZmZXJcclxuICAgICAgICB0aGlzLl9xdWFkcyA9IG5ldyBRdWFkSW5kZXhCdWZmZXIodGhpcy5fbWF4SW1hZ2VzLCB0cnVlKTtcclxuICAgIH1cclxuICAgIF90cmFuc2Zvcm1GcmFnbWVudFNvdXJjZShzb3VyY2UsIG1heFRleHR1cmVzKSB7XHJcbiAgICAgICAgbGV0IG5ld1NvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKCclJWNvdW50JSUnLCBtYXhUZXh0dXJlcy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgdGV4dHVyZVBpY2tlckJ1aWxkZXIgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGBpZiAodl90ZXh0dXJlSW5kZXggPD0gJHtpfS41KSB7XFxuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGAgICBlbHNlIGlmICh2X3RleHR1cmVJbmRleCA8PSAke2l9LjUpIHtcXG5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGAgICAgICBjb2xvciA9IHRleHR1cmUodV90ZXh0dXJlc1ske2l9XSwgdl90ZXhjb29yZCk7XFxuYDtcclxuICAgICAgICAgICAgdGV4dHVyZVBpY2tlckJ1aWxkZXIgKz0gYCAgIH1cXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdTb3VyY2UgPSBuZXdTb3VyY2UucmVwbGFjZSgnJSV0ZXh0dXJlX3BpY2tlciUlJywgdGV4dHVyZVBpY2tlckJ1aWxkZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXdTb3VyY2U7XHJcbiAgICB9XHJcbiAgICBfYWRkSW1hZ2VBc1RleHR1cmUoaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZUxvYWRlci5sb2FkKGltYWdlKTtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYmluZFRleHR1cmVzKGdsKSB7XHJcbiAgICAgICAgLy8gQmluZCB0ZXh0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWF4VGV4dHVyZXM7IGkrKykge1xyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVzW2ldIHx8IHRoaXMuX3RleHR1cmVzWzBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0VGV4dHVyZUlkRm9ySW1hZ2UoaW1hZ2UpIHtcclxuICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmluZGV4T2YoVGV4dHVyZUxvYWRlci5nZXQoaW1hZ2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgX2lzRnVsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VDb3VudCA+PSB0aGlzLl9tYXhJbWFnZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlcy5sZW5ndGggPj0gdGhpcy5fbWF4VGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRyYXcoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAvLyBGb3JjZSBhIHJlbmRlciBpZiB0aGUgYmF0Y2ggaXMgZnVsbFxyXG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGwoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ltYWdlQ291bnQrKztcclxuICAgICAgICB0aGlzLl9hZGRJbWFnZUFzVGV4dHVyZShpbWFnZSk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gKGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS53aWR0aCkgfHwgc3dpZHRoIHx8IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IChpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuaGVpZ2h0KSB8fCBzaGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgbGV0IHZpZXcgPSBbMCwgMCwgKF9hID0gc3dpZHRoICE9PSBudWxsICYmIHN3aWR0aCAhPT0gdm9pZCAwID8gc3dpZHRoIDogaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCAoX2IgPSBzaGVpZ2h0ICE9PSBudWxsICYmIHNoZWlnaHQgIT09IHZvaWQgMCA/IHNoZWlnaHQgOiBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwXTtcclxuICAgICAgICBsZXQgZGVzdCA9IFtzeCAhPT0gbnVsbCAmJiBzeCAhPT0gdm9pZCAwID8gc3ggOiAxLCBzeSAhPT0gbnVsbCAmJiBzeSAhPT0gdm9pZCAwID8gc3kgOiAxXTtcclxuICAgICAgICAvLyBJZiBkZXN0aW5hdGlvbiBpcyBzcGVjaWZpZWQsIHVwZGF0ZSB2aWV3IGFuZCBkZXN0XHJcbiAgICAgICAgaWYgKGR4ICE9PSB1bmRlZmluZWQgJiYgZHkgIT09IHVuZGVmaW5lZCAmJiBkd2lkdGggIT09IHVuZGVmaW5lZCAmJiBkaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmlldyA9IFtzeCAhPT0gbnVsbCAmJiBzeCAhPT0gdm9pZCAwID8gc3ggOiAxLCBzeSAhPT0gbnVsbCAmJiBzeSAhPT0gdm9pZCAwID8gc3kgOiAxLCAoX2MgPSBzd2lkdGggIT09IG51bGwgJiYgc3dpZHRoICE9PSB2b2lkIDAgPyBzd2lkdGggOiBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2Uud2lkdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsIChfZCA9IHNoZWlnaHQgIT09IG51bGwgJiYgc2hlaWdodCAhPT0gdm9pZCAwID8gc2hlaWdodCA6IGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5oZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDBdO1xyXG4gICAgICAgICAgICBkZXN0ID0gW2R4LCBkeV07XHJcbiAgICAgICAgICAgIHdpZHRoID0gZHdpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBkaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzeCA9IHZpZXdbMF07XHJcbiAgICAgICAgc3kgPSB2aWV3WzFdO1xyXG4gICAgICAgIGNvbnN0IHN3ID0gdmlld1syXTtcclxuICAgICAgICBjb25zdCBzaCA9IHZpZXdbM107XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIGN1cnJlbnQgY29udGV4dFxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX2NvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuX2NvbnRleHQub3BhY2l0eTtcclxuICAgICAgICBjb25zdCBzbmFwVG9QaXhlbCA9IHRoaXMuX2NvbnRleHQuc25hcFRvUGl4ZWw7XHJcbiAgICAgICAgbGV0IHRvcExlZnQgPSB2ZWMoZGVzdFswXSwgZGVzdFsxXSk7XHJcbiAgICAgICAgbGV0IHRvcFJpZ2h0ID0gdmVjKGRlc3RbMF0gKyB3aWR0aCwgZGVzdFsxXSk7XHJcbiAgICAgICAgbGV0IGJvdHRvbUxlZnQgPSB2ZWMoZGVzdFswXSwgZGVzdFsxXSArIGhlaWdodCk7XHJcbiAgICAgICAgbGV0IGJvdHRvbVJpZ2h0ID0gdmVjKGRlc3RbMF0gKyB3aWR0aCwgZGVzdFsxXSArIGhlaWdodCk7XHJcbiAgICAgICAgdG9wTGVmdCA9IHRyYW5zZm9ybS5tdWx0aXBseSh0b3BMZWZ0KTtcclxuICAgICAgICB0b3BSaWdodCA9IHRyYW5zZm9ybS5tdWx0aXBseSh0b3BSaWdodCk7XHJcbiAgICAgICAgYm90dG9tTGVmdCA9IHRyYW5zZm9ybS5tdWx0aXBseShib3R0b21MZWZ0KTtcclxuICAgICAgICBib3R0b21SaWdodCA9IHRyYW5zZm9ybS5tdWx0aXBseShib3R0b21SaWdodCk7XHJcbiAgICAgICAgaWYgKHNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgIHRvcExlZnQueCA9IH5+KHRvcExlZnQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICB0b3BMZWZ0LnkgPSB+fih0b3BMZWZ0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueCA9IH5+KHRvcFJpZ2h0LnggKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueSA9IH5+KHRvcFJpZ2h0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgYm90dG9tTGVmdC54ID0gfn4oYm90dG9tTGVmdC54ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIGJvdHRvbUxlZnQueSA9IH5+KGJvdHRvbUxlZnQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC54ID0gfn4oYm90dG9tUmlnaHQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC55ID0gfn4oYm90dG9tUmlnaHQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aW50ID0gdGhpcy5fY29udGV4dC50aW50O1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVJZCA9IHRoaXMuX2dldFRleHR1cmVJZEZvckltYWdlKGltYWdlKTtcclxuICAgICAgICBjb25zdCBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGggfHwgd2lkdGg7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHV2eDAgPSAoc3gpIC8gaW1hZ2VXaWR0aDtcclxuICAgICAgICBjb25zdCB1dnkwID0gKHN5KSAvIGltYWdlSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHV2eDEgPSAoc3ggKyBzdyAtIDAuMDEpIC8gaW1hZ2VXaWR0aDtcclxuICAgICAgICBjb25zdCB1dnkxID0gKHN5ICsgc2ggLSAwLjAxKSAvIGltYWdlSGVpZ2h0O1xyXG4gICAgICAgIC8vIHVwZGF0ZSBkYXRhXHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fbGF5b3V0LnZlcnRleEJ1ZmZlci5idWZmZXJEYXRhO1xyXG4gICAgICAgIC8vICgwLCAwKSAtIDBcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0b3BMZWZ0Lng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdG9wTGVmdC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGludC5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRpbnQuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LmE7XHJcbiAgICAgICAgLy8gKDAsIDEpIC0gMVxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGJvdHRvbUxlZnQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBib3R0b21MZWZ0Lnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dngwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGV4dHVyZUlkO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRpbnQuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGludC5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRpbnQuYTtcclxuICAgICAgICAvLyAoMSwgMCkgLSAyXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdG9wUmlnaHQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0b3BSaWdodC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGludC5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRpbnQuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LmE7XHJcbiAgICAgICAgLy8gKDEsIDEpIC0gM1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGJvdHRvbVJpZ2h0Lng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gYm90dG9tUmlnaHQueTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBvcGFjaXR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0ZXh0dXJlSWQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGludC5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRpbnQuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aW50LmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGludC5hO1xyXG4gICAgfVxyXG4gICAgaGFzUGVuZGluZ0RyYXdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZUNvdW50ICE9PSAwO1xyXG4gICAgfVxyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgLy8gbm90aGluZyB0byBkcmF3IGVhcmx5IGV4aXRcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgLy8gQmluZCB0aGUgc2hhZGVyXHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgIC8vIEJpbmQgdGhlIG1lbW9yeSBsYXlvdXQgYW5kIHVwbG9hZCBkYXRhXHJcbiAgICAgICAgdGhpcy5fbGF5b3V0LnVzZSh0cnVlLCA0ICogMTAgKiB0aGlzLl9pbWFnZUNvdW50KTtcclxuICAgICAgICAvLyBVcGRhdGUgb3J0aG8gbWF0cml4IHVuaWZvcm1cclxuICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9jb250ZXh0Lm9ydGhvKTtcclxuICAgICAgICAvLyBCaW5kIHRleHR1cmVzIHRvXHJcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVzKGdsKTtcclxuICAgICAgICAvLyBCaW5kIGluZGV4IGJ1ZmZlclxyXG4gICAgICAgIHRoaXMuX3F1YWRzLmJpbmQoKTtcclxuICAgICAgICAvLyBEcmF3IGFsbCB0aGUgcXVhZHNcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLl9pbWFnZUNvdW50ICogNiwgdGhpcy5fcXVhZHMuYnVmZmVyR2xUeXBlLCAwKTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgKz0gdGhpcy5faW1hZ2VDb3VudDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQrKztcclxuICAgICAgICAvLyBSZXNldFxyXG4gICAgICAgIHRoaXMuX2ltYWdlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9yZWN0YW5nbGUtcmVuZGVyZXIvcmVjdGFuZ2xlLXJlbmRlcmVyLmZyYWcuZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCByZWN0YW5nbGVfcmVuZGVyZXJfZnJhZyA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcblxcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbi8vIFVWIGNvb3JkXFxyXFxuaW4gdmVjMiB2X3V2O1xcclxcblxcclxcbmluIHZlYzIgdl9zaXplOyAvLyBpbiBwaXhlbHNcXHJcXG5cXHJcXG4vLyBDb2xvciBjb29yZCB0byBibGVuZCB3aXRoIGltYWdlXFxyXFxuaW4gbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxuLy8gU3Ryb2tlIGNvbG9yIGlmIHVzZWRcXHJcXG5pbiBsb3dwIHZlYzQgdl9zdHJva2VDb2xvcjtcXHJcXG5cXHJcXG4vLyBTdHJva2UgdGhpY2tuZXNzIGlmIHVzZWRcXHJcXG5pbiBsb3dwIGZsb2F0IHZfc3Ryb2tlVGhpY2tuZXNzOyAvLyBpbiBwaXhlbHNcXHJcXG5cXHJcXG4vLyBPcGFjaXR5XFxyXFxuaW4gZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbm91dCB2ZWM0IGZyYWdDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgIC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTkxOTc2NzEvZ2xzbC1yb3VuZGVkLXJlY3RhbmdsZS13aXRoLXZhcmlhYmxlLWJvcmRlclxcclxcbiAgICB2ZWMyIHV2ID0gdl91djtcXHJcXG4gICAgdmVjMiBmcmFnQ29vcmQgPSB1diAqIHZfc2l6ZTtcXHJcXG4gICAgZmxvYXQgbWF4WCA9IHZfc2l6ZS54IC0gdl9zdHJva2VUaGlja25lc3M7XFxyXFxuICAgIGZsb2F0IG1pblggPSB2X3N0cm9rZVRoaWNrbmVzcztcXHJcXG4gICAgZmxvYXQgbWF4WSA9IHZfc2l6ZS55IC0gdl9zdHJva2VUaGlja25lc3M7XFxyXFxuICAgIGZsb2F0IG1pblkgPSB2X3N0cm9rZVRoaWNrbmVzcztcXHJcXG5cXHJcXG4gICAgaWYgKGZyYWdDb29yZC54IDwgbWF4WCAmJiBmcmFnQ29vcmQueCA+IG1pblggJiZcXHJcXG4gICAgICAgIGZyYWdDb29yZC55IDwgbWF4WSAmJiBmcmFnQ29vcmQueSA+IG1pblkpIHtcXHJcXG4gICAgICBmcmFnQ29sb3IgPSB2X2NvbG9yO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIGZyYWdDb2xvciA9IHZfc3Ryb2tlQ29sb3I7XFxyXFxuICAgIH1cXHJcXG4gICAgZnJhZ0NvbG9yLmEgKj0gdl9vcGFjaXR5O1xcclxcbiAgICBmcmFnQ29sb3IucmdiICo9IGZyYWdDb2xvci5hO1xcclxcblxcclxcbiAgICAvLyB2ZWMyIHYyQ2VudGVyZWRQb3MgICAgID0gYWJzKGZyYWdDb29yZCAtIHZfc2l6ZS54eSAvIDIuMCk7XFxyXFxuICAgIC8vIHZlYzIgdjJIYWxmU2hhcGVTaXplUHggPSB2X3NpemUueHkvMi4wIC0gdl9zdHJva2VUaGlja25lc3MvMi4wO1xcclxcblxcclxcbiAgICAvLyBmbG9hdCBmSGFsZkJvcmRlckRpc3QgICAgICA9IDAuMDtcXHJcXG4gICAgLy8gZmxvYXQgZkhhbGZCb3JkZXJUaGlja25lc3MgPSAwLjA7XFxyXFxuXFxyXFxuICAgIC8vIGlmIChmcmFnQ29vcmQueCA+IG1heCh2X3JhZGl1cywgdl9zdHJva2VUaGlja25lc3MpICYmIFxcclxcbiAgICAvLyAgICAgZnJhZ0Nvb3JkLnggPCB2X3NpemUueCAtIG1heCh2X3JhZGl1cywgdl9zdHJva2VUaGlja25lc3MpKVxcclxcbiAgICAvLyB7XFxyXFxuICAgIC8vICAgICBmSGFsZkJvcmRlckRpc3QgICAgICA9IHYyQ2VudGVyZWRQb3MueSAtIHYySGFsZlNoYXBlU2l6ZVB4Lnk7XFxyXFxuICAgIC8vICAgICBmSGFsZkJvcmRlclRoaWNrbmVzcyA9IHZfc3Ryb2tlVGhpY2tuZXNzIC8gMi4wO1xcclxcbiAgICAvLyB9XFxyXFxuICAgIC8vIGVsc2UgaWYgKGZyYWdDb29yZC55ID4gbWF4KHZfcmFkaXVzLCB2X3N0cm9rZVRoaWNrbmVzcykgJiYgXFxyXFxuICAgIC8vICAgICAgICAgIGZyYWdDb29yZC55IDwgdl9zaXplLnkgLSBtYXgodl9yYWRpdXMsIHZfc3Ryb2tlVGhpY2tuZXNzKSlcXHJcXG4gICAgLy8ge1xcclxcbiAgICAvLyAgICAgZkhhbGZCb3JkZXJEaXN0ICAgICAgPSB2MkNlbnRlcmVkUG9zLnggLSB2MkhhbGZTaGFwZVNpemVQeC54O1xcclxcbiAgICAvLyAgICAgZkhhbGZCb3JkZXJUaGlja25lc3MgPSB2X3N0cm9rZVRoaWNrbmVzcyAvIDIuMDtcXHJcXG4gICAgLy8gfVxcclxcbiAgICAvLyBlbHNlXFxyXFxuICAgIC8vIHtcXHJcXG4gICAgLy8gICAgIHZlYzIgZWRnZVZlYyA9IG1heCh2ZWMyKDAuMCksIHZfcmFkaXVzIC0gdmVjMihcXHJcXG4gICAgLy8gICAgICAgICB1di54ID4gMC41ID8gdl9zaXplLnggLSBmcmFnQ29vcmQueCA6IGZyYWdDb29yZC54LFxcclxcbiAgICAvLyAgICAgICAgIHV2LnkgPiAwLjUgPyB2X3NpemUueSAtIGZyYWdDb29yZC55IDogZnJhZ0Nvb3JkLnkpKTtcXHJcXG4gICAgICAgIFxcclxcbiAgICAvLyAgICAgZmxvYXQgZWxsaXBzZV9hYiAgICA9IHZfcmFkaXVzLXZfc3Ryb2tlVGhpY2tuZXNzO1xcclxcbiAgICAvLyAgICAgdmVjMiBlbGxpcHNlX2lzZWN0ID0gKHZfc3Ryb2tlVGhpY2tuZXNzID4gdl9yYWRpdXMgfHwgdl9zdHJva2VUaGlja25lc3MgPiB2X3JhZGl1cykgPyB2ZWMyKDAuMCkgOlxcclxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVZlYy54eSAqIGVsbGlwc2VfYWIqZWxsaXBzZV9hYiAvIGxlbmd0aChlbGxpcHNlX2FiKmVkZ2VWZWMueXgpOyBcXHJcXG4gICAgICAgICAgICBcXHJcXG4gICAgLy8gICAgIGZIYWxmQm9yZGVyVGhpY2tuZXNzID0gKHZfcmFkaXVzIC0gbGVuZ3RoKGVsbGlwc2VfaXNlY3QpKSAvIDIuMDtcXHJcXG4gICAgLy8gICAgIGZIYWxmQm9yZGVyRGlzdCAgICAgID0gbGVuZ3RoKGVkZ2VWZWMpIC0gKHZfcmFkaXVzIC0gZkhhbGZCb3JkZXJUaGlja25lc3MpO1xcclxcbiAgICAvLyB9XFxyXFxuXFxyXFxuICAgIC8vIHZlYzQgdjRGcm9tQ29sb3IgPSB2X3N0cm9rZUNvbG9yO1xcclxcbiAgICAvLyB2NEZyb21Db2xvci5yZ2IgKj0gdjRGcm9tQ29sb3IuYTtcXHJcXG4gICAgLy8gdmVjNCB2NFRvQ29sb3IgICA9IHZlYzQoMC4wKTsgLy8gYmFja2dyb3VuZCBjb2xvciBpcyB0cmFuc3BhcmVudFxcclxcbiAgICAvLyBpZiAoZkhhbGZCb3JkZXJEaXN0IDwgMC4wKSB7XFxyXFxuICAgIC8vICAgICB2NFRvQ29sb3IgPSB2X2NvbG9yO1xcclxcbiAgICAvLyAgICAgdjRUb0NvbG9yLnJnYiAqPSB2NFRvQ29sb3IuYTtcXHJcXG4gICAgLy8gfVxcclxcblxcclxcbiAgICAvLyBmbG9hdCBtaXhQY3QgPSBhYnMoZkhhbGZCb3JkZXJEaXN0KSAtIGZIYWxmQm9yZGVyVGhpY2tuZXNzO1xcclxcblxcclxcbiAgICAvLyB2ZWM0IGZpbmFsQ29sb3IgPSBtaXgodjRGcm9tQ29sb3IsIHY0VG9Db2xvciwgbWl4UGN0KTtcXHJcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gZmluYWxDb2xvcjtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9yZWN0YW5nbGUtcmVuZGVyZXIvcmVjdGFuZ2xlLXJlbmRlcmVyLnZlcnQuZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCByZWN0YW5nbGVfcmVuZGVyZXJfdmVydCA9IChcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbmluIHZlYzIgYV9wb3NpdGlvbjtcXHJcXG5cXHJcXG4vLyBVViBjb29yZGluYXRlXFxyXFxuaW4gdmVjMiBhX3V2O1xcclxcbm91dCB2ZWMyIHZfdXY7XFxyXFxuXFxyXFxuaW4gdmVjMiBhX3NpemU7XFxyXFxub3V0IHZlYzIgdl9zaXplO1xcclxcblxcclxcbi8vIE9wYWNpdHkgXFxyXFxuaW4gZmxvYXQgYV9vcGFjaXR5O1xcclxcbm91dCBmbG9hdCB2X29wYWNpdHk7XFxyXFxuXFxyXFxuaW4gdmVjNCBhX2NvbG9yO1xcclxcbm91dCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxuaW4gdmVjNCBhX3N0cm9rZUNvbG9yO1xcclxcbm91dCB2ZWM0IHZfc3Ryb2tlQ29sb3I7XFxyXFxuXFxyXFxuaW4gZmxvYXQgYV9zdHJva2VUaGlja25lc3M7XFxyXFxub3V0IGZsb2F0IHZfc3Ryb2tlVGhpY2tuZXNzO1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXHJcXG5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgLy8gU2V0IHRoZSB2ZXJ0ZXggcG9zaXRpb24gdXNpbmcgdGhlIG9ydGhvIHRyYW5zZm9ybSBtYXRyaXhcXHJcXG4gICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIFVWIGNvb3Jkc1xcclxcbiAgIHZfdXYgPSBhX3V2O1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCBzaXplXFxyXFxuICAgdl9zaXplID0gYV9zaXplO1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgT3BhY2l0eSB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl9vcGFjaXR5ID0gYV9vcGFjaXR5O1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgY29sb3IgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfY29sb3IgPSBhX2NvbG9yO1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgc3Ryb2tlIGNvbG9yIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X3N0cm9rZUNvbG9yID0gYV9zdHJva2VDb2xvcjtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIHN0cm9rZSB0aGlja2Vuc3MgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfc3Ryb2tlVGhpY2tuZXNzID0gYV9zdHJva2VUaGlja25lc3M7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvcmVjdGFuZ2xlLXJlbmRlcmVyL3JlY3RhbmdsZS1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFJlY3RhbmdsZVJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5yZWN0YW5nbGUnO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuX21heFJlY3RhbmdsZXMgPSAxMDkyMjsgLy8gbWF4KHVpbnQxNikgLyA2IHZlcnRzXHJcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEluZGV4ID0gMDtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoZ2wsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5MTk3NjcxL2dsc2wtcm91bmRlZC1yZWN0YW5nbGUtd2l0aC12YXJpYWJsZS1ib3JkZXJcclxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2hhZGVyKHtcclxuICAgICAgICAgICAgZnJhZ21lbnRTb3VyY2U6IHJlY3RhbmdsZV9yZW5kZXJlcl9mcmFnLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhTb3VyY2U6IHJlY3RhbmdsZV9yZW5kZXJlcl92ZXJ0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAvLyBzZXR1cCB1bmlmb3Jtc1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci51c2UoKTtcclxuICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCBjb250ZXh0Lm9ydGhvKTtcclxuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKHtcclxuICAgICAgICAgICAgc2l6ZTogMTYgKiA0ICogdGhpcy5fbWF4UmVjdGFuZ2xlcyxcclxuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFZlcnRleExheW91dCh7XHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRoaXMuX2J1ZmZlcixcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgWydhX3Bvc2l0aW9uJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdXYnLCAyXSxcclxuICAgICAgICAgICAgICAgIFsnYV9zaXplJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2Ffb3BhY2l0eScsIDFdLFxyXG4gICAgICAgICAgICAgICAgWydhX2NvbG9yJywgNF0sXHJcbiAgICAgICAgICAgICAgICBbJ2Ffc3Ryb2tlQ29sb3InLCA0XSxcclxuICAgICAgICAgICAgICAgIFsnYV9zdHJva2VUaGlja25lc3MnLCAxXVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcXVhZHMgPSBuZXcgUXVhZEluZGV4QnVmZmVyKHRoaXMuX21heFJlY3RhbmdsZXMsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2lzRnVsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVjdGFuZ2xlQ291bnQgPj0gdGhpcy5fbWF4UmVjdGFuZ2xlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZHJhdyguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBWZWN0b3IgJiYgYXJnc1sxXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdMaW5lLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGNvbG9yLCB0aGlja25lc3MgPSAxKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRnVsbCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlQ291bnQrKztcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gY3VycmVudCBjb250ZXh0XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5fY29udGV4dC5nZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5fY29udGV4dC5vcGFjaXR5O1xyXG4gICAgICAgIGNvbnN0IHNuYXBUb1BpeGVsID0gdGhpcy5fY29udGV4dC5zbmFwVG9QaXhlbDtcclxuICAgICAgICBjb25zdCBkaXIgPSBlbmQuc3ViKHN0YXJ0KTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBkaXIuc2l6ZTtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBkaXIubm9ybWFsaXplKCkucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIGNvbnN0IGhhbGZUaGljayA9IHRoaWNrbmVzcyAvIDI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLV4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xyXG4gICAgICAgICAqICAgIHwgICAgICAgICAgICAgICAgICAgICB8IChub3JtYWwpICAgICAgICAgICAgIHxcclxuICAgICAgICAgKiAgIChzdGFydHgsIHN0YXJ0eSktLS0tLS0tLS0tLS0tLS0tLS0+KGVuZHgsIGVuZHkpXHJcbiAgICAgICAgICogICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAqICAgICsgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBzdGFydFRvcCA9IHRyYW5zZm9ybS5tdWx0aXBseShub3JtYWwuc2NhbGUoaGFsZlRoaWNrKS5hZGQoc3RhcnQpKTtcclxuICAgICAgICBjb25zdCBzdGFydEJvdHRvbSA9IHRyYW5zZm9ybS5tdWx0aXBseShub3JtYWwuc2NhbGUoLWhhbGZUaGljaykuYWRkKHN0YXJ0KSk7XHJcbiAgICAgICAgY29uc3QgZW5kVG9wID0gdHJhbnNmb3JtLm11bHRpcGx5KG5vcm1hbC5zY2FsZShoYWxmVGhpY2spLmFkZChlbmQpKTtcclxuICAgICAgICBjb25zdCBlbmRCb3R0b20gPSB0cmFuc2Zvcm0ubXVsdGlwbHkobm9ybWFsLnNjYWxlKC1oYWxmVGhpY2spLmFkZChlbmQpKTtcclxuICAgICAgICBpZiAoc25hcFRvUGl4ZWwpIHtcclxuICAgICAgICAgICAgc3RhcnRUb3AueCA9IH5+KHN0YXJ0VG9wLnggKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgc3RhcnRUb3AueSA9IH5+KHN0YXJ0VG9wLnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgZW5kVG9wLnggPSB+fihlbmRUb3AueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBlbmRUb3AueSA9IH5+KGVuZFRvcC55ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIHN0YXJ0Qm90dG9tLnggPSB+fihzdGFydEJvdHRvbS54ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIHN0YXJ0Qm90dG9tLnkgPSB+fihzdGFydEJvdHRvbS55ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIGVuZEJvdHRvbS54ID0gfn4oZW5kQm90dG9tLnggKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgZW5kQm90dG9tLnkgPSB+fihlbmRCb3R0b20ueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIHV2IGNvdWxkIGJlIHN0YXRpYyB2ZXJ0ZXggYnVmZmVyXHJcbiAgICAgICAgY29uc3QgdXZ4MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ5MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ4MSA9IDE7XHJcbiAgICAgICAgY29uc3QgdXZ5MSA9IDE7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlID0gQ29sb3IuVHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gMDtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IDE7XHJcbiAgICAgICAgLy8gdXBkYXRlIGRhdGFcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl9sYXlvdXQudmVydGV4QnVmZmVyLmJ1ZmZlckRhdGE7XHJcbiAgICAgICAgLy8gKDAsIDApIC0gMFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0YXJ0VG9wLng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3RhcnRUb3AueTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dngwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gbGVuZ3RoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRoaWNrbmVzcztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBvcGFjaXR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlVGhpY2tuZXNzIC8gd2lkdGg7XHJcbiAgICAgICAgLy8gKDAsIDEpIC0gMVxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0YXJ0Qm90dG9tLng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3RhcnRCb3R0b20ueTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dngwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eTE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gbGVuZ3RoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRoaWNrbmVzcztcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBvcGFjaXR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlVGhpY2tuZXNzIC8gd2lkdGg7XHJcbiAgICAgICAgLy8gKDEsIDApIC0gMlxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGVuZFRvcC54O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGVuZFRvcC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBsZW5ndGg7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2VUaGlja25lc3MgLyB3aWR0aDtcclxuICAgICAgICAvLyAoMSwgMSkgLSAzXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gZW5kQm90dG9tLng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gZW5kQm90dG9tLnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGxlbmd0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0aGlja25lc3M7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZVRoaWNrbmVzcyAvIHdpZHRoO1xyXG4gICAgfVxyXG4gICAgZHJhd1JlY3RhbmdsZShwb3MsIHdpZHRoLCBoZWlnaHQsIGNvbG9yLCBzdHJva2UgPSBDb2xvci5UcmFuc3BhcmVudCwgc3Ryb2tlVGhpY2tuZXNzID0gMCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGwoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlY3RhbmdsZUNvdW50Kys7XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIGN1cnJlbnQgY29udGV4dFxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX2NvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMuX2NvbnRleHQub3BhY2l0eTtcclxuICAgICAgICBjb25zdCBzbmFwVG9QaXhlbCA9IHRoaXMuX2NvbnRleHQuc25hcFRvUGl4ZWw7XHJcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IHRyYW5zZm9ybS5tdWx0aXBseShwb3MuYWRkKHZlYygwLCAwKSkpO1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gdHJhbnNmb3JtLm11bHRpcGx5KHBvcy5hZGQodmVjKHdpZHRoLCAwKSkpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gdHJhbnNmb3JtLm11bHRpcGx5KHBvcy5hZGQodmVjKHdpZHRoLCBoZWlnaHQpKSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHRyYW5zZm9ybS5tdWx0aXBseShwb3MuYWRkKHZlYygwLCBoZWlnaHQpKSk7XHJcbiAgICAgICAgaWYgKHNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgIHRvcExlZnQueCA9IH5+KHRvcExlZnQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICB0b3BMZWZ0LnkgPSB+fih0b3BMZWZ0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueCA9IH5+KHRvcFJpZ2h0LnggKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueSA9IH5+KHRvcFJpZ2h0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgYm90dG9tTGVmdC54ID0gfn4oYm90dG9tTGVmdC54ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIGJvdHRvbUxlZnQueSA9IH5+KGJvdHRvbUxlZnQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC54ID0gfn4oYm90dG9tUmlnaHQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC55ID0gfn4oYm90dG9tUmlnaHQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIHV2IGNvdWxkIGJlIHN0YXRpYyB2ZXJ0ZXggYnVmZmVyXHJcbiAgICAgICAgY29uc3QgdXZ4MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ5MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ4MSA9IDE7XHJcbiAgICAgICAgY29uc3QgdXZ5MSA9IDE7XHJcbiAgICAgICAgLy8gdXBkYXRlIGRhdGFcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl9sYXlvdXQudmVydGV4QnVmZmVyLmJ1ZmZlckRhdGE7XHJcbiAgICAgICAgLy8gKDAsIDApIC0gMFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRvcExlZnQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0b3BMZWZ0Lnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHdpZHRoO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGhlaWdodDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBvcGFjaXR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIC8vICgwLCAxKSAtIDFcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBib3R0b21MZWZ0Lng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gYm90dG9tTGVmdC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBoZWlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZVRoaWNrbmVzcztcclxuICAgICAgICAvLyAoMSwgMCkgLSAyXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdG9wUmlnaHQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0b3BSaWdodC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBoZWlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZVRoaWNrbmVzcztcclxuICAgICAgICAvLyAoMSwgMSkgLSAzXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gYm90dG9tUmlnaHQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBib3R0b21SaWdodC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB3aWR0aDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBoZWlnaHQ7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZVRoaWNrbmVzcztcclxuICAgIH1cclxuICAgIGhhc1BlbmRpbmdEcmF3cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlQ291bnQgIT09IDA7XHJcbiAgICB9XHJcbiAgICBmbHVzaCgpIHtcclxuICAgICAgICAvLyBub3RoaW5nIHRvIGRyYXcgZWFybHkgZXhpdFxyXG4gICAgICAgIGlmICh0aGlzLl9yZWN0YW5nbGVDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgLy8gQmluZCB0aGUgc2hhZGVyXHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgIC8vIEJpbmQgdGhlIG1lbW9yeSBsYXlvdXQgYW5kIHVwbG9hZCBkYXRhXHJcbiAgICAgICAgdGhpcy5fbGF5b3V0LnVzZSh0cnVlKTtcclxuICAgICAgICAvLyBVcGRhdGUgb3J0aG8gbWF0cml4IHVuaWZvcm1cclxuICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9jb250ZXh0Lm9ydGhvKTtcclxuICAgICAgICAvLyBCaW5kIGluZGV4IGJ1ZmZlclxyXG4gICAgICAgIHRoaXMuX3F1YWRzLmJpbmQoKTtcclxuICAgICAgICAvLyBEcmF3IGFsbCB0aGUgcXVhZHNcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLl9yZWN0YW5nbGVDb3VudCAqIDYsIHRoaXMuX3F1YWRzLmJ1ZmZlckdsVHlwZSwgMCk7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50ICs9IHRoaXMuX3JlY3RhbmdsZUNvdW50O1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd0NhbGxDb3VudCsrO1xyXG4gICAgICAgIC8vIFJlc2V0XHJcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEluZGV4ID0gMDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvY2lyY2xlLXJlbmRlcmVyL2NpcmNsZS1yZW5kZXJlci5mcmFnLmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY2lyY2xlX3JlbmRlcmVyX2ZyYWcgPSAoXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxuLy8gVVYgY29vcmRcXHJcXG5pbiB2ZWMyIHZfdXY7XFxyXFxuXFxyXFxuLy8gQ29sb3IgY29vcmQgdG8gYmxlbmQgd2l0aCBpbWFnZVxcclxcbmluIGxvd3AgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbi8vIFN0cm9rZSBjb2xvciBpZiB1c2VkXFxyXFxuaW4gbG93cCB2ZWM0IHZfc3Ryb2tlQ29sb3I7XFxyXFxuXFxyXFxuLy8gU3Ryb2tlIHRoaWNrbmVzcyBpZiB1c2VkXFxyXFxuaW4gbG93cCBmbG9hdCB2X3N0cm9rZVRoaWNrbmVzcztcXHJcXG5cXHJcXG4vLyBPcGFjaXR5XFxyXFxuaW4gZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbm91dCB2ZWM0IGZyYWdDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAvLyBtYWtlICgwLCAwKSB0aGUgY2VudGVyIHRoZSB1diBcXHJcXG4gIHZlYzIgdXYgPSB2X3V2ICogMi4wIC0gMS4wO1xcclxcblxcclxcbiAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxyXFxuICB2ZWM0IHN0cm9rZUNvbG9yID0gdl9zdHJva2VDb2xvcjtcXHJcXG5cXHJcXG4gIC8vIGNpcmNsZSBib3JkZXIgaXMgYXQgcmFkaXVzIDEuMCBcXHJcXG4gIC8vIGRpc3QgaXMgPiAwIHdoZW4gaW5zaWRlIHRoZSBjaXJjbGUgXFxyXFxuICBmbG9hdCBkID0gbGVuZ3RoKHV2KTtcXHJcXG4gIGZsb2F0IGRpc3QgPSAxLjAgLSBsZW5ndGgodXYpO1xcclxcblxcclxcbiAgLy8gRmFkZSBiYXNlZCBvbiBmd2lkdGhcXHJcXG4gIGZsb2F0IGZhZGUgPSBmd2lkdGgoZG90KHV2LCB1dikpO1xcclxcblxcclxcbiAgLy8gaWYgZGlzdCBpcyBncmVhdGVyIHRoYW4gMCBzdGVwIHRvIDE7XFxyXFxuICAvLyB3aGVuIHdlIGNyb3NzIHRoaXMgMCB0aHJlc2hvbGQgYWRkIGEgc21vb3RoIGZhZGVcXHJcXG4gIGZsb2F0IGZpbGwgPSBzbW9vdGhzdGVwKC1mYWRlLzIuMCwgZmFkZS8yLjAsIGRpc3QpO1xcclxcblxcclxcbiAgLy8gaWYgZGlzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHN0cm9rZSB0aGlja25lc3Mgc3RlcCB0byAxXFxyXFxuICBmbG9hdCBzdHJva2UgPSAxLjAgLSBzbW9vdGhzdGVwKHZfc3Ryb2tlVGhpY2tuZXNzLCB2X3N0cm9rZVRoaWNrbmVzcyArIGZhZGUsIGRpc3QpO1xcclxcblxcclxcbiAgc3Ryb2tlQ29sb3IuYSAqPSBmaWxsICogc3Ryb2tlO1xcclxcbiAgc3Ryb2tlQ29sb3IucmdiICo9IHN0cm9rZUNvbG9yLmE7XFxyXFxuXFxyXFxuICBjb2xvci5hICo9IGZpbGwgKiAoMS4wIC0gc3Ryb2tlKTtcXHJcXG4gIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcclxcblxcclxcbiAgdmVjNCBmaW5hbENvbG9yID0gbWl4KHZlYzQoMC4wKSwgKGNvbG9yICsgc3Ryb2tlQ29sb3IpLCBmaWxsKTtcXHJcXG4gIGZpbmFsQ29sb3IucmdiID0gZmluYWxDb2xvci5yZ2IgKiB2X29wYWNpdHk7XFxyXFxuICBmaW5hbENvbG9yLmEgPSBmaW5hbENvbG9yLmEgKiB2X29wYWNpdHk7XFxyXFxuICBmcmFnQ29sb3IgPSBmaW5hbENvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2NpcmNsZS1yZW5kZXJlci9jaXJjbGUtcmVuZGVyZXIudmVydC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNpcmNsZV9yZW5kZXJlcl92ZXJ0ID0gKFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxuaW4gdmVjMiBhX3Bvc2l0aW9uO1xcclxcblxcclxcbi8vIFVWIGNvb3JkaW5hdGVcXHJcXG5pbiB2ZWMyIGFfdXY7XFxyXFxub3V0IHZlYzIgdl91djtcXHJcXG5cXHJcXG4vLyBPcGFjaXR5IFxcclxcbmluIGZsb2F0IGFfb3BhY2l0eTtcXHJcXG5vdXQgZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbmluIHZlYzQgYV9jb2xvcjtcXHJcXG5vdXQgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbmluIHZlYzQgYV9zdHJva2VDb2xvcjtcXHJcXG5vdXQgdmVjNCB2X3N0cm9rZUNvbG9yO1xcclxcblxcclxcbmluIGZsb2F0IGFfc3Ryb2tlVGhpY2tuZXNzO1xcclxcbm91dCBmbG9hdCB2X3N0cm9rZVRoaWNrbmVzcztcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxyXFxuXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgIC8vIFNldCB0aGUgdmVydGV4IHBvc2l0aW9uIHVzaW5nIHRoZSBvcnRobyB0cmFuc2Zvcm0gbWF0cml4XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCBVViBjb29yZHNcXHJcXG4gICB2X3V2ID0gYV91djtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIE9wYWNpdHkgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfb3BhY2l0eSA9IGFfb3BhY2l0eTtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIGNvbG9yIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X2NvbG9yID0gYV9jb2xvcjtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIHN0cm9rZSBjb2xvciB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl9zdHJva2VDb2xvciA9IGFfc3Ryb2tlQ29sb3I7XFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBzdHJva2UgdGhpY2tlbnNzIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X3N0cm9rZVRoaWNrbmVzcyA9IGFfc3Ryb2tlVGhpY2tuZXNzO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2NpcmNsZS1yZW5kZXJlci9jaXJjbGUtcmVuZGVyZXIudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBDaXJjbGVSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguY2lyY2xlJztcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl9tYXhDaXJjbGVzID0gMTA5MjI7IC8vIG1heCh1aW50MTYpIC8gNiB2ZXJ0c1xyXG4gICAgICAgIHRoaXMuX2NpcmNsZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKGdsLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2hhZGVyKHtcclxuICAgICAgICAgICAgZnJhZ21lbnRTb3VyY2U6IGNpcmNsZV9yZW5kZXJlcl9mcmFnLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhTb3VyY2U6IGNpcmNsZV9yZW5kZXJlcl92ZXJ0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAvLyBzZXR1cCB1bmlmb3Jtc1xyXG4gICAgICAgIHRoaXMuX3NoYWRlci51c2UoKTtcclxuICAgICAgICB0aGlzLl9zaGFkZXIuc2V0VW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCBjb250ZXh0Lm9ydGhvKTtcclxuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKHtcclxuICAgICAgICAgICAgc2l6ZTogMTQgKiA0ICogdGhpcy5fbWF4Q2lyY2xlcyxcclxuICAgICAgICAgICAgdHlwZTogJ2R5bmFtaWMnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFZlcnRleExheW91dCh7XHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRoaXMuX2J1ZmZlcixcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgWydhX3Bvc2l0aW9uJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdXYnLCAyXSxcclxuICAgICAgICAgICAgICAgIFsnYV9vcGFjaXR5JywgMV0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfY29sb3InLCA0XSxcclxuICAgICAgICAgICAgICAgIFsnYV9zdHJva2VDb2xvcicsIDRdLFxyXG4gICAgICAgICAgICAgICAgWydhX3N0cm9rZVRoaWNrbmVzcycsIDFdXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9xdWFkcyA9IG5ldyBRdWFkSW5kZXhCdWZmZXIodGhpcy5fbWF4Q2lyY2xlcywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfaXNGdWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGVDb3VudCA+PSB0aGlzLl9tYXhDaXJjbGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBkcmF3KHBvcywgcmFkaXVzLCBjb2xvciwgc3Ryb2tlID0gQ29sb3IuVHJhbnNwYXJlbnQsIHN0cm9rZVRoaWNrbmVzcyA9IDApIHtcclxuICAgICAgICBpZiAodGhpcy5faXNGdWxsKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaXJjbGVDb3VudCsrO1xyXG4gICAgICAgIC8vIHRyYW5zZm9ybSBiYXNlZCBvbiBjdXJyZW50IGNvbnRleHRcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl9jb250ZXh0LmdldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLl9jb250ZXh0Lm9wYWNpdHk7XHJcbiAgICAgICAgY29uc3Qgc25hcFRvUGl4ZWwgPSB0aGlzLl9jb250ZXh0LnNuYXBUb1BpeGVsO1xyXG4gICAgICAgIGNvbnN0IHRvcExlZnQgPSB0cmFuc2Zvcm0ubXVsdGlwbHkocG9zLmFkZCh2ZWMoLXJhZGl1cywgLXJhZGl1cykpKTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHRyYW5zZm9ybS5tdWx0aXBseShwb3MuYWRkKHZlYyhyYWRpdXMsIC1yYWRpdXMpKSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm0ubXVsdGlwbHkocG9zLmFkZCh2ZWMocmFkaXVzLCByYWRpdXMpKSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHRyYW5zZm9ybS5tdWx0aXBseShwb3MuYWRkKHZlYygtcmFkaXVzLCByYWRpdXMpKSk7XHJcbiAgICAgICAgaWYgKHNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgIHRvcExlZnQueCA9IH5+KHRvcExlZnQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICB0b3BMZWZ0LnkgPSB+fih0b3BMZWZ0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueCA9IH5+KHRvcFJpZ2h0LnggKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgdG9wUmlnaHQueSA9IH5+KHRvcFJpZ2h0LnkgKyBwaXhlbFNuYXBFcHNpbG9uKTtcclxuICAgICAgICAgICAgYm90dG9tTGVmdC54ID0gfn4oYm90dG9tTGVmdC54ICsgcGl4ZWxTbmFwRXBzaWxvbik7XHJcbiAgICAgICAgICAgIGJvdHRvbUxlZnQueSA9IH5+KGJvdHRvbUxlZnQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC54ID0gfn4oYm90dG9tUmlnaHQueCArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodC55ID0gfn4oYm90dG9tUmlnaHQueSArIHBpeGVsU25hcEVwc2lsb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIFVWIGNvdWxkIGJlIHN0YXRpYyB2ZXJ0ZXggYnVmZmVyXHJcbiAgICAgICAgY29uc3QgdXZ4MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ5MCA9IDA7XHJcbiAgICAgICAgY29uc3QgdXZ4MSA9IDE7XHJcbiAgICAgICAgY29uc3QgdXZ5MSA9IDE7XHJcbiAgICAgICAgLy8gdXBkYXRlIGRhdGFcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl9sYXlvdXQudmVydGV4QnVmZmVyLmJ1ZmZlckRhdGE7XHJcbiAgICAgICAgLy8gKDAsIDApIC0gMFxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRvcExlZnQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB0b3BMZWZ0Lnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkwO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2VUaGlja25lc3MgLyByYWRpdXM7XHJcbiAgICAgICAgLy8gKDAsIDEpIC0gMVxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGJvdHRvbUxlZnQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBib3R0b21MZWZ0Lnk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ4MDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dnkxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IG9wYWNpdHk7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuciAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2UuYTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBzdHJva2VUaGlja25lc3MgLyByYWRpdXM7XHJcbiAgICAgICAgLy8gKDEsIDApIC0gMlxyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHRvcFJpZ2h0Lng7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdG9wUmlnaHQueTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSB1dngxO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eTA7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gb3BhY2l0eTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuYiAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5yIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5nIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZS5hO1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHN0cm9rZVRoaWNrbmVzcyAvIHJhZGl1cztcclxuICAgICAgICAvLyAoMSwgMSkgLSAzXHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gYm90dG9tUmlnaHQueDtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBib3R0b21SaWdodC55O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IHV2eDE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gdXZ5MTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBvcGFjaXR5O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gY29sb3IuZyAvIDI1NTtcclxuICAgICAgICB2ZXJ0ZXhCdWZmZXJbdGhpcy5fdmVydGV4SW5kZXgrK10gPSBjb2xvci5iIC8gMjU1O1xyXG4gICAgICAgIHZlcnRleEJ1ZmZlclt0aGlzLl92ZXJ0ZXhJbmRleCsrXSA9IGNvbG9yLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLnIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmcgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmIgLyAyNTU7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlLmE7XHJcbiAgICAgICAgdmVydGV4QnVmZmVyW3RoaXMuX3ZlcnRleEluZGV4KytdID0gc3Ryb2tlVGhpY2tuZXNzIC8gcmFkaXVzO1xyXG4gICAgfVxyXG4gICAgaGFzUGVuZGluZ0RyYXdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVDb3VudCAhPT0gMDtcclxuICAgIH1cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZHJhdyBlYXJseSBleGl0XHJcbiAgICAgICAgaWYgKHRoaXMuX2NpcmNsZUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICAvLyBCaW5kIHRoZSBzaGFkZXJcclxuICAgICAgICB0aGlzLl9zaGFkZXIudXNlKCk7XHJcbiAgICAgICAgLy8gQmluZCB0aGUgbWVtb3J5IGxheW91dCBhbmQgdXBsb2FkIGRhdGFcclxuICAgICAgICB0aGlzLl9sYXlvdXQudXNlKHRydWUpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBvcnRobyBtYXRyaXggdW5pZm9ybVxyXG4gICAgICAgIHRoaXMuX3NoYWRlci5zZXRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHQub3J0aG8pO1xyXG4gICAgICAgIC8vIEJpbmQgaW5kZXggYnVmZmVyXHJcbiAgICAgICAgdGhpcy5fcXVhZHMuYmluZCgpO1xyXG4gICAgICAgIC8vIERyYXcgYWxsIHRoZSBxdWFkc1xyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuX2NpcmNsZUNvdW50ICogNiwgdGhpcy5fcXVhZHMuYnVmZmVyR2xUeXBlLCAwKTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgKz0gdGhpcy5fY2lyY2xlQ291bnQ7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50Kys7XHJcbiAgICAgICAgLy8gUmVzZXRcclxuICAgICAgICB0aGlzLl9jaXJjbGVDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4SW5kZXggPSAwO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9Qb29sLnRzXG5cclxuY2xhc3MgUG9vbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihidWlsZGVyLCByZWN5Y2xlciwgbWF4T2JqZWN0cyA9IDEwMCkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XHJcbiAgICAgICAgdGhpcy5yZWN5Y2xlciA9IHJlY3ljbGVyO1xyXG4gICAgICAgIHRoaXMubWF4T2JqZWN0cyA9IG1heE9iamVjdHM7XHJcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRpb25zID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRpc2FibGVXYXJuaW5ncyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgcHJlYWxsb2NhdGUoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1heE9iamVjdHM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLm9iamVjdHNbaV0gPSB0aGlzLmJ1aWxkZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBtYW55IGluc3RhbmNlcyBvdXQgb2YgdGhlIGluIHRoZSBjb250ZXh0IGFuZCByZXR1cm4gYWxsIHRvIHRoZSBwb29sLlxyXG4gICAgICpcclxuICAgICAqIEJ5IHJldHVybmluZyB2YWx1ZXMgb3V0IG9mIHRoZSBjb250ZXh0IHRoZXkgd2lsbCBiZSB1bi1ob29rZWQgZnJvbSB0aGUgcG9vbCBhbmQgYXJlIGZyZWUgdG8gYmUgcGFzc2VkIHRvIGNvbnN1bWVyc1xyXG4gICAgICogQHBhcmFtIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgdXNpbmcoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQodGhpcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb25lKC4uLnJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIGEgc2luZ2xlIGluc3RhbmNlIG91dCBvZiB0aCBwb29sIGFuZCBpbW1lZGlhdGVseSByZXR1cm4gaXQgdG8gdGhlIHBvb2xcclxuICAgICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGJvcnJvdyhjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5nZXQoKTtcclxuICAgICAgICBjb250ZXh0KG9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5pbmRleC0tO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIHZhbHVlIGZyb20gdGhlIHBvb2wsIHdpbGwgYWxsb2NhdGUgYSBuZXcgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5IG9yIHJlY3ljbGUgZnJvbSB0aGUgcG9vbFxyXG4gICAgICogQHBhcmFtIGFyZ3NcclxuICAgICAqL1xyXG4gICAgZ2V0KC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5tYXhPYmplY3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdNYXggcG9vbGVkIG9iamVjdHMgcmVhY2hlZCwgcG9zc2libGUgbWVtb3J5IGxlYWs/IERvdWJsaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXhPYmplY3RzID0gdGhpcy5tYXhPYmplY3RzICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0c1t0aGlzLmluZGV4XSkge1xyXG4gICAgICAgICAgICAvLyBQb29sIGhhcyBhbiBhdmFpbGFibGUgb2JqZWN0IGFscmVhZHkgY29uc3RydWN0ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjeWNsZXIodGhpcy5vYmplY3RzW3RoaXMuaW5kZXgrK10sIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTmV3IGFsbG9jYXRpb25cclxuICAgICAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRpb25zKys7XHJcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9ICh0aGlzLm9iamVjdHNbdGhpcy5pbmRleCsrXSA9IHRoaXMuYnVpbGRlciguLi5hcmdzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZG9uZSguLi5vYmplY3RzKSB7XHJcbiAgICAgICAgLy8gQWxsIG9iamVjdHMgaW4gcG9vbCBub3cgY29uc2lkZXJlZCBcImZyZWVcIlxyXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9vbEluZGV4ID0gdGhpcy5vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcclxuICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgb2JqZWN0IHRvIHRha2UgdGhlIHBvb2wgcGxhY2VcclxuICAgICAgICAgICAgdGhpcy5vYmplY3RzW3Bvb2xJbmRleF0gPSB0aGlzLmJ1aWxkZXIoKTsgLy8gVE9ETyBwcm9ibGVtYXRpYyAwLWFyZyBvbmx5IHN1cHBvcnRcclxuICAgICAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRpb25zKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3RzO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9kcmF3LWNhbGwudHNcblxyXG5cclxuY2xhc3MgRHJhd0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHo6IDAsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHRpbnQ6IENvbG9yLldoaXRlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyByZW5kZXJlcnNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgcGl4ZWxTbmFwRXBzaWxvbiA9IDAuMDAwMTtcclxuY2xhc3MgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0xEZWJ1ZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfd2ViZ2xDdHgpIHtcclxuICAgICAgICB0aGlzLl93ZWJnbEN0eCA9IF93ZWJnbEN0eDtcclxuICAgICAgICB0aGlzLl9kZWJ1Z1RleHQgPSBuZXcgRGVidWdUZXh0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkZWJ1Z2dpbmcgcmVjdGFuZ2xlIHRvIHRoZSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqIEBwYXJhbSB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWN0T3B0aW9ucyA9IHsgY29sb3I6IENvbG9yLkJsYWNrIH0pIHtcclxuICAgICAgICB0aGlzLmRyYXdMaW5lKHZlYyh4LCB5KSwgdmVjKHggKyB3aWR0aCwgeSksIHsgLi4ucmVjdE9wdGlvbnMgfSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZSh2ZWMoeCArIHdpZHRoLCB5KSwgdmVjKHggKyB3aWR0aCwgeSArIGhlaWdodCksIHsgLi4ucmVjdE9wdGlvbnMgfSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZSh2ZWMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KSwgdmVjKHgsIHkgKyBoZWlnaHQpLCB7IC4uLnJlY3RPcHRpb25zIH0pO1xyXG4gICAgICAgIHRoaXMuZHJhd0xpbmUodmVjKHgsIHkgKyBoZWlnaHQpLCB2ZWMoeCwgeSksIHsgLi4ucmVjdE9wdGlvbnMgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkZWJ1Z2dpbmcgbGluZSB0byB0aGUgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHN0YXJ0XHJcbiAgICAgKiBAcGFyYW0gZW5kXHJcbiAgICAgKiBAcGFyYW0gbGluZU9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZHJhd0xpbmUoc3RhcnQsIGVuZCwgbGluZU9wdGlvbnMgPSB7IGNvbG9yOiBDb2xvci5CbGFjayB9KSB7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2xDdHguZHJhdygnZXgubGluZScsIHN0YXJ0LCBlbmQsIGxpbmVPcHRpb25zLmNvbG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnZ2luZyBwb2ludCB0byB0aGUgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGRyYXdQb2ludChwb2ludCwgcG9pbnRPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2ssIHNpemU6IDUgfSkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsQ3R4LmRyYXcoJ2V4LnBvaW50JywgcG9pbnQsIHBvaW50T3B0aW9ucy5jb2xvciwgcG9pbnRPcHRpb25zLnNpemUpO1xyXG4gICAgfVxyXG4gICAgZHJhd1RleHQodGV4dCwgcG9zKSB7XHJcbiAgICAgICAgdGhpcy5fZGVidWdUZXh0LndyaXRlKHRoaXMuX3dlYmdsQ3R4LCB0ZXh0LCBwb3MpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5faXNEcmF3TGlmZWN5Y2xlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51c2VEcmF3U29ydGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZHJhd0NhbGxQb29sID0gbmV3IFBvb2woKCkgPT4gbmV3IERyYXdDYWxsKCksIChpbnN0YW5jZSkgPT4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnogPSAwO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXJlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXJncyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICAgIH0sIDQwMDApO1xyXG4gICAgICAgIHRoaXMuX2RyYXdDYWxscyA9IFtdO1xyXG4gICAgICAgIC8vIFBvc3Rwcm9jZXNzaW5nIGlzIGEgdHVwbGUgd2l0aCAyIHJlbmRlciB0YXJnZXRzLCB0aGVzZSBhcmUgZmxpcC1mbG9wcGVkIGR1cmluZyB0aGUgcG9zdHByb2Nlc3NpbmcgcHJvY2Vzc1xyXG4gICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Bvc3Rwcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0YWNrKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGVTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNtb290aGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuRXhjYWxpYnVyQmx1ZTtcclxuICAgICAgICB0aGlzLl9hbHJlYWR5V2FybmVkRHJhd0xpZmVjeWNsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBuZXcgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0xEZWJ1Zyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IGNhbnZhc0VsZW1lbnQsIGVuYWJsZVRyYW5zcGFyZW5jeSwgc21vb3RoaW5nLCBzbmFwVG9QaXhlbCwgYmFja2dyb3VuZENvbG9yLCB1c2VEcmF3U29ydGluZyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9fZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJ3dlYmdsMicsIHtcclxuICAgICAgICAgICAgYW50aWFsaWFzOiBzbW9vdGhpbmcgIT09IG51bGwgJiYgc21vb3RoaW5nICE9PSB2b2lkIDAgPyBzbW9vdGhpbmcgOiB0aGlzLnNtb290aGluZyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcclxuICAgICAgICAgICAgYWxwaGE6IGVuYWJsZVRyYW5zcGFyZW5jeSAhPT0gbnVsbCAmJiBlbmFibGVUcmFuc3BhcmVuY3kgIT09IHZvaWQgMCA/IGVuYWJsZVRyYW5zcGFyZW5jeSA6IHRydWUsXHJcbiAgICAgICAgICAgIGRlcHRoOiB0cnVlLFxyXG4gICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJ1xyXG4gICAgICAgICAgICAvLyBUT0RPIENocm9taXVtIGZpeGVkIHRoZSBidWcgd2hlcmUgdGhpcyBkaWRuJ3Qgd29yayBub3cgaXQgYnJlYWtzIENJIDooXHJcbiAgICAgICAgICAgIC8vIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuX19nbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRmFpbGVkIHRvIHJldHJpZXZlIHdlYmdsIGNvbnRleHQgZnJvbSBicm93c2VyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV4Y2FsaWJ1cldlYkdMQ29udGV4dEFjY2Vzc29yLnJlZ2lzdGVyKHRoaXMuX19nbCk7XHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5yZWdpc3Rlcih0aGlzLl9fZ2wpO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSBzbmFwVG9QaXhlbCAhPT0gbnVsbCAmJiBzbmFwVG9QaXhlbCAhPT0gdm9pZCAwID8gc25hcFRvUGl4ZWwgOiB0aGlzLnNuYXBUb1BpeGVsO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nID0gc21vb3RoaW5nICE9PSBudWxsICYmIHNtb290aGluZyAhPT0gdm9pZCAwID8gc21vb3RoaW5nIDogdGhpcy5zbW9vdGhpbmc7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwgJiYgYmFja2dyb3VuZENvbG9yICE9PSB2b2lkIDAgPyBiYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB0aGlzLnVzZURyYXdTb3J0aW5nID0gdXNlRHJhd1NvcnRpbmcgIT09IG51bGwgJiYgdXNlRHJhd1NvcnRpbmcgIT09IHZvaWQgMCA/IHVzZURyYXdTb3J0aW5nIDogdGhpcy51c2VEcmF3U29ydGluZztcclxuICAgICAgICB0aGlzLl9kcmF3Q2FsbFBvb2wuZGlzYWJsZVdhcm5pbmdzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9kcmF3Q2FsbFBvb2wucHJlYWxsb2NhdGUoKTtcclxuICAgICAgICB0aGlzLl9pbml0KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgeigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY3VycmVudC56O1xyXG4gICAgfVxyXG4gICAgc2V0IHoodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50LnogPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5jdXJyZW50Lm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3BhY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnQub3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQudGludDtcclxuICAgIH1cclxuICAgIHNldCB0aW50KGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudC50aW50ID0gY29sb3I7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19nbC5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZ2wuY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBvcnRobygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3J0aG87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgdW5kZXJseWluZyB3ZWJnbCBpbXBsZW1lbnRhdGlvbiBpZiB0aGUgcmVxdWVzdGVkIGludGVybmFsIHJlc29sdXRpb24gaXMgc3VwcG9ydGVkXHJcbiAgICAgKiBAcGFyYW0gZGltXHJcbiAgICAgKi9cclxuICAgIGNoZWNrSWZSZXNvbHV0aW9uU3VwcG9ydGVkKGRpbSkge1xyXG4gICAgICAgIC8vIFNsaWdodCBoYWNrIGJhc2VkIG9uIHRoaXMgdGhyZWFkIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZy93ZWJnbC1kZXYtbGlzdC9jL0FIT052ejNvUVRvXHJcbiAgICAgICAgbGV0IHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGRpbS53aWR0aCA+IDQwOTYgfHwgZGltLmhlaWdodCA+IDQwOTYpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICBfaW5pdCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICAvLyBTZXR1cCB2aWV3cG9ydCBhbmQgdmlldyBtYXRyaXhcclxuICAgICAgICB0aGlzLl9vcnRobyA9IE1hdHJpeC5vcnRobygwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQsIDAsIDQwMCwgLTQwMCk7XHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAvLyBDbGVhciBiYWNrZ3JvdW5kXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvci5yIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5nIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5iIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5hKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAvLyBFbmFibGUgYWxwaGEgYmxlbmRpbmdcclxuICAgICAgICAvLyBodHRwczovL3d3dy5yZWFsdGltZXJlbmRlcmluZy5jb20vYmxvZy9ncHVzLXByZWZlci1wcmVtdWx0aXBsaWNhdGlvbi9cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAvLyBTZXR1cCBidWlsdGluIHJlbmRlcmVyc1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXIobmV3IEltYWdlUmVuZGVyZXIoKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcihuZXcgUmVjdGFuZ2xlUmVuZGVyZXIoKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcihuZXcgQ2lyY2xlUmVuZGVyZXIoKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcihuZXcgUG9pbnRSZW5kZXJlcigpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKG5ldyBMaW5lUmVuZGVyZXIoKSk7XHJcbiAgICAgICAgdGhpcy5fc2NyZWVuUmVuZGVyZXIgPSBuZXcgU2NyZWVuUGFzc1BhaW50ZXIoZ2wpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoe1xyXG4gICAgICAgICAgICBnbCxcclxuICAgICAgICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcG9zdFByb2Nlc3NUYXJnZXRzID0gW1xyXG4gICAgICAgICAgICBuZXcgUmVuZGVyVGFyZ2V0KHtcclxuICAgICAgICAgICAgICAgIGdsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgbmV3IFJlbmRlclRhcmdldCh7XHJcbiAgICAgICAgICAgICAgICBnbCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBnbC5jYW52YXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXIocmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMuc2V0KHJlbmRlcmVyLnR5cGUsIHJlbmRlcmVyKTtcclxuICAgICAgICByZW5kZXJlci5pbml0aWFsaXplKHRoaXMuX19nbCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQocmVuZGVyZXJOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVycy5nZXQocmVuZGVyZXJOYW1lKTtcclxuICAgIH1cclxuICAgIF9pc0N1cnJlbnRSZW5kZXJlcihyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudFJlbmRlcmVyIHx8IHRoaXMuX2N1cnJlbnRSZW5kZXJlciA9PT0gcmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGJlZ2luRHJhd0xpZmVjeWNsZSgpIHtcclxuICAgICAgICB0aGlzLl9pc0RyYXdMaWZlY3ljbGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZW5kRHJhd0xpZmVjeWNsZSgpIHtcclxuICAgICAgICB0aGlzLl9pc0RyYXdMaWZlY3ljbGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGRyYXcocmVuZGVyZXJOYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0RyYXdMaWZlY3ljbGUgJiYgIXRoaXMuX2FscmVhZHlXYXJuZWREcmF3TGlmZWN5Y2xlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBBdHRlbXB0aW5nIHRvIGRyYXcgb3V0c2lkZSB0aGUgdGhlIGRyYXdpbmcgbGlmZWN5Y2xlIChwcmVEcmF3L3Bvc3REcmF3KSBpcyBub3Qgc3VwcG9ydGVkIGFuZCBpcyBhIHNvdXJjZSBvZiBidWdzL2Vycm9ycy5cXG5gICtcclxuICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byBkbyBjdXN0b20gZHJhd2luZywgdXNlIEFjdG9yLmdyYXBoaWNzLCBvciBhbnkgb25QcmVEcmF3IG9yIG9uUG9zdERyYXcgaGFuZGxlci5gKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxyZWFkeVdhcm5lZERyYXdMaWZlY3ljbGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVycy5nZXQocmVuZGVyZXJOYW1lKTtcclxuICAgICAgICBpZiAocmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXNlRHJhd1NvcnRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdDYWxsID0gdGhpcy5fZHJhd0NhbGxQb29sLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgZHJhd0NhbGwueiA9IHRoaXMuX3N0YXRlLmN1cnJlbnQuejtcclxuICAgICAgICAgICAgICAgIGRyYXdDYWxsLnByaW9yaXR5ID0gcmVuZGVyZXIucHJpb3JpdHk7XHJcbiAgICAgICAgICAgICAgICBkcmF3Q2FsbC5yZW5kZXJlciA9IHJlbmRlcmVyTmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtKCkuY2xvbmUoZHJhd0NhbGwudHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgICAgIGRyYXdDYWxsLnN0YXRlLnogPSB0aGlzLl9zdGF0ZS5jdXJyZW50Lno7XHJcbiAgICAgICAgICAgICAgICBkcmF3Q2FsbC5zdGF0ZS5vcGFjaXR5ID0gdGhpcy5fc3RhdGUuY3VycmVudC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgZHJhd0NhbGwuc3RhdGUudGludCA9IHRoaXMuX3N0YXRlLmN1cnJlbnQudGludDtcclxuICAgICAgICAgICAgICAgIGRyYXdDYWxsLmFyZ3MgPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhbGxzLnB1c2goZHJhd0NhbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHJlbmRlcmVyIGlmIG5vdCBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0N1cnJlbnRSZW5kZXJlcihyZW5kZXJlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZ3JhcGhpY3MgbWVhbnMgd2UgbXVzdCBmbHVzaCB0aGUgcHJldmlvdXNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBzdGlsbCB1c2luZyB0aGUgc2FtZSByZW5kZXJlciB3ZSBjYW4gYWRkIHRvIHRoZSBjdXJyZW50IGJhdGNoXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5kcmF3KC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBObyByZW5kZXJlciB3aXRoIG5hbWUgJHtyZW5kZXJlck5hbWV9IGhhcyBiZWVuIHJlZ2lzdGVyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uY3VycmVudCA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmlld3BvcnQocmVzb2x1dGlvbikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fX2dsO1xyXG4gICAgICAgIHRoaXMuX29ydGhvID0gdGhpcy5fb3J0aG8gPSBNYXRyaXgub3J0aG8oMCwgcmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQsIDAsIDQwMCwgLTQwMCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFJlc29sdXRpb24oZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc1RhcmdldHNbMF0uc2V0UmVzb2x1dGlvbihnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzVGFyZ2V0c1sxXS5zZXRSZXNvbHV0aW9uKGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBkcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIGlmIChzd2lkdGggPT09IDAgfHwgc2hlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIGRlc3QgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkd2lkdGggPT09IDAgfHwgZGhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIGRlc3QgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbWFnZS53aWR0aCA9PT0gMCB8fCBpbWFnZS5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyB6ZXJvIGRpbWVuc2lvbiBzb3VyY2UgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWltYWdlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCBkcmF3IGEgbnVsbCBvciB1bmRlZmluZWQgaW1hZ2UnKTtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhdygnZXguaW1hZ2UnLCBpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGNvbG9yLCB0aGlja25lc3MgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5kcmF3KCdleC5yZWN0YW5nbGUnLCBzdGFydCwgZW5kLCBjb2xvciwgdGhpY2tuZXNzKTtcclxuICAgIH1cclxuICAgIGRyYXdSZWN0YW5nbGUocG9zLCB3aWR0aCwgaGVpZ2h0LCBjb2xvciwgc3Ryb2tlLCBzdHJva2VUaGlja25lc3MpIHtcclxuICAgICAgICB0aGlzLmRyYXcoJ2V4LnJlY3RhbmdsZScsIHBvcywgd2lkdGgsIGhlaWdodCwgY29sb3IsIHN0cm9rZSwgc3Ryb2tlVGhpY2tuZXNzKTtcclxuICAgIH1cclxuICAgIGRyYXdDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yLCBzdHJva2UsIHRoaWNrbmVzcykge1xyXG4gICAgICAgIHRoaXMuZHJhdygnZXguY2lyY2xlJywgcG9zLCByYWRpdXMsIGNvbG9yLCBzdHJva2UsIHRoaWNrbmVzcyk7XHJcbiAgICB9XHJcbiAgICBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuc2F2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucmVzdG9yZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnRyYW5zbGF0ZSh0aGlzLnNuYXBUb1BpeGVsID8gfn4oeCArIHBpeGVsU25hcEVwc2lsb24pIDogeCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+KHkgKyBwaXhlbFNuYXBFcHNpbG9uKSA6IHkpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnJvdGF0ZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnNjYWxlKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5jdXJyZW50ID0gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgZ2V0VHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0uY3VycmVudDtcclxuICAgIH1cclxuICAgIG11bHRpcGx5KG0pIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uY3VycmVudC5tdWx0aXBseShtLCB0aGlzLl90cmFuc2Zvcm0uY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBhZGRQb3N0UHJvY2Vzc29yKHBvc3Rwcm9jZXNzb3IpIHtcclxuICAgICAgICB0aGlzLl9wb3N0cHJvY2Vzc29ycy5wdXNoKHBvc3Rwcm9jZXNzb3IpO1xyXG4gICAgICAgIHBvc3Rwcm9jZXNzb3IuaW5pdGlhbGl6ZSh0aGlzLl9fZ2wpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUG9zdFByb2Nlc3Nvcihwb3N0cHJvY2Vzc29yKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wb3N0cHJvY2Vzc29ycy5pbmRleE9mKHBvc3Rwcm9jZXNzb3IpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zdHByb2Nlc3NvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhclBvc3RQcm9jZXNzb3JzKCkge1xyXG4gICAgICAgIHRoaXMuX3Bvc3Rwcm9jZXNzb3JzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQudXNlKCk7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvci5yIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5nIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5iIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5hKTtcclxuICAgICAgICAvLyBDbGVhciB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXdseSBzZXQgY29sb3IuIFRoaXMgaXNcclxuICAgICAgICAvLyB0aGUgZnVuY3Rpb24gY2FsbCB0aGF0IGFjdHVhbGx5IGRvZXMgdGhlIGRyYXdpbmcuXHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoZXMgYWxsIGJhdGNoZWQgcmVuZGVyaW5nIHRvIHRoZSBzY3JlZW5cclxuICAgICAqL1xyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9fZ2w7XHJcbiAgICAgICAgLy8gcmVuZGVyIHRhcmdldCBjYXB0dXJlcyBhbGwgZHJhd3MgYW5kIHJlZGlyZWN0cyB0byB0aGUgcmVuZGVyIHRhcmdldFxyXG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC51c2UoKTtcclxuICAgICAgICBpZiAodGhpcy51c2VEcmF3U29ydGluZykge1xyXG4gICAgICAgICAgICAvLyBzb3J0IGRyYXcgY2FsbHNcclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBkcmF3IGNhbGxcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTb3J0ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lXSBvZiB0aGlzLl9yZW5kZXJlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLl9kcmF3Q2FsbHMuZmluZEluZGV4KGRjID0+IGRjLnJlbmRlcmVyID09PSBuYW1lKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsU29ydC5zZXQobmFtZSwgZmlyc3RJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHJhd0NhbGxzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpJbmRleCA9IGEueiAtIGIuejtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU29ydE9yZGVyID0gb3JpZ2luYWxTb3J0LmdldChhLnJlbmRlcmVyKSAtIG9yaWdpbmFsU29ydC5nZXQoYi5yZW5kZXJlcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eSA9IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHpJbmRleCA9PT0gMCkgeyAvLyBzb3J0IGJ5IHogZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3JpdHkgPT09IDApIHsgLy8gc29ydCBieSBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTb3J0T3JkZXI7IC8vIHVzZSB0aGUgb3JpZ2luYWwgb3JkZXIgdG8gaW5mb3JtIGRyYXcgY2FsbCBwYWNraW5nIHRvIG1heGltYWxseSBwcmVzZXJ2ZSBwYWludGVyIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmlvcml0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB6SW5kZXg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUcmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0uY3VycmVudDtcclxuICAgICAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZS5jdXJyZW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd0NhbGxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRSZW5kZXJlck5hbWUgPSB0aGlzLl9kcmF3Q2FsbHNbMF0ucmVuZGVyZXI7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzLmdldChjdXJyZW50UmVuZGVyZXJOYW1lKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHlkcmF0ZSB0aGUgc3RhdGUgZm9yIHJlbmRlcmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5jdXJyZW50ID0gdGhpcy5fZHJhd0NhbGxzW2ldLnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50ID0gdGhpcy5fZHJhd0NhbGxzW2ldLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3Q2FsbHNbaV0ucmVuZGVyZXIgIT09IGN1cnJlbnRSZW5kZXJlck5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGdyYXBoaWNzIHJlbmRlcmVyIG1lYW5zIHdlIG11c3QgZmx1c2ggdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyZXJOYW1lID0gdGhpcy5fZHJhd0NhbGxzW2ldLnJlbmRlcmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcnMuZ2V0KGN1cnJlbnRSZW5kZXJlck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgdXNpbmcgdGhlIHNhbWUgcmVuZGVyZXIgd2UgY2FuIGFkZCB0byB0aGUgY3VycmVudCBiYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJlci5kcmF3KC4uLnRoaXMuX2RyYXdDYWxsc1tpXS5hcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVuZGVyZXIuaGFzUGVuZGluZ0RyYXdzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXNldCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0uY3VycmVudCA9IG9sZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudCA9IG9sZFN0YXRlO1xyXG4gICAgICAgICAgICAvLyByZWNsYWltIGRyYXcgY2FsbHNcclxuICAgICAgICAgICAgdGhpcy5fZHJhd0NhbGxQb29sLmRvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd0NhbGxzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaW5hbCBmbHVzaCBhdCB0aGUgbW9tZW50IHRvIGRyYXcgYW55IGxlZnRvdmVyIHBlbmRpbmcgZHJhd1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHRoaXMuX3JlbmRlcmVycy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmhhc1BlbmRpbmdEcmF3cygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuZGlzYWJsZSgpO1xyXG4gICAgICAgIC8vIHBvc3QgcHJvY2VzcyBzdGVwXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5fcmVuZGVyVGFyZ2V0LnRvUmVuZGVyU291cmNlKCk7XHJcbiAgICAgICAgc291cmNlLnVzZSgpO1xyXG4gICAgICAgIC8vIGZsaXAgZmxvcCByZW5kZXIgdGFyZ2V0c1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcG9zdHByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zdFByb2Nlc3NUYXJnZXRzW2kgJSAyXS51c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2NyZWVuUmVuZGVyZXIucmVuZGVyV2l0aFBvc3RQcm9jZXNzb3IodGhpcy5fcG9zdHByb2Nlc3NvcnNbaV0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc1RhcmdldHNbaSAlIDJdLnRvUmVuZGVyU291cmNlKCkudXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhc3NpbmcgbnVsbCBzd2l0Y2hlcyByZW5kZXJpbmcgYmFjayB0byB0aGUgY2FudmFzXHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB0aGlzLl9zY3JlZW5SZW5kZXJlci5yZW5kZXJUb1NjcmVlbigpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9FeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcy50c1xuXHJcblxyXG5cclxuXHJcbmNvbnN0IEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24gPSAwLjAwMDE7XHJcbmNsYXNzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzRGVidWcge1xyXG4gICAgY29uc3RydWN0b3IoX2V4KSB7XHJcbiAgICAgICAgdGhpcy5fZXggPSBfZXg7XHJcbiAgICAgICAgdGhpcy5fZGVidWdUZXh0ID0gbmV3IERlYnVnVGV4dCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGVidWcgcmVjdGFuZ2xlIHRvIHRoZSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqIEBwYXJhbSB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc3Ryb2tlUmVjdCh0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+KHggKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IHgsIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn4oeSArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogeSwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fih3aWR0aCArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogd2lkdGgsIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn4oaGVpZ2h0ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGxpbmVPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2sgfSkge1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zdHJva2VTdHlsZSA9IGxpbmVPcHRpb25zLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgubW92ZVRvKHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn4oc3RhcnQueCArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogc3RhcnQueCwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fihzdGFydC55ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBzdGFydC55KTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5saW5lVG8odGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fihlbmQueCArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogZW5kLngsIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn4oZW5kLnkgKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IGVuZC55KTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdQb2ludChwb2ludCwgcG9pbnRPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2ssIHNpemU6IDUgfSkge1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5maWxsU3R5bGUgPSBwb2ludE9wdGlvbnMuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5hcmModGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fihwb2ludC54ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBwb2ludC54LCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+KHBvaW50LnkgKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IHBvaW50LnksIHBvaW50T3B0aW9ucy5zaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguZmlsbCgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdUZXh0KHRleHQsIHBvcykge1xyXG4gICAgICAgIHRoaXMuX2RlYnVnVGV4dC53cml0ZSh0aGlzLl9leCwgdGV4dCwgcG9zKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW51c2VkIGluIENhbnZhcyBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXNlRHJhd1NvcnRpbmcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnVzZWQgaW4gQ2FudmFzIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLkV4Y2FsaWJ1ckJsdWU7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGVTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlYnVnID0gbmV3IEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzRGVidWcodGhpcyk7XHJcbiAgICAgICAgY29uc3QgeyBjYW52YXNFbGVtZW50LCBlbmFibGVUcmFuc3BhcmVuY3ksIHNuYXBUb1BpeGVsLCBzbW9vdGhpbmcsIGJhY2tncm91bmRDb2xvciB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9fY3R4ID0gY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcsIHtcclxuICAgICAgICAgICAgYWxwaGE6IGVuYWJsZVRyYW5zcGFyZW5jeSAhPT0gbnVsbCAmJiBlbmFibGVUcmFuc3BhcmVuY3kgIT09IHZvaWQgMCA/IGVuYWJsZVRyYW5zcGFyZW5jeSA6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCAmJiBiYWNrZ3JvdW5kQ29sb3IgIT09IHZvaWQgMCA/IGJhY2tncm91bmRDb2xvciA6IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSBzbmFwVG9QaXhlbCAhPT0gbnVsbCAmJiBzbmFwVG9QaXhlbCAhPT0gdm9pZCAwID8gc25hcFRvUGl4ZWwgOiB0aGlzLnNuYXBUb1BpeGVsO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nID0gc21vb3RoaW5nICE9PSBudWxsICYmIHNtb290aGluZyAhPT0gdm9pZCAwID8gc21vb3RoaW5nIDogdGhpcy5zbW9vdGhpbmc7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdHguY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2N0eC5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQub3BhY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudC5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdGludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY3VycmVudC50aW50O1xyXG4gICAgfVxyXG4gICAgc2V0IHRpbnQoY29sb3IpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50LnRpbnQgPSBjb2xvcjtcclxuICAgIH1cclxuICAgIGdldCBzbW9vdGhpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IHNtb290aGluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX19jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWaWV3cG9ydChfcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxuICAgIGRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHN3aWR0aCA9PT0gMCB8fCBzaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR3aWR0aCA9PT0gMCB8fCBkaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltYWdlLndpZHRoID09PSAwIHx8IGltYWdlLmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIHNvdXJjZSBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IFtpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0XVxyXG4gICAgICAgICAgICAuZmlsdGVyKChhKSA9PiBhICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIC5tYXAoKGEpID0+ICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdGhpcy5zbmFwVG9QaXhlbCA/IH5+YSA6IGEpKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmRyYXdJbWFnZS5hcHBseSh0aGlzLl9fY3R4LCBhcmdzKTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQrKztcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgPSAxO1xyXG4gICAgfVxyXG4gICAgZHJhd0xpbmUoc3RhcnQsIGVuZCwgY29sb3IsIHRoaWNrbmVzcyA9IDEpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHgubW92ZVRvKHRoaXMuc25hcFRvUGl4ZWwgPyB+fihzdGFydC54ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBzdGFydC54LCB0aGlzLnNuYXBUb1BpeGVsID8gfn4oc3RhcnQueSArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogc3RhcnQueSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5saW5lVG8odGhpcy5zbmFwVG9QaXhlbCA/IH5+KGVuZC54ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBlbmQueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+KGVuZC55ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBlbmQueSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zdHJva2UoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhd1JlY3RhbmdsZShwb3MsIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFJlY3QodGhpcy5zbmFwVG9QaXhlbCA/IH5+KHBvcy54ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBwb3MueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+KHBvcy55ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiBwb3MueSwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+KHdpZHRoICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiB3aWR0aCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+KGhlaWdodCArIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzX3BpeGVsU25hcEVwc2lsb24pIDogaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yLCBzdHJva2UsIHRoaWNrbmVzcykge1xyXG4gICAgICAgIHRoaXMuX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9fY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlja25lc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2N0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmFyYyh0aGlzLnNuYXBUb1BpeGVsID8gfn4ocG9zLnggKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IHBvcy54LCB0aGlzLnNuYXBUb1BpeGVsID8gfn4ocG9zLnkgKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IHBvcy55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmZpbGwoKTtcclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNhbnZhcyB0byB0aGUgc3RhY2sgKHRyYW5zZm9ybXMgYW5kIG9wYWNpdHkpXHJcbiAgICAgKi9cclxuICAgIHNhdmUoKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBjYW52YXMgZnJvbSB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgYnkgYW4geCBhbmQgeVxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC50cmFuc2xhdGUodGhpcy5zbmFwVG9QaXhlbCA/IH5+KHggKyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc19waXhlbFNuYXBFcHNpbG9uKSA6IHgsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fih5ICsgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNfcGl4ZWxTbmFwRXBzaWxvbikgOiB5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHRoZSBjb250ZXh0IGFib3V0IHRoZSBjdXJyZW50IG9yaWdpblxyXG4gICAgICovXHJcbiAgICByb3RhdGUoYW5nbGUpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJvdGF0ZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlIHRoZSBjb250ZXh0IGJ5IGFuIHggYW5kIHkgZmFjdG9yXHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX19jdHguc2NhbGUoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBnZXRUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcclxuICAgIH1cclxuICAgIG11bHRpcGx5KF9tKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zZXRUcmFuc2Zvcm0odGhpcy5fX2N0eC5nZXRUcmFuc2Zvcm0oKS5tdWx0aXBseShfbS50b0RPTU1hdHJpeCgpKSk7XHJcbiAgICB9XHJcbiAgICBhZGRQb3N0UHJvY2Vzc29yKF9wb3N0cHJvY2Vzc29yKSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUG9zdFByb2Nlc3NvcihfcG9zdHByb2Nlc3Nvcikge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxuICAgIGNsZWFyUG9zdFByb2Nlc3NvcnMoKSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG4gICAgYmVnaW5EcmF3TGlmZWN5Y2xlKCkge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxuICAgIGVuZERyYXdMaWZlY3ljbGUoKSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgLy8gQ2xlYXIgZnJhbWVcclxuICAgICAgICB0aGlzLl9fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmx1c2hlcyB0aGUgYmF0Y2hlZCBkcmF3IGNhbGxzIHRvIHRoZSBzY3JlZW5cclxuICAgICAqL1xyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vU2NyZWVuLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBkaXNwbGF5IG1vZGVzIGF2YWlsYWJsZSB0byBFeGNhbGlidXIuXHJcbiAqL1xyXG52YXIgRGlzcGxheU1vZGU7XHJcbihmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCwgdXNlIGEgc3BlY2lmaWVkIHJlc29sdXRpb24gZm9yIHRoZSBnYW1lLiBMaWtlIDgwMHg2MDAgcGl4ZWxzIGZvciBleGFtcGxlLlxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpeGVkXCJdID0gXCJGaXhlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXQgdGhlIGFzcGVjdCByYXRpbyBnaXZlbiBieSB0aGUgZ2FtZSByZXNvbHV0aW9uIHdpdGhpbiB0aGUgY29udGFpbmVyIGF0IGFsbCB0aW1lcyB3aWxsIGZpbGwgYW55IGdhcHMgd2l0aCBjYW52YXMuXHJcbiAgICAgKiBUaGUgZGlzcGxheWVkIGFyZWEgb3V0c2lkZSB0aGUgYXNwZWN0IHJhdGlvIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIG9uIHRoZSBzY3JlZW4sIG9ubHkgdGhlIFtbU2NyZWVuLmNvbnRlbnRBcmVhXV1cclxuICAgICAqIGlzIGd1YXJhbnRlZWQgdG8gYmUgb24gc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpdENvbnRhaW5lckFuZEZpbGxcIl0gPSBcIkZpdENvbnRhaW5lckFuZEZpbGxcIjtcclxuICAgIC8qKlxyXG4gICAgICogRml0IHRoZSBhc3BlY3QgcmF0aW8gZ2l2ZW4gYnkgdGhlIGdhbWUgcmVzb2x1dGlvbiB0aGUgc2NyZWVuIGF0IGFsbCB0aW1lcyB3aWxsIGZpbGwgdGhlIHNjcmVlbi5cclxuICAgICAqIFRoaXMgZGlzcGxheWVkIGFyZWEgb3V0c2lkZSB0aGUgYXNwZWN0IHJhdGlvIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIG9uIHRoZSBzY3JlZW4sIG9ubHkgdGhlIFtbU2NyZWVuLmNvbnRlbnRBcmVhXV1cclxuICAgICAqIGlzIGd1YXJhbnRlZWQgdG8gYmUgb24gc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpdFNjcmVlbkFuZEZpbGxcIl0gPSBcIkZpdFNjcmVlbkFuZEZpbGxcIjtcclxuICAgIC8qKlxyXG4gICAgICogRml0IHRoZSB2aWV3cG9ydCB0byB0aGUgcGFyZW50IGVsZW1lbnQgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvIGdpdmVuIGJ5IHRoZSBnYW1lIHJlc29sdXRpb24sIGJ1dCB6b29tcyBpbiB0byBhdm9pZCB0aGUgYmxhY2sgYmFyc1xyXG4gICAgICogKGxldHRlcmJveCkgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgcHJlc2VudCBpbiBbW0ZpdENvbnRhaW5lcl1dLlxyXG4gICAgICpcclxuICAgICAqICoqd2FybmluZyoqIFRoaXMgd2lsbCBjbGlwIHNvbWUgZHJhd2FibGUgYXJlYSBmcm9tIHRoZSB1c2VyIGJlY2F1c2Ugb2YgdGhlIHpvb20sXHJcbiAgICAgKiB1c2UgW1tTY3JlZW4uY29udGVudEFyZWFdXSB0byBrbm93IHRoZSBzYWZlIHRvIGRyYXcgYXJlYS5cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaXRDb250YWluZXJBbmRab29tXCJdID0gXCJGaXRDb250YWluZXJBbmRab29tXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGRldmljZSBzY3JlZW4gbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvIGdpdmVuIGJ5IHRoZSBnYW1lIHJlc29sdXRpb24sIGJ1dCB6b29tcyBpbiB0byBhdm9pZCB0aGUgYmxhY2sgYmFyc1xyXG4gICAgICogKGxldHRlcmJveCkgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgcHJlc2VudCBpbiBbW0ZpdFNjcmVlbl1dLlxyXG4gICAgICpcclxuICAgICAqICoqd2FybmluZyoqIFRoaXMgd2lsbCBjbGlwIHNvbWUgZHJhd2FibGUgYXJlYSBmcm9tIHRoZSB1c2VyIGJlY2F1c2Ugb2YgdGhlIHpvb20sXHJcbiAgICAgKiB1c2UgW1tTY3JlZW4uY29udGVudEFyZWFdXSB0byBrbm93IHRoZSBzYWZlIHRvIGRyYXcgYXJlYS5cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaXRTY3JlZW5BbmRab29tXCJdID0gXCJGaXRTY3JlZW5BbmRab29tXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZpdCB0byBzY3JlZW4gdXNpbmcgYXMgbXVjaCBzcGFjZSBhcyBwb3NzaWJsZSB3aGlsZSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW8gYW5kIHJlc29sdXRpb24uXHJcbiAgICAgKiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBbW1NjcmVlbi5nb0Z1bGxTY3JlZW5dXSBidXQgYmVoYXZlcyBpbiBhIHNpbWlsYXIgd2F5IG1haW50YWluaW5nIGFzcGVjdCByYXRpby5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgbWF5IHdhbnQgdG8gY2VudGVyIHlvdXIgZ2FtZSBoZXJlIGlzIGFuIGV4YW1wbGVcclxuICAgICAqIGBgYGh0bWxcclxuICAgICAqIDwhLS0gaHRtbCAtLT5cclxuICAgICAqIDxib2R5PlxyXG4gICAgICogPG1haW4+XHJcbiAgICAgKiAgIDxjYW52YXMgaWQ9XCJnYW1lXCI+PC9jYW52YXM+XHJcbiAgICAgKiA8L21haW4+XHJcbiAgICAgKiA8L2JvZHk+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBgYGBjc3NcclxuICAgICAqIC8vIGNzc1xyXG4gICAgICogbWFpbiB7XHJcbiAgICAgKiAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgKiAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgKiAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgICogICBoZWlnaHQ6IDEwMCU7XHJcbiAgICAgKiAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIERpc3BsYXlNb2RlW1wiRml0U2NyZWVuXCJdID0gXCJGaXRTY3JlZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogRmlsbCB0aGUgZW50aXJlIHNjcmVlbidzIGNzcyB3aWR0aC9oZWlnaHQgZm9yIHRoZSBnYW1lIHJlc29sdXRpb24gZHluYW1pY2FsbHkuIFRoaXMgbWVhbnMgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdhbWUgd2lsbFxyXG4gICAgICogY2hhbmdlIGR5bmFtaWNhbGx5IGFzIHRoZSB3aW5kb3cgaXMgcmVzaXplZC4gVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgW1tTY3JlZW4uZ29GdWxsU2NyZWVuXV1cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaWxsU2NyZWVuXCJdID0gXCJGaWxsU2NyZWVuXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZpdCB0byBwYXJlbnQgZWxlbWVudCB3aWR0aC9oZWlnaHQgdXNpbmcgYXMgbXVjaCBzcGFjZSBhcyBwb3NzaWJsZSB3aGlsZSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW8gYW5kIHJlc29sdXRpb24uXHJcbiAgICAgKi9cclxuICAgIERpc3BsYXlNb2RlW1wiRml0Q29udGFpbmVyXCJdID0gXCJGaXRDb250YWluZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoZSBwYXJlbnQgRE9NIGNvbnRhaW5lcidzIGNzcyB3aWR0aC9oZWlnaHQgZm9yIHRoZSBnYW1lIHJlc29sdXRpb24gZHluYW1pY2FsbHlcclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaWxsQ29udGFpbmVyXCJdID0gXCJGaWxsQ29udGFpbmVyXCI7XHJcbn0pKERpc3BsYXlNb2RlIHx8IChEaXNwbGF5TW9kZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDb252ZW5pZW5jZSBjbGFzcyBmb3IgcXVpY2sgcmVzb2x1dGlvbnNcclxuICogTW9zdGx5IHNvdXJjZWQgZnJvbSBodHRwczovL2VtdWxhdGlvbi5nYW1ldGVjaHdpa2kuY29tL2luZGV4LnBocC9SZXNvbHV0aW9uXHJcbiAqL1xyXG5jbGFzcyBSZXNvbHV0aW9uIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IFNWR0EoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IFN0YW5kYXJkKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IEF0YXJpMjYwMCgpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMTYwLCBoZWlnaHQ6IDE5MiB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgR2FtZUJveSgpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMTYwLCBoZWlnaHQ6IDE0NCB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgR2FtZUJveUFkdmFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDI0MCwgaGVpZ2h0OiAxNjAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IE5pbnRlbmRvRFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDI1NiwgaGVpZ2h0OiAxOTIgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IE5FUygpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDIyNCB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgU05FUygpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDI0NCB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgU2NyZWVuIGhhbmRsZXMgYWxsIGFzcGVjdHMgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2NyZWVuIGZvciBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBTY3JlZW4ge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMuX2FudGlhbGlhc2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvblN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsUmF0aW9PdmVycmlkZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faXNGdWxsU2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuX2Z1bGxzY3JlZW5DaGFuZ2VIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0Z1bGxTY3JlZW4gPSAhdGhpcy5faXNGdWxsU2NyZWVuO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0Z1bGxzY3JlZW4gQ2hhbmdlJywgdGhpcy5faXNGdWxsU2NyZWVuKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BpeGVsUmF0aW9DaGFuZ2VIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1BpeGVsIFJhdGlvIENoYW5nZScsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRm9yUGl4ZWxSYXRpbygpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5fY2FsY3VsYXRlRGV2aWNlUGl4ZWxSYXRpbygpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdWaWV3IHBvcnQgcmVzaXplZCcpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRSZXNvbHV0aW9uQW5kVmlld3BvcnRCeURpc3BsYXlNb2RlKHBhcmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEFza2luZyB0aGUgd2luZG93LmRldmljZVBpeGVsUmF0aW8gaXMgZXhwZW5zaXZlIHdlIGRvIGl0IG9uY2VcclxuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5fY2FsY3VsYXRlRGV2aWNlUGl4ZWxSYXRpbygpO1xyXG4gICAgICAgIHRoaXMuX2FscmVhZHlXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jb250ZW50QXJlYSA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBvcHRpb25zLnZpZXdwb3J0O1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IChfYSA9IG9wdGlvbnMucmVzb2x1dGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeyAuLi50aGlzLnZpZXdwb3J0IH07XHJcbiAgICAgICAgdGhpcy5fY29udGVudFJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5fZGlzcGxheU1vZGUgPSAoX2IgPSBvcHRpb25zLmRpc3BsYXlNb2RlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBvcHRpb25zLmNhbnZhcztcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcclxuICAgICAgICB0aGlzLl9hbnRpYWxpYXNpbmcgPSAoX2MgPSBvcHRpb25zLmFudGlhbGlhc2luZykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5fYW50aWFsaWFzaW5nO1xyXG4gICAgICAgIHRoaXMuX2Jyb3dzZXIgPSBvcHRpb25zLmJyb3dzZXI7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpb092ZXJyaWRlID0gb3B0aW9ucy5waXhlbFJhdGlvO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5RGlzcGxheU1vZGUoKTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5Gb3JQaXhlbFJhdGlvKCk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl9mdWxsc2NyZWVuQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5hcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgfVxyXG4gICAgX2xpc3RlbkZvclBpeGVsUmF0aW8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lZGlhUXVlcnlMaXN0ICYmICF0aGlzLl9tZWRpYVF1ZXJ5TGlzdC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PTEzLjEgd29ya2Fyb3VuZCwgcmVtb3ZlIGFueSBleGlzdGluZyBoYW5kbGVyc1xyXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9waXhlbFJhdGlvQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0ID0gdGhpcy5fYnJvd3Nlci53aW5kb3cubmF0aXZlQ29tcG9uZW50Lm1hdGNoTWVkaWEoYChyZXNvbHV0aW9uOiAke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfWRwcHgpYCk7XHJcbiAgICAgICAgLy8gU2FmYXJpIDw9MTMuMSB3b3JrYXJvdW5kXHJcbiAgICAgICAgaWYgKHRoaXMuX21lZGlhUXVlcnlMaXN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0LmFkZExpc3RlbmVyKHRoaXMuX3BpeGVsUmF0aW9DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBoYW5kbGVyc1xyXG4gICAgICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYnJvd3Nlci53aW5kb3cub2ZmKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplSGFuZGxlcik7XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PTEzLjEgd29ya2Fyb3VuZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWVkaWFRdWVyeUxpc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIodGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5fZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jYWxjdWxhdGVEZXZpY2VQaXhlbFJhdGlvKCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBpeGVsUmF0aW8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BpeGVsUmF0aW9PdmVycmlkZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpb092ZXJyaWRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBpc0hpRHBpKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW8gIT09IDE7XHJcbiAgICB9XHJcbiAgICBnZXQgZGlzcGxheU1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlNb2RlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNhbnZhcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZGlzcGxheU1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBEaXNwbGF5TW9kZS5GaWxsQ29udGFpbmVyOlxyXG4gICAgICAgICAgICBjYXNlIERpc3BsYXlNb2RlLkZpdENvbnRhaW5lcjpcclxuICAgICAgICAgICAgY2FzZSBEaXNwbGF5TW9kZS5GaXRDb250YWluZXJBbmRGaWxsOlxyXG4gICAgICAgICAgICBjYXNlIERpc3BsYXlNb2RlLkZpdENvbnRhaW5lckFuZFpvb206XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgcmVzb2x1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIHNldCByZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcclxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIGdldCB2aWV3cG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmlld3BvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIHNldCB2aWV3cG9ydCh2aWV3cG9ydCkge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb24ud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBzY2FsZWRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbi53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBzY2FsZWRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb24uaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudENhbWVyYShjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB9XHJcbiAgICBwdXNoUmVzb2x1dGlvbkFuZFZpZXdwb3J0KCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25TdGFjay5wdXNoKHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTdGFjay5wdXNoKHRoaXMudmlld3BvcnQpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHsgLi4udGhpcy5yZXNvbHV0aW9uIH07XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHsgLi4udGhpcy52aWV3cG9ydCB9O1xyXG4gICAgfVxyXG4gICAgcGVla1ZpZXdwb3J0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFN0YWNrW3RoaXMuX3ZpZXdwb3J0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBwZWVrUmVzb2x1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvblN0YWNrW3RoaXMuX3Jlc29sdXRpb25TdGFjay5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHBvcFJlc29sdXRpb25BbmRWaWV3cG9ydCgpIHtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl9yZXNvbHV0aW9uU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0U3RhY2sucG9wKCk7XHJcbiAgICB9XHJcbiAgICBhcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLnNjYWxlZFdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLnNjYWxlZEhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc0NvbnRleHQgaW5zdGFuY2VvZiBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmdyYXBoaWNzQ29udGV4dC5jaGVja0lmUmVzb2x1dGlvblN1cHBvcnRlZCh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zY2FsZWRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zY2FsZWRIZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGVkICYmICF0aGlzLl9hbHJlYWR5V2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbHJlYWR5V2FybmVkID0gdHJ1ZTsgLy8gd2FybiBvbmNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgVGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHJlc29sdXRpb24gKCR7dGhpcy5yZXNvbHV0aW9uLndpZHRofXgke3RoaXMucmVzb2x1dGlvbi5oZWlnaHR9KSBhbmQgcGl4ZWwgcmF0aW8gKCR7dGhpcy5waXhlbFJhdGlvfSlgICtcclxuICAgICAgICAgICAgICAgICAgICAnIGFyZSB0b28gbGFyZ2UgZm9yIHRoZSBwbGF0Zm9ybSBXZWJHTCBpbXBsZW1lbnRhdGlvbiwgdGhpcyBtYXkgd29yayBidXQgY2F1c2UgV2ViR0wgcmVuZGVyaW5nIHRvIGJlaGF2ZSBvZGRseS4nICtcclxuICAgICAgICAgICAgICAgICAgICAnIFRyeSByZWR1Y2luZyB0aGUgcmVzb2x1dGlvbiBvciBkaXNhYmxpbmcgSGkgRFBJIHNjYWxpbmcgdG8gYXZvaWQgdGhpcycgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgKHJlYWQgbW9yZSBoZXJlIGh0dHBzOi8vZXhjYWxpYnVyanMuY29tL2RvY3Mvc2NyZWVucyN1bmRlcnN0YW5kaW5nLXZpZXdwb3J0LS1yZXNvbHV0aW9uKS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYW50aWFsaWFzaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdhdXRvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdwaXhlbGF0ZWQnO1xyXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gJ2NyaXNwLWVkZ2VzJyBpZiAncGl4ZWxhdGVkJyBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSBmb3IgZmlyZWZveCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvaW1hZ2UtcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAnY3Jpc3AtZWRnZXMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMudmlld3BvcnQud2lkdGggKyAncHgnO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXdwb3J0LmhlaWdodCArICdweCc7XHJcbiAgICAgICAgLy8gQWZ0ZXIgbWVzc2luZyB3aXRoIHRoZSBjYW52YXMgd2lkdGgvaGVpZ2h0IHRoZSBncmFwaGljcyBjb250ZXh0IGlzIGludmFsaWRhdGVkIGFuZCBuZWVkcyB0byBoYXZlIHNvbWUgcHJvcGVydGllcyByZXNldFxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZVZpZXdwb3J0KHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC5zbW9vdGhpbmcgPSB0aGlzLl9hbnRpYWxpYXNpbmc7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NDb250ZXh0IGluc3RhbmNlb2YgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQuc2NhbGUodGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpeGVsUmF0aW8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBhbnRpYWxpYXNpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FudGlhbGlhc2luZztcclxuICAgIH1cclxuICAgIHNldCBhbnRpYWxpYXNpbmcoaXNTbW9vdGgpIHtcclxuICAgICAgICB0aGlzLl9hbnRpYWxpYXNpbmcgPSBpc1Ntb290aDtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC5zbW9vdGhpbmcgPSB0aGlzLl9hbnRpYWxpYXNpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBleGNhbGlidXIgaXMgZnVsbHNjcmVlbiB1c2luZyB0aGUgYnJvd3NlciBmdWxsc2NyZWVuIGFwaVxyXG4gICAgICovXHJcbiAgICBnZXQgaXNGdWxsU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Z1bGxTY3JlZW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIHRvIGdvIGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGJyb3dzZXIgZnVsbHNjcmVlbiBhcGksIHJlcXVpcmVzIHVzZXIgaW50ZXJhY3Rpb24gdG8gYmUgc3VjY2Vzc2Z1bC5cclxuICAgICAqIEZvciBleGFtcGxlLCB3aXJlIHRoaXMgdG8gYSB1c2VyIGNsaWNrIGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogT3B0aW9uYWxseSBzcGVjaWZ5IGEgdGFyZ2V0IGVsZW1lbnQgaWQgdG8gZ28gZnVsbHNjcmVlbiwgYnkgZGVmYXVsdCB0aGUgZ2FtZSBjYW52YXMgaXMgdXNlZFxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRJZFxyXG4gICAgICovXHJcbiAgICBnb0Z1bGxTY3JlZW4oZWxlbWVudElkKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXliZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0cyB0byBleGl0IGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGJyb3dzZXIgZnVsbHNjcmVlbiBhcGlcclxuICAgICAqL1xyXG4gICAgZXhpdEZ1bGxTY3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgY29vcmRpbmF0ZSBpbiBub3JtYWwgaHRtbCBwYWdlIHNwYWNlLCBmb3IgZXhhbXBsZSBmcm9tIGEgcG9pbnRlciBtb3ZlIGV2ZW50LCBhbmQgdHJhbnNsYXRlcyBpdCB0b1xyXG4gICAgICogRXhjYWxpYnVyIHNjcmVlbiBzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBFeGNhbGlidXIgc2NyZWVuIHNwYWNlIHN0YXJ0cyBhdCB0aGUgdG9wIGxlZnQgKDAsIDApIGNvcm5lciBvZiB0aGUgdmlld3BvcnQsIGFuZCBleHRlbmRzIHRvIHRoZVxyXG4gICAgICogYm90dG9tIHJpZ2h0IGNvcm5lciAocmVzb2x1dGlvblgsIHJlc29sdXRpb25ZKVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIHBhZ2VUb1NjcmVlbkNvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgbGV0IG5ld1ggPSBwb2ludC54O1xyXG4gICAgICAgIGxldCBuZXdZID0gcG9pbnQueTtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzRnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBuZXdYIC09IGdldFBvc2l0aW9uKHRoaXMuX2NhbnZhcykueDtcclxuICAgICAgICAgICAgbmV3WSAtPSBnZXRQb3NpdGlvbih0aGlzLl9jYW52YXMpLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIGZ1bGxzY3JlZW4gYXBpIG9uIGl0IGNlbnRlcnMgd2l0aCBibGFjayBiYXJzXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHNjcmVlbiB0byB3b3JsZCBjb29yZGluYXRlcyBpbiB0aGlzIGNhc2VcclxuICAgICAgICBpZiAodGhpcy5faXNGdWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW8gPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbk1hcmdpblkgPSAod2luZG93LmlubmVySGVpZ2h0IC0gc2NyZWVuSGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gKChuZXdZIC0gc2NyZWVuTWFyZ2luWSkgLyBzY3JlZW5IZWlnaHQpICogdGhpcy52aWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBuZXdYID0gKG5ld1ggLyB3aW5kb3cuaW5uZXJXaWR0aCkgKiB0aGlzLnZpZXdwb3J0LndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuV2lkdGggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuTWFyZ2luWCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHNjcmVlbldpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBuZXdYID0gKChuZXdYIC0gc2NyZWVuTWFyZ2luWCkgLyBzY3JlZW5XaWR0aCkgKiB0aGlzLnZpZXdwb3J0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9IChuZXdZIC8gd2luZG93LmlubmVySGVpZ2h0KSAqIHRoaXMudmlld3BvcnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMudmlld3BvcnQud2lkdGgpICogdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgICAgIG5ld1kgPSAobmV3WSAvIHRoaXMudmlld3BvcnQuaGVpZ2h0KSAqIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IobmV3WCwgbmV3WSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgY29vcmRpbmF0ZSBpbiBFeGNhbGlidXIgc2NyZWVuIHNwYWNlLCBhbmQgdHJhbnNsYXRlcyBpdCB0byBub3JtYWwgaHRtbCBwYWdlIHNwYWNlLiBGb3IgZXhhbXBsZSxcclxuICAgICAqIHRoaXMgaXMgd2hlcmUgaHRtbCBlbGVtZW50cyBtaWdodCBsaXZlIGlmIHlvdSB3YW50IHRvIHBvc2l0aW9uIHRoZW0gcmVsYXRpdmUgdG8gRXhjYWxpYnVyLlxyXG4gICAgICpcclxuICAgICAqIEV4Y2FsaWJ1ciBzY3JlZW4gc3BhY2Ugc3RhcnRzIGF0IHRoZSB0b3AgbGVmdCAoMCwgMCkgY29ybmVyIG9mIHRoZSB2aWV3cG9ydCwgYW5kIGV4dGVuZHMgdG8gdGhlXHJcbiAgICAgKiBib3R0b20gcmlnaHQgY29ybmVyIChyZXNvbHV0aW9uWCwgcmVzb2x1dGlvblkpXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgc2NyZWVuVG9QYWdlQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICBsZXQgbmV3WCA9IHBvaW50Lng7XHJcbiAgICAgICAgbGV0IG5ld1kgPSBwb2ludC55O1xyXG4gICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMucmVzb2x1dGlvbi53aWR0aCkgKiB0aGlzLnZpZXdwb3J0LndpZHRoO1xyXG4gICAgICAgIG5ld1kgPSAobmV3WSAvIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQpICogdGhpcy52aWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5NYXJnaW5ZID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIHNjcmVlbkhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy52aWV3cG9ydC5oZWlnaHQpICogc2NyZWVuSGVpZ2h0ICsgc2NyZWVuTWFyZ2luWTtcclxuICAgICAgICAgICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMudmlld3BvcnQud2lkdGgpICogd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5NYXJnaW5YID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gc2NyZWVuV2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMudmlld3BvcnQud2lkdGgpICogc2NyZWVuV2lkdGggKyBzY3JlZW5NYXJnaW5YO1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy52aWV3cG9ydC5oZWlnaHQpICogd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faXNGdWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIG5ld1ggKz0gZ2V0UG9zaXRpb24odGhpcy5fY2FudmFzKS54O1xyXG4gICAgICAgICAgICBuZXdZICs9IGdldFBvc2l0aW9uKHRoaXMuX2NhbnZhcykueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IobmV3WCwgbmV3WSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgY29vcmRpbmF0ZSBpbiBFeGNhbGlidXIgc2NyZWVuIHNwYWNlLCBhbmQgdHJhbnNsYXRlcyBpdCB0byBFeGNhbGlidXIgd29ybGQgc3BhY2UuXHJcbiAgICAgKlxyXG4gICAgICogV29ybGQgc3BhY2UgaXMgd2hlcmUgW1tFbnRpdHl8ZW50aXRpZXNdXSBpbiBFeGNhbGlidXIgbGl2ZSBieSBkZWZhdWx0IFtbQ29vcmRQbGFuZS5Xb3JsZF1dXHJcbiAgICAgKiBhbmQgZXh0ZW5kcyBpbmZpbml0ZWx5IG91dCByZWxhdGl2ZSBmcm9tIHRoZSBbW0NhbWVyYV1dLlxyXG4gICAgICogQHBhcmFtIHBvaW50ICBTY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgKi9cclxuICAgIHNjcmVlblRvV29ybGRDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIC8vIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBzY3JlZW4gJiB3b3JsZCBpcyB0aGUgY2FtZXJhIHRyYW5zZm9ybVxyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYS5pbnZlcnNlLm11bHRpcGx5KHBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LnN1Yih2ZWModGhpcy5yZXNvbHV0aW9uLndpZHRoIC8gMiwgdGhpcy5yZXNvbHV0aW9uLmhlaWdodCAvIDIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjb29yZGluYXRlIGluIEV4Y2FsaWJ1ciB3b3JsZCBzcGFjZSwgYW5kIHRyYW5zbGF0ZXMgaXQgdG8gRXhjYWxpYnVyIHNjcmVlbiBzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBTY3JlZW4gc3BhY2UgaXMgd2hlcmUgW1tTY3JlZW5FbGVtZW50fHNjcmVlbiBlbGVtZW50c11dIGFuZCBbW0VudGl0eXxlbnRpdGllc11dIHdpdGggW1tDb29yZFBsYW5lLlNjcmVlbl1dIGxpdmUuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgIFdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICovXHJcbiAgICB3b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW1lcmEudHJhbnNmb3JtLm11bHRpcGx5KHBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LmFkZCh2ZWModGhpcy5yZXNvbHV0aW9uLndpZHRoIC8gMiwgdGhpcy5yZXNvbHV0aW9uLmhlaWdodCAvIDIpKTtcclxuICAgIH1cclxuICAgIHBhZ2VUb1dvcmxkQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBzY3JlZW4gPSB0aGlzLnBhZ2VUb1NjcmVlbkNvb3JkaW5hdGVzKHBvaW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoc2NyZWVuKTtcclxuICAgIH1cclxuICAgIHdvcmxkVG9QYWdlQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBzY3JlZW4gPSB0aGlzLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9QYWdlQ29vcmRpbmF0ZXMoc2NyZWVuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEJvdW5kaW5nQm94IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNjcmVlblxyXG4gICAgICogYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKlxyXG4gICAgICogV29ybGQgYm91bmRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcywgdXNlZnVsIGZvciBjdWxsaW5nIG9iamVjdHMgb2Zmc2NyZWVuXHJcbiAgICAgKi9cclxuICAgIGdldFdvcmxkQm91bmRzKCkge1xyXG4gICAgICAgIGNvbnN0IHRvcExlZnQgPSB0aGlzLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhWZWN0b3IuWmVybyk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0b3BMZWZ0LnggKyB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICBjb25zdCBib3R0b20gPSB0b3BMZWZ0LnkgKyB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0b3BMZWZ0LngsIHRvcExlZnQueSwgcmlnaHQsIGJvdHRvbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgKiByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgd2lkdGggY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscywgKHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQgb2ZcclxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZDYW52YXNIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdXaWR0aCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24ud2lkdGggLyB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmRHJhd1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdXaWR0aCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBkcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQgLyB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdIZWlnaHQgLyAyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHNjcmVlbiBjZW50ZXIgY29vcmRpbmF0ZXMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdmVjKHRoaXMuaGFsZkRyYXdXaWR0aCwgdGhpcy5oYWxmRHJhd0hlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgYXJlYSBpbiBzY3JlZW4gc3BhY2Ugd2hlcmUgaXQgaXMgc2FmZSB0byBwbGFjZSBjb250ZW50XHJcbiAgICAgKi9cclxuICAgIGdldCBjb250ZW50QXJlYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudEFyZWE7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUZpdCgpIHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGxldCBhZGp1c3RlZFdpZHRoID0gMDtcclxuICAgICAgICBsZXQgYWRqdXN0ZWRIZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAvIGFzcGVjdCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gd2luZG93LmlubmVySGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICBhZGp1c3RlZEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IGFkanVzdGVkV2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYWRqdXN0ZWRIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRBcmVhID0gQm91bmRpbmdCb3guZnJvbURpbWVuc2lvbih0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQsIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlRml0U2NyZWVuQW5kRmlsbCgpIHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICBjb25zdCB2dyA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIGNvbnN0IHZoID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVGaXRBbmRGaWxsKHZ3LCB2aCk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUZpdENvbnRhaW5lckFuZEZpbGwoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5jYW52YXMucGFyZW50RWxlbWVudDtcclxuICAgICAgICBjb25zdCB2dyA9IHBhcmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICBjb25zdCB2aCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZUZpdEFuZEZpbGwodncsIHZoKTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlRml0QW5kRmlsbCh2dywgdmgpIHtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogdncsXHJcbiAgICAgICAgICAgIGhlaWdodDogdmhcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNjcmVlbiBhc3BlY3RSYXRpbyBpcyBsZXNzIHRoYW4gdGhlIG9yaWdpbmFsIGFzcGVjdFJhdGlvXHJcbiAgICAgICAgaWYgKHZ3IC8gdmggPD0gdGhpcy5fY29udGVudFJlc29sdXRpb24ud2lkdGggLyB0aGlzLl9jb250ZW50UmVzb2x1dGlvbi5oZWlnaHQpIHtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBuZXcgcmVzb2x1dGlvbiB0byBtYXRjaCB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB2dyAqIHRoaXMuX2NvbnRlbnRSZXNvbHV0aW9uLndpZHRoIC8gdncsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHZ3ICogdGhpcy5fY29udGVudFJlc29sdXRpb24ud2lkdGggLyB2dyAqIHZoIC8gdndcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgY2xpcCA9ICh0aGlzLnJlc29sdXRpb24uaGVpZ2h0IC0gdGhpcy5fY29udGVudFJlc29sdXRpb24uaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRBcmVhID0gbmV3IEJvdW5kaW5nQm94KHtcclxuICAgICAgICAgICAgICAgIHRvcDogY2xpcCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5fY29udGVudFJlc29sdXRpb24ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMucmVzb2x1dGlvbi5oZWlnaHQgLSBjbGlwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHZoICogdGhpcy5fY29udGVudFJlc29sdXRpb24uaGVpZ2h0IC8gdmggKiB2dyAvIHZoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB2aCAqIHRoaXMuX2NvbnRlbnRSZXNvbHV0aW9uLmhlaWdodCAvIHZoXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSAodGhpcy5yZXNvbHV0aW9uLndpZHRoIC0gdGhpcy5fY29udGVudFJlc29sdXRpb24ud2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5fY29udGVudEFyZWEgPSBuZXcgQm91bmRpbmdCb3goe1xyXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogY2xpcCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnJlc29sdXRpb24ud2lkdGggLSBjbGlwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLl9jb250ZW50UmVzb2x1dGlvbi5oZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVGaXRTY3JlZW5BbmRab29tKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBjb25zdCB2dyA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIGNvbnN0IHZoID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVGaXRBbmRab29tKHZ3LCB2aCk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUZpdENvbnRhaW5lckFuZFpvb20oKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgcGFyZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICBwYXJlbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICBjb25zdCB2dyA9IHBhcmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICBjb25zdCB2aCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZUZpdEFuZFpvb20odncsIHZoKTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlRml0QW5kWm9vbSh2dywgdmgpIHtcclxuICAgICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGxldCBhZGp1c3RlZFdpZHRoID0gMDtcclxuICAgICAgICBsZXQgYWRqdXN0ZWRIZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmICh2dyAvIGFzcGVjdCA8IHZoKSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSB2dztcclxuICAgICAgICAgICAgYWRqdXN0ZWRIZWlnaHQgPSB2dyAvIGFzcGVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSB2aCAqIGFzcGVjdDtcclxuICAgICAgICAgICAgYWRqdXN0ZWRIZWlnaHQgPSB2aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gdncgLyBhZGp1c3RlZFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IHZoIC8gYWRqdXN0ZWRIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgbWF4U2NhbGVGYWN0b3IgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgICAgY29uc3Qgem9vbWVkV2lkdGggPSBhZGp1c3RlZFdpZHRoICogbWF4U2NhbGVGYWN0b3I7XHJcbiAgICAgICAgY29uc3Qgem9vbWVkSGVpZ2h0ID0gYWRqdXN0ZWRIZWlnaHQgKiBtYXhTY2FsZUZhY3RvcjtcclxuICAgICAgICAvLyBDZW50ZXIgem9vbWVkIGRpbWVuc2lvbiBpZiBiaWdnZXIgdGhhbiB0aGUgc2NyZWVuXHJcbiAgICAgICAgaWYgKHpvb21lZFdpZHRoID4gdncpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IC0oem9vbWVkV2lkdGggLSB2dykgLyAyICsgJ3B4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHpvb21lZEhlaWdodCA+IHZoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IC0oem9vbWVkSGVpZ2h0IC0gdmgpIC8gMiArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHpvb21lZFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHpvb21lZEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gQm91bmRpbmdCb3guZnJvbURpbWVuc2lvbih0aGlzLnZpZXdwb3J0LndpZHRoLCB0aGlzLnZpZXdwb3J0LmhlaWdodCwgVmVjdG9yLlplcm8pO1xyXG4gICAgICAgIC8vIHJldHVybiBzYWZlIGFyZWFcclxuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC53aWR0aCA+IHZ3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSAodGhpcy52aWV3cG9ydC53aWR0aCAtIHZ3KSAvIHRoaXMudmlld3BvcnQud2lkdGggKiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XHJcbiAgICAgICAgICAgIGJvdW5kcy50b3AgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMubGVmdCA9IGNsaXAgLyAyO1xyXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgPSB0aGlzLnJlc29sdXRpb24ud2lkdGggLSBjbGlwIC8gMjtcclxuICAgICAgICAgICAgYm91bmRzLmJvdHRvbSA9IHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmhlaWdodCA+IHZoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSAodGhpcy52aWV3cG9ydC5oZWlnaHQgLSB2aCkgLyB0aGlzLnZpZXdwb3J0LmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGJvdW5kcy50b3AgPSBjbGlwIC8gMjtcclxuICAgICAgICAgICAgYm91bmRzLmxlZnQgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMuYm90dG9tID0gdGhpcy5yZXNvbHV0aW9uLmhlaWdodCAtIGNsaXAgLyAyO1xyXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgPSB0aGlzLnJlc29sdXRpb24ud2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRBcmVhID0gYm91bmRzO1xyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVGaXRDb250YWluZXIoKSB7XHJcbiAgICAgICAgY29uc3QgYXNwZWN0ID0gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICBsZXQgYWRqdXN0ZWRXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGFkanVzdGVkSGVpZ2h0ID0gMDtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQuY2xpZW50V2lkdGggLyBhc3BlY3QgPCBwYXJlbnQuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gcGFyZW50LmNsaWVudFdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IHBhcmVudC5jbGllbnRIZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IGFkanVzdGVkV2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYWRqdXN0ZWRIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRBcmVhID0gQm91bmRpbmdCb3guZnJvbURpbWVuc2lvbih0aGlzLnJlc29sdXRpb24ud2lkdGgsIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQsIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIF9hcHBseURpc3BsYXlNb2RlKCkge1xyXG4gICAgICAgIHRoaXMuX3NldFJlc29sdXRpb25BbmRWaWV3cG9ydEJ5RGlzcGxheU1vZGUodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgIC8vIHdhdGNoIHJlc2l6aW5nXHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgV2luZG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jyb3dzZXIud2luZG93Lm9uKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcmVzb2x1dGlvbiBhbmQgdmlld3BvcnQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cclxuICAgICAqL1xyXG4gICAgX3NldFJlc29sdXRpb25BbmRWaWV3cG9ydEJ5RGlzcGxheU1vZGUocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpbGxDb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmVudC5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50LmNsaWVudEhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRmlsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJlbnQuaW5uZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50LmlubmVySGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GaXRTY3JlZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRml0Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVGaXRDb250YWluZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpdFNjcmVlbkFuZEZpbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdFNjcmVlbkFuZEZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpdENvbnRhaW5lckFuZEZpbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdENvbnRhaW5lckFuZEZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpdFNjcmVlbkFuZFpvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdFNjcmVlbkFuZFpvb20oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpdENvbnRhaW5lckFuZFpvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdENvbnRhaW5lckFuZFpvb20oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvU291bmQvQXVkaW9Db250ZXh0LnRzXG4vKipcclxuICogSW50ZXJuYWwgY2xhc3MgdXNlZCB0byBidWlsZCBpbnN0YW5jZXMgb2YgQXVkaW9Db250ZXh0XHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5jbGFzcyBBdWRpb0NvbnRleHRGYWN0b3J5IHtcclxuICAgIHN0YXRpYyBjcmVhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9JTlNUQU5DRSkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9JTlNUQU5DRSA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fSU5TVEFOQ0U7XHJcbiAgICB9XHJcbn1cclxuQXVkaW9Db250ZXh0RmFjdG9yeS5fSU5TVEFOQ0UgPSBudWxsO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvV2ViQXVkaW8udHNcblxyXG5cclxuLyoqXHJcbiAqIFBhdGNoIGZvciBkZXRlY3RpbmcgbGVnYWN5IHdlYiBhdWRpbyBpbiBicm93c2Vyc1xyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHNvdXJjZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNMZWdhY3lXZWJBdWRpb1NvdXJjZShzb3VyY2UpIHtcclxuICAgIHJldHVybiAhIXNvdXJjZS5wbGF5YmFja1N0YXRlO1xyXG59XHJcbmNsYXNzIFdlYkF1ZGlvIHtcclxuICAgIC8qKlxyXG4gICAgICogUGxheSBhbiBlbXB0eSBzb3VuZCB0byB1bmxvY2sgU2FmYXJpIFdlYkF1ZGlvIGNvbnRleHQuIENhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICogcmlnaHQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uIGV2ZW50LlxyXG4gICAgICogQHNvdXJjZSBodHRwczovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdW5sb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChXZWJBdWRpby5fVU5MT0NLRUQgfHwgIUF1ZGlvQ29udGV4dEZhY3RvcnkuY3JlYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHVubG9ja1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRXhjYWxpYnVyIHdhcyB1bmFibGUgdG8gdW5sb2NrIHRoZSBhdWRpbyBjb250ZXh0LCBhdWRpbyBwcm9iYWJseSB3aWxsIG5vdCBwbGF5IGluIHRoaXMgYnJvd3Nlci4nKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHRGYWN0b3J5LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQucmVzdW1lKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZW1wdHkgYnVmZmVyIGFuZCBwbGF5IGl0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25lbmRlZCA9ICgpID0+IChlbmRlZCA9IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xyXG4gICAgICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgdGhlIHBsYXkgc3RhdGUgYWZ0ZXIgc29tZSB0aW1lLCB3ZSBrbm93IGlmIHdlJ3JlIHJlYWxseSB1bmxvY2tlZFxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWN5V2ViQXVkaW9Tb3VyY2Uoc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnBsYXliYWNrU3RhdGUgPT09IHNvdXJjZS5QTEFZSU5HX1NUQVRFIHx8IHNvdXJjZS5wbGF5YmFja1N0YXRlID09PSBzb3VyY2UuRklOSVNIRURfU1RBVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYkF1ZGlvLl9VTkxPQ0tFRCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgPiAwIHx8IGVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fVU5MT0NLRUQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodW5sb2NrVGltZW91dFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1VubG9ja2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9VTkxPQ0tFRDtcclxuICAgIH1cclxufVxyXG5XZWJBdWRpby5fVU5MT0NLRUQgPSBmYWxzZTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9DbGFzcy50c1xuXHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgc3VjaCBhcyBbW0V2ZW50RGlzcGF0Y2hlcl1dXHJcbiAqIGFuZCBleHRlbmRpbmcgYWJpbGl0aWVzIGZvciB2YW5pbGxhIEphdmFzY3JpcHQgcHJvamVjdHNcclxuICovXHJcbmNsYXNzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYGFkZEV2ZW50TGlzdGVuZXJgLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXHJcbiAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcclxuICAgICAqL1xyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGByZW1vdmVFdmVudExpc3RlbmVyYC4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICogaXQgd2lsbCByZW1vdmUgYWxsIGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIHRoYXQgc3BlY2lmaWMgZXZlbnQuIElmIHRoZSBldmVudE5hbWVcclxuICAgICAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW1pdHMgYSBuZXcgZXZlbnRcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgICBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRPYmplY3QgRGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxyXG4gICAgICovXHJcbiAgICBlbWl0KGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgZXZlbnRPYmplY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmNlIGxpc3RlbnMgdG8gYW4gZXZlbnQgb25lIHRpbWUsIHRoZW4gdW5zdWJzY3JpYmVzIGZyb20gdGhhdCBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0byBvbmNlXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgIFRoZSBoYW5kbGVyIG9mIHRoZSBldmVudCB0aGF0IHdpbGwgYmUgYXV0byB1bnN1YnNjcmliZWRcclxuICAgICAqL1xyXG4gICAgb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0RyYXdVdGlsLnRzXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIERyYXcgYSBsaW5lIG9uIGNhbnZhcyBjb250ZXh0XHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggVGhlIGNhbnZhcyBjb250ZXh0XHJcbiAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGxpbmVcclxuICogQHBhcmFtIHgxIFRoZSBzdGFydCB4IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHkxIFRoZSBzdGFydCB5IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHgyIFRoZSBlbmRpbmcgeCBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB5MiBUaGUgZW5kaW5nIHkgY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0gdGhpY2tuZXNzIFRoZSBsaW5lIHRoaWNrbmVzc1xyXG4gKiBAcGFyYW0gY2FwIFRoZSBbW0xpbmVDYXBTdHlsZV1dIChidXR0LCByb3VuZCwgb3Igc3F1YXJlKVxyXG4gKi9cclxuZnVuY3Rpb24gbGluZShjdHgsIGNvbG9yID0gQ29sb3IuUmVkLCB4MSwgeTEsIHgyLCB5MiwgdGhpY2tuZXNzID0gMSwgY2FwID0gJ2J1dHQnKSB7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcclxuICAgIGN0eC5saW5lQ2FwID0gY2FwO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIERyYXcgdGhlIHZlY3RvciBhcyBhIHBvaW50IG9udG8gdGhlIGNhbnZhcy5cclxuICovXHJcbmZ1bmN0aW9uIHBvaW50KGN0eCwgY29sb3IgPSBDb2xvci5SZWQsIHBvaW50KSB7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuLyoqXHJcbiAqIERyYXcgdGhlIHZlY3RvciBhcyBhIGxpbmUgb250byB0aGUgY2FudmFzIHN0YXJ0aW5nIGEgb3JpZ2luIHBvaW50LlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB2ZWN0b3IoY3R4LCBjb2xvciwgb3JpZ2luLCB2ZWN0b3IsIHNjYWxlID0gMS4wKSB7XHJcbiAgICBjb25zdCBjID0gY29sb3IgPyBjb2xvci50b1N0cmluZygpIDogJ2JsdWUnO1xyXG4gICAgY29uc3QgdiA9IHZlY3Rvci5zY2FsZShzY2FsZSk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjO1xyXG4gICAgY3R4Lm1vdmVUbyhvcmlnaW4ueCwgb3JpZ2luLnkpO1xyXG4gICAgY3R4LmxpbmVUbyhvcmlnaW4ueCArIHYueCwgb3JpZ2luLnkgKyB2LnkpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBEcmF3IGEgcm91bmQgcmVjdGFuZ2xlIG9uIGEgY2FudmFzIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICogQHBhcmFtIHggVGhlIHRvcC1sZWZ0IHggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0geSBUaGUgdG9wLWxlZnQgeSBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gcmFkaXVzIFRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcclxuICogQHBhcmFtIHN0cm9rZSBUaGUgW1tDb2xvcl1dIHRvIHN0cm9rZSByZWN0YW5nbGUgd2l0aFxyXG4gKiBAcGFyYW0gZmlsbCBUaGUgW1tDb2xvcl1dIHRvIGZpbGwgcmVjdGFuZ2xlIHdpdGhcclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyA9IDUsIHN0cm9rZSA9IENvbG9yLldoaXRlLCBmaWxsID0gbnVsbCkge1xyXG4gICAgbGV0IGJyO1xyXG4gICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYnIgPSB7IHRsOiByYWRpdXMsIHRyOiByYWRpdXMsIGJyOiByYWRpdXMsIGJsOiByYWRpdXMgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSYWRpdXMgPSB7IHRsOiAwLCB0cjogMCwgYnI6IDAsIGJsOiAwIH07XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRlZmF1bHRSYWRpdXMpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmF1bHRSYWRpdXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBwcm9wO1xyXG4gICAgICAgICAgICAgICAgYnJbc2lkZV0gPSByYWRpdXNbc2lkZV0gfHwgZGVmYXVsdFJhZGl1c1tzaWRlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5tb3ZlVG8oeCArIGJyLnRsLCB5KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gYnIudHIsIHkpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBici50cik7XHJcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJyLmJyKTtcclxuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYnIuYnIsIHkgKyBoZWlnaHQpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgYnIuYmwsIHkgKyBoZWlnaHQpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJyLmJsKTtcclxuICAgIGN0eC5saW5lVG8oeCwgeSArIGJyLnRsKTtcclxuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyBici50bCwgeSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMsIHN0cm9rZSA9IENvbG9yLldoaXRlLCBmaWxsID0gbnVsbCkge1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0xvYWRlci5sb2dvLnBuZ1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb2FkZXJfbG9nbyA9IChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBZFFBQUFCMkNBWUFBQUJ4aEdJOUFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFLblVsRVFWUjQydTNkUDJ3alN4MEg4TjhoSklvbklSbUpqc3EwU0JSK0JRMWRjcUtoZTBsRDc3U3ZTd3BLa0pLR1B1bHBrdGZSSU1VZEVxS0lxVjU3cnBBb2tNNGRiU2l5cTdPTlBUUDd4MzlpZno3U0ZibkVucDN4ZXI0N083dXpIMTVmWHdNQTZPWUhtZ0FBQkNvQUNGUUFFS2dBZ0VBRkFJRUtBQUlWQUFRcUFDQlFBVUNnQW9CQUJRQ0JDZ0FJVkFBUXFBQWdVQUZBb0FJQUFoVUFCQ29BQ0ZRQUVLZ0FnRUNGTGJtT2lOZUZmMlBiQXl6NjhQcjZxaFVnYlJ3UjkydisvendpSnJZSE1FS0ZNbWNOLy8vVXRnY1FxRkJrMVBELzk3VTlReDhWQ0ZTZ3U0RW1BSUVLQUFJVkFBUXFBQ0JRNFoyNWpvalA4ZVgrMFd0TkFnSVZhT1krSW01aitlS2gyNGg0MWpRZ1VJRXlaN0Y1TmFQVTd3Q0JDaXdZZC93OWNPQitxQWxnSjNLTExvdzBFVjE5ODgwM1JXdkpmdmZkZHgrMGxoRXFIS3U1SmdBalZDQnZsaG1GempRUlhVZWtIejkrVFA3OXk4dUxSak5DaFhmdm9lUHZBWUVLeE50ajFlNDIvTzVKb0lKQUJjcmRSTVJWTE0rWDNrVEVwYWFCOTg4Y0t1eldnOUVvYlRXZE14ME9seTh1TjRkcWhBb0FScWduYU4zYXJIZnF1N095SDhJdEtMVkIvUCtDRWZNVEh5R1BZM25weDFtOHpXR0RFZW9CZlVrL3hkdGk1N2RyL3IxV3YyKzZFUG93M3RaNXJSZFM3MnMxbmV1Rjk3eHZXZCtYVEgwL1YrVU10dERXcWJJL3IybnJ4ZnAranYydVNqU083UytPWHkvQS8zbE4rOXhYNVQ1SHhFVVBaWjB0ZkI3MSt3NTdlSi9IRnUreitqa3YxdTkyWVg5ZmJJL0hoWDNKQTlycDVNUHI2NnRXYUc5VWZVR2JySEl6aTdjTFV5WUZmL3RwVGFkeTAzRUVlTDhtVUo2aTdNS1lOdldOcXI0UGUyanJhZFhPNjBMcnZQQXoyUFE1UlBYNjg0YWg4ZHhEKzJ6YW50bkNnVmlwU1ZWK20vdGdCOVcyRERxMlN4L3ZNOTV3Y0hoWmhXVkptOHlydjU4Y1NnZlRkYzcwKysrL1gvcjUyMisvdFVLU0VlcEJxbytvbTRaTFBlck1qVXd1Tm5RQ3R4MUdXSnRlZTFGd2RENXVXZDg2eExzOFVhVnQyYU5FTzEvc2FaL1o1cllNVzR6cTZ2MzRyR1Y5QmczcTJlWjlTa2VObTlxd3lVaDMwT1BJSFlGS3g1RkcwM0M3em5TT3FZQnErcVcvenBRM2FuSDAzN1ROSGx1RzZmMFdQc1BoSHZhYjRRRnR5N29nT2V1eERZY055Mi96dTIyMTRXTllXeG1CdXJOTzhiR245N3BOQk9POHh5Lzl1Q29yWlo0STJyNEM3YUpnTzdaVjlpRTQ5RG02TnZPV3grcFdFOUNVcTN6YmRUcDlkb3ozOFRiWHR6cUg5UlQ1Q3lXZTQyMk9hWm9aR2VaQ2FicmhQUVk5SGp3c2pwVHZDZzRZdGxFMitUYS9qMmJ6bjhmcXJEcWdtKzZ5VUhPbUF2V1VqQXRHaGJOWXZzQmtuRG5xSDFRaGM3Vm14SGdlYi9OYnVkQTVqL1VYbFl3aWYycDZsdWhBYzl0ZXUxbnBpSEtuRHM4aWY2dENtN0pMWDNOS3BndHRYZTlydWM5bUhNZDdhODNpd2R4RjV2dDh0dXRBUmFDZWtsUm5OSzlDOFduTkY3Z2VKUTRUNFhHM0poU25WZGlsUXJHK3lPbnJsVkhmc0VHWXpoTkJuN0x1NnRTNytISmFmSlE0RU1pTmxOcVdYWjlXUHZWZ25WWUhHNU0xQnlEWGtUNmxlWDJFZ1RxSnR5dDQ1eXY3UzJxTzNzRVpqWmhETFhlUitZS2RKMFpkazhRb2N2SDlONzMyS3JOdHErRlovenpJSEFCY0pyWXBkK1h2MTRsT2Q1YXA3NlNncmR1Vy9WVFExcWNRcHFuYmd1NGlmWnZVTU5wZDlYdW9abXZDdFBhUTJZL0JDSFZMZ2JySlRlUlBEZFZmNnBmTUtEVTJmT2tIbVZGRmZYcjNNc291THNuTnZWNWtSb2U1K3M0MzFQZXVvS1BxV25hdXJZL1pQQkVlcXdjZU40bDk2aXdPNkg3TWpxNHk3VkdQVk5lMTBWYVpNelZDUFZXcEkvWjZGWmJjdjVmTXFHQ1UrZExmRkd6ajU4alA4K2JDZEpDbzd5ektUd2RPRjBidTlVZzdWNGMreXo3RkpmWWVHb3lzVXNzMEhzc0lkVlp3WUxEdWpNcWxFU29DZFR0R3NadGJIbkpCZU5kRFNKU3MwalRLZE1KTjFITlg1NFd2N2J2c1U5TmtWSlZhMTNkWCsvd3VBclYwWC9sNVJIeW8vbG5mRjRHNnA2RHJTMGtIZHRYaHkzNVRHRXJEUFlaVW4yV2ZXcURPby9sVnFkTUQyTy9oS0poRDdTL29kdWt5bXE5czAyUU40RUVQUi96YmFPdW1aYytyMTV6SzFacXpubDlqc2ZpZW1UTTFRbVYzSFV1VGtlZGxnOUhJUXpSYlVEOTNkZkMrMnRwajJmSUhFSDIrUnFDQ1FIMTNnWnE3aFdYVE5wVnUxOU9CMWZjOW5RMEFLT0tVYjVsVTBQMWtEeU9uZW9XazBsT1o5Y0lQMHg3cXU4KzJCaENvUjJ3WXUxK2U3RG1hWHpCU3N1NXZhWDFuZTJ6cnBtVVBUbXhmN1BNMURtNHkvdkM3bnk3TmlmNyt6LzlabXRNMFozcGFuUEx0UG1yYTlmMTZiY0swRHBibndrNDNWZC9SSHR1NnpmTlFUeTFRQnkzYXFHMmc5blZteG1sK0JPb0p5VDNOcFdtbjl4aGZGbnU0YnZEYSs0NEJYaHFxZmRmM3VVRjkreXo3N0FUMzFZdWUybWplY1lRNjJOTGZna0E5Z2hIcUxORWhOZW00SDFjNnZkeUR4aGYvYnB6NW00Y29XL2MzOXdpNlZIMmJQdEhsY2FWOWN2WHRzK3p4Q2U2clRlcWMybmRMN3VHZDkzUXdNOWJGY0F6TW9aWjdTZ1RCYld4K2FzdWk2MWgvaXExK1JtanFkYm5RWFEzVDFETlE2M1YvVTl1Y3FtL3BNelBiMXJlUHNrLzFpVE9qZ3ZhdFI0VzNMYzhVTEI3OHBFTHlybkFmZVRjajFOVTUwOS84Nm1mSjMzLzgrTWYwMGEwNVV5UFVFdzdVVkNlV0cvV05FaUV4eUhSTXQ1bHRXMzBpelVQazE4eXR0N2xOZmM4aS8vRHZ0dlh0byt5U0E1QmpsanNMVUY4bFBrcU1QRXRXMUpvbURzaUdCWjlCeWI0TkF2VUlUU045R3V3c0lqNnQ2VVRPcWs3akpSRWttenFsaTh4SXM5NnVkU08yMHNYMEgxdlc5MklMOWUxYTlyZ3FWeWY5MWdiUHNUeTlVRDluOWxPa1Q4aytSZmtGUjVQTU5xeE9jZFNmMzJQQnZnM3ZpbE8remR4RStva3g5V20wcGgzNlhZc1JaQ3BNRjk5M0dPazVxdnFCM0RjdDZqdnNzYjY3S3Z1VU5KM2ZydzkyYmhyOC9TVFNGMEpkUlBNTHBVQ2duc2dvOVM3NlBaMjQ2WkZrMXdXdks1bTN2Vm9ZdlcxU3o3bk45MWpmWGJRMVpRYzdUVzZIZWFvT2FseXBHLzgvcC9yUDFhTkFjNlpIelNuZmRxUFVQaGR5MlBRdzZOejlnU1ZodWhpcXVlVUhSM3V1N3k3SzNyZERYNHU0NlpyUGJVYTBJRkJaMHNlS1EzWFFUUnQydm0zVy9hMkRiTkt5cysrcnZtM2VwNit5MXgyVWRQM2JXVTlsenJhNDdVMUdtbGN0WC9zUTIzdCthT2xCeUxUaC80TkFQYUNSeHRjZE81SExTSi82dk50Q3dHeDY3VlBtUGJ2V2QxcTlmcktIdHA0a0FxUkoySFI5ajc2MkpmWDNiWi8vZWxQdGoxM1BQRHgxK0Q1dHFrL1hpNk5POFNIejdNbUgxOWRYcmRCTmZWRlA2VDJQVDFVSE5pdDg3L3Q0bTUrYVJIK25RQmR2cXloWkRLSkxmWnM4aDdYUHNxZFYyWk9WK3RhbktCOGFsbjBkeXhkQVhiVjRqNGd2dDRvTU9yYlA2dmJVNzNOVzdUTWxiZFRuUHJXcGZxWGZoOUhLWjl2a2U3S3VUZVpSTnRYUlNlNisxRlYvL2NlL2xuNWVYZnNYZ2NxWHpyNis5MjYxTTNtb09vYTdFNm52VFpUZnk3aU5zbWZiN2tqZmdYR3N2eGUwdmloc0V0czlIVHF1UHB0MXExdnRhaHUyVHFBaVVBRUVLajB6aHdvQVJxZ0F1L09uWC80NDJXSCs5eGMvV3ZyNThyZS9UcjdmNDEvK1pzUnFoQW9BQ0ZRQUVLZ0FjSGpNb1FKc2tKc3ovZXFycjVaK3Z2cjd2NWZtUUZldkFsNWx6dFFJRlFBUXFBQWdVQUhnSUpsREJkaGdkUTQxTjJlS0VTb0FJRkFCUUtBQ3dGRXdod29BUnFnQUlGQUJRS0FDQUFJVkFBUXFBQWhVQUJDb0FJQkFCUUNCQ2dBQ0ZRQUVLZ0FnVUFGQW9BS0FRQVVBZ1FvQUNGUUFFS2dBSUZBQlFLQUNBQUlWQUFRcUFBaFVBQkNvQUlCQUJRQ0JDZ0FDRlFBUXFBQWdVQUZBb0FLQVFBVUFsdndQY0ZEbnMxRHNINHNBQUFBQVNVVk9SSzVDWUlJPVwiKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9Mb2FkZXIuY3NzXG52YXIgTG9hZGVyXzAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzODgpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUmFzdGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQSBSYXN0ZXIgaXMgYSBHcmFwaGljIHRoYXQgbmVlZHMgdG8gYmUgZmlyc3QgcGFpbnRlZCB0byBhIEhUTUxDYW52YXNFbGVtZW50IGJlZm9yZSBpdCBjYW4gYmUgZHJhd24gdG8gdGhlXHJcbiAqIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV0uIFRoaXMgaXMgdXNlZnVsIGZvciBnZW5lcmF0aW5nIGN1c3RvbSBpbWFnZXMgdXNpbmcgdGhlIDJEIGNhbnZhcyBhcGkuXHJcbiAqXHJcbiAqIEltcGxlbWVudG9ycyBtdXN0IGltcGxlbWVudCB0aGUgW1tSYXN0ZXIuZXhlY3V0ZV1dIG1ldGhvZCB0byByYXN0ZXJpemUgdGhlaXIgZHJhd2luZy5cclxuICovXHJcbmNsYXNzIFJhc3RlciBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmZpbHRlcmluZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5lQ2FwID0gJ2J1dHQnO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Ntb290aGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gd2F0Y2goQ29sb3IuQmxhY2ssICgpID0+IHRoaXMuZmxhZ0RpcnR5KCkpO1xyXG4gICAgICAgIHRoaXMuX2xpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5fbGluZURhc2ggPSBbXTtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nID0gMDtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLnF1YWxpdHkgPSAoX2EgPSBvcHRpb25zLnF1YWxpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucXVhbGl0eTtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IChfYiA9IG9wdGlvbnMuY29sb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENvbG9yLkJsYWNrO1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0cm9rZUNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLnNtb290aGluZyA9IChfYyA9IG9wdGlvbnMuc21vb3RoaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLnNtb290aGluZztcclxuICAgICAgICAgICAgdGhpcy5saW5lV2lkdGggPSAoX2QgPSBvcHRpb25zLmxpbmVXaWR0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubGluZURhc2ggPSAoX2UgPSBvcHRpb25zLmxpbmVEYXNoKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLmxpbmVEYXNoO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVDYXAgPSAoX2YgPSBvcHRpb25zLmxpbmVDYXApICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMubGluZUNhcDtcclxuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gKF9nID0gb3B0aW9ucy5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLnBhZGRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gKF9oID0gb3B0aW9ucy5maWx0ZXJpbmcpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRoaXMuZmlsdGVyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9iaXRtYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAvLyBnZXQgdGhlIGRlZmF1bHQgY2FudmFzIHdpZHRoL2hlaWdodCBhcyBhIGZhbGxiYWNrXHJcbiAgICAgICAgY29uc3QgYml0bWFwV2lkdGggPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IHRoaXMuX2JpdG1hcC53aWR0aDtcclxuICAgICAgICBjb25zdCBiaXRtYXBIZWlnaHQgPSAoX2sgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiB0aGlzLl9iaXRtYXAuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBiaXRtYXBXaWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGJpdG1hcEhlaWdodDtcclxuICAgICAgICBjb25zdCBtYXliZUN0eCA9IHRoaXMuX2JpdG1hcC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGlmICghbWF5YmVDdHgpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgMmQgY2FudmFzIGRyYXdpbmcsIGNhbm5vdCBjcmVhdGUgUmFzdGVyIGdyYXBoaWMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IG1heWJlQ3R4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb25lUmFzdGVyT3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvciA/IHRoaXMuY29sb3IuY2xvbmUoKSA6IG51bGwsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiB0aGlzLnN0cm9rZUNvbG9yID8gdGhpcy5zdHJva2VDb2xvci5jbG9uZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgc21vb3RoaW5nOiB0aGlzLnNtb290aGluZyxcclxuICAgICAgICAgICAgbGluZVdpZHRoOiB0aGlzLmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgbGluZURhc2g6IHRoaXMubGluZURhc2gsXHJcbiAgICAgICAgICAgIGxpbmVDYXA6IHRoaXMubGluZUNhcCxcclxuICAgICAgICAgICAgcXVhbGl0eTogdGhpcy5xdWFsaXR5LFxyXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdyYXBoaWMgaXMgZGlydHksIHRoaXMgbWVhbnMgdGhlcmUgYXJlIGNoYW5nZXMgdGhhdCBoYXZlbid0IGJlZW4gcmUtcmFzdGVyaXplZFxyXG4gICAgICovXHJcbiAgICBnZXQgZGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGbGFncyB0aGUgZ3JhcGhpYyBhcyBkaXJ0eSwgbWVhbmluZyBpdCBtdXN0IGJlIHJlLXJhc3Rlcml6ZWQgYmVmb3JlIGRyYXcuXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlIGdyYXBoaWNzIHN0YXRlIGNoYW5nZXMgc3VjaCB0aGF0IGl0IGFmZmVjdHMgdGhlIG91dHB1dHRlZCBkcmF3aW5nXHJcbiAgICAgKi9cclxuICAgIGZsYWdEaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIHdpZHRoIHdpbGwgY2F1c2UgdGhlIHJhc3RlclxyXG4gICAgICogdG8gYmUgZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGBwYWRkaW5nYHMgb3IgYHF1YWxpdHlgIHNldCB3aWxsIGJlIGZhY3RvcmVkIGludG8gdGhlIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5fZ2V0VG90YWxXaWR0aCgpICogdGhpcy5zY2FsZS54KTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlIC89IE1hdGguYWJzKHRoaXMuc2NhbGUueCk7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwLndpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIFJhc3RlciBncmFwaGljLiBTZXR0aW5nIHRoZSBoZWlnaHQgd2lsbCBjYXVzZSB0aGUgcmFzdGVyXHJcbiAgICAgKiB0byBiZSBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqXHJcbiAgICAgKiBBbnkgYHBhZGRpbmdgIG9yIGBxdWFsaXR5YCBzZXQgd2lsbCBiZSBmYWN0b3JlZCBpbnRvIHRoZSBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5fZ2V0VG90YWxIZWlnaHQoKSAqIHRoaXMuc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgLz0gTWF0aC5hYnModGhpcy5zY2FsZS55KTtcclxuICAgICAgICB0aGlzLl9iaXRtYXAuaGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxIZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgX2dldFRvdGFsV2lkdGgoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoKChfYSA9IHRoaXMuX29yaWdpbmFsV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2JpdG1hcC53aWR0aCkgKyB0aGlzLnBhZGRpbmcgKiAyKSAqIDE7XHJcbiAgICB9XHJcbiAgICBfZ2V0VG90YWxIZWlnaHQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoKChfYSA9IHRoaXMuX29yaWdpbmFsSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9iaXRtYXAuaGVpZ2h0KSArIHRoaXMucGFkZGluZyAqIDIpICogMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBSYXN0ZXIgaW5jbHVkaW5nIHRoZSBwYWRkaW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3guZnJvbURpbWVuc2lvbih0aGlzLl9nZXRUb3RhbFdpZHRoKCkgKiB0aGlzLnNjYWxlLngsIHRoaXMuX2dldFRvdGFsSGVpZ2h0KCkgKiB0aGlzLnNjYWxlLnksIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzbW9vdGhpbmcgKGFudGktYWxpYXNpbmcgb2YgdGhlIGdyYXBoaWMpLiBTZXR0aW5nIHRoZSBoZWlnaHQgd2lsbCBjYXVzZSB0aGUgcmFzdGVyXHJcbiAgICAgKiB0byBiZSBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNtb290aGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3RoaW5nO1xyXG4gICAgfVxyXG4gICAgc2V0IHNtb290aGluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Ntb290aGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmlsbFN0eWxlIG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgZmlsbFN0eWxlIHdpbGwgY2F1c2UgdGhlIHJhc3RlciB0byBiZVxyXG4gICAgICogZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gd2F0Y2godmFsdWUsICgpID0+IHRoaXMuZmxhZ0RpcnR5KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHN0cm9rZVN0eWxlIG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgc3Ryb2tlU3R5bGUgd2lsbCBjYXVzZSB0aGUgcmFzdGVyIHRvIGJlXHJcbiAgICAgKiBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0cm9rZUNvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvcjtcclxuICAgIH1cclxuICAgIHNldCBzdHJva2VDb2xvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSB3YXRjaCh2YWx1ZSwgKCkgPT4gdGhpcy5mbGFnRGlydHkoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGluZSB3aWR0aCBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIGxpbmVXaWR0aCB3aWxsIGNhdXNlIHRoZSByYXN0ZXIgdG8gYmVcclxuICAgICAqIGZsYWdnZWQgZGlydHkgY2F1c2luZyBhIHJlLXJhc3RlciBvbiB0aGUgbmV4dCBkcmF3LlxyXG4gICAgICovXHJcbiAgICBnZXQgbGluZVdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lV2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgbGluZVdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZVdpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIGdldCBsaW5lRGFzaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XHJcbiAgICB9XHJcbiAgICBzZXQgbGluZURhc2godmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9saW5lRGFzaCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFkZGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcclxuICAgIH1cclxuICAgIHNldCBwYWRkaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJhc3Rlcml6ZSB0aGUgZ3JhcGhpYyB0byBhIGJpdG1hcCBtYWtpbmcgaXQgdXNhYmxlIGFzIGluIGV4Y2FsaWJ1ci4gUmFzdGVyaXplIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmXHJcbiAgICAgKiB0aGUgZ3JhcGhpYyBpcyBbW1Jhc3Rlci5kaXJ0eV1dIG9uIHRoZSBuZXh0IFtbR3JhcGhpYy5kcmF3XV0gY2FsbFxyXG4gICAgICovXHJcbiAgICByYXN0ZXJpemUoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2dldFRvdGFsV2lkdGgoKSwgdGhpcy5fZ2V0VG90YWxIZWlnaHQoKSk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9hcHBseVJhc3RlclByb3BlcnRpZXModGhpcy5fY3R4KTtcclxuICAgICAgICB0aGlzLmV4ZWN1dGUodGhpcy5fY3R4KTtcclxuICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIC8vIFRoZSB3ZWJnbCB0ZXh0dXJlIG5lZWRzIHRvIGJlIHVwZGF0ZWQgaWYgaXQgZXhpc3RzIGFmdGVyIGEgcmFzdGVyIGN5Y2xlXHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5sb2FkKHRoaXMuX2JpdG1hcCwgdGhpcy5maWx0ZXJpbmcsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5UmFzdGVyUHJvcGVydGllcyhjdHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLl9iaXRtYXAud2lkdGggPSB0aGlzLl9nZXRUb3RhbFdpZHRoKCkgKiB0aGlzLnF1YWxpdHk7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwLmhlaWdodCA9IHRoaXMuX2dldFRvdGFsSGVpZ2h0KCkgKiB0aGlzLnF1YWxpdHk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMucXVhbGl0eSwgdGhpcy5xdWFsaXR5KTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucGFkZGluZywgdGhpcy5wYWRkaW5nKTtcclxuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdGhpcy5zbW9vdGhpbmc7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaCgoX2EgPSB0aGlzLmxpbmVEYXNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZ2V0TGluZURhc2goKSk7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmxpbmVDYXA7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gKF9iID0gdGhpcy5zdHJva2VDb2xvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IChfYyA9IHRoaXMuY29sb3IpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShleCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleC5zY2FsZSgxIC8gdGhpcy5xdWFsaXR5LCAxIC8gdGhpcy5xdWFsaXR5KTtcclxuICAgICAgICBleC5kcmF3SW1hZ2UodGhpcy5fYml0bWFwLCB4LCB5KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NhbnZhcy50c1xuXHJcbi8qKlxyXG4gKiBBIGNhbnZhcyBbW0dyYXBoaWNdXSB0byBwcm92aWRlIGFuIGFkYXB0ZXIgYmV0d2VlbiB0aGUgMkQgQ2FudmFzIEFQSSBhbmQgdGhlIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV0uXHJcbiAqXHJcbiAqIFRoZSBbW0NhbnZhc11dIHdvcmtzIGJ5IHJlLXJhc3RlcmluZyBhIGRyYXcgaGFuZGxlciB0byBhIEhUTUxDYW52YXNFbGVtZW50IGZvciBldmVyeSBkcmF3IHdoaWNoIGlzIHRoZW4gcGFzc2VkXHJcbiAqIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dIGltcGxlbWVudGF0aW9uIGFzIGEgcmVuZGVyZWQgaW1hZ2UuXHJcbiAqXHJcbiAqICoqTG93IHBlcmZvcm1hbmNlIEFQSSoqXHJcbiAqL1xyXG5jbGFzcyBDYW52YXMgZXh0ZW5kcyBSYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihfb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIDJEIGdyYXBoaWNzIGNvbnRleHQgb2YgdGhpcyBjYW52YXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGN0eCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSxcclxuICAgICAgICAgICAgLi4udGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdykge1xyXG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnRlcmZhY2VzL0F1ZGlvSW1wbGVtZW50YXRpb24udHNcbmNsYXNzIEV4UmVzcG9uc2Uge1xyXG59XHJcbkV4UmVzcG9uc2UudHlwZSA9IHtcclxuICAgIGFueTogJycsXHJcbiAgICBibG9iOiAnYmxvYicsXHJcbiAgICBqc29uOiAnanNvbicsXHJcbiAgICB0ZXh0OiAndGV4dCcsXHJcbiAgICBkb2N1bWVudDogJ2RvY3VtZW50JyxcclxuICAgIGFycmF5YnVmZmVyOiAnYXJyYXlidWZmZXInXHJcbn07XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9TdGF0ZU1hY2hpbmUudHNcbmNsYXNzIFN0YXRlTWFjaGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50U3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcclxuICAgIH1cclxuICAgIHNldCBjdXJyZW50U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSBzdGF0ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUobWFjaGluZURlc2NyaXB0aW9uLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUoKTtcclxuICAgICAgICBtYWNoaW5lLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGVOYW1lIGluIG1hY2hpbmVEZXNjcmlwdGlvbi5zdGF0ZXMpIHtcclxuICAgICAgICAgICAgbWFjaGluZS5zdGF0ZXMuc2V0KHN0YXRlTmFtZSwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogc3RhdGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgLi4ubWFjaGluZURlc2NyaXB0aW9uLnN0YXRlc1tzdGF0ZU5hbWVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2YWxpZGF0ZSB0cmFuc2l0aW9ucyBhcmUgc3RhdGVzXHJcbiAgICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBtYWNoaW5lLnN0YXRlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zaXRpb25TdGF0ZSBvZiBzdGF0ZS50cmFuc2l0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25TdGF0ZSA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hY2hpbmUuc3RhdGVzLmhhcyh0cmFuc2l0aW9uU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgc3RhdGUgbWFjaGluZSwgc3RhdGUgWyR7c3RhdGUubmFtZX1dIGhhcyBhIHRyYW5zaXRpb24gdG8gYW5vdGhlciBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QgWyR7dHJhbnNpdGlvblN0YXRlfV1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYWNoaW5lLmN1cnJlbnRTdGF0ZSA9IG1hY2hpbmUuc3RhcnRTdGF0ZSA9IG1hY2hpbmUuc3RhdGVzLmdldChtYWNoaW5lRGVzY3JpcHRpb24uc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiBtYWNoaW5lO1xyXG4gICAgfVxyXG4gICAgaW4oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGUubmFtZSA9PT0gc3RhdGU7XHJcbiAgICB9XHJcbiAgICBnbyhzdGF0ZU5hbWUsIGV2ZW50RGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlLnRyYW5zaXRpb25zLmluY2x1ZGVzKHN0YXRlTmFtZSkgfHwgdGhpcy5jdXJyZW50U3RhdGUudHJhbnNpdGlvbnMuaW5jbHVkZXMoJyonKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxOZXdTdGF0ZSA9IHRoaXMuc3RhdGVzLmdldChzdGF0ZU5hbWUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUub25FeGl0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5FeGl0ID0gKF9hID0gdGhpcy5jdXJyZW50U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkV4aXQoeyB0bzogcG90ZW50aWFsTmV3U3RhdGUubmFtZSwgZGF0YTogdGhpcy5kYXRhIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbkV4aXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb3RlbnRpYWxOZXdTdGF0ZSA9PT0gbnVsbCB8fCBwb3RlbnRpYWxOZXdTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG90ZW50aWFsTmV3U3RhdGUub25FbnRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuRW50ZXIgPSBwb3RlbnRpYWxOZXdTdGF0ZSA9PT0gbnVsbCB8fCBwb3RlbnRpYWxOZXdTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG90ZW50aWFsTmV3U3RhdGUub25FbnRlcih7IGZyb206IHRoaXMuY3VycmVudFN0YXRlLm5hbWUsIGV2ZW50RGF0YSwgZGF0YTogdGhpcy5kYXRhIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbkVudGVyID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHt0aGlzLmN1cnJlbnRTdGF0ZS5uYW1lfSA9PiAke3BvdGVudGlhbE5ld1N0YXRlLm5hbWV9ICgke2V2ZW50RGF0YX0pYCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gcG90ZW50aWFsTmV3U3RhdGU7XHJcbiAgICAgICAgICAgIGlmICgoX2IgPSB0aGlzLmN1cnJlbnRTdGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uU3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVsYXBzZWRNcykge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZS5vblVwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5vblVwZGF0ZSh0aGlzLmRhdGEsIGVsYXBzZWRNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2F2ZShzYXZlS2V5KSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc2F2ZUtleSwgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHRoaXMuY3VycmVudFN0YXRlLm5hbWUsXHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJlc3RvcmUoc2F2ZUtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzYXZlS2V5KSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoc3RhdGUuY3VycmVudFN0YXRlKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBzdGF0ZS5kYXRhO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1NvdW5kL1dlYkF1ZGlvSW5zdGFuY2UudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBXZWIgQXVkaW8gQXVkaW9CdWZmZXJTb3VyY2VOb2RlIGluc3RhbmNlXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BdWRpb19BUElcclxuICovXHJcbmNsYXNzIFdlYkF1ZGlvSW5zdGFuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoX3NyYykge1xyXG4gICAgICAgIHRoaXMuX3NyYyA9IF9zcmM7XHJcbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0RmFjdG9yeS5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLl92b2x1bWVOb2RlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9zdGF0ZU1hY2hpbmUgPSBTdGF0ZU1hY2hpbmUuY3JlYXRlKHtcclxuICAgICAgICAgICAgc3RhcnQ6ICdTVE9QUEVEJyxcclxuICAgICAgICAgICAgc3RhdGVzOiB7XHJcbiAgICAgICAgICAgICAgICBQTEFZSU5HOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjogKHsgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1ZmZlciBub2RlcyBhcmUgc2luZ2xlIHVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXJ0KDAsIGRhdGEucGF1c2VkQXQgKiB0aGlzLl9wbGF5YmFja1JhdGUsIHRoaXMuZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ZWRBdCA9ICh0aGlzLl9hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgLSBkYXRhLnBhdXNlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wYXVzZWRBdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN0YXRlOiAoKSA9PiB0aGlzLl9wbGF5U3RhcnRlZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdDogKHsgdG8gfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3UndmUgZXhpdGVkIGVhcmx5IG9ubHkgcmVzb2x2ZSBpZiBleHBsaWNpdGx5IFNUT1BQRURcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09PSAnU1RPUFBFRCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdSZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW5ldmVyIHlvdSdyZSBub3QgcGxheWluZy4uLiB5b3Ugc3RvcCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uub25lbmRlZCA9IG51bGw7IC8vIGRpc2Nvbm5lY3QgdGhlIHdpcmVkIG9uLWVuZCBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RvcCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IFsnU1RPUFBFRCcsICdQQVVTRUQnLCAnU0VFSyddXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgU0VFSzoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRW50ZXI6ICh7IGV2ZW50RGF0YTogcG9zaXRpb24sIGRhdGEgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBhdXNlZEF0ID0gKHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6IDApIC8gdGhpcy5fcGxheWJhY2tSYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ZWRBdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uczogWycqJ11cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBTVE9QUEVEOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjogKHsgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGF1c2VkQXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ZWRBdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdSZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IFsnUExBWUlORycsICdQQVVTRUQnLCAnU0VFSyddXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgUEFVU0VEOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjogKHsgZGF0YSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYXliYWNrIHJhdGUgd2lsbCBiZSBhIHNjYWxlIGZhY3RvciBvZiBob3cgZmFzdC9zbG93IHRoZSBhdWRpbyBpcyBiZWluZyBwbGF5ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyAxLjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbnZlcnQgaXQgdG8gZ2V0IHRoZSB0aW1lIHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucGF1c2VkQXQgPSAodGhpcy5fYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lIC0gZGF0YS5zdGFydGVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IFsnUExBWUlORycsICdTVE9QUEVEJywgJ1NFRUsnXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBzdGFydGVkQXQ6IDAsXHJcbiAgICAgICAgICAgIHBhdXNlZEF0OiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gMTtcclxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxyXG4gICAgICAgIHRoaXMuX3BsYXlTdGFydGVkID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IDEuMDtcclxuICAgICAgICB0aGlzLl9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKSB7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UuYnVmZmVyID0gdGhpcy5fc3JjO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5fcGxheWJhY2tSYXRlO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLmNvbm5lY3QodGhpcy5fdm9sdW1lTm9kZSk7XHJcbiAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5jb25uZWN0KHRoaXMuX2F1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlRW5kKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sb29wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLm9uZW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5aW5nUmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQgbG9vcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UubG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9vcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uub25lbmRlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wbGF5aW5nUmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbG9vcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgIH1cclxuICAgIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAwLCAxLjApO1xyXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZU1hY2hpbmUuaW4oJ1BMQVlJTkcnKSAmJiB0aGlzLl92b2x1bWVOb2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKSB7XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb1BhcmFtL3NldFRhcmdldEF0VGltZVxyXG4gICAgICAgICAgICAvLyBBZnRlciBlYWNoIC4xIHNlY29uZHMgdGltZXN0ZXAsIHRoZSB0YXJnZXQgdmFsdWUgd2lsbCB+NjMuMiUgY2xvc2VyIHRvIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgZXhwb25lbnRpYWwgcmFtcCBwcm92aWRlcyBhIG1vcmUgcGxlYXNhbnQgdHJhbnNpdGlvbiBpbiBnYWluXHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMuX2F1ZGlvQ29udGV4dC5jdXJyZW50VGltZSwgMC4xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB2b2x1bWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2V0IGR1cmF0aW9uIHRvIHBsYXksIG90aGVyd2lzZSByZXR1cm5zIHRoZSB0b3RhbCBkdXJhdGlvbiBpZiB1bnNldFxyXG4gICAgICovXHJcbiAgICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5nZXRUb3RhbFBsYXliYWNrRHVyYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkdXJhdGlvbiB0aGF0IHRoaXMgYXVkaW8gc2hvdWxkIHBsYXkuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogaWYgeW91IHNlZWsgdG8gYSBzcGVjaWZpYyBwb2ludCB0aGUgZHVyYXRpb24gd2lsbCBzdGFydCBmcm9tIHRoYXQgcG9pbnQsIGZvciBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogSWYgeW91IGhhdmUgYSAxMCBzZWNvbmQgY2xpcCwgc2VlayB0byA1IHNlY29uZHMsIHRoZW4gc2V0IHRoZSBkdXJhdGlvbiB0byAyLCBpdCB3aWxsIHBsYXkgdGhlIGNsaXAgZnJvbSA1LTcgc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgc2V0IGR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIH1cclxuICAgIGlzUGxheWluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYWNoaW5lLmluKCdQTEFZSU5HJyk7XHJcbiAgICB9XHJcbiAgICBpc1BhdXNlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYWNoaW5lLmluKCdQQVVTRUQnKSB8fCB0aGlzLl9zdGF0ZU1hY2hpbmUuaW4oJ1NFRUsnKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cclxuICAgIHBsYXkocGxheVN0YXJ0ZWQgPSAoKSA9PiB7IH0pIHtcclxuICAgICAgICB0aGlzLl9wbGF5U3RhcnRlZCA9IHBsYXlTdGFydGVkO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlTWFjaGluZS5nbygnUExBWUlORycpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5aW5nUHJvbWlzZTtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlTWFjaGluZS5nbygnUEFVU0VEJyk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlTWFjaGluZS5nbygnU1RPUFBFRCcpO1xyXG4gICAgfVxyXG4gICAgc2Vlayhwb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlTWFjaGluZS5nbygnUEFVU0VEJyk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVNYWNoaW5lLmdvKCdTRUVLJywgcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0VG90YWxQbGF5YmFja0R1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcmMuZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBnZXRQbGF5YmFja1Bvc2l0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGF1c2VkQXQsIHN0YXJ0ZWRBdCB9ID0gdGhpcy5fc3RhdGVNYWNoaW5lLmRhdGE7XHJcbiAgICAgICAgaWYgKHBhdXNlZEF0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXVzZWRBdCAqIHRoaXMuX3BsYXliYWNrUmF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ZWRBdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2F1ZGlvQ29udGV4dC5jdXJyZW50VGltZSAtIHN0YXJ0ZWRBdCkgKiB0aGlzLl9wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgc2V0IHBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpIHtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLl9wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XHJcbiAgICB9XHJcbiAgICBnZXQgcGxheWJhY2tSYXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZS5wbGF5YmFja1JhdGUudmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FdmVudHMvTWVkaWFFdmVudHMudHNcblxyXG5jbGFzcyBNZWRpYUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgX25hbWUgPSAnTWVkaWFFdmVudCcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVkaWEgZXZlbnQgY2Fubm90IGJ1YmJsZVxyXG4gICAgICovXHJcbiAgICBzZXQgYnViYmxlcyhfdmFsdWUpIHtcclxuICAgICAgICAvLyBzdHViYmVkXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lZGlhIGV2ZW50IGNhbm5vdCBidWJibGVcclxuICAgICAqL1xyXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZWRpYSBldmVudCBjYW5ub3QgYnViYmxlLCBzbyB0aGV5IGhhdmUgbm8gcGF0aFxyXG4gICAgICovXHJcbiAgICBnZXQgX3BhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lZGlhIGV2ZW50IGNhbm5vdCBidWJibGUsIHNvIHRoZXkgaGF2ZSBubyBwYXRoXHJcbiAgICAgKi9cclxuICAgIHNldCBfcGF0aChfdmFsKSB7XHJcbiAgICAgICAgLy8gc3R1YmJlZFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50cyBldmVudCBmcm9tIGJ1YmJsaW5nXHJcbiAgICAgKi9cclxuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdHViXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjdGlvbiwgdGhhdCBjYWxscyB3aGVuIGV2ZW50IGhhcHBlbnNcclxuICAgICAqL1xyXG4gICAgYWN0aW9uKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0dWJcclxuICAgICAgICAgKi9cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGFnYXRlIGV2ZW50IGZ1cnRoZXIgdGhyb3VnaCBldmVudCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHByb3BhZ2F0ZSgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdHViXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICBsYXlQYXRoKF9hY3Rvcikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0dWJcclxuICAgICAgICAgKi9cclxuICAgIH1cclxufVxyXG5jbGFzcyBOYXRpdmVTb3VuZEV2ZW50IGV4dGVuZHMgTWVkaWFFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHRyYWNrKSB7XHJcbiAgICAgICAgc3VwZXIodGFyZ2V0LCAnTmF0aXZlU291bmRFdmVudCcpO1xyXG4gICAgICAgIHRoaXMudHJhY2sgPSB0cmFjaztcclxuICAgIH1cclxufVxyXG5jbGFzcyBOYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50IGV4dGVuZHMgTWVkaWFFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIF9wcm9jZXNzZWREYXRhKSB7XHJcbiAgICAgICAgc3VwZXIodGFyZ2V0LCAnTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCcpO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZERhdGEgPSBfcHJvY2Vzc2VkRGF0YTtcclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9wcm9jZXNzZWREYXRhO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9Tb3VuZC50c1xuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBjYW4gcGxheSB0aGlzIGZpbGUgYXMgSFRNTDUgQXVkaW9cclxuICovXHJcbmZ1bmN0aW9uIGNhblBsYXlGaWxlKGZpbGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYSA9IG5ldyBBdWRpbygpO1xyXG4gICAgICAgIGNvbnN0IGZpbGV0eXBlID0gLy4qXFwuKFtBLVphLXowLTldKykkLztcclxuICAgICAgICBjb25zdCB0eXBlID0gZmlsZS5tYXRjaChmaWxldHlwZSlbMV07XHJcbiAgICAgICAgaWYgKGEuY2FuUGxheVR5cGUoJ2F1ZGlvLycgKyB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCBkZXRlcm1pbmUgYXVkaW8gc3VwcG9ydCwgYXNzdW1pbmcgbm8gc3VwcG9ydCBmb3IgdGhlIEF1ZGlvIFRhZycsIGUpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9Tb3VuZC9Tb3VuZC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFtbU291bmRdXSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGF1ZGlvXHJcbiAqIGNvbXBvbmVudHMsIGZyb20gc291bmR0cmFja3MgdG8gc291bmQgZWZmZWN0cy4gW1tTb3VuZF1dIGlzIGFuIFtbTG9hZGFibGVdXVxyXG4gKiB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXSB0byBwcmUtbG9hZCBiZWZvcmUgYSBnYW1lIG9yIGxldmVsLlxyXG4gKi9cclxuY2xhc3MgU291bmQgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRocyBBIGxpc3Qgb2YgYXVkaW8gc291cmNlcyAoY2xpcC53YXYsIGNsaXAubXAzLCBjbGlwLm9nZykgZm9yIHRoaXMgYXVkaW8gY2xpcC4gVGhpcyBpcyBkb25lIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKC4uLnBhdGhzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl92b2x1bWUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHByaXZhdGUgX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheWJhY2tSYXRlID0gMS4wO1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dEZhY3RvcnkuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2UoJycsIEV4UmVzcG9uc2UudHlwZS5hcnJheWJ1ZmZlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hyb21lIDogTVAzLCBXQVYsIE9nZ1xyXG4gICAgICAgICAqIEZpcmVmb3ggOiBXQVYsIE9nZyxcclxuICAgICAgICAgKiBJRSA6IE1QMywgV0FWIGNvbWluZyBzb29uXHJcbiAgICAgICAgICogU2FmYXJpIE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcclxuICAgICAgICAgICAgaWYgKGNhblBsYXlGaWxlKHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBhdWRpbyBmaWxlcyBzcGVjaWZpZWQ6JywgcGF0aHMuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0F0dGVtcHRpbmcgdG8gdXNlJywgcGF0aHNbMF0pO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoc1swXTsgLy8gc2VsZWN0IHRoZSBmaXJzdCBzcGVjaWZpZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGlwIHNob3VsZCBsb29wIHdoZW4gY29tcGxldGVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgU2V0IHRoZSBsb29waW5nIGZsYWdcclxuICAgICAqL1xyXG4gICAgc2V0IGxvb3AodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLl90cmFja3MpIHtcclxuICAgICAgICAgICAgdHJhY2subG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgdGhpcy5fbG9vcCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9vcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgIH1cclxuICAgIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICB0cmFjay52b2x1bWUgPSB0aGlzLl92b2x1bWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdCgndm9sdW1lY2hhbmdlJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgdGhpcy5fdm9sdW1lKTtcclxuICAgIH1cclxuICAgIGdldCB2b2x1bWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkdXJhdGlvbiB0aGF0IHRoaXMgYXVkaW8gc2hvdWxkIHBsYXkuIElmIHVuc2V0IHRoZSB0b3RhbCBuYXR1cmFsIHBsYXliYWNrIGR1cmF0aW9uIHdpbGwgYmUgdXNlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBkdXJhdGlvbiB0aGF0IHRoaXMgYXVkaW8gc2hvdWxkIHBsYXkuIElmIHVuc2V0IHRoZSB0b3RhbCBuYXR1cmFsIHBsYXliYWNrIGR1cmF0aW9uIHdpbGwgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBpZiB5b3Ugc2VlayB0byBhIHNwZWNpZmljIHBvaW50IHRoZSBkdXJhdGlvbiB3aWxsIHN0YXJ0IGZyb20gdGhhdCBwb2ludCwgZm9yIGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3UgaGF2ZSBhIDEwIHNlY29uZCBjbGlwLCBzZWVrIHRvIDUgc2Vjb25kcywgdGhlbiBzZXQgdGhlIGR1cmF0aW9uIHRvIDIsIGl0IHdpbGwgcGxheSB0aGUgY2xpcCBmcm9tIDUtNyBzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYXJyYXkgb2YgQ3VycmVudCBBdWRpb0luc3RhbmNlcyBwbGF5aW5nIG9yIGJlaW5nIHBhdXNlZFxyXG4gICAgICovXHJcbiAgICBnZXQgaW5zdGFuY2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3M7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2UucGF0aDtcclxuICAgIH1cclxuICAgIHNldCBwYXRoKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlLnBhdGggPSB2YWw7XHJcbiAgICB9XHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICBhc3luYyBsb2FkKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcnJheWJ1ZmZlciA9IGF3YWl0IHRoaXMuX3Jlc291cmNlLmxvYWQoKTtcclxuICAgICAgICBjb25zdCBhdWRpb2J1ZmZlciA9IGF3YWl0IHRoaXMuZGVjb2RlQXVkaW8oYXJyYXlidWZmZXIuc2xpY2UoMCkpO1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gKF9iID0gKF9hID0gdGhpcy5fZHVyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGF1ZGlvYnVmZmVyID09PSBudWxsIHx8IGF1ZGlvYnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb2J1ZmZlci5kdXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJvY2Vzc2VkJywgbmV3IE5hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQodGhpcywgYXVkaW9idWZmZXIpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gYXVkaW9idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBkZWNvZGVBdWRpbyhkYXRhKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2F1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoZGF0YS5zbGljZSgwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdVbmFibGUgdG8gZGVjb2RlICcgK1xyXG4gICAgICAgICAgICAgICAgJyB0aGlzIGJyb3dzZXIgbWF5IG5vdCBmdWxseSBzdXBwb3J0IHRoaXMgZm9ybWF0LCBvciB0aGUgZmlsZSBtYXkgYmUgY29ycnVwdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnaWYgdGhpcyBpcyBhbiBtcDMgdHJ5IHJlbW92aW5nIGlkMyB0YWdzIGFuZCBhbGJ1bSBhcnQgZnJvbSB0aGUgZmlsZS4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVqZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2lyZUVuZ2luZShlbmdpbmUpIHtcclxuICAgICAgICBpZiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCdoaWRkZW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIHRoaXMuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbigndmlzaWJsZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3N0YXJ0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3N0b3AnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBob3cgbWFueSBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAgICovXHJcbiAgICBpbnN0YW5jZUNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3MubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc291bmQgaXMgcGxheWluZyByaWdodCBub3dcclxuICAgICAqL1xyXG4gICAgaXNQbGF5aW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3Muc29tZSgodCkgPT4gdC5pc1BsYXlpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBpc1BhdXNlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLnNvbWUodCA9PiB0LmlzUGF1c2VkKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5IHRoZSBzb3VuZCwgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzb3VuZCBpcyBkb25lIHBsYXlpbmdcclxuICAgICAqIEFuIG9wdGlvbmFsIHZvbHVtZSBhcmd1bWVudCBjYW4gYmUgcGFzc2VkIGluIHRvIHBsYXkgdGhlIHNvdW5kLiBNYXggdm9sdW1lIGlzIDEuMFxyXG4gICAgICovXHJcbiAgICBwbGF5KHZvbHVtZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0xvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0Nhbm5vdCBzdGFydCBwbGF5aW5nLiBSZXNvdXJjZScsIHRoaXMucGF0aCwgJ2lzIG5vdCBsb2FkZWQgeWV0Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pc1N0b3BwZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2Fubm90IHN0YXJ0IHBsYXlpbmcuIEVuZ2luZSBpcyBpbiBhIHN0b3BwZWQgc3RhdGUuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZvbHVtZSA9IHZvbHVtZSB8fCB0aGlzLnZvbHVtZTtcclxuICAgICAgICBpZiAodGhpcy5pc1BhdXNlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bWVQbGF5YmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0UGxheWJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNvdW5kLCBhbmQgZG8gbm90IHJld2luZFxyXG4gICAgICovXHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICB0cmFjay5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoJ3BhdXNlJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQYXVzZWQgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNvdW5kIGlmIGl0IGlzIGN1cnJlbnRseSBwbGF5aW5nIGFuZCByZXdpbmQgdGhlIHRyYWNrLiBJZiB0aGUgc291bmQgaXMgbm90IHBsYXlpbmcsIHJld2luZHMgdGhlIHRyYWNrLlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdGhpcy5fdHJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTdG9wcGVkIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXliYWNrUmF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xyXG4gICAgfVxyXG4gICAgc2V0IHBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpIHtcclxuICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tzLmZvckVhY2godCA9PiB7XHJcbiAgICAgICAgICAgIHQucGxheWJhY2tSYXRlID0gdGhpcy5fcGxheWJhY2tSYXRlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2Vlayhwb3NpdGlvbiwgdHJhY2tJZCA9IDApIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRUcmFja0luc3RhbmNlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyYWNrc1t0cmFja0lkXS5zZWVrKHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGdldFRvdGFsUGxheWJhY2tEdXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcGxheWJhY2sgdGltZSBvZiB0aGUgcGxheWluZyB0cmFjayBpbiBzZWNvbmRzIGZyb20gdGhlIHN0YXJ0LlxyXG4gICAgICpcclxuICAgICAqIE9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgdHJhY2sgdG8gcXVlcnkgaWYgbXVsdGlwbGUgYXJlIHBsYXlpbmcgYXQgb25jZS5cclxuICAgICAqIEBwYXJhbSB0cmFja0lkXHJcbiAgICAgKi9cclxuICAgIGdldFBsYXliYWNrUG9zaXRpb24odHJhY2tJZCA9IDApIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzW3RyYWNrSWRdLmdldFBsYXliYWNrUG9zaXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBJZCBvZiBwcm92aWRlZCBBdWRpb0luc3RhbmNlIGluIGN1cnJlbnQgdHJhY2tMaXN0XHJcbiAgICAgKiBAcGFyYW0gdHJhY2sgW1tBdWRpb11dIHdoaWNoIElkIGlzIHRvIGJlIGdpdmVuXHJcbiAgICAgKi9cclxuICAgIGdldFRyYWNrSWQodHJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tzLmluZGV4T2YodHJhY2spO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgX3Jlc3VtZVBsYXliYWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VtZWQgPSBbXTtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHJlc3VtZSAqY3VycmVudCogdHJhY2tzIChpZiBwYXVzZWQpXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdGhpcy5fdHJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bWVkLnB1c2godHJhY2sucGxheSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGxheWJhY2tlbmQnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzLCB0cmFjaykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrcy5zcGxpY2UodGhpcy5nZXRUcmFja0lkKHRyYWNrKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdSZXN1bWluZyBwYXVzZWQgaW5zdGFuY2VzIGZvciBzb3VuZCcsIHRoaXMucGF0aCwgdGhpcy5fdHJhY2tzKTtcclxuICAgICAgICAgICAgLy8gcmVzb2x2ZSB3aGVuIHJlc3VtZWQgdHJhY2tzIGFyZSBkb25lXHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VtZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHBsYXliYWNrLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcGxheWJhY2sgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgYXN5bmMgX3N0YXJ0UGxheWJhY2soKSB7XHJcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhd2FpdCB0aGlzLl9nZXRUcmFja0luc3RhbmNlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSBhd2FpdCB0cmFjay5wbGF5KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwbGF5YmFja3N0YXJ0JywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcywgdHJhY2spKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1BsYXlpbmcgbmV3IGluc3RhbmNlIGZvciBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gd2hlbiBkb25lLCByZW1vdmUgdHJhY2tcclxuICAgICAgICB0aGlzLmVtaXQoJ3BsYXliYWNrZW5kJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcywgdHJhY2spKTtcclxuICAgICAgICB0aGlzLl90cmFja3Muc3BsaWNlKHRoaXMuZ2V0VHJhY2tJZCh0cmFjayksIDEpO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgIH1cclxuICAgIF9nZXRUcmFja0luc3RhbmNlKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBuZXdUcmFjayA9IG5ldyBXZWJBdWRpb0luc3RhbmNlKGRhdGEpO1xyXG4gICAgICAgIG5ld1RyYWNrLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgICAgbmV3VHJhY2sudm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgICAgbmV3VHJhY2suZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgIG5ld1RyYWNrLnBsYXliYWNrUmF0ZSA9IHRoaXMuX3BsYXliYWNrUmF0ZTtcclxuICAgICAgICB0aGlzLl90cmFja3MucHVzaChuZXdUcmFjayk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1RyYWNrO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTG9hZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJlLWxvYWRpbmcgYXNzZXRzXHJcbiAqXHJcbiAqIFRoZSBsb2FkZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcHJlbG9hZCBtdWx0aXBsZSByZXNvdXJjZXMgYXRcclxuICogb25lIHRpbWUuIFRoZSBsb2FkZXIgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGVuZ2luZSBpbiBvcmRlciB0b1xyXG4gKiB0cmlnZ2VyIHRoZSBsb2FkaW5nIHByb2dyZXNzIGJhci5cclxuICpcclxuICogVGhlIFtbTG9hZGVyXV0gaXRzZWxmIGltcGxlbWVudHMgW1tMb2FkYWJsZV1dIHNvIHlvdSBjYW4gbG9hZCBsb2FkZXJzLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlOiBQcmUtbG9hZGluZyByZXNvdXJjZXMgZm9yIGEgZ2FtZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBjcmVhdGUgYSBsb2FkZXJcclxuICogdmFyIGxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcclxuICpcclxuICogLy8gY3JlYXRlIGEgcmVzb3VyY2UgZGljdGlvbmFyeSAoYmVzdCBwcmFjdGljZSBpcyB0byBrZWVwIGEgc2VwYXJhdGUgZmlsZSlcclxuICogdmFyIHJlc291cmNlcyA9IHtcclxuICogICBUZXh0dXJlR3JvdW5kOiBuZXcgZXguVGV4dHVyZShcIi9pbWFnZXMvdGV4dHVyZXMvZ3JvdW5kLnBuZ1wiKSxcclxuICogICBTb3VuZERlYXRoOiBuZXcgZXguU291bmQoXCIvc291bmQvZGVhdGgud2F2XCIsIFwiL3NvdW5kL2RlYXRoLm1wM1wiKVxyXG4gKiB9O1xyXG4gKlxyXG4gKiAvLyBsb29wIHRocm91Z2ggZGljdGlvbmFyeSBhbmQgYWRkIHRvIGxvYWRlclxyXG4gKiBmb3IgKHZhciBsb2FkYWJsZSBpbiByZXNvdXJjZXMpIHtcclxuICogICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGxvYWRhYmxlKSkge1xyXG4gKiAgICAgbG9hZGVyLmFkZFJlc291cmNlKHJlc291cmNlc1tsb2FkYWJsZV0pO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiAvLyBzdGFydCBnYW1lXHJcbiAqIGdhbWUuc3RhcnQobG9hZGVyKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICogICBjb25zb2xlLmxvZyhcIkdhbWUgc3RhcnRlZCFcIik7XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogIyMgQ3VzdG9taXplIHRoZSBMb2FkZXJcclxuICpcclxuICogVGhlIGxvYWRlciBjYW4gYmUgY3VzdG9taXplZCB0byBzaG93IGRpZmZlcmVudCwgdGV4dCwgbG9nbywgYmFja2dyb3VuZCBjb2xvciwgYW5kIGJ1dHRvbi5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgZXguTG9hZGVyKFtwbGF5ZXJUZXh0dXJlXSk7XHJcbiAqXHJcbiAqIC8vIFRoZSBsb2FkZXJzIGJ1dHRvbiB0ZXh0IGNhbiBzaW1wbHkgbW9kaWZpZWQgdXNpbmcgdGhpc1xyXG4gKiBsb2FkZXIucGxheUJ1dHRvblRleHQgPSAnU3RhcnQgdGhlIGJlc3QgZ2FtZSBldmVyJztcclxuICpcclxuICogLy8gVGhlIGxvZ28gY2FuIGJlIGNoYW5nZWQgYnkgaW5zZXJ0aW5nIGEgYmFzZTY0IGltYWdlIHN0cmluZyBoZXJlXHJcbiAqXHJcbiAqIGxvYWRlci5sb2dvID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncuLi4nO1xyXG4gKiBsb2FkZXIubG9nb1dpZHRoID0gMTU7XHJcbiAqIGxvYWRlci5sb2dvSGVpZ2h0ID0gMTQ7XHJcbiAqXHJcbiAqIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGNhbiBiZSBjaGFuZ2VkIGxpa2Ugc28gYnkgc3VwcGx5aW5nIGEgdmFsaWQgQ1NTIGNvbG9yIHN0cmluZ1xyXG4gKlxyXG4gKiBsb2FkZXIuYmFja2dyb3VuZENvbG9yID0gJ3JlZCdcclxuICogbG9hZGVyLmJhY2tncm91bmRDb2xvciA9ICcjMTc2QkFBJ1xyXG4gKlxyXG4gKiAvLyBUbyBidWlsZCBhIGNvbXBsZXRlbHkgbmV3IGJ1dHRvblxyXG4gKiBsb2FkZXIuc3RhcnRCdXR0b25GYWN0b3J5ID0gKCkgPT4ge1xyXG4gKiAgICAgbGV0IG15QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAqICAgICBteUJ1dHRvbi50ZXh0Q29udGVudCA9ICdUaGUgYmVzdCBidXR0b24nO1xyXG4gKiAgICAgcmV0dXJuIG15QnV0dG9uO1xyXG4gKiB9O1xyXG4gKlxyXG4gKiBlbmdpbmUuc3RhcnQobG9hZGVyKS50aGVuKCgpID0+IHt9KTtcclxuICogYGBgXHJcbiAqL1xyXG5jbGFzcyBMb2FkZXIgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIE9wdGlvbmFsbHkgcHJvdmlkZSB0aGUgbGlzdCBvZiByZXNvdXJjZXMgeW91IHdhbnQgdG8gbG9hZCBhdCBjb25zdHJ1Y3RvciB0aW1lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRhYmxlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHtcclxuICAgICAgICAgICAgZmlsdGVyaW5nOiBJbWFnZUZpbHRlcmluZy5CbGVuZGVkLFxyXG4gICAgICAgICAgICBzbW9vdGhpbmc6IHRydWUsXHJcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgICAgICAgICBkcmF3OiB0aGlzLmRyYXcuYmluZCh0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU2hvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9udW1Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ291bnRzID0ge307XHJcbiAgICAgICAgdGhpcy5fdG90YWxDb3VudHMgPSB7fTtcclxuICAgICAgICAvLyBsb2dvIGRyYXdpbmcgc3R1ZmZcclxuICAgICAgICAvLyBiYXNlNjQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBleGNhbGlidXIgbG9nbyAobG9nby13aGl0ZS5wbmcpXHJcbiAgICAgICAgdGhpcy5sb2dvID0gTG9hZGVyX2xvZ287XHJcbiAgICAgICAgdGhpcy5sb2dvV2lkdGggPSA0Njg7XHJcbiAgICAgICAgdGhpcy5sb2dvSGVpZ2h0ID0gMTE4O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY29sb3Igb2YgdGhlIGxvYWRpbmcgYmFyLCBkZWZhdWx0IGlzIFtbQ29sb3IuV2hpdGVdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0JhckNvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBsb2FkZXIgYXMgYSBoZXggc3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnIzE3NkJBQSc7XHJcbiAgICAgICAgdGhpcy5zdXBwcmVzc1BsYXlCdXR0b24gPSBmYWxzZTtcclxuICAgICAgICAvKiogTG9hZHMgdGhlIGNzcyBmcm9tIExvYWRlci5jc3MgKi9cclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU3R5bGVzID0gTG9hZGVyXzAvKiBkZWZhdWx0LnRvU3RyaW5nICovLloudG9TdHJpbmcoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQvc2V0IHBsYXkgYnV0dG9uIHRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsYXlCdXR0b25UZXh0ID0gJ1BsYXkgZ2FtZSc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgaHRtbCBidXR0b24gZWxlbWVudCBmb3IgZXhjYWxpYnVyIHRvIHVzZSBhcyBhIHBsYXkgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydEJ1dHRvbkZhY3RvcnkgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4Y2FsaWJ1ci1wbGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICghYnV0dG9uRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1dHRvbkVsZW1lbnQuaWQgPSAnZXhjYWxpYnVyLXBsYXknO1xyXG4gICAgICAgICAgICBidXR0b25FbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5wbGF5QnV0dG9uVGV4dDtcclxuICAgICAgICAgICAgYnV0dG9uRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uRWxlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICAgICAgaWYgKGxvYWRhYmxlcykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJlc291cmNlcyhsb2FkYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBfaW1hZ2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5zcmMgPSB0aGlzLmxvZ287XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcGxheUJ1dHRvblJvb3RFbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcGxheUJ1dHRvbkVsZW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlCdXR0b25FbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IF9wbGF5QnV0dG9uKCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGNhbGlidXItcGxheS1yb290Jyk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQgPSBleGlzdGluZ1Jvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuaWQgPSAnZXhjYWxpYnVyLXBsYXktcm9vdCc7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdHlsZUJsb2NrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZUJsb2NrLnRleHRDb250ZW50ID0gdGhpcy5fcGxheUJ1dHRvblN0eWxlcztcclxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9zdHlsZUJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wbGF5QnV0dG9uRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uRWxlbWVudCA9IHRoaXMuc3RhcnRCdXR0b25GYWN0b3J5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wbGF5QnV0dG9uRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5QnV0dG9uRWxlbWVudDtcclxuICAgIH1cclxuICAgIHdpcmVFbmdpbmUoZW5naW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5fZW5naW5lLmNhbnZhcy53aWR0aDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLl9lbmdpbmUuY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgcmVzb3VyY2UgdG8gdGhlIGxvYWRlciB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gbG9hZGFibGUgIFJlc291cmNlIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRSZXNvdXJjZShsb2FkYWJsZSkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX2luZGV4Kys7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMaXN0LnB1c2gobG9hZGFibGUpO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ291bnRzW2tleV0gPSAwO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsQ291bnRzW2tleV0gPSAxO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlQ291bnQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbGlzdCBvZiByZXNvdXJjZXMgdG8gdGhlIGxvYWRlciB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gbG9hZGFibGVzICBUaGUgbGlzdCBvZiByZXNvdXJjZXMgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBhZGRSZXNvdXJjZXMobG9hZGFibGVzKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGxvYWRhYmxlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZShsb2FkYWJsZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlbHkgbG9hZGVkIGFsbCByZXNvdXJjZXNcclxuICAgICAqL1xyXG4gICAgaXNMb2FkZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bUxvYWRlZCA9PT0gdGhpcy5fcmVzb3VyY2VDb3VudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIHBsYXkgYnV0dG9uIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gY2xpY2tlZFxyXG4gICAgICovXHJcbiAgICBhc3luYyBzaG93UGxheUJ1dHRvbigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzUGxheUJ1dHRvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVQbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IGlzIHRvIGdpdmUgdGhlIGxvZ28gYSBjaGFuY2UgdG8gc2hvdywgb3RoZXJ3aXNlIGRvbid0IGRlbGF5XHJcbiAgICAgICAgICAgIGF3YWl0IGRlbGF5KDUwMCwgKF9hID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUGxheUJ1dHRvbigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoKF9iID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmJyb3dzZXIud2luZG93Lm9uKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU2hvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5rZXkgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblBsYXlCdXR0b24oKTtcclxuICAgICAgICAgICAgY29uc3QgcGxheUJ1dHRvbkNsaWNrZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRCdXR0b25IYW5kbGVyID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIHRvIGtlZXAgYnViYmxpbmcgdG8gdGhlIGVuZ2luZSBwb2ludGVyIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIEJ1dHRvbiBhZnRlciBjbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBsYXlCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuYnJvd3Nlci53aW5kb3cub2ZmKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEJ1dHRvbkhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHN0YXJ0QnV0dG9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHN0YXJ0QnV0dG9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcGxheUJ1dHRvbkNsaWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGlkZVBsYXlCdXR0b24oKSB7XHJcbiAgICAgICAgdGhpcy5fcGxheUJ1dHRvblNob3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBnZW5lcmF0ZWQgZWxlbWVudHMgZm9yIHRoZSBsb2FkZXJcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3BsYXlCdXR0b25FbGVtZW50KTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHRoaXMuX3N0eWxlQmxvY2spO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlQmxvY2sgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBvdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgYXJlUmVzb3VyY2VzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nRnV0dXJlLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2luIGxvYWRpbmcgYWxsIG9mIHRoZSBzdXBwbGllZCByZXNvdXJjZXMsIHJldHVybmluZyBhIHByb21pc2VcclxuICAgICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZSBBTkQgdGhlIHVzZXIgaGFzIGNsaWNrZWQgdGhlIFwiUGxheSBidXR0b25cIlxyXG4gICAgICovXHJcbiAgICBhc3luYyBsb2FkKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuX2ltYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb2RlKCkpOyAvLyBkZWNvZGUgbG9nbyBpZiBpdCBleGlzdHNcclxuICAgICAgICB0aGlzLmNhbnZhcy5mbGFnRGlydHkoKTtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9yZXNvdXJjZUxpc3QubWFwKGFzeW5jIChyKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHIubG9hZCgpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBwcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtTG9hZGVkKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5mbGFnRGlydHkoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIFdpcmUgYWxsIHNvdW5kIHRvIHRoZSBlbmdpbmVcclxuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHRoaXMuX3Jlc291cmNlTGlzdCkge1xyXG4gICAgICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBTb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2Uud2lyZUVuZ2luZSh0aGlzLl9lbmdpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdGdXR1cmUucmVzb2x2ZSgpO1xyXG4gICAgICAgIC8vIHNob3J0IGRlbGF5IGluIHNob3dpbmcgdGhlIGJ1dHRvbiBmb3IgYWVzdGhldGljc1xyXG4gICAgICAgIGF3YWl0IGRlbGF5KDIwMCwgKF9iID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xvY2spO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2hvd1BsYXlCdXR0b24oKTtcclxuICAgICAgICAvLyBVbmxvY2sgYnJvd3NlciBBdWRpb0NvbnRleHQgaW4gYWZ0ZXIgdXNlciBnZXN0dXJlXHJcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2lzc3Vlcy8yNjJcclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzEwMzFcclxuICAgICAgICBhd2FpdCBXZWJBdWRpby51bmxvY2soKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZGF0YSA9IHRoaXMuX3Jlc291cmNlTGlzdCk7XHJcbiAgICB9XHJcbiAgICBtYXJrUmVzb3VyY2VDb21wbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLl9udW1Mb2FkZWQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvYWRlciBhcyBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcm9ncmVzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VDb3VudCA+IDAgPyBjbGFtcCh0aGlzLl9udW1Mb2FkZWQsIDAsIHRoaXMuX3Jlc291cmNlQ291bnQpIC8gdGhpcy5fcmVzb3VyY2VDb3VudCA6IDE7XHJcbiAgICB9XHJcbiAgICBfcG9zaXRpb25QbGF5QnV0dG9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gdGhpcy5fZW5naW5lLnNjcmVlbi52aWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbldpZHRoID0gdGhpcy5fZW5naW5lLnNjcmVlbi52aWV3cG9ydC53aWR0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2VuZ2luZS5jYW52YXMub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMuX2VuZ2luZS5jYW52YXMub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uV2lkdGggPSB0aGlzLl9wbGF5QnV0dG9uLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uSGVpZ2h0ID0gdGhpcy5fcGxheUJ1dHRvbi5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF5QnV0dG9uUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3RoaXMucGxheUJ1dHRvblBvc2l0aW9uLnh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5zdHlsZS50b3AgPSBgJHt0aGlzLnBsYXlCdXR0b25Qb3NpdGlvbi55fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7bGVmdCArIHNjcmVlbldpZHRoIC8gMiAtIGJ1dHRvbldpZHRoIC8gMn1weGA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIHNjcmVlbkhlaWdodCAvIDIgLSBidXR0b25IZWlnaHQgLyAyICsgMTAwfXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZGVyIGRyYXcgZnVuY3Rpb24uIERyYXdzIHRoZSBkZWZhdWx0IEV4Y2FsaWJ1ciBsb2FkaW5nIHNjcmVlbi5cclxuICAgICAqIE92ZXJyaWRlIGBsb2dvYCwgYGxvZ29XaWR0aGAsIGBsb2dvSGVpZ2h0YCBhbmQgYGJhY2tncm91bmRDb2xvcmAgcHJvcGVydGllc1xyXG4gICAgICogdG8gY3VzdG9taXplIHRoZSBkcmF3aW5nLCBvciBqdXN0IG92ZXJyaWRlIGVudGlyZSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gdGhpcy5fZW5naW5lLmNhbnZhc0hlaWdodCAvIHRoaXMuX2VuZ2luZS5waXhlbFJhdGlvO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gdGhpcy5fZW5naW5lLmNhbnZhc1dpZHRoIC8gdGhpcy5fZW5naW5lLnBpeGVsUmF0aW87XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25QbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICBsZXQgbG9nb1kgPSBjYW52YXNIZWlnaHQgLyAyO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4odGhpcy5sb2dvV2lkdGgsIGNhbnZhc1dpZHRoICogMC43NSk7XHJcbiAgICAgICAgbGV0IGxvZ29YID0gY2FudmFzV2lkdGggLyAyIC0gd2lkdGggLyAyO1xyXG4gICAgICAgIGlmICh0aGlzLmxvZ29Qb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsb2dvWCA9IHRoaXMubG9nb1Bvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGxvZ29ZID0gdGhpcy5sb2dvUG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSBNYXRoLmZsb29yKHdpZHRoICogKHRoaXMubG9nb0hlaWdodCAvIHRoaXMubG9nb1dpZHRoKSk7IC8vIE9HIGhlaWdodC93aWR0aCBmYWN0b3JcclxuICAgICAgICBjb25zdCBvbGRBbnRpYWxpYXMgPSB0aGlzLl9lbmdpbmUuZ2V0QW50aWFsaWFzaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyh0cnVlKTtcclxuICAgICAgICBpZiAoIXRoaXMubG9nb1Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDAsIHRoaXMubG9nb1dpZHRoLCB0aGlzLmxvZ29IZWlnaHQsIGxvZ29YLCBsb2dvWSAtIGltYWdlSGVpZ2h0IC0gMjAsIHdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwLCB0aGlzLmxvZ29XaWR0aCwgdGhpcy5sb2dvSGVpZ2h0LCBsb2dvWCwgbG9nb1ksIHdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvYWRpbmcgYm94XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHByZXNzUGxheUJ1dHRvbiAmJiB0aGlzLl9wbGF5QnV0dG9uU2hvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2FkaW5nWCA9IGxvZ29YO1xyXG4gICAgICAgIGxldCBsb2FkaW5nWSA9IGxvZ29ZO1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdCYXJQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsb2FkaW5nWCA9IHRoaXMubG9hZGluZ0JhclBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGxvYWRpbmdZID0gdGhpcy5sb2FkaW5nQmFyUG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgcm91bmRSZWN0KGN0eCwgbG9hZGluZ1gsIGxvYWRpbmdZLCB3aWR0aCwgMjAsIDEwLCB0aGlzLmxvYWRpbmdCYXJDb2xvcik7XHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB3aWR0aCAqIHRoaXMucHJvZ3Jlc3M7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0gNTtcclxuICAgICAgICBjb25zdCBwcm9ncmVzc1dpZHRoID0gcHJvZ3Jlc3MgLSBtYXJnaW4gKiAyO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IDIwIC0gbWFyZ2luICogMjtcclxuICAgICAgICByb3VuZFJlY3QoY3R4LCBsb2FkaW5nWCArIG1hcmdpbiwgbG9hZGluZ1kgKyBtYXJnaW4sIHByb2dyZXNzV2lkdGggPiAxMCA/IHByb2dyZXNzV2lkdGggOiAxMCwgaGVpZ2h0LCA1LCBudWxsLCB0aGlzLmxvYWRpbmdCYXJDb2xvcik7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9EZXRlY3Rvci50c1xuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBsaXN0IG9mIGZlYXR1cmVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxvZyB0aGUgc3VwcG9ydGVkXHJcbiAqIGZlYXR1cmVzIHRvIHRoZSBjb25zb2xlIHdoZW4gRGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCkgaXMgY2FsbGVkLlxyXG4gKi9cclxuY29uc3QgUkVQT1JURURfRkVBVFVSRVMgPSB7XHJcbiAgICB3ZWJnbDogJ1dlYkdMJyxcclxuICAgIHdlYmF1ZGlvOiAnV2ViQXVkaW8nLFxyXG4gICAgZ2FtZXBhZGFwaTogJ0dhbWVwYWQgQVBJJ1xyXG59O1xyXG4vKipcclxuICogRXhjYWxpYnVyIGludGVybmFsIGZlYXR1cmUgZGV0ZWN0aW9uIGhlbHBlciBjbGFzc1xyXG4gKi9cclxuY2xhc3MgRGV0ZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkVGVzdHMgPSBbXTtcclxuICAgICAgICAvLyBjcml0aWNhbCBicm93c2VyIGZlYXR1cmVzIHJlcXVpcmVkIGZvciBleCB0byBydW5cclxuICAgICAgICB0aGlzLl9jcml0aWNhbFRlc3RzID0ge1xyXG4gICAgICAgICAgICAvLyBUZXN0IGNhbnZhcy8yZCBjb250ZXh0IHN1cHBvcnRcclxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IGFycmF5IGJ1ZmZlciBzdXBwb3J0IGV4IHVzZXMgZm9yIGRvd25sb2FkaW5nIGJpbmFyeSBkYXRhXHJcbiAgICAgICAgICAgIGFycmF5QnVmZmVyU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgJy8nKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IGRhdGEgdXJscyBleCB1c2VzIGZvciBzcHJpdGVzXHJcbiAgICAgICAgICAgIGRhdGFVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5pbmRleE9mKCdkYXRhOmltYWdlL3BuZycpID09PSAwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IG9iamVjdCB1cmwgc3VwcG9ydCBmb3IgbG9hZGluZ1xyXG4gICAgICAgICAgICBvYmplY3RVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdyZXZva2VPYmplY3RVUkwnIGluIFVSTCAmJiAnY3JlYXRlT2JqZWN0VVJMJyBpbiBVUkw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIFJHQkEgc3VwcG9ydCBmb3IgY29sb3JzXHJcbiAgICAgICAgICAgIHJnYmFTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSAnYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE1MCwyNTUsMTUwLC41KSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgc3R5bGUuYmFja2dyb3VuZENvbG9yKS5pbmRleE9mKCdyZ2JhJykgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gd2FybmluZ3MgZXhjYWxpYnVyIHBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWRcclxuICAgICAgICB0aGlzLl93YXJuaW5nVGVzdCA9IHtcclxuICAgICAgICAgICAgd2ViQXVkaW9TdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISEod2luZG93LkF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9BdWRpb0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3ZWJnbFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCd3ZWJnbCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgY3VycmVudGx5IHN1cHBvcnRlZCBicm93c2VyIGZlYXR1cmVzLiBUaGlzIG1ldGhvZFxyXG4gICAgICogdHJlYXRzIHRoZSBmZWF0dXJlcyBhcyBhIHNpbmdsZXRvbiBhbmQgd2lsbCBvbmx5IGNhbGN1bGF0ZSBmZWF0dXJlXHJcbiAgICAgKiBzdXBwb3J0IGlmIGl0IGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGRvbmUuXHJcbiAgICAgKi9cclxuICAgIGdldEJyb3dzZXJGZWF0dXJlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmVhdHVyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwb3J0IG9uIG5vbi1jcml0aWNhbCBicm93c2VyIHN1cHBvcnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAqIFVzZSBuYXRpdmUgYnJvd3NlciBjb25zb2xlIGNvbG9ycyBmb3IgdmlzaWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgbG9nQnJvd3NlckZlYXR1cmVzKCkge1xyXG4gICAgICAgIGxldCBtc2cgPSAnJWNTVVBQT1JURUQgQlJPV1NFUiBGRUFUVVJFU1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09JWNcXG4nO1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogbmF2eScsICdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCddO1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IHRoaXMuZ2V0QnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIE9iamVjdC5rZXlzKFJFUE9SVEVEX0ZFQVRVUkVTKSkge1xyXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkW2ZlYXR1cmVdKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTMlYyknOyAvLyAo4pyTKVxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IGdyZWVuJyk7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTclYyknOyAvLyAo4pyXKVxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IHJlZCcpO1xyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1zZyArPSAnICcgKyBSRVBPUlRFRF9GRUFUVVJFU1tmZWF0dXJlXSArICdcXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcmdzLnVuc2hpZnQobXNnKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyBzZXZlcmFsIElJRkUncyB0byBnZXQgYSBjb25zdGFudCByZWZlcmVuY2UgdG8gc3VwcG9ydGVkXHJcbiAgICAgKiBmZWF0dXJlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIF9sb2FkQnJvd3NlckZlYXR1cmVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgY2FudmFzIHN1cHBvcnRcclxuICAgICAgICAgICAgY2FudmFzOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMuY2FudmFzU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGFycmF5YnVmZmVyIHN1cHBvcnRcclxuICAgICAgICAgICAgYXJyYXlidWZmZXI6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGljYWxUZXN0cy5hcnJheUJ1ZmZlclN1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBkYXRhdXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgZGF0YXVybDogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcml0aWNhbFRlc3RzLmRhdGFVcmxTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgb2JqZWN0dXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgb2JqZWN0dXJsOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMub2JqZWN0VXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHJnYmEgc3VwcG9ydFxyXG4gICAgICAgICAgICByZ2JhOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMucmdiYVN1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayB3ZWJhdWRpbyBzdXBwb3J0XHJcbiAgICAgICAgICAgIHdlYmF1ZGlvOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdUZXN0LndlYkF1ZGlvU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHdlYmdsIHN1cHBvcnRcclxuICAgICAgICAgICAgd2ViZ2w6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2FybmluZ1Rlc3Qud2ViZ2xTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZ2FtZXBhZGFwaSBzdXBwb3J0XHJcbiAgICAgICAgICAgIGdhbWVwYWRhcGk6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuYXZpZ2F0b3IuZ2V0R2FtZXBhZHM7XHJcbiAgICAgICAgICAgIH0pKClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdGVzdCgpIHtcclxuICAgICAgICAvLyBDcml0aWNhbCB0ZXN0IHdpbGwgZm9yIGV4IG5vdCB0byBydW5cclxuICAgICAgICBsZXQgZmFpbGVkQ3JpdGljYWwgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3QgaW4gdGhpcy5fY3JpdGljYWxUZXN0cykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NyaXRpY2FsVGVzdHNbdGVzdF0uY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRUZXN0cy5wdXNoKHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0NyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZSBtaXNzaW5nLCBFeGNhbGlidXIgcmVxdWlyZXM6JywgdGVzdCk7XHJcbiAgICAgICAgICAgICAgICBmYWlsZWRDcml0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhaWxlZENyaXRpY2FsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2FybmluZyB0ZXN0cyBkbyBub3QgZm9yIGV4IHRvIHJldHVybiBmYWxzZSB0byBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgZm9yIChjb25zdCB3YXJuaW5nIGluIHRoaXMuX3dhcm5pbmdUZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FybmluZ1Rlc3Rbd2FybmluZ10oKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignV2FybmluZyBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHdpbGwgaGF2ZSByZWR1Y2VkIHBlcmZvcm1hbmNlOicsIHdhcm5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpc2lvblR5cGUudHNcbi8qKlxyXG4gKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGJvZGllcyBjYW4gcGFydGljaXBhdGUgaW5cclxuICovXHJcbnZhciBDb2xsaXNpb25UeXBlO1xyXG4oZnVuY3Rpb24gKENvbGxpc2lvblR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogQm9kaWVzIHdpdGggdGhlIGBQcmV2ZW50Q29sbGlzaW9uYCBzZXR0aW5nIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBhbnlcclxuICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBDb2xsaXNpb25UeXBlW1wiUHJldmVudENvbGxpc2lvblwiXSA9IFwiUHJldmVudENvbGxpc2lvblwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb2RpZXMgd2l0aCB0aGUgYFBhc3NpdmVgIHNldHRpbmcgb25seSByYWlzZSBjb2xsaXNpb24gZXZlbnRzLCBidXQgYXJlIG5vdFxyXG4gICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBib2RpZXMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBib2RpZXMuXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdXNlIGluIHRyaWdnZXIgdHlwZSBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIlBhc3NpdmVcIl0gPSBcIlBhc3NpdmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQm9kaWVzIHdpdGggdGhlIGBBY3RpdmVgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGVcclxuICAgICAqIGluIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBib2RpZXMgYW5kIHdpbGwgYmUgcHVzaCBvciBtb3ZlZCBieSBib2RpZXMgc2hhcmluZ1xyXG4gICAgICogdGhlIGBBY3RpdmVgIG9yIGBGaXhlZGAgc2V0dGluZy5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIkFjdGl2ZVwiXSA9IFwiQWN0aXZlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJvZGllcyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGUgaW5cclxuICAgICAqIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBib2RpZXMuIEFjdG9ycyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgd2lsbCBub3QgYmVcclxuICAgICAqIHB1c2hlZCBvciBtb3ZlZCBieSBvdGhlciBib2RpZXMgc2hhcmluZyB0aGUgYEZpeGVkYC4gVGhpbmsgb2YgRml4ZWRcclxuICAgICAqIGJvZGllcyBhcyBcImltbW92YWJsZS91bnN0b3BwYWJsZVwiIG9iamVjdHMuIElmIHR3byBgRml4ZWRgIGJvZGllcyBtZWV0IHRoZXkgd2lsbFxyXG4gICAgICogbm90IGJlIHB1c2hlZCBvciBtb3ZlZCBieSBlYWNoIG90aGVyLCB0aGV5IHdpbGwgbm90IGludGVyYWN0IGV4Y2VwdCB0byB0aHJvd1xyXG4gICAgICogY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIkZpeGVkXCJdID0gXCJGaXhlZFwiO1xyXG59KShDb2xsaXNpb25UeXBlIHx8IChDb2xsaXNpb25UeXBlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0RlY29yYXRvcnMudHNcblxyXG5cclxuY29uc3QgbWF4TWVzc2FnZXMgPSA1O1xyXG5jb25zdCBvYnNvbGV0ZU1lc3NhZ2UgPSB7fTtcclxuY29uc3QgcmVzZXRPYnNvbGV0ZUNvdW50ZXIgPSAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2UgaW4gb2Jzb2xldGVNZXNzYWdlKSB7XHJcbiAgICAgICAgb2Jzb2xldGVNZXNzYWdlW21lc3NhZ2VdID0gMDtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nTWVzc2FnZSA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XHJcbiAgICBjb25zdCBzdXBwcmVzc09ic29sZXRlTWVzc2FnZXMgPSBGbGFncy5pc0VuYWJsZWQoJ3N1cHByZXNzLW9ic29sZXRlLW1lc3NhZ2UnKTtcclxuICAgIGlmIChvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0gPCBtYXhNZXNzYWdlcyAmJiAhc3VwcHJlc3NPYnNvbGV0ZU1lc3NhZ2VzKSB7XHJcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihtZXNzYWdlKTtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWNvbnNvbGVcclxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSAmJiBvcHRpb25zLnNob3dTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb2Jzb2xldGVNZXNzYWdlW21lc3NhZ2VdKys7XHJcbn07XHJcbi8qKlxyXG4gKiBPYnNvbGV0ZSBkZWNvcmF0b3IgZm9yIG1hcmtpbmcgRXhjYWxpYnVyIG1ldGhvZHMgb2Jzb2xldGUsIHlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgY3VzdG9tIG1lc3NhZ2UgYW5kL29yIGFsdGVybmF0ZSByZXBsYWNlbWVudFxyXG4gKiBtZXRob2QgZG8gdGhlIGRlcHJlY2F0ZWQgb25lLiBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vamF5cGhlbHBzL2NvcmUtZGVjb3JhdG9ycy5qc1xyXG4gKi9cclxuZnVuY3Rpb24gb2Jzb2xldGUob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgICBtZXNzYWdlOiAnVGhpcyBmZWF0dXJlIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRXhjYWxpYnVyLicsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiBudWxsLFxyXG4gICAgICAgIHNob3dTdGFja1RyYWNlOiBmYWxzZSxcclxuICAgICAgICAuLi5vcHRpb25zXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiZcclxuICAgICAgICAgICAgISh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ09ubHkgY2xhc3Nlcy9mdW5jdGlvbnMvZ2V0dGVycy9zZXR0ZXJzIGNhbiBiZSBtYXJrZWQgYXMgb2Jzb2xldGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gYCR7dGFyZ2V0Lm5hbWUgfHwgJyd9JHt0YXJnZXQubmFtZSAmJiBwcm9wZXJ0eSA/ICcuJyA6ICcnfSR7cHJvcGVydHkgPyBwcm9wZXJ0eSA6ICcnfWA7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke21ldGhvZFNpZ25hdHVyZX0gaXMgbWFya2VkIG9ic29sZXRlOiAke29wdGlvbnMubWVzc2FnZX1gICtcclxuICAgICAgICAgICAgKG9wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kID8gYCBVc2UgJHtvcHRpb25zLmFsdGVybmF0ZU1ldGhvZH0gaW5zdGVhZGAgOiAnJyk7XHJcbiAgICAgICAgaWYgKCFvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0pIHtcclxuICAgICAgICAgICAgb2Jzb2xldGVNZXNzYWdlW21lc3NhZ2VdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgZGVzY3JpcHRvciBpcyBudWxsIGl0IGlzIGEgY2xhc3NcclxuICAgICAgICBjb25zdCBtZXRob2QgPSBkZXNjcmlwdG9yID8geyAuLi5kZXNjcmlwdG9yIH0gOiB0YXJnZXQ7XHJcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIHdpdGggZXMyMDE1IGNsYXNzZXMgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGRlY29yYXRpb24gdGFjdGljXHJcbiAgICAgICAgICAgIGNsYXNzIERlY29yYXRlZENsYXNzIGV4dGVuZHMgbWV0aG9kIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dNZXNzYWdlKG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZWRDbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZSkge1xyXG4gICAgICAgICAgICBtZXRob2QudmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dNZXNzYWdlKG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQpIHtcclxuICAgICAgICAgICAgbWV0aG9kLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICAgICAgbWV0aG9kLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgIH07XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vUGh5c2ljcy50c1xudmFyIF9fZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFBvc3NpYmxlIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcclxuICpcclxuICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlXV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy4gVGhpcyBpcyB1c2VmdWwgZm9yIHRoaW5nc1xyXG4gKiBsaWtlIHBsYXRmb3JtZXJzIG9yIHRvcCBkb3duIGdhbWVzLlxyXG4gKlxyXG4gKiBNb3JlIGFkdmFuY2VkIHJpZ2lkIGJvZHkgcGh5c2ljcyBhcmUgZW5hYmxlZCBieSBzZXR0aW5nIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJlYWxpc3RpY11dIHdoaWNoIGFsbG93cyBmb3IgY29tcGxpY2F0ZWRcclxuICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICovXHJcbnZhciBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbXCJBcmNhZGVcIl0gPSBcImFyY2FkZVwiO1xyXG4gICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiUmVhbGlzdGljXCJdID0gXCJyZWFsaXN0aWNcIjtcclxufSkoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5IHx8IChDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSB7fSkpO1xyXG4vKipcclxuICogUG9zc2libGUgYnJvYWRwaGFzZSBjb2xsaXNpb24gcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVnaWVzXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIFtbQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZV1dIHdoaWNoIHVzZXMgYSBiaW5hcnkgdHJlZSBvZiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgdG8gaWRlbnRpZnlcclxuICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci5cclxuICovXHJcbnZhciBCcm9hZHBoYXNlU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQnJvYWRwaGFzZVN0cmF0ZWd5KSB7XHJcbiAgICBCcm9hZHBoYXNlU3RyYXRlZ3lbQnJvYWRwaGFzZVN0cmF0ZWd5W1wiRHluYW1pY0FBQkJUcmVlXCJdID0gMF0gPSBcIkR5bmFtaWNBQUJCVHJlZVwiO1xyXG59KShCcm9hZHBoYXNlU3RyYXRlZ3kgfHwgKEJyb2FkcGhhc2VTdHJhdGVneSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBQb3NzaWJsZSBudW1lcmljYWwgaW50ZWdyYXRvcnMgZm9yIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eVxyXG4gKi9cclxudmFyIEludGVncmF0b3I7XHJcbihmdW5jdGlvbiAoSW50ZWdyYXRvcikge1xyXG4gICAgSW50ZWdyYXRvcltJbnRlZ3JhdG9yW1wiRXVsZXJcIl0gPSAwXSA9IFwiRXVsZXJcIjtcclxufSkoSW50ZWdyYXRvciB8fCAoSW50ZWdyYXRvciA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgW1tQaHlzaWNzXV0gb2JqZWN0IGlzIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGFsbCBFeGNhbGlidXIgcGh5c2ljcy5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmNsYXNzIFBoeXNpY3Mge1xyXG4gICAgc3RhdGljIGdldCBncmF2aXR5KCkge1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzLmFjYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXQgZ3Jhdml0eSh2KSB7XHJcbiAgICAgICAgUGh5c2ljcy5hY2MgPSB2O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgXCJhcmNhZGVcIiBwaHlzaWNzLiBBcmNhZGUgcGh5c2ljcyB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlQXJjYWRlUGh5c2ljcygpIHtcclxuICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5BcmNhZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgRXhjYWxpYnVyIHRvIHVzZSByaWdpZCBib2R5IHBoeXNpY3MuIFJpZ2lkIGJvZHkgcGh5c2ljcyBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlUmVhbGlzdGljUGh5c2ljcygpIHtcclxuICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IGR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyKCkge1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcih2YWx1ZSkge1xyXG4gICAgICAgIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXIgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2xvYmFsIGFjY2VsZXJhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gYWxsIHZhbmlsbGEgYWN0b3JzIHRoYXQgaGF2ZSBhIFtbQ29sbGlzaW9uVHlwZS5BY3RpdmV8YWN0aXZlXV0gY29sbGlzaW9uIHR5cGUuXHJcbiAqIEdsb2JhbCBhY2NlbGVyYXRpb24gd29uJ3QgZWZmZWN0IFtbTGFiZWx8bGFiZWxzXV0sIFtbU2NyZWVuRWxlbWVudHx1aSBhY3RvcnNdXSwgb3IgW1tUcmlnZ2VyfHRyaWdnZXJzXV0gaW4gRXhjYWxpYnVyLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgZ3JlYXQgd2F5IHRvIGdsb2JhbGx5IHNpbXVsYXRlIGVmZmVjdHMgbGlrZSBncmF2aXR5LlxyXG4gKi9cclxuUGh5c2ljcy5hY2MgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4vKipcclxuICogR2xvYmFsbHkgc3dpdGNoZXMgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzIGJlaGF2aW9yIG9uIG9yIG9mZi5cclxuICovXHJcblBoeXNpY3MuZW5hYmxlZCA9IHRydWU7XHJcbi8qKlxyXG4gKiBHZXRzIG9yIHNldHMgdGhlIGJyb2FkcGhhc2UgcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVneS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlXV0gd2hpY2ggdXNlcyBhIGJpbmFyeSB0cmVlIG9mIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyB0byBpZGVudGlmeVxyXG4gKiBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obmxvZyhuKSkgZmFzdGVyLlxyXG4gKi9cclxuUGh5c2ljcy5icm9hZHBoYXNlU3RyYXRlZ3kgPSBCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlO1xyXG4vKipcclxuICogR2V0cyBvciBzZXRzIHRoZSBnbG9iYWwgY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3kgKG5hcnJvd3BoYXNlKS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlXV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICpcclxuICogTW9yZSBhZHZhbmNlZCByaWdpZCBib2R5IHBoeXNpY3MgYXJlIGVuYWJsZWQgYnkgc2V0dGluZyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWNdXSB3aGljaCBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAqL1xyXG5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5BcmNhZGU7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBtYXNzIHRvIHVzZSBpZiBub25lIGlzIHNwZWNpZmllZFxyXG4gKi9cclxuUGh5c2ljcy5kZWZhdWx0TWFzcyA9IDEwO1xyXG4vKipcclxuICogR2V0cyBvciBzZXRzIHRoZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgcG9zaXRpb25hbCBpbnRlZ3JhdG9yLCBjdXJyZW50bHkgb25seSBFdWxlciBpcyBzdXBwb3J0ZWQuXHJcbiAqL1xyXG5QaHlzaWNzLmludGVncmF0b3IgPSBJbnRlZ3JhdG9yLkV1bGVyO1xyXG4vKipcclxuICogRmFjdG9yIHRvIGFkZCB0byB0aGUgUmlnaWRCb2R5IEJvdW5kaW5nQm94LCBib3VuZGluZyBib3ggKGRpbWVuc2lvbnMgKz0gdmVsICogZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXIpO1xyXG4gKi9cclxuUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbGllciA9IDI7XHJcbi8qKlxyXG4gKiBQYWQgUmlnaWRCb2R5IEJvdW5kaW5nQm94IGJ5IGEgY29uc3RhbnQgYW1vdW50XHJcbiAqL1xyXG5QaHlzaWNzLmJvdW5kc1BhZGRpbmcgPSA1O1xyXG4vKipcclxuICogTnVtYmVyIG9mIHBvc2l0aW9uIGl0ZXJhdGlvbnMgKG92ZXJsYXApIHRvIHJ1biBpbiB0aGUgc29sdmVyXHJcbiAqL1xyXG5QaHlzaWNzLnBvc2l0aW9uSXRlcmF0aW9ucyA9IDM7XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgdmVsb2NpdHkgaXRlcmF0aW9uIChyZXNwb25zZSkgdG8gcnVuIGluIHRoZSBzb2x2ZXJcclxuICovXHJcblBoeXNpY3MudmVsb2NpdHlJdGVyYXRpb25zID0gODtcclxuLyoqXHJcbiAqIEFtb3VudCBvZiBvdmVybGFwIHRvIHRvbGVyYXRlIGluIHBpeGVsc1xyXG4gKi9cclxuUGh5c2ljcy5zbG9wID0gMTtcclxuLyoqXHJcbiAqIEFtb3VudCBvZiBwb3NpdGlvbmFsIG92ZXJsYXAgY29ycmVjdGlvbiB0byBhcHBseSBlYWNoIHBvc2l0aW9uIGl0ZXJhdGlvbiBvZiB0aGUgc29sdmVyXHJcbiAqIE8gLSBtZWFuaW5nIG5vIGNvcnJlY3Rpb24sIDEgLSBtZWFuaW5nIGNvcnJlY3QgYWxsIG92ZXJsYXBcclxuICovXHJcblBoeXNpY3Muc3RlZXJpbmdGYWN0b3IgPSAwLjI7XHJcbi8qKlxyXG4gKiBXYXJtIHN0YXJ0IHNldCB0byB0cnVlIHJlLXVzZXMgaW1wdWxzZXMgZnJvbSBwcmV2aW91cyBmcmFtZXMgYmFjayBpbiB0aGUgc29sdmVyXHJcbiAqL1xyXG5QaHlzaWNzLndhcm1TdGFydCA9IHRydWU7XHJcbi8qKlxyXG4gKiBCeSBkZWZhdWx0IGJvZGllcyBkbyBub3Qgc2xlZXBcclxuICovXHJcblBoeXNpY3MuYm9kaWVzQ2FuU2xlZXBCeURlZmF1bHQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFN1cmZhY2UgZXBzaWxvbiBpcyB1c2VkIHRvIGhlbHAgZGVhbCB3aXRoIHN1cmZhY2UgcGVuZXRyYXRpb25cclxuICovXHJcblBoeXNpY3Muc3VyZmFjZUVwc2lsb24gPSAwLjE7XHJcblBoeXNpY3Muc2xlZXBFcHNpbG9uID0gMC4wNztcclxuUGh5c2ljcy53YWtlVGhyZXNob2xkID0gUGh5c2ljcy5zbGVlcEVwc2lsb24gKiAzO1xyXG5QaHlzaWNzLnNsZWVwQmlhcyA9IDAuOTtcclxuLyoqXHJcbiAqIEVuYWJsZSBmYXN0IG1vdmluZyBib2R5IGNoZWNraW5nLCB0aGlzIGVuYWJsZXMgY2hlY2tpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyB2aWEgcmF5Y2FzdCBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0cyB0byBwcmV2ZW50XHJcbiAqIGJvZGllcyBmcm9tIHR1bm5lbGluZyB0aHJvdWdoIG9uZSBhbm90aGVyLlxyXG4gKi9cclxuUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMgPSB0cnVlO1xyXG4vKipcclxuICogRGlzYWJsZSBtaW5pbXVtIGZhc3QgbW92aW5nIGJvZHkgcmF5Y2FzdCwgYnkgZGVmYXVsdCBpZiBleC5QaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcyA9IHRydWUgRXhjYWxpYnVyIHdpbGwgb25seSBjaGVjayBpZiB0aGVcclxuICogYm9keSBpcyBtb3ZpbmcgYXQgbGVhc3QgaGFsZiBvZiBpdHMgbWluaW11bSBkaW1lbnNpb24gaW4gYW4gdXBkYXRlLiBJZiBleC5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSBpcyBzZXQgdG8gdHJ1ZSxcclxuICogRXhjYWxpYnVyIHdpbGwgYWx3YXlzIHBlcmZvcm0gdGhlIGZhc3QgYm9keSByYXljYXN0IHJlZ2FyZGxlc3Mgb2Ygc3BlZWQuXHJcbiAqL1xyXG5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSA9IGZhbHNlO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQWxpYXMgZm9yIGluY29ycmVjdCBzcGVsbGluZyB1c2VkIGluIG9sZGVyIHZlcnNpb25zLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXInXHJcbiAgICB9KVxyXG5dLCBQaHlzaWNzLCBcImR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyXCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvY29vcmQtcGxhbmUudHNcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgY29vcmRpbmF0ZSBwbGFuZSBmb3IgdGhlIHBvc2l0aW9uIDJEIHZlY3RvciBpbiB0aGUgW1tUcmFuc2Zvcm1Db21wb25lbnRdXVxyXG4gKi9cclxudmFyIENvb3JkUGxhbmU7XHJcbihmdW5jdGlvbiAoQ29vcmRQbGFuZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd29ybGQgY29vcmRpbmF0ZSBwbGFuZSAoZGVmYXVsdCkgcmVwcmVzZW50cyB3b3JsZCBzcGFjZSwgYW55IGVudGl0aWVzIGRyYXduIHdpdGggd29ybGRcclxuICAgICAqIHNwYWNlIG1vdmUgd2hlbiB0aGUgY2FtZXJhIG1vdmVzLlxyXG4gICAgICovXHJcbiAgICBDb29yZFBsYW5lW1wiV29ybGRcIl0gPSBcIndvcmxkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY3JlZW4gY29vcmRpbmF0ZSBwbGFuZSByZXByZXNlbnRzIHNjcmVlbiBzcGFjZSwgZW50aXRpZXMgZHJhd24gaW4gc2NyZWVuIHNwYWNlIGFyZSBwaW5uZWRcclxuICAgICAqIHRvIHNjcmVlbiBjb29yZGluYXRlcyBpZ25vcmluZyB0aGUgY2FtZXJhLlxyXG4gICAgICovXHJcbiAgICBDb29yZFBsYW5lW1wiU2NyZWVuXCJdID0gXCJzY3JlZW5cIjtcclxufSkoQ29vcmRQbGFuZSB8fCAoQ29vcmRQbGFuZSA9IHt9KSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC92ZWN0b3Itdmlldy50c1xuXHJcbmNsYXNzIFZlY3RvclZpZXcgZXh0ZW5kcyBWZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2dldFggPSBvcHRpb25zLmdldFg7XHJcbiAgICAgICAgdGhpcy5fZ2V0WSA9IG9wdGlvbnMuZ2V0WTtcclxuICAgICAgICB0aGlzLl9zZXRYID0gb3B0aW9ucy5zZXRYO1xyXG4gICAgICAgIHRoaXMuX3NldFkgPSBvcHRpb25zLnNldFk7XHJcbiAgICB9XHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3ggPSB0aGlzLl9nZXRYKCkpO1xyXG4gICAgfVxyXG4gICAgc2V0IHgodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0WCh2YWwpO1xyXG4gICAgICAgIHRoaXMuX3ggPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3kgPSB0aGlzLl9nZXRZKCkpO1xyXG4gICAgfVxyXG4gICAgc2V0IHkodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0WSh2YWwpO1xyXG4gICAgICAgIHRoaXMuX3kgPSB2YWw7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3dhdGNoLXZlY3Rvci50c1xuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIHZlY3RvciBhbmQgd2F0Y2hlcyBmb3IgY2hhbmdlcyBpbiB0aGUgeC95LCBtb2RpZmllcyB0aGUgb3JpZ2luYWwgdmVjdG9yLlxyXG4gKi9cclxuY2xhc3MgV2F0Y2hWZWN0b3IgZXh0ZW5kcyBWZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWwsIGNoYW5nZSkge1xyXG4gICAgICAgIHN1cGVyKG9yaWdpbmFsLngsIG9yaWdpbmFsLnkpO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDtcclxuICAgICAgICB0aGlzLmNoYW5nZSA9IGNoYW5nZTtcclxuICAgIH1cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl94ID0gdGhpcy5vcmlnaW5hbC54O1xyXG4gICAgfVxyXG4gICAgc2V0IHgobmV3WCkge1xyXG4gICAgICAgIHRoaXMuY2hhbmdlKG5ld1gsIHRoaXMuX3kpO1xyXG4gICAgICAgIHRoaXMuX3ggPSB0aGlzLm9yaWdpbmFsLnggPSBuZXdYO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kgPSB0aGlzLm9yaWdpbmFsLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgeShuZXdZKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2UodGhpcy5feCwgbmV3WSk7XHJcbiAgICAgICAgdGhpcy5feSA9IHRoaXMub3JpZ2luYWwueSA9IG5ld1k7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3RyYW5zZm9ybS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBUcmFuc2Zvcm0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BvcyA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB2ZWMoMSwgMSk7XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzSW52ZXJzZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgdGhpcy5faW52ZXJzZSA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gICAgfVxyXG4gICAgc2V0IHBhcmVudCh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHRyYW5zZm9ybTtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fY2hpbGRyZW4ucHVzaCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIGdldCBjaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBzZXQgcG9zKHYpIHtcclxuICAgICAgICBpZiAoIXYuZXF1YWxzKHRoaXMuX3BvcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zLnggPSB2Lng7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvcy55ID0gdi55O1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBXYXRjaFZlY3Rvcih0aGlzLl9wb3MsICh4LCB5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh4ICE9PSB0aGlzLl9wb3MueCB8fCB5ICE9PSB0aGlzLl9wb3MueSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0IGdsb2JhbFBvcyh2KSB7XHJcbiAgICAgICAgbGV0IGxvY2FsUG9zID0gdi5jbG9uZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICBsb2NhbFBvcyA9IHRoaXMucGFyZW50LmludmVyc2UubXVsdGlwbHkodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbG9jYWxQb3MuZXF1YWxzKHRoaXMuX3BvcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zID0gbG9jYWxQb3M7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGdsb2JhbFBvcygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZpZXcoe1xyXG4gICAgICAgICAgICBnZXRYOiAoKSA9PiB0aGlzLm1hdHJpeC5kYXRhWzRdLFxyXG4gICAgICAgICAgICBnZXRZOiAoKSA9PiB0aGlzLm1hdHJpeC5kYXRhWzVdLFxyXG4gICAgICAgICAgICBzZXRYOiAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4OiBuZXdYIH0gPSB0aGlzLnBhcmVudC5pbnZlcnNlLm11bHRpcGx5KHZlYyh4LCB0aGlzLnBvcy55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MueCA9IG5ld1g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcy54ID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ICE9PSB0aGlzLm1hdHJpeC5kYXRhWzRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0WTogKHkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeTogbmV3WSB9ID0gdGhpcy5wYXJlbnQuaW52ZXJzZS5tdWx0aXBseSh2ZWModGhpcy5wb3MueCwgeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zLnkgPSBuZXdZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MueSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSAhPT0gdGhpcy5tYXRyaXguZGF0YVs1XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbihyb3RhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGNhbm9uUm90YXRpb24gPSBjYW5vbmljYWxpemVBbmdsZShyb3RhdGlvbik7XHJcbiAgICAgICAgaWYgKGNhbm9uUm90YXRpb24gIT09IHRoaXMuX3JvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gY2Fub25Sb3RhdGlvbjtcclxuICAgIH1cclxuICAgIGdldCByb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgZ2xvYmFsUm90YXRpb24ocm90YXRpb24pIHtcclxuICAgICAgICBsZXQgaW52ZXJzZVJvdGF0aW9uID0gMDtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaW52ZXJzZVJvdGF0aW9uID0gdGhpcy5wYXJlbnQuZ2xvYmFsUm90YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbm9uUm90YXRpb24gPSBjYW5vbmljYWxpemVBbmdsZShyb3RhdGlvbiArIGludmVyc2VSb3RhdGlvbik7XHJcbiAgICAgICAgaWYgKGNhbm9uUm90YXRpb24gIT09IHRoaXMuX3JvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gY2Fub25Sb3RhdGlvbjtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxSb3RhdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldFJvdGF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjYWxlKHYpIHtcclxuICAgICAgICBpZiAoIXYuZXF1YWxzKHRoaXMuX3NjYWxlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZS54ID0gdi54O1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZS55ID0gdi55O1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdhdGNoVmVjdG9yKHRoaXMuX3NjYWxlLCAoeCwgeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoeCAhPT0gdGhpcy5fc2NhbGUueCB8fCB5ICE9PSB0aGlzLl9zY2FsZS55KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2xvYmFsU2NhbGUodikge1xyXG4gICAgICAgIGxldCBpbnZlcnNlU2NhbGUgPSB2ZWMoMSwgMSk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGludmVyc2VTY2FsZSA9IHRoaXMucGFyZW50Lmdsb2JhbFNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjYWxlID0gdi5zY2FsZSh2ZWMoMSAvIGludmVyc2VTY2FsZS54LCAxIC8gaW52ZXJzZVNjYWxlLnkpKTtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxTY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZpZXcoe1xyXG4gICAgICAgICAgICBnZXRYOiAoKSA9PiB0aGlzLnBhcmVudCA/IHRoaXMubWF0cml4LmdldFNjYWxlWCgpIDogdGhpcy5zY2FsZS54LFxyXG4gICAgICAgICAgICBnZXRZOiAoKSA9PiB0aGlzLnBhcmVudCA/IHRoaXMubWF0cml4LmdldFNjYWxlWSgpIDogdGhpcy5zY2FsZS55LFxyXG4gICAgICAgICAgICBzZXRYOiAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU2NhbGVYID0gdGhpcy5wYXJlbnQuZ2xvYmFsU2NhbGUueDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSB4IC8gZ2xvYmFsU2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0WTogKHkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNjYWxlWSA9IHRoaXMucGFyZW50Lmdsb2JhbFNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0geSAvIGdsb2JhbFNjYWxlWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBtYXRyaXgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlydHkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRyaXggPSB0aGlzLl9jYWxjdWxhdGVNYXRyaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hdHJpeCA9IHRoaXMucGFyZW50Lm1hdHJpeC5tdWx0aXBseSh0aGlzLl9jYWxjdWxhdGVNYXRyaXgoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xyXG4gICAgfVxyXG4gICAgZ2V0IGludmVyc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW52ZXJzZURpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludmVyc2UgPSB0aGlzLm1hdHJpeC5pbnZlcnNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW52ZXJzZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZlcnNlO1xyXG4gICAgfVxyXG4gICAgX2NhbGN1bGF0ZU1hdHJpeCgpIHtcclxuICAgICAgICBjb25zdCBtYXRyaXggPSBBZmZpbmVNYXRyaXguaWRlbnRpdHkoKVxyXG4gICAgICAgICAgICAudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpXHJcbiAgICAgICAgICAgIC5yb3RhdGUodGhpcy5yb3RhdGlvbilcclxuICAgICAgICAgICAgLnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgZmxhZ0RpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzSW52ZXJzZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFwcGx5KHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4Lm11bHRpcGx5KHBvaW50KTtcclxuICAgIH1cclxuICAgIGFwcGx5SW52ZXJzZShwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2UubXVsdGlwbHkocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgc2V0VHJhbnNmb3JtKHBvcywgcm90YXRpb24sIHNjYWxlKSB7XHJcbiAgICAgICAgdGhpcy5fcG9zLnggPSBwb3MueDtcclxuICAgICAgICB0aGlzLl9wb3MueSA9IHBvcy55O1xyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gY2Fub25pY2FsaXplQW5nbGUocm90YXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlLnggPSBzY2FsZS54O1xyXG4gICAgICAgIHRoaXMuX3NjYWxlLnkgPSBzY2FsZS55O1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZShkZXN0KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZGVzdCAhPT0gbnVsbCAmJiBkZXN0ICE9PSB2b2lkIDAgPyBkZXN0IDogbmV3IFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHRoaXMuX3Bvcy5jbG9uZSh0YXJnZXQuX3Bvcyk7XHJcbiAgICAgICAgdGFyZ2V0Ll9yb3RhdGlvbiA9IHRoaXMuX3JvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlLmNsb25lKHRhcmdldC5fc2NhbGUpO1xyXG4gICAgICAgIHRhcmdldC5mbGFnRGlydHkoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9Db21wb25lbnQudHNcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgY29tcG9uZW50IGltcGxlbWVudHMgY2xvbmVcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIGhhc0Nsb25lKHgpIHtcclxuICAgIHJldHVybiAhISh4ID09PSBudWxsIHx8IHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHguY2xvbmUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wb25lbnRzIGFyZSBjb250YWluZXJzIGZvciBzdGF0ZSBpbiBFeGNhbGlidXIsIHRoZSBhcmUgbWVhbnQgdG8gY29udmV5IGNhcGFiaWxpdGllcyB0aGF0IGFuIEVudGl0eSBwb3NzZXNzZXNcclxuICpcclxuICogSW1wbGVtZW50YXRpb25zIG9mIENvbXBvbmVudCBtdXN0IGhhdmUgYSB6ZXJvLWFyZyBjb25zdHJ1Y3RvciB0byBzdXBwb3J0IGRlcGVuZGVuY2llc1xyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgZXguQ29tcG9uZW50PCdteSc+IHtcclxuICogICBwdWJsaWMgcmVhZG9ubHkgdHlwZSA9ICdteSc7XHJcbiAqICAgLy8gemVybyBhcmcgc3VwcG9ydCByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgY29tcG9uZW50IGRlcGVuZGVuY2llc1xyXG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25hbFBvcz86IGV4LlZlY3Rvcikge31cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IG93bmluZyBbW0VudGl0eV1dLCBpZiBhbnksIG9mIHRoaXMgY29tcG9uZW50LiBOdWxsIGlmIG5vdCBhZGRlZCB0byBhbnkgW1tFbnRpdHldXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZXMgYW55IHByb3BlcnRpZXMgb24gdGhpcyBjb21wb25lbnQsIGlmIHRoYXQgcHJvcGVydHkgdmFsdWUgaGFzIGEgYGNsb25lKClgIG1ldGhvZCBpdCB3aWxsIGJlIGNhbGxlZFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBuZXdDb21wb25lbnQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0Nsb25lKHZhbCkgJiYgcHJvcCAhPT0gJ293bmVyJyAmJiBwcm9wICE9PSAnY2xvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tcG9uZW50W3Byb3BdID0gdmFsLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb21wb25lbnRbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0NvbXBvbmVudDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGFnIGNvbXBvbmVudHMgYXJlIGEgd2F5IG9mIHRhZ2dpbmcgYSBjb21wb25lbnQgd2l0aCBsYWJlbCBhbmQgYSBzaW1wbGUgdmFsdWVcclxuICpcclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgaXNPZmZzY3JlZW4gPSBuZXcgVGFnQ29tcG9uZW50KCdvZmZzY3JlZW4nKTtcclxuICogZW50aXR5LmFkZENvbXBvbmVudChpc09mZnNjcmVlbik7XHJcbiAqIGVudGl0eS50YWdzLmluY2x1ZGVzXHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgVGFnQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvT2JzZXJ2YWJsZS50c1xuLyoqXHJcbiAqIFNpbXBsZSBPYnNlcnZhYmxlIGltcGxlbWVudGF0aW9uXHJcbiAqIEB0ZW1wbGF0ZSBUIGlzIHRoZSB0eXBlc2NyaXB0IFR5cGUgdGhhdCBkZWZpbmVzIHRoZSBkYXRhIGJlaW5nIG9ic2VydmVkXHJcbiAqL1xyXG5jbGFzcyBPYnNlcnZhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIHRvIGxpc3RlbiB0byB0aGlzIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBvYnNlcnZlclxyXG4gICAgICovXHJcbiAgICByZWdpc3RlcihvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGxpc3RlbiB0byB0aGlzIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBmdW5jXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShmdW5jKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZnVuYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBvYnNlcnZlciBmcm9tIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgKiBAcGFyYW0gb2JzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlcihvYnNlcnZlcikge1xyXG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgY2FsbGJhY2sgdGhhdCBpcyBsaXN0ZW5pbmcgdG8gdGhpcyBvYnNlcnZhYmxlXHJcbiAgICAgKiBAcGFyYW0gZnVuY1xyXG4gICAgICovXHJcbiAgICB1bnN1YnNjcmliZShmdW5jKSB7XHJcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuc3Vic2NyaXB0aW9ucy5pbmRleE9mKGZ1bmMpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0cyBhIG1lc3NhZ2UgdG8gYWxsIG9ic2VydmVycyBhbmQgY2FsbGJhY2tzXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBub3RpZnlBbGwobWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyc0xlbmd0aCA9IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ic2VydmVyc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2ldLm5vdGlmeShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uc0xlbmd0aCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpcHRpb25zTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zW2ldKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgb2JzZXJ2ZXJzIGFuZCBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9Db21wb25lbnRzL1RyYW5zZm9ybUNvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFRyYW5zZm9ybUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC50cmFuc2Zvcm0nO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLl9hZGRDaGlsZFRyYW5zZm9ybSA9IChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFR4Q29tcG9uZW50ID0gY2hpbGQuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFR4Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFR4Q29tcG9uZW50Ll90cmFuc2Zvcm0ucGFyZW50ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgeiBpbmRleCBjaGFuZ2VzIG9uIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy56SW5kZXhDaGFuZ2VkJCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5feiA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFtbQ29vcmRQbGFuZXxjb29yZGluYXRlIHBsYW5lfF1dIGZvciB0aGlzIHRyYW5zZm9ybSBmb3IgdGhlIGVudGl0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvb3JkUGxhbmUgPSBDb29yZFBsYW5lLldvcmxkO1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICBvbkFkZChvd25lcikge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygb3duZXIuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGRUcmFuc2Zvcm0oY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvd25lci5jaGlsZHJlbkFkZGVkJC5zdWJzY3JpYmUoY2hpbGQgPT4gdGhpcy5fYWRkQ2hpbGRUcmFuc2Zvcm0oY2hpbGQpKTtcclxuICAgICAgICBvd25lci5jaGlsZHJlblJlbW92ZWQkLnN1YnNjcmliZShjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHhDb21wb25lbnQgPSBjaGlsZC5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHhDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkVHhDb21wb25lbnQuX3RyYW5zZm9ybS5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvblJlbW92ZShfcHJldmlvdXNPd25lcikge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgei1pbmRleCBvcmRlcmluZyBvZiB0aGUgZW50aXR5LCBhIGhpZ2hlciB2YWx1ZXMgYXJlIGRyYXduIG9uIHRvcCBvZiBsb3dlciB2YWx1ZXMuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSB6PTk5IHdvdWxkIGJlIGRyYXduIG9uIHRvcCBvZiB6PTAuXHJcbiAgICAgKi9cclxuICAgIGdldCB6KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96O1xyXG4gICAgfVxyXG4gICAgc2V0IHoodmFsKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkeiA9IHRoaXMuX3o7XHJcbiAgICAgICAgdGhpcy5feiA9IHZhbDtcclxuICAgICAgICBpZiAob2xkeiAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuekluZGV4Q2hhbmdlZCQubm90aWZ5QWxsKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLnBvcztcclxuICAgIH1cclxuICAgIHNldCBwb3Modikge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wb3MgPSB2O1xyXG4gICAgfVxyXG4gICAgZ2V0IGdsb2JhbFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLmdsb2JhbFBvcztcclxuICAgIH1cclxuICAgIHNldCBnbG9iYWxQb3Modikge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5nbG9iYWxQb3MgPSB2O1xyXG4gICAgfVxyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgcm90YXRpb24ocm90YXRpb24pIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxSb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IGdsb2JhbFJvdGF0aW9uKHJvdGF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICB9XHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybS5zY2FsZTtcclxuICAgIH1cclxuICAgIHNldCBzY2FsZSh2KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnNjYWxlID0gdjtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxTY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLmdsb2JhbFNjYWxlO1xyXG4gICAgfVxyXG4gICAgc2V0IGdsb2JhbFNjYWxlKHYpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uZ2xvYmFsU2NhbGUgPSB2O1xyXG4gICAgfVxyXG4gICAgYXBwbHlJbnZlcnNlKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLmFwcGx5SW52ZXJzZSh2KTtcclxuICAgIH1cclxuICAgIGFwcGx5KHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLmFwcGx5KHYpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL0NvbXBvbmVudHMvTW90aW9uQ29tcG9uZW50LnRzXG5cclxuXHJcbmNsYXNzIE1vdGlvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5tb3Rpb24nO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB2ZWxvY2l0eSBvZiBhbiBlbnRpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhY2NlbGVyYXRpb24gb2YgZW50aXR5IGluIHBpeGVscyBwZXIgc2Vjb25kXjJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzY2FsZSByYXRlIG9mIGNoYW5nZSBpbiBzY2FsZSB1bml0cyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2FsZUZhY3RvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IHdoaWNoIGlzIGhvdyBxdWlja2x5IHRoZSBlbnRpdHkgaXMgcm90YXRpbmcgaW4gcmFkaWFucyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGVudGl0eSwgYW5ndWxhciBhY2NlbGVyYXRpb24gaXMgdG9ycXVlICogaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG9ycXVlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmVydGlhIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIG1vdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5lcnRpYSA9IDE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vR3JvdXAvQ29sbGlzaW9uR3JvdXAudHNcbi8qKlxyXG4gKiBDb2xsaXNpb25Hcm91cHMgaW5kaWNhdGUgbGlrZSBtZW1iZXJzIHRoYXQgZG8gbm90IGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyLiBVc2UgW1tDb2xsaXNpb25Hcm91cE1hbmFnZXJdXSB0byBjcmVhdGUgW1tDb2xsaXNpb25Hcm91cF1dc1xyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogUGxheWVycyBoYXZlIGNvbGxpc2lvbiBncm91cCBcInBsYXllclwiXHJcbiAqXHJcbiAqICFbUGxheWVyIENvbGxpc2lvbiBHcm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNQbGF5ZXIucG5nKVxyXG4gKlxyXG4gKiBFbmVtaWVzIGhhdmUgY29sbGlzaW9uIGdyb3VwIFwiZW5lbXlcIlxyXG4gKlxyXG4gKiAhW0VuZW15IENvbGxpc2lvbiBHcm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNFbmVteS5wbmcpXHJcbiAqXHJcbiAqIEJsb2NrcyBoYXZlIGNvbGxpc2lvbiBncm91cCBcImdyb3VuZFwiXHJcbiAqXHJcbiAqICFbR3JvdW5kIGNvbGxpc2lvbiBncm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNHcm91bmQucG5nKVxyXG4gKlxyXG4gKiBQbGF5ZXJzIGRvbid0IGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyLCBidXQgZW5lbWllcyBhbmQgYmxvY2tzLiBMaWtld2lzZSwgZW5lbWllcyBkb24ndCBjb2xsaWRlIHdpdGggZWFjaCBvdGhlciBidXQgY29sbGlkZVxyXG4gKiB3aXRoIHBsYXllcnMgYW5kIGJsb2Nrcy5cclxuICpcclxuICogVGhpcyBpcyBkb25lIHdpdGggYml0bWFza2luZywgc2VlIHRoZSBmb2xsb3dpbmcgcHNldWRvLWNvZGVcclxuICpcclxuICogUGxheWVyR3JvdXAgPSBgMGIwMDFgXHJcbiAqIFBsYXllckdyb3VwTWFzayA9IGAwYjExMGBcclxuICpcclxuICogRW5lbXlHcm91cCA9IGAwYjAxMGBcclxuICogRW5lbXlHcm91cE1hc2sgPSBgMGIxMDFgXHJcbiAqXHJcbiAqIEJsb2NrR3JvdXAgPSBgMGIxMDBgXHJcbiAqIEJsb2NrR3JvdXBNYXNrID0gYDBiMDExYFxyXG4gKlxyXG4gKiBTaG91bGQgUGxheWVycyBjb2xsaWRlPyBObyBiZWNhdXNlIHRoZSBiaXR3aXNlIG1hc2sgZXZhbHVhdGVzIHRvIDBcclxuICogYChwbGF5ZXIxLmdyb3VwICYgcGxheWVyMi5tYXNrKSA9PT0gMGBcclxuICogYCgwYjAwMSAmIDBiMTEwKSA9PT0gMGBcclxuICpcclxuICogU2hvdWxkIFBsYXllcnMgYW5kIEVuZW1pZXMgY29sbGlkZT8gWWVzIGJlY2F1c2UgdGhlIGJpdHdpc2UgbWFzayBpcyBub24temVyb1xyXG4gKiBgKHBsYXllcjEuZ3JvdXAgJiBlbmVteTEubWFzaykgPT09IDFgXHJcbiAqIGAoMGIwMDEgJiAwYjEwMSkgPT09IDFgXHJcbiAqXHJcbiAqIFNob3VsZCBQbGF5ZXJzIGFuZCBCbG9ja3MgY29sbGlkZT8gWWVzIGJlY2F1c2UgdGhlIGJpdHdpc2UgbWFzayBpcyBub24temVyb1xyXG4gKiBgKHBsYXllcjEuZ3JvdXAgJiBibG9ja3MxLm1hc2spID09PSAxYFxyXG4gKiBgKDBiMDAxICYgMGIwMTEpID09PSAxYFxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uR3JvdXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTVE9QISEqKiBJdCBpcyBwcmVmZXJyZWQgdGhhdCBbW0NvbGxpc2lvbkdyb3VwTWFuYWdlci5jcmVhdGVdXSBpcyB1c2VkIHRvIGNyZWF0ZSBjb2xsaXNpb24gZ3JvdXBzXHJcbiAgICAgKiAgdW5sZXNzIHlvdSBrbm93IGhvdyB0byBjb25zdHJ1Y3QgdGhlIHByb3BlciBiaXRtYXNrcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzEwOTEgZm9yIG1vcmUgaW5mby5cclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IDMyIGJpdCBjYXRlZ29yeSBmb3IgdGhlIGdyb3VwLCBzaG91bGQgYmUgYSB1bmlxdWUgcG93ZXIgb2YgMi4gRm9yIGV4YW1wbGUgYDBiMDAxYCBvciBgMGIwMTBgXHJcbiAgICAgKiBAcGFyYW0gbWFzayAzMiBiaXQgbWFzayBvZiBjYXRlZ29yeSwgb3IgYH5jYXRlZ29yeWAgZ2VuZXJhbGx5LiBGb3IgYSBjYXRlZ29yeSBvZiBgMGIwMDFgLCB0aGUgbWFzayB3b3VsZCBiZSBgMGIxMTBgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNhdGVnb3J5LCBtYXNrKSB7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcnkgPSBjYXRlZ29yeTtcclxuICAgICAgICB0aGlzLl9tYXNrID0gbWFzaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAqL1xyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2F0ZWdvcnkgb2YgdGhlIGNvbGxpc2lvbiBncm91cCwgYSAzMiBiaXQgbnVtYmVyIHdoaWNoIHNob3VsZCBiZSBhIHVuaXF1ZSBwb3dlciBvZiAyXHJcbiAgICAgKi9cclxuICAgIGdldCBjYXRlZ29yeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWFzayBmb3IgdGhpcyBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlcyB3aGV0aGVyIDIgY29sbGlzaW9uIGdyb3VwcyBjYW4gY29sbGlkZVxyXG4gICAgICogQHBhcmFtIG90aGVyICBDb2xsaXNpb25Hcm91cFxyXG4gICAgICovXHJcbiAgICBjYW5Db2xsaWRlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmNhdGVnb3J5ICYgb3RoZXIubWFzaykgIT09IDAgJiYgKG90aGVyLmNhdGVnb3J5ICYgdGhpcy5tYXNrKSAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0cyB0aGUgY29sbGlzaW9uIGdyb3VwLiBGb3IgZXhhbXBsZSwgaWYgYmVmb3JlIHRoZSBncm91cCBzcGVjaWZpZWQgXCJwbGF5ZXJzXCIsXHJcbiAgICAgKiBpbnZlcnRpbmcgd291bGQgc3BlY2lmeSBhbGwgZ3JvdXBzIGV4Y2VwdCBwbGF5ZXJzXHJcbiAgICAgKiBAcmV0dXJucyBDb2xsaXNpb25Hcm91cFxyXG4gICAgICovXHJcbiAgICBpbnZlcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Hcm91cCgnfignICsgdGhpcy5uYW1lICsgJyknLCB+dGhpcy5jYXRlZ29yeSwgfnRoaXMubWFzayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgY29sbGlzaW9uIGdyb3VwcyB3aXRoIGVhY2ggb3RoZXIuIFRoZSBuZXcgZ3JvdXAgaW5jbHVkZXMgYWxsIG9mIHRoZSBwcmV2aW91cyBncm91cHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxpc2lvbkdyb3Vwc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tYmluZShjb2xsaXNpb25Hcm91cHMpIHtcclxuICAgICAgICBjb25zdCBjb21iaW5lZE5hbWUgPSBjb2xsaXNpb25Hcm91cHMubWFwKChjKSA9PiBjLm5hbWUpLmpvaW4oJysnKTtcclxuICAgICAgICBjb25zdCBjb21iaW5lZENhdGVnb3J5ID0gY29sbGlzaW9uR3JvdXBzLnJlZHVjZSgoY3VycmVudCwgZykgPT4gZy5jYXRlZ29yeSB8IGN1cnJlbnQsIDBiMCk7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRNYXNrID0gfmNvbWJpbmVkQ2F0ZWdvcnk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Hcm91cChjb21iaW5lZE5hbWUsIGNvbWJpbmVkQ2F0ZWdvcnksIGNvbWJpbmVkTWFzayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsaXNpb24gZ3JvdXAgdGhhdCBjb2xsaWRlcyB3aXRoIHRoZSBsaXN0ZWQgZ3JvdXBzXHJcbiAgICAgKiBAcGFyYW0gY29sbGlzaW9uR3JvdXBzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb2xsaWRlc1dpdGgoY29sbGlzaW9uR3JvdXBzKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkdyb3VwLmNvbWJpbmUoY29sbGlzaW9uR3JvdXBzKS5pbnZlcnQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGBBbGxgIFtbQ29sbGlzaW9uR3JvdXBdXSBpcyBhIHNwZWNpYWwgZ3JvdXAgdGhhdCBjb2xsaWRlcyB3aXRoIGFsbCBvdGhlciBncm91cHMgaW5jbHVkaW5nIGl0c2VsZixcclxuICogaXQgaXMgdGhlIGRlZmF1bHQgY29sbGlzaW9uIGdyb3VwIG9uIGNvbGxpZGVycy5cclxuICovXHJcbkNvbGxpc2lvbkdyb3VwLkFsbCA9IG5ldyBDb2xsaXNpb25Hcm91cCgnQ29sbGlkZSB3aXRoIGFsbCBncm91cHMnLCAtMSwgLTEpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9EZXRlY3Rpb24vUGFpci50c1xuXHJcblxyXG4vKipcclxuICogTW9kZWxzIGEgcG90ZW50aWFsIGNvbGxpc2lvbiBiZXR3ZWVuIDIgY29sbGlkZXJzXHJcbiAqL1xyXG5jbGFzcyBQYWlyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyQSwgY29sbGlkZXJCKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlckEgPSBjb2xsaWRlckE7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlckIgPSBjb2xsaWRlckI7XHJcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goY29sbGlkZXJBLmlkLCBjb2xsaWRlckIuaWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBpdCBpcyBhbGxvd2VkIGZvciAyIGNvbGxpZGVycyBpbiBhIFBhaXIgdG8gY29sbGlkZVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyQVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyQlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2FuQ29sbGlkZShjb2xsaWRlckEsIGNvbGxpZGVyQikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEgPT09IG51bGwgfHwgY29sbGlkZXJBID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb2xsaWRlckIgPT09IG51bGwgfHwgY29sbGlkZXJCID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgLy8gUHJldmVudCBzZWxmIGNvbGxpc2lvblxyXG4gICAgICAgIGlmIChjb2xsaWRlckEuaWQgPT09IGNvbGxpZGVyQi5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbGxpZGVycyB3aXRoIHRoZSBzYW1lIG93bmVyIGRvIG5vdCBjb2xsaWRlIChjb21wb3NpdGUgY29sbGlkZXJzKVxyXG4gICAgICAgIGlmIChjb2xsaWRlckEub3duZXIgJiZcclxuICAgICAgICAgICAgY29sbGlkZXJCLm93bmVyICYmXHJcbiAgICAgICAgICAgIGNvbGxpZGVyQS5vd25lci5pZCA9PT0gY29sbGlkZXJCLm93bmVyLmlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHBhaXIgaGFzIGEgbWVtYmVyIHdpdGggemVybyBkaW1lbnNpb24gZG9uJ3QgY29sbGlkZVxyXG4gICAgICAgIGlmIChjb2xsaWRlckEubG9jYWxCb3VuZHMuaGFzWmVyb0RpbWVuc2lvbnMoKSB8fCBjb2xsaWRlckIubG9jYWxCb3VuZHMuaGFzWmVyb0RpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJvZHkncyBuZWVkZWQgZm9yIGNvbGxpc2lvbiBpbiB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIC8vIFRPRE8gY2FuIHdlIGNvbGxpZGUgd2l0aG91dCBhIGJvZHk/XHJcbiAgICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBib3RoIGFyZSBpbiB0aGUgc2FtZSBjb2xsaXNpb24gZ3JvdXAgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmICghYm9keUEuZ3JvdXAuY2FuQ29sbGlkZShib2R5Qi5ncm91cCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBib3RoIGFyZSBmaXhlZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBlaXRoZXIgaXMgcHJldmVudCBjb2xsaXNpb24gc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gfHwgYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgZWl0aGVyIGlzIGRlYWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmICghYm9keUEuYWN0aXZlIHx8ICFib2R5Qi5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhaXJzIHRvIGNvbGxpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbkNvbGxpZGUoKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJBID0gdGhpcy5jb2xsaWRlckE7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJCID0gdGhpcy5jb2xsaWRlckI7XHJcbiAgICAgICAgcmV0dXJuIFBhaXIuY2FuQ29sbGlkZShjb2xsaWRlckEsIGNvbGxpZGVyQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGNvbGxpc2lvbiBpbnRlcnNlY3Rpb24gbG9naWMgb24gdGhlIG1lbWJlcnMgb2YgdGhpcyBwYWlyXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJBLmNvbGxpZGUodGhpcy5jb2xsaWRlckIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgY29sbGlkZXIgaXMgcGFydCBvZiB0aGUgcGFpclxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGhhc0NvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyID09PSB0aGlzLmNvbGxpZGVyQSB8fCBjb2xsaWRlciA9PT0gdGhpcy5jb2xsaWRlckI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHVuaXF1ZSBwYWlyIGhhc2ggaWQgZm9yIHRoaXMgY29sbGlzaW9uIHBhaXIgKG93bmluZyBpZClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNhbGN1bGF0ZVBhaXJIYXNoKGlkQSwgaWRCKSB7XHJcbiAgICAgICAgaWYgKGlkQS52YWx1ZSA8IGlkQi52YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCMke2lkQS52YWx1ZX0rJHtpZEIudmFsdWV9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgIyR7aWRCLnZhbHVlfSske2lkQS52YWx1ZX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvcHJvamVjdGlvbi50c1xuLyoqXHJcbiAqIEEgMSBkaW1lbnNpb25hbCBwcm9qZWN0aW9uIG9uIGFuIGF4aXMsIHVzZWQgdG8gdGVzdCBvdmVybGFwc1xyXG4gKi9cclxuY2xhc3MgUHJvamVjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4sIG1heCkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgb3ZlcmxhcHMocHJvamVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heCA+IHByb2plY3Rpb24ubWluICYmIHByb2plY3Rpb24ubWF4ID4gdGhpcy5taW47XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGFwKHByb2plY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5vdmVybGFwcyhwcm9qZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXggPiBwcm9qZWN0aW9uLm1heCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb24ubWF4IC0gdGhpcy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggLSBwcm9qZWN0aW9uLm1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9EZXRlY3Rpb24vRHluYW1pY1RyZWUudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIER5bmFtaWMgVHJlZSBOb2RlIHVzZWQgZm9yIHRyYWNraW5nIGJvdW5kcyB3aXRoaW4gdGhlIHRyZWVcclxuICovXHJcbmNsYXNzIFRyZWVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgfVxyXG4gICAgaXNMZWFmKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5sZWZ0ICYmICF0aGlzLnJpZ2h0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgRHluYW1pY1RyZWVzIHByb3ZpZGVzIGEgc3BhdGlhbCBwYXJ0aXRpb25pbmcgZGF0YSBzdHJ1Y3R1cmUgZm9yIHF1aWNrbHkgcXVlcnlpbmcgZm9yIG92ZXJsYXBwaW5nIGJvdW5kaW5nIGJveGVzIGZvclxyXG4gKiBhbGwgdHJhY2tlZCBib2RpZXMuIFRoZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIG9mIHRoaXMgaXMgTyhuKmxvZyhuKSkgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGJvZGllcyBpbiB0aGUgdHJlZS5cclxuICpcclxuICogSW50ZXJuYWxseSB0aGUgYm91bmRpbmcgYm94ZXMgYXJlIG9yZ2FuaXplZCBhcyBhIGJhbGFuY2VkIGJpbmFyeSB0cmVlIG9mIGJvdW5kaW5nIGJveGVzLCB3aGVyZSB0aGUgbGVhZiBub2RlcyBhcmUgdHJhY2tlZCBib2RpZXMuXHJcbiAqIEV2ZXJ5IG5vbi1sZWFmIG5vZGUgaXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBjaGlsZCBib3VuZGluZyBib3hlcy5cclxuICovXHJcbmNsYXNzIER5bmFtaWNUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHdvcmxkQm91bmRzID0gbmV3IEJvdW5kaW5nQm94KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSkpIHtcclxuICAgICAgICB0aGlzLndvcmxkQm91bmRzID0gd29ybGRCb3VuZHM7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5vZGVzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBub2RlIGludG8gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICovXHJcbiAgICBfaW5zZXJ0KGxlYWYpIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbm9kZXMgaW4gdGhlIHRyZWUsIG1ha2UgdGhpcyB0aGUgcm9vdCBsZWFmXHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWFmO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWFyY2ggdGhlIHRyZWUgZm9yIGEgbm9kZSB0aGF0IGlzIG5vdCBhIGxlYWYgYW5kIGZpbmQgdGhlIGJlc3QgcGxhY2UgdG8gaW5zZXJ0XHJcbiAgICAgICAgY29uc3QgbGVhZkFBQkIgPSBsZWFmLmJvdW5kcztcclxuICAgICAgICBsZXQgY3VycmVudFJvb3QgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgd2hpbGUgKCFjdXJyZW50Um9vdC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gY3VycmVudFJvb3QubGVmdDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBjdXJyZW50Um9vdC5yaWdodDtcclxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGN1cnJlbnRSb290LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgY29tYmluZWRBQUJCID0gY3VycmVudFJvb3QuYm91bmRzLmNvbWJpbmUobGVhZkFBQkIpO1xyXG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb3N0IGhldXJpc3RpYyBmb3IgY3JlYXRpbmcgYSBuZXcgcGFyZW50IGFuZCBsZWFmXHJcbiAgICAgICAgICAgIGNvbnN0IGNvc3QgPSAyICogY29tYmluZWRBcmVhO1xyXG4gICAgICAgICAgICAvLyBNaW5pbXVtIGNvc3Qgb2YgcHVzaGluZyB0aGUgbGVhZiBkb3duIHRoZSB0cmVlXHJcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhbmNlQ29zdCA9IDIgKiAoY29tYmluZWRBcmVhIC0gYXJlYSk7XHJcbiAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZ1xyXG4gICAgICAgICAgICBsZXQgbGVmdENvc3QgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKGxlZnQuYm91bmRzKTtcclxuICAgICAgICAgICAgbGV0IG5ld0FyZWE7XHJcbiAgICAgICAgICAgIGxldCBvbGRBcmVhO1xyXG4gICAgICAgICAgICBpZiAobGVmdC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdENvc3QgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbGRBcmVhID0gbGVmdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdBcmVhID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgbGVmdENvc3QgPSBuZXdBcmVhIC0gb2xkQXJlYSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmlnaHRDb3N0ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUocmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENvc3QgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2xkQXJlYSA9IHJpZ2h0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIG5ld0FyZWEgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gbmV3QXJlYSAtIG9sZEFyZWEgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29zdCBpcyBhY2NlcHRhYmxlXHJcbiAgICAgICAgICAgIGlmIChjb3N0IDwgbGVmdENvc3QgJiYgY29zdCA8IHJpZ2h0Q29zdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGVzY2VuZCB0byB0aGUgZGVwdGhzXHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q29zdCA8IHJpZ2h0Q29zdCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSByaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBwYXJlbnQgbm9kZSBhbmQgaW5zZXJ0IGludG8gdGhlIHRyZWVcclxuICAgICAgICBjb25zdCBvbGRQYXJlbnQgPSBjdXJyZW50Um9vdC5wYXJlbnQ7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gbmV3IFRyZWVOb2RlKG9sZFBhcmVudCk7XHJcbiAgICAgICAgbmV3UGFyZW50LmJvdW5kcyA9IGxlYWZBQUJCLmNvbWJpbmUoY3VycmVudFJvb3QuYm91bmRzKTtcclxuICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gY3VycmVudFJvb3QuaGVpZ2h0ICsgMTtcclxuICAgICAgICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIG5vdCB0aGUgcm9vdFxyXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50LmxlZnQgPT09IGN1cnJlbnRSb290KSB7XHJcbiAgICAgICAgICAgICAgICBvbGRQYXJlbnQubGVmdCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9sZFBhcmVudC5yaWdodCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xyXG4gICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgdGhlIHJvb3RcclxuICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcclxuICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcclxuICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3UGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWxrIHVwIHRoZSB0cmVlIGZpeGluZyBoZWlnaHRzIGFuZCBBQUJCc1xyXG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IGxlYWYucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuX2JhbGFuY2UoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgbGVmdCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCByaWdodCBjaGlsZCcgKyBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgKi9cclxuICAgIF9yZW1vdmUobGVhZikge1xyXG4gICAgICAgIGlmIChsZWFmID09PSB0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBsZWFmLnBhcmVudDtcclxuICAgICAgICBjb25zdCBncmFuZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgbGV0IHNpYmxpbmc7XHJcbiAgICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBsZWFmKSB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChncmFuZFBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQubGVmdCA9PT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5sZWZ0ID0gc2libGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LnJpZ2h0ID0gc2libGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IGdyYW5kUGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuX2JhbGFuY2UoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYWNrcyBhIGJvZHkgaW4gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICovXHJcbiAgICB0cmFja0NvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcmVlTm9kZSgpO1xyXG4gICAgICAgIG5vZGUuZGF0YSA9IGNvbGxpZGVyO1xyXG4gICAgICAgIG5vZGUuYm91bmRzID0gY29sbGlkZXIuYm91bmRzO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLmxlZnQgLT0gMjtcclxuICAgICAgICBub2RlLmJvdW5kcy50b3AgLT0gMjtcclxuICAgICAgICBub2RlLmJvdW5kcy5yaWdodCArPSAyO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLmJvdHRvbSArPSAyO1xyXG4gICAgICAgIHRoaXMubm9kZXNbY29sbGlkZXIuaWQudmFsdWVdID0gbm9kZTtcclxuICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGR5bmFtaWMgdHJlZSBnaXZlbiB0aGUgY3VycmVudCBib3VuZHMgb2YgZWFjaCBib2R5IGJlaW5nIHRyYWNrZWRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbY29sbGlkZXIuaWQudmFsdWVdO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGIgPSBjb2xsaWRlci5ib3VuZHM7XHJcbiAgICAgICAgLy8gaWYgdGhlIGJvZHkgaXMgb3V0c2lkZSB0aGUgd29ybGQgbm8gbG9uZ2VyIHVwZGF0ZSBpdFxyXG4gICAgICAgIGlmICghdGhpcy53b3JsZEJvdW5kcy5jb250YWlucyhiKSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDb2xsaWRlciB3aXRoIGlkICcgKyBjb2xsaWRlci5pZC52YWx1ZSArICcgaXMgb3V0c2lkZSB0aGUgd29ybGQgYm91bmRzIGFuZCB3aWxsIG5vIGxvbmdlciBiZSB0cmFja2VkIGZvciBwaHlzaWNzJyk7XHJcbiAgICAgICAgICAgIHRoaXMudW50cmFja0NvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5ib3VuZHMuY29udGFpbnMoYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgYi5sZWZ0IC09IFBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICBiLnRvcCAtPSBQaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgYi5yaWdodCArPSBQaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgYi5ib3R0b20gKz0gUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgIC8vIFRISVMgSVMgQ0FVU0lORyBVTkVDRVNTQVJZIENIRUNLU1xyXG4gICAgICAgIGlmIChjb2xsaWRlci5vd25lcikge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5ID0gKF9hID0gY29sbGlkZXIub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtdWx0ZHggPSAoKGJvZHkudmVsLnggKiAzMikgLyAxMDAwKSAqIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtdWx0ZHkgPSAoKGJvZHkudmVsLnkgKiAzMikgLyAxMDAwKSAqIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAobXVsdGR4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIubGVmdCArPSBtdWx0ZHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ICs9IG11bHRkeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtdWx0ZHkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi50b3AgKz0gbXVsdGR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5ib3R0b20gKz0gbXVsdGR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuYm91bmRzID0gYjtcclxuICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVudHJhY2tzIGEgYm9keSBmcm9tIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAqL1xyXG4gICAgdW50cmFja0NvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbY29sbGlkZXIuaWQudmFsdWVdO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGVzW2NvbGxpZGVyLmlkLnZhbHVlXSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbY29sbGlkZXIuaWQudmFsdWVdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCYWxhbmNlcyB0aGUgdHJlZSBhYm91dCBhIG5vZGVcclxuICAgICAqL1xyXG4gICAgX2JhbGFuY2Uobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGJhbGFuY2UgYXQgbnVsbCBub2RlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlzTGVhZigpIHx8IG5vZGUuaGVpZ2h0IDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IG5vZGUubGVmdDtcclxuICAgICAgICBjb25zdCByaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgY29uc3QgYSA9IG5vZGU7XHJcbiAgICAgICAgY29uc3QgYiA9IGxlZnQ7XHJcbiAgICAgICAgY29uc3QgYyA9IHJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGQgPSBsZWZ0LmxlZnQ7XHJcbiAgICAgICAgY29uc3QgZSA9IGxlZnQucmlnaHQ7XHJcbiAgICAgICAgY29uc3QgZiA9IHJpZ2h0LmxlZnQ7XHJcbiAgICAgICAgY29uc3QgZyA9IHJpZ2h0LnJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBjLmhlaWdodCAtIGIuaGVpZ2h0O1xyXG4gICAgICAgIC8vIFJvdGF0ZSBjIG5vZGUgdXBcclxuICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcclxuICAgICAgICAgICAgLy8gU3dhcCB0aGUgcmlnaHQgbm9kZSB3aXRoIGl0J3MgcGFyZW50XHJcbiAgICAgICAgICAgIGMubGVmdCA9IGE7XHJcbiAgICAgICAgICAgIGMucGFyZW50ID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGEucGFyZW50ID0gYztcclxuICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byB0aGUgcmlnaHQgbm9kZVxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1lZ2EgY29uZnVzaW5nXHJcbiAgICAgICAgICAgIGlmIChjLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGMucGFyZW50LmxlZnQgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5sZWZ0ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGMucGFyZW50LnJpZ2h0ID0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUm90YXRlXHJcbiAgICAgICAgICAgIGlmIChmLmhlaWdodCA+IGcuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZjtcclxuICAgICAgICAgICAgICAgIGEucmlnaHQgPSBnO1xyXG4gICAgICAgICAgICAgICAgZy5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGYuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMucmlnaHQgPSBnO1xyXG4gICAgICAgICAgICAgICAgYS5yaWdodCA9IGY7XHJcbiAgICAgICAgICAgICAgICBmLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBmLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSb3RhdGUgbGVmdCBub2RlIHVwXHJcbiAgICAgICAgaWYgKGJhbGFuY2UgPCAtMSkge1xyXG4gICAgICAgICAgICAvLyBzd2FwXHJcbiAgICAgICAgICAgIGIubGVmdCA9IGE7XHJcbiAgICAgICAgICAgIGIucGFyZW50ID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGEucGFyZW50ID0gYjtcclxuICAgICAgICAgICAgLy8gbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIGJcclxuICAgICAgICAgICAgaWYgKGIucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQubGVmdCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIucGFyZW50LmxlZnQgPSBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LnJpZ2h0ICE9PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdFcnJvciByb3RhdGluZyBEeW5hbWljIFRyZWUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5yaWdodCA9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJvdGF0ZVxyXG4gICAgICAgICAgICBpZiAoZC5oZWlnaHQgPiBlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgYi5yaWdodCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBhLmxlZnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgZS5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIucmlnaHQgPSBlO1xyXG4gICAgICAgICAgICAgICAgYS5sZWZ0ID0gZDtcclxuICAgICAgICAgICAgICAgIGQucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBoZWlnaHQgb2YgdGhlIHRyZWUsIHNob3J0ZXIgdHJlZXMgYXJlIGJldHRlci4gUGVyZm9ybWFuY2UgZHJvcHMgYXMgdGhlIHRyZWUgZ3Jvd3NcclxuICAgICAqL1xyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBjb2xsaWRpbmcgd2l0aCB0aGUgcHJvdmlkZWQgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgcXVlcnkgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcGFzc2VkIGEgcG90ZW50aWFsIGNvbGxpZGVyLiBSZXR1cm5pbmcgdHJ1ZSBmcm9tIHRoaXMgY2FsbGJhY2sgaW5kaWNhdGVzXHJcbiAgICAgKiB0aGF0IHlvdSBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCB5b3UgZG8gbm90IHdhbnQgdG8gY29udGludWUuIFJldHVybmluZyBmYWxzZSB3aWxsIGNvbnRpbnVlIHNlYXJjaGluZ1xyXG4gICAgICogdGhlIHRyZWUgdW50aWwgYWxsIHBvc3NpYmxlIGNvbGxpZGVycyBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5KGNvbGxpZGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGNvbGxpZGVyLmJvdW5kcztcclxuICAgICAgICBjb25zdCBoZWxwZXIgPSAoY3VycmVudE5vZGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLmJvdW5kcy5vdmVybGFwcyhib3VuZHMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkgJiYgY3VycmVudE5vZGUuZGF0YSAhPT0gY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChjb2xsaWRlciwgY3VycmVudE5vZGUuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSB8fCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBpbnRlcnNlY3RpbmcuIEJ5IGRlZmF1bHQgdGhlIHJheWNhc3QgcXVlcnkgdXNlcyBhbiBpbmZpbml0ZWx5XHJcbiAgICAgKiBsb25nIHJheSB0byB0ZXN0IHRoZSB0cmVlIHNwZWNpZmllZCBieSBgbWF4YC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgcXVlcnkgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcGFzc2VkIGEgcG90ZW50aWFsIGJvZHkgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHJheWNhc3QuIFJldHVybmluZyB0cnVlIGZyb20gdGhpc1xyXG4gICAgICogY2FsbGJhY2sgaW5kaWNhdGVzIHRoYXQgeW91ciBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCBkbyBub3Qgd2FudCB0byBjb250aW51ZS4gUmV0dXJuIGZhbHNlIHdpbGwgY29udGludWUgc2VhcmNoaW5nXHJcbiAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgYm9kaWVzIHRoYXQgd291bGQgaW50ZXJzZWN0IHdpdGggdGhlIHJheSBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIHJheUNhc3RRdWVyeShyYXksIG1heCA9IEluZmluaXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGhlbHBlciA9IChjdXJyZW50Tm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLnJheUNhc3QocmF5LCBtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChyYXksIGN1cnJlbnROb2RlLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJheSBoaXQgYSBsZWFmISByZXR1cm4gdGhlIGJvZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBidXQgbm90IGF0IGEgbGVhZiwgcmVjdXJzZSBkZWVwZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByYXkgbWlzc2VkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgIH1cclxuICAgIGdldE5vZGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGhlbHBlciA9IChjdXJyZW50Tm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbY3VycmVudE5vZGVdLmNvbmNhdChoZWxwZXIoY3VycmVudE5vZGUubGVmdCksIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCkge1xyXG4gICAgICAgIC8vIGRyYXcgYWxsIHRoZSBub2RlcyBpbiB0aGUgRHluYW1pYyBUcmVlXHJcbiAgICAgICAgY29uc3QgaGVscGVyID0gKGN1cnJlbnROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRyYXcoZXgsIENvbG9yLkdyZWVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcy5kcmF3KGV4LCBDb2xvci5XaGl0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9yYXkudHNcbi8qKlxyXG4gKiBBIDJEIHJheSB0aGF0IGNhbiBiZSBjYXN0IGludG8gdGhlIHNjZW5lIHRvIGRvIGNvbGxpc2lvbiBkZXRlY3Rpb25cclxuICovXHJcbmNsYXNzIFJheSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgcmF5XHJcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocG9zLCBkaXIpIHtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICB0aGlzLmRpciA9IGRpci5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgYSB3aGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCBhIGxpbmUgc2VnbWVudC4gUmV0dXJucyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBvbiBzdWNjZXNzLlxyXG4gICAgICogVGhpcyBudW1iZXIgaW5kaWNhdGVzIHRoZSBtYXRoZW1hdGljYWwgaW50ZXJzZWN0aW9uIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gbGluZSAgVGhlIGxpbmUgdG8gdGVzdFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3QobGluZSkge1xyXG4gICAgICAgIGNvbnN0IG51bWVyYXRvciA9IGxpbmUuYmVnaW4uc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICBpZiAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSA9PT0gMCAmJiBudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSk7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ID0gbnVtZXJhdG9yLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgIGlmICh0ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgLyBkaXZpc29yIC8gbGluZS5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGludGVyc2VjdFBvaW50KGxpbmUpIHtcclxuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5pbnRlcnNlY3QobGluZSk7XHJcbiAgICAgICAgaWYgKHRpbWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh0aW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxyXG4gICAgICovXHJcbiAgICBnZXRQb2ludCh0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh0aGlzLmRpci5zY2FsZSh0aW1lKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vRGV0ZWN0aW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVzcG9uc2libGUgZm9yIHBlcmZvcm1pbmcgdGhlIGNvbGxpc2lvbiBicm9hZHBoYXNlIChsb2NhdGluZyBwb3RlbnRpYWwgY29sbGlzaW9ucykgYW5kXHJcbiAqIHRoZSBuYXJyb3dwaGFzZSAoYWN0dWFsIGNvbGxpc2lvbiBjb250YWN0cylcclxuICovXHJcbmNsYXNzIER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5fcGFpcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpZGVycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2tzIGEgcGh5c2ljcyBib2R5IGZvciBjb2xsaXNpb25zXHJcbiAgICAgKi9cclxuICAgIHRyYWNrKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCB0cmFjayBudWxsIGNvbGxpZGVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRhcmdldC5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgYy5vd25lciA9IHRhcmdldC5vd25lcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tDb2xsaWRlcihjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tDb2xsaWRlcih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW50cmFja3MgYSBwaHlzaWNzIGJvZHlcclxuICAgICAqL1xyXG4gICAgdW50cmFjayh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgdW50cmFjayBhIG51bGwgY29sbGlkZXInKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGFyZ2V0LmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbGxpZGVycy5pbmRleE9mKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudW50cmFja0NvbGxpZGVyKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbGxpZGVycy5pbmRleE9mKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVudHJhY2tDb2xsaWRlcih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wYWlyRXhpc3RzKGNvbGxpZGVyQSwgY29sbGlkZXJCKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGNvbGxpc2lvbiBwYWlyIGhhcyBiZWVuIGNhbGN1bGF0ZWQgYWxyZWFkeSBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goY29sbGlkZXJBLmlkLCBjb2xsaWRlckIuaWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWlycy5oYXMoaGFzaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVjdHMgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyBpbiBhIGJyb2FkcGhhc2UgYXBwcm9hY2ggd2l0aCB0aGUgZHluYW1pYyBBQUJCIHRyZWUgc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgYnJvYWRwaGFzZSh0YXJnZXRzLCBkZWx0YSwgc3RhdHMpIHtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXHJcbiAgICAgICAgY29uc3QgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoKG90aGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoX2EgPSBvdGhlci5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuICgoX2IgPSBvdGhlci5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdGl2ZSkgJiYgYm9keS5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2xlYXIgb2xkIGxpc3Qgb2YgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgdGhpcy5fcGFpcnMuY2xlYXIoKTtcclxuICAgICAgICAvLyBjaGVjayBmb3Igbm9ybWFsIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgIGxldCBjb2xsaWRlcjtcclxuICAgICAgICBmb3IgKGxldCBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgY29sbGlkZXIgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XHJcbiAgICAgICAgICAgIC8vIFF1ZXJ5IHRoZSBjb2xsaXNpb24gdHJlZSBmb3IgcG90ZW50aWFsIGNvbGxpZGVyc1xyXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5xdWVyeShjb2xsaWRlciwgKG90aGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhaXJFeGlzdHMoY29sbGlkZXIsIG90aGVyKSAmJiBQYWlyLmNhbkNvbGxpZGUoY29sbGlkZXIsIG90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihjb2xsaWRlciwgb3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhaXJzLmFkZChwYWlyLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gZmFsc2UsIHRvIHF1ZXJ5IHdob2xlIHRyZWUuIFJldHVybmluZyB0cnVlIGluIHRoZSBxdWVyeSBtZXRob2Qgc3RvcHMgc2VhcmNoaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5wYWlycyA9IHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGR5bmFtaWMgdHJlZSBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0c1xyXG4gICAgICAgIC8vIEZhc3QgbW92aW5nIG9iamVjdHMgYXJlIHRob3NlIG1vdmluZyBhdCBsZWFzdCB0aGVyZSBzbWFsbGVzdCBib3VuZCBwZXIgZnJhbWVcclxuICAgICAgICBpZiAoUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBwb3RlbnRpYWxDb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb2xsaWRlci5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIG5vbi1hY3RpdmUgb2JqZWN0cy4gRG9lcyBub3QgbWFrZSBzZW5zZSBvbiBvdGhlciBjb2xsaXNpb24gdHlwZXNcclxuICAgICAgICAgICAgICAgIGlmIChib2R5LmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBNYXhpbXVtIHRyYXZlbCBkaXN0YW5jZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVEaXN0YW5jZSA9IGJvZHkudmVsLnNpemUgKiBzZWNvbmRzICsgLy8gdmVsb2NpdHkgdGVybVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYWNjLnNpemUgKiAwLjUgKiBzZWNvbmRzICogc2Vjb25kczsgLy8gYWNjIHRlcm1cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1pbmltdW0gZGltZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihjb2xsaWRlci5ib3VuZHMuaGVpZ2h0LCBjb2xsaWRlci5ib3VuZHMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBoeXNpY3MuZGlzYWJsZU1pbmltdW1TcGVlZEZvckZhc3RCb2R5IHx8IHVwZGF0ZURpc3RhbmNlID4gbWluRGltZW5zaW9uIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2RpZXMrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCB0aGUgb2xkUG9zIGJlY2F1c2UgdGhlIGludGVncmF0aW9uIGZvciBhY3RvcnMgaGFzIGFscmVhZHkgaGFwcGVuZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHJlc3Rpbmcgb24gYSBzdXJmYWNlIG1heSBiZSBzbGlnaHRseSBwZW5ldHJhdGluZyBpbiB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVZlYyA9IGJvZHkuZ2xvYmFsUG9zLnN1Yihib2R5Lm9sZFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyUG9pbnQgPSBjb2xsaWRlci5jZW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVydGhlc3RQb2ludCA9IGNvbGxpZGVyLmdldEZ1cnRoZXN0UG9pbnQoYm9keS52ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGZ1cnRoZXN0UG9pbnQuc3ViKHVwZGF0ZVZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF5ID0gbmV3IFJheShvcmlnaW4sIGJvZHkudmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIHRoZSByYXkgdXAgYnkgLTJ4IHN1cmZhY2VFcHNpbG9uIHRvIGFjY291bnQgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgc3RhcnRpbmcgb24gdGhlIHN1cmZhY2VcclxuICAgICAgICAgICAgICAgICAgICByYXkucG9zID0gcmF5LnBvcy5hZGQocmF5LmRpci5zY2FsZSgtMiAqIFBoeXNpY3Muc3VyZmFjZUVwc2lsb24pKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWluQ29sbGlkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pblRyYW5zbGF0ZSA9IG5ldyBWZWN0b3IoSW5maW5pdHksIEluZmluaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5yYXlDYXN0UXVlcnkocmF5LCB1cGRhdGVEaXN0YW5jZSArIFBoeXNpY3Muc3VyZmFjZUVwc2lsb24gKiAyLCAob3RoZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYWlyRXhpc3RzKGNvbGxpZGVyLCBvdGhlcikgJiYgUGFpci5jYW5Db2xsaWRlKGNvbGxpZGVyLCBvdGhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpdFBvaW50ID0gb3RoZXIucmF5Q2FzdChyYXksIHVwZGF0ZURpc3RhbmNlICsgUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGhpdFBvaW50LnN1YihvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGUuc2l6ZSA8IG1pblRyYW5zbGF0ZS5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29sbGlkZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5Db2xsaWRlciAmJiBWZWN0b3IuaXNWYWxpZChtaW5UcmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihjb2xsaWRlciwgbWluQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhaXJzLmhhcyhwYWlyLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpcnMuYWRkKHBhaXIuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgZmFzdCBtb3Zpbmcgb2JqZWN0IHRvIHRoZSBvdGhlciBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcHVzaCBpbnRvIHRoZSBzdXJmYWNlIGJ5IGV4LlBoeXNpY3Muc3VyZmFjZUVwc2lsb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBjZW50ZXJQb2ludC5zdWIoZnVydGhlc3RQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZ2xvYmFsUG9zID0gb3JpZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHNoaWZ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChtaW5UcmFuc2xhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHJheS5kaXIuc2NhbGUoMTAgKiBQaHlzaWNzLnN1cmZhY2VFcHNpbG9uKSk7IC8vIG5lZWRlZCB0byBwdXNoIHRoZSBzaGFwZSBzbGlnaHRseSBpbnRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlKGJvZHkudHJhbnNmb3JtLmdldCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmZhc3RCb2R5Q29sbGlzaW9ucysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVybiBjYWNoZVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgbmFycm93IHBoYXNlIG9uIGNvbGxpc2lvbiBwYWlycyB0byBmaW5kIGFjdHVhbCBhcmVhIGludGVyc2VjdGlvbnNcclxuICAgICAqIEFkZHMgYWN0dWFsIGNvbGxpZGluZyBwYWlycyB0byBzdGF0cycgRnJhbWUgZGF0YVxyXG4gICAgICovXHJcbiAgICBuYXJyb3dwaGFzZShwYWlycywgc3RhdHMpIHtcclxuICAgICAgICBsZXQgY29udGFjdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRhY3RzID0gcGFpcnNbaV0uY29sbGlkZSgpO1xyXG4gICAgICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLmNvbmNhdChuZXdDb250YWN0cyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cyAmJiBuZXdDb250YWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgbmV3Q29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbnRhY3RzLnNldChjLmlkLCBjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5jb2xsaXNpb25zICs9IGNvbnRhY3RzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGR5bmFtaWMgdHJlZSBwb3NpdGlvbnNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHRhcmdldHMpIHtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IDA7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGFyZ2V0cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudXBkYXRlQ29sbGlkZXIodGFyZ2V0c1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4KSB7XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUuZGVidWcoZXgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9Db2xsaWRlci50c1xuXHJcblxyXG4vKipcclxuICogQSBjb2xsaXNpb24gY29sbGlkZXIgc3BlY2lmaWVzIHRoZSBnZW9tZXRyeSB0aGF0IGNhbiBkZXRlY3Qgd2hlbiBvdGhlciBjb2xsaXNpb24gY29sbGlkZXJzIGludGVyc2VjdFxyXG4gKiBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbGxpZGluZyAyIG9iamVjdHMgaW4gZXhjYWxpYnVyLlxyXG4gKi9cclxuY2xhc3MgQ29sbGlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGNyZWF0ZUlkKCdjb2xsaWRlcicsIENvbGxpZGVyLl9JRCsrKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeGNhbGlidXIgdXNlcyB0aGlzIHRvIHNpZ25hbCB0byB0aGUgW1tDb2xsaXNpb25TeXN0ZW1dXSB0aGlzIGlzIHBhcnQgb2YgYSBjb21wb3NpdGUgY29sbGlkZXJcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKiBAaGlkZGVuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fX2NvbXBvc2l0ZUNvbGxpZGVySWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGNvbGxpZGVkIHdpdGhcclxuICAgICAqIG9yIHdhcyBpbiBzdGF0aW9uYXJ5IGNvbnRhY3Qgd2l0aFxyXG4gICAgICogdGhlIGJvZHkgb2YgdGhlIG90aGVyIFtbQ29sbGlkZXJdXVxyXG4gICAgICovXHJcbiAgICB0b3VjaGluZyhvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhY3QgPSB0aGlzLmNvbGxpZGUob3RoZXIpO1xyXG4gICAgICAgIGlmIChjb250YWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuQ29sbGlkZXIuX0lEID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL0NvbXBvc2l0ZUNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIENvbXBvc2l0ZUNvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGlkZXJzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25Qcm9jZXNzb3IgPSBuZXcgRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IoKTtcclxuICAgICAgICB0aGlzLl9keW5hbWljQUFCQlRyZWUgPSBuZXcgRHluYW1pY1RyZWUoKTtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlkZXIoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBhZGRDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLndpcmUoY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICBjb2xsaWRlci5fX2NvbXBvc2l0ZUNvbGxpZGVySWQgPSB0aGlzLmlkO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVycy5wdXNoKGNvbGxpZGVyKTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25Qcm9jZXNzb3IudHJhY2soY29sbGlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNBQUJCVHJlZS50cmFja0NvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHMudW53aXJlKGNvbGxpZGVyLmV2ZW50cyk7XHJcbiAgICAgICAgY29sbGlkZXIuX19jb21wb3NpdGVDb2xsaWRlcklkID0gbnVsbDtcclxuICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGNvbGxpZGVyLCB0aGlzLl9jb2xsaWRlcnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvblByb2Nlc3Nvci51bnRyYWNrKGNvbGxpZGVyKTtcclxuICAgICAgICB0aGlzLl9keW5hbWljQUFCQlRyZWUudW50cmFja0NvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgIH1cclxuICAgIGdldENvbGxpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gVE9ETyB0cmFuc2Zvcm0gY29tcG9uZW50IHdvcmxkIHBvc1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbGxpZGVycy5yZWR1Y2UoKGFjYywgY29sbGlkZXIpID0+IGFjYy5jb21iaW5lKGNvbGxpZGVyLmJvdW5kcyksIChfYiA9IChfYSA9IGNvbGxpZGVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCkudHJhbnNsYXRlKHRoaXMud29ybGRQb3MpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbGxpZGVycy5yZWR1Y2UoKGFjYywgY29sbGlkZXIpID0+IGFjYy5jb21iaW5lKGNvbGxpZGVyLmxvY2FsQm91bmRzKSwgKF9iID0gKF9hID0gY29sbGlkZXJzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxCb3VuZHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBCb3VuZGluZ0JveCgpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIGdldCBheGVzKCkge1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgbGV0IGF4ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBheGVzID0gYXhlcy5jb25jYXQoY29sbGlkZXIuYXhlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgfVxyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGNvbnN0IGZ1cnRoZXN0UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgZnVydGhlc3RQb2ludHMucHVzaChjb2xsaWRlci5nZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQaWNrIGJlc3QgcG9pbnQgZnJvbSBhbGwgY29sbGlkZXJzXHJcbiAgICAgICAgbGV0IGJlc3RQb2ludCA9IGZ1cnRoZXN0UG9pbnRzWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZnVydGhlc3RQb2ludHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwb2ludC5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdFBvaW50O1xyXG4gICAgfVxyXG4gICAgZ2V0SW5lcnRpYShtYXNzKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBsZXQgdG90YWxJbmVydGlhID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICB0b3RhbEluZXJ0aWEgKz0gY29sbGlkZXIuZ2V0SW5lcnRpYShtYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSW5lcnRpYTtcclxuICAgIH1cclxuICAgIGNvbGxpZGUob3RoZXIpIHtcclxuICAgICAgICBsZXQgb3RoZXJDb2xsaWRlcnMgPSBbb3RoZXJdO1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIG90aGVyQ29sbGlkZXJzID0gb3RoZXIuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIG90aGVyQ29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNBQUJCVHJlZS5xdWVyeShjLCAocG90ZW50aWFsQ29sbGlkZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gobmV3IFBhaXIoYywgcG90ZW50aWFsQ29sbGlkZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250YWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwYWlycykge1xyXG4gICAgICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLmNvbmNhdChwLmNvbGxpZGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWN0cztcclxuICAgIH1cclxuICAgIGdldENsb3Nlc3RMaW5lQmV0d2VlbihvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckNvbGxpZGVycyA9IG90aGVyLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyQSBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXJCIG9mIG90aGVyQ29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVMaW5lID0gY29sbGlkZXJBLmdldENsb3Nlc3RMaW5lQmV0d2Vlbihjb2xsaWRlckIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChtYXliZUxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlTGluZSA9IG90aGVyLmdldENsb3Nlc3RMaW5lQmV0d2Vlbihjb2xsaWRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChtYXliZUxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IG1pbkxlbmd0aCA9IGxpbmVzWzBdLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICBsZXQgbWluTGluZSA9IGxpbmVzWzBdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGxpbmUuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgbWluTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkxpbmUgPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtaW5MaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXIuY29udGFpbnMocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByYXlDYXN0KHJheSwgbWF4KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZWMgPSBjb2xsaWRlci5yYXlDYXN0KHJheSwgbWF4KTtcclxuICAgICAgICAgICAgaWYgKHZlYykge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbWluUG9pbnQgPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IG1pblBvaW50LmRvdChyYXkuZGlyKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcmF5LmRpci5kb3QocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Qb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pblBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHByb2plY3QoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcHJvanMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qID0gY29sbGlkZXIucHJvamVjdChheGlzKTtcclxuICAgICAgICAgICAgaWYgKHByb2opIHtcclxuICAgICAgICAgICAgICAgIHByb2pzLnB1c2gocHJvaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgYWxsIHByb2oncyBvbiB0aGUgc2FtZSBheGlzXHJcbiAgICAgICAgaWYgKHByb2pzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb24ocHJvanNbMF0ubWluLCBwcm9qc1swXS5tYXgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2ogb2YgcHJvanMpIHtcclxuICAgICAgICAgICAgICAgIG5ld1Byb2plY3Rpb24ubWluID0gTWF0aC5taW4ocHJvai5taW4sIG5ld1Byb2plY3Rpb24ubWluKTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb2plY3Rpb24ubWF4ID0gTWF0aC5tYXgocHJvai5tYXgsIG5ld1Byb2plY3Rpb24ubWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UHJvamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIub3duZXIgPSB0aGlzLm93bmVyO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCwgY29sb3IpIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyLmRlYnVnKGV4LCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVDb2xsaWRlcih0aGlzLl9jb2xsaWRlcnMubWFwKChjKSA9PiBjLmNsb25lKCkpKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvbGluZS1zZWdtZW50LnRzXG5cclxuLyoqXHJcbiAqIEEgMkQgbGluZSBzZWdtZW50XHJcbiAqL1xyXG5jbGFzcyBMaW5lU2VnbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBiZWdpbiAgVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcclxuICAgICAqIEBwYXJhbSBlbmQgIFRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByYXcgc2xvcGUgKG0pIG9mIHRoZSBsaW5lLiBXaWxsIHJldHVybiAoKy8tKUluZmluaXR5IGZvciB2ZXJ0aWNhbCBsaW5lcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNsb3BlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueSkgLyAodGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFktaW50ZXJjZXB0IChiKSBvZiB0aGUgbGluZS4gV2lsbCByZXR1cm4gKCsvLSlJbmZpbml0eSBpZiB0aGVyZSBpcyBubyBpbnRlcmNlcHQuXHJcbiAgICAgKi9cclxuICAgIGdldCBpbnRlcmNlcHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW4ueSAtIHRoaXMuc2xvcGUgKiB0aGlzLmJlZ2luLng7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5vcm1hbCBvZiB0aGUgbGluZVxyXG4gICAgICovXHJcbiAgICBub3JtYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsID0gdGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLm5vcm1hbCgpO1xyXG4gICAgfVxyXG4gICAgZGlyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA9IHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKTtcclxuICAgIH1cclxuICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuYmVnaW4sIHRoaXMuZW5kXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3Igb2YgbGVuZ3RoIDFcclxuICAgICAqL1xyXG4gICAgZ2V0U2xvcGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nsb3BlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbG9wZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2xvcGUgPSBlbmQuc3ViKGJlZ2luKS5zY2FsZSgxIC8gZGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGdlIG9mIHRoZSBsaW5lIGFzIHZlY3RvciwgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yIGlzIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2VcclxuICAgICAqL1xyXG4gICAgZ2V0RWRnZSgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuYmVnaW47XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0TGVuZ3RoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID0gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pZHBvaW50IG9mIHRoZSBlZGdlXHJcbiAgICAgKi9cclxuICAgIGdldCBtaWRwb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi5hZGQodGhpcy5lbmQpLnNjYWxlKDAuNSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsaXBzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICovXHJcbiAgICBmbGlwKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVNlZ21lbnQodGhpcy5lbmQsIHRoaXMuYmVnaW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIHBvaW50IGlzIGJlbG93IHRoZSBsaW5lLCBwb2ludHMgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb24gYWJvdmUgdGhlIGxpbmUgYXJlIGNvbnNpZGVyZWQgYWJvdmUuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgYmVsb3cocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBhYm92ZTIgPSAodGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueCkgKiAocG9pbnQueSAtIHRoaXMuYmVnaW4ueSkgLSAodGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueSkgKiAocG9pbnQueCAtIHRoaXMuYmVnaW4ueCk7XHJcbiAgICAgICAgcmV0dXJuIGFib3ZlMiA+PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGlwIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gc2lkZVZlY3RvciBWZWN0b3IgdGhhdCB0cmFjZXMgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIHRvIGNsaXAgYWxvbmcgc2lkZVxyXG4gICAgICovXHJcbiAgICBjbGlwKHNpZGVWZWN0b3IsIGxlbmd0aCkge1xyXG4gICAgICAgIGxldCBkaXIgPSBzaWRlVmVjdG9yO1xyXG4gICAgICAgIGRpciA9IGRpci5ub3JtYWxpemUoKTtcclxuICAgICAgICBjb25zdCBuZWFyID0gZGlyLmRvdCh0aGlzLmJlZ2luKSAtIGxlbmd0aDtcclxuICAgICAgICBjb25zdCBmYXIgPSBkaXIuZG90KHRoaXMuZW5kKSAtIGxlbmd0aDtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgaWYgKG5lYXIgPD0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5iZWdpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYXIgPD0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVhciAqIGZhciA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY2xpcFRpbWUgPSBuZWFyIC8gKG5lYXIgLSBmYXIpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5iZWdpbi5hZGQodGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLnNjYWxlKGNsaXBUaW1lKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVNlZ21lbnQocmVzdWx0c1swXSwgcmVzdWx0c1sxXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2VUb1BvaW50KHBvaW50LCBzaWduZWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHgwID0gcG9pbnQueDtcclxuICAgICAgICBjb25zdCB5MCA9IHBvaW50Lnk7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgY29uc3QgZHkgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IChkeSAqIHgwIC0gZHggKiB5MCArIHRoaXMuZW5kLnggKiB0aGlzLmJlZ2luLnkgLSB0aGlzLmVuZC55ICogdGhpcy5iZWdpbi54KSAvIGw7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25lZCA/IGRpc3RhbmNlIDogTWF0aC5hYnMoZGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwZXJwZW5kaWN1bGFyIGxpbmUgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgKiAoYSAtIHApIC0gKChhIC0gcCkgKiBuKW5cclxuICAgICAqIGEgaXMgYSBwb2ludCBvbiB0aGUgbGluZVxyXG4gICAgICogcCBpcyB0aGUgYXJiaXRyYXJ5IHBvaW50IGFib3ZlIHRoZSBsaW5lXHJcbiAgICAgKiBuIGlzIGEgdW5pdCB2ZWN0b3IgaW4gZGlyZWN0aW9uIG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgZmluZFZlY3RvclRvUG9pbnQocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBhTWludXNQID0gdGhpcy5iZWdpbi5zdWIocG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldFNsb3BlKCk7XHJcbiAgICAgICAgcmV0dXJuIGFNaW51c1Auc3ViKG4uc2NhbGUoYU1pbnVzUC5kb3QobikpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYSBwb2ludCBvbiB0aGUgbGluZSBnaXZlbiBvbmx5IGFuIFggb3IgYSBZIHZhbHVlLiBHaXZlbiBhbiBYIHZhbHVlLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xyXG4gICAgICogYSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBZIHZhbHVlIGFuZCB2aWNlLXZlcnNhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IFRoZSBrbm93biBYIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAqIEBwYXJhbSB5IFRoZSBrbm93biBZIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHBvaW50IHdpdGggdGhlIG90aGVyIGNhbGN1bGF0ZWQgYXhpcyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBmaW5kUG9pbnQoeCA9IG51bGwsIHkgPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuc2xvcGU7XHJcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuaW50ZXJjZXB0O1xyXG4gICAgICAgIGlmICh4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIG0gKiB4ICsgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoKHkgLSBiKSAvIG0sIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIFggb3IgYSBZIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExOTA4MTU4LzEwOTQ1OFxyXG4gICAgICovXHJcbiAgICBoYXNQb2ludCgpIHtcclxuICAgICAgICBsZXQgY3VyclBvaW50O1xyXG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjdXJyUG9pbnQgPSBuZXcgVmVjdG9yKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gYXJndW1lbnRzWzJdIHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBjdXJyUG9pbnQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGFyZ3VtZW50c1sxXSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0NvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGFyZ3VtZW50cyBmb3IgVmVjdG9yLmhhc1BvaW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHhjID0gY3VyclBvaW50LnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgY29uc3QgZHljID0gY3VyclBvaW50LnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgY29uc3QgZHgxID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICBjb25zdCBkeTEgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIGNvbnN0IGNyb3NzID0gZHhjICogZHkxIC0gZHljICogZHgxO1xyXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcG9pbnQgbGluZXMgb24gdGhlIGxpbmVcclxuICAgICAgICBpZiAoTWF0aC5hYnMoY3Jvc3MpID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBwb2ludCBsaWVzIGluLWJldHdlZW4gc3RhcnQgYW5kIGVuZFxyXG4gICAgICAgIGlmIChNYXRoLmFicyhkeDEpID49IE1hdGguYWJzKGR5MSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR4MSA+IDAgPyB0aGlzLmJlZ2luLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5lbmQueCA6IHRoaXMuZW5kLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR5MSA+IDAgPyB0aGlzLmJlZ2luLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5lbmQueSA6IHRoaXMuZW5kLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ2xvc2VzdExpbmVKdW1wVGFibGUudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgY2xvc2VzIGxpbmUgYmV0d2VlbiAyIGxpbmUgc2VnbWVudHMsIHdlcmUgdGhlIG1hZ25pdHVkZSBvZiB1LCB2IGFyZSB0aGUgbGVuZ3RocyBvZiBlYWNoIHNlZ21lbnRcclxuICogTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICogTDIgPSBRKHQpID0gcTAgKyB0ICogdiwgd2hlcmUgdCBpcyB0aW1lIGFuZCBxMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICogQHBhcmFtIHAwIFBvaW50IHdoZXJlIEwxIGJlZ2luc1xyXG4gKiBAcGFyYW0gdSBEaXJlY3Rpb24gYW5kIGxlbmd0aCBvZiBMMVxyXG4gKiBAcGFyYW0gcTAgUG9pbnQgd2VyZSBMMiBiZWdpbnNcclxuICogQHBhcmFtIHYgRGlyZWN0aW9uIGFuZCBsZW5ndGggb2YgTDJcclxuICovXHJcbmZ1bmN0aW9uIENsb3Nlc3RMaW5lKHAwLCB1LCBxMCwgdikge1xyXG4gICAgLy8gRGlzdGFuY2UgYmV0d2VlbiAyIGxpbmVzIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA3LV9kaXN0YW5jZS5odG1sXHJcbiAgICAvLyB3KHMsIHQpID0gUChzKSAtIFEodClcclxuICAgIC8vIFRoZSB3KHMsIHQpIHRoYXQgaGFzIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHdlIHdpbGwgc2F5IGlzIHcoc0Nsb3Nlc3QsIHRDbG9zZXN0KSA9IHdDbG9zZXN0XHJcbiAgICAvL1xyXG4gICAgLy8gd0Nsb3Nlc3QgaXMgdGhlIHZlY3RvciB0aGF0IGlzIHVuaXF1ZWx5IHBlcnBlbmRpY3VsYXIgdG8gdGhlIDIgbGluZSBkaXJlY3Rpb25zIHUgJiB2LlxyXG4gICAgLy8gd0Nsb3Nlc3QgPSB3MCArIHNDbG9zZXN0ICogdSAtIHRDbG9zZXN0ICogdiwgd2hlcmUgdzAgaXMgcDAgLSBxMFxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBjbG9zZXN0IHBvaW50IGJldHdlZW4gMiBsaW5lcyB0aGVuIHNhdGlzZmllcyB0aGlzIHBhaXIgb2YgZXF1YXRpb25zXHJcbiAgICAvLyAxOiB1ICogd0Nsb3Nlc3QgPSAwXHJcbiAgICAvLyAyOiB2ICogd0Nsb3Nlc3QgPSAwXHJcbiAgICAvL1xyXG4gICAgLy8gU3Vic3RpdHV0aW5nIHdDbG9zZXN0IGludG8gdGhlIGVxdWF0aW9ucyB3ZSBnZXRcclxuICAgIC8vXHJcbiAgICAvLyAxOiAodSAqIHUpICogc0Nsb3Nlc3QgLSAodSAqIHYpIHRDbG9zZXN0ID0gLXUgKiB3MFxyXG4gICAgLy8gMjogKHYgKiB1KSAqIHNDbG9zZXN0IC0gKHYgKiB2KSB0Q2xvc2VzdCA9IC12ICogdzBcclxuICAgIC8vIHNpbXBsaWZ5IHcwXHJcbiAgICBjb25zdCB3MCA9IHAwLnN1YihxMCk7XHJcbiAgICAvLyBzaW1wbGlmeSAodSAqIHUpO1xyXG4gICAgY29uc3QgYSA9IHUuZG90KHUpO1xyXG4gICAgLy8gc2ltcGxpZnkgKHUgKiB2KTtcclxuICAgIGNvbnN0IGIgPSB1LmRvdCh2KTtcclxuICAgIC8vIHNpbXBsaWZ5ICh2ICogdilcclxuICAgIGNvbnN0IGMgPSB2LmRvdCh2KTtcclxuICAgIC8vIHNpbXBsaWZ5ICh1ICogdzApXHJcbiAgICBjb25zdCBkID0gdS5kb3QodzApO1xyXG4gICAgLy8gc2ltcGxpZnkgKHYgKiB3MClcclxuICAgIGNvbnN0IGUgPSB2LmRvdCh3MCk7XHJcbiAgICAvLyBkZW5vbWluYXRvciBhYyAtIGJeMlxyXG4gICAgY29uc3QgZGVub20gPSBhICogYyAtIGIgKiBiO1xyXG4gICAgbGV0IHNEZW5vbSA9IGRlbm9tO1xyXG4gICAgbGV0IHREZW5vbSA9IGRlbm9tO1xyXG4gICAgLy8gaWYgZGVub20gaXMgMCB0aGV5IGFyZSBwYXJhbGxlbCwgdXNlIGFueSBwb2ludCBmcm9tIGVpdGhlciBhcyB0aGUgc3RhcnQgaW4gdGhpcyBjYXNlIHAwXHJcbiAgICBpZiAoZGVub20gPT09IDAgfHwgZGVub20gPD0gMC4wMSkge1xyXG4gICAgICAgIGNvbnN0IHRDbG9zZXN0UGFyYWxsZWwgPSBkIC8gYjtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KHAwLCBxMC5hZGQodi5zY2FsZSh0Q2xvc2VzdFBhcmFsbGVsKSkpO1xyXG4gICAgfVxyXG4gICAgLy8gU29sdmUgZm9yIHNDbG9zZXN0IGZvciBpbmZpbml0ZSBsaW5lXHJcbiAgICBsZXQgc0Nsb3Nlc3QgPSBiICogZSAtIGMgKiBkOyAvLyAvIGRlbm9tO1xyXG4gICAgLy8gU29sdmUgZm9yIHRDbG9zZXN0IGZvciBpbmZpbml0ZSBsaW5lXHJcbiAgICBsZXQgdENsb3Nlc3QgPSBhICogZSAtIGIgKiBkOyAvLyAvIGRlbm9tO1xyXG4gICAgLy8gU29sdmUgZm9yIHNlZ21lbnRzIGNhbmRpZGF0ZSBlZGdlcywgaWYgc0Nsb3Nlc3QgYW5kIHRDbG9zZXN0IGFyZSBvdXRzaWRlIHRoZWlyIHNlZ21lbnRzXHJcbiAgICBpZiAoc0Nsb3Nlc3QgPCAwKSB7XHJcbiAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIHRDbG9zZXN0ID0gZTtcclxuICAgICAgICB0RGVub20gPSBjO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc0Nsb3Nlc3QgPiBzRGVub20pIHtcclxuICAgICAgICBzQ2xvc2VzdCA9IHNEZW5vbTtcclxuICAgICAgICB0Q2xvc2VzdCA9IGUgKyBiO1xyXG4gICAgICAgIHREZW5vbSA9IGM7XHJcbiAgICB9XHJcbiAgICBpZiAodENsb3Nlc3QgPCAwKSB7XHJcbiAgICAgICAgdENsb3Nlc3QgPSAwO1xyXG4gICAgICAgIGlmICgtZCA8IDApIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgtZCA+IGEpIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSBzRGVub207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IC1kO1xyXG4gICAgICAgICAgICBzRGVub20gPSBhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRDbG9zZXN0ID4gdERlbm9tKSB7XHJcbiAgICAgICAgdENsb3Nlc3QgPSB0RGVub207XHJcbiAgICAgICAgaWYgKC1kICsgYiA8IDApIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgtZCArIGIgPiBhKSB7XHJcbiAgICAgICAgICAgIHNDbG9zZXN0ID0gc0Rlbm9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAtZCArIGI7XHJcbiAgICAgICAgICAgIHNEZW5vbSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc0Nsb3Nlc3QgPSBNYXRoLmFicyhzQ2xvc2VzdCkgPCAwLjAwMSA/IDAgOiBzQ2xvc2VzdCAvIHNEZW5vbTtcclxuICAgIHRDbG9zZXN0ID0gTWF0aC5hYnModENsb3Nlc3QpIDwgMC4wMDEgPyAwIDogdENsb3Nlc3QgLyB0RGVub207XHJcbiAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KHAwLmFkZCh1LnNjYWxlKHNDbG9zZXN0KSksIHEwLmFkZCh2LnNjYWxlKHRDbG9zZXN0KSkpO1xyXG59XHJcbmNvbnN0IENsb3Nlc3RMaW5lSnVtcFRhYmxlID0ge1xyXG4gICAgUG9seWdvblBvbHlnb25DbG9zZXN0TGluZShwb2x5Z29uQSwgcG9seWdvbkIpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSAyIGNsb3Nlc3QgZmFjZXMgb24gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgY29uc3Qgb3RoZXJXb3JsZFBvcyA9IHBvbHlnb25CLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRGlyZWN0aW9uID0gb3RoZXJXb3JsZFBvcy5zdWIocG9seWdvbkEud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNEaXJlY3Rpb24gPSBvdGhlckRpcmVjdGlvbi5uZWdhdGUoKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzT3RoZXIgPSBuZXcgUmF5KHBvbHlnb25BLndvcmxkUG9zLCBvdGhlckRpcmVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgcmF5VG93YXJkc1RoaXMgPSBuZXcgUmF5KG90aGVyV29ybGRQb3MsIHRoaXNEaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHRoaXNQb2ludCA9IHBvbHlnb25BLnJheUNhc3QocmF5VG93YXJkc090aGVyKS5hZGQocmF5VG93YXJkc090aGVyLmRpci5zY2FsZSgwLjEpKTtcclxuICAgICAgICBjb25zdCBvdGhlclBvaW50ID0gcG9seWdvbkIucmF5Q2FzdChyYXlUb3dhcmRzVGhpcykuYWRkKHJheVRvd2FyZHNUaGlzLmRpci5zY2FsZSgwLjEpKTtcclxuICAgICAgICBjb25zdCB0aGlzRmFjZSA9IHBvbHlnb25BLmdldENsb3Nlc3RGYWNlKHRoaXNQb2ludCk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJGYWNlID0gcG9seWdvbkIuZ2V0Q2xvc2VzdEZhY2Uob3RoZXJQb2ludCk7XHJcbiAgICAgICAgLy8gTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBwMCA9IHRoaXNGYWNlLmZhY2UuYmVnaW47XHJcbiAgICAgICAgY29uc3QgdSA9IHRoaXNGYWNlLmZhY2UuZ2V0RWRnZSgpO1xyXG4gICAgICAgIC8vIEwyID0gUSh0KSA9IHEwICsgdCAqIHYsIHdoZXJlIHQgaXMgdGltZSBhbmQgcTAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgcTAgPSBvdGhlckZhY2UuZmFjZS5iZWdpbjtcclxuICAgICAgICBjb25zdCB2ID0gb3RoZXJGYWNlLmZhY2UuZ2V0RWRnZSgpO1xyXG4gICAgICAgIHJldHVybiBDbG9zZXN0TGluZShwMCwgdSwgcTAsIHYpO1xyXG4gICAgfSxcclxuICAgIFBvbHlnb25FZGdlQ2xvc2VzdExpbmUocG9seWdvbiwgZWRnZSkge1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIDIgY2xvc2VzdCBmYWNlcyBvbiBlYWNoIHBvbHlnb25cclxuICAgICAgICBjb25zdCBvdGhlcldvcmxkUG9zID0gZWRnZS53b3JsZFBvcztcclxuICAgICAgICBjb25zdCBvdGhlckRpcmVjdGlvbiA9IG90aGVyV29ybGRQb3Muc3ViKHBvbHlnb24ud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNPdGhlciA9IG5ldyBSYXkocG9seWdvbi53b3JsZFBvcywgb3RoZXJEaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHRoaXNQb2ludCA9IHBvbHlnb24ucmF5Q2FzdChyYXlUb3dhcmRzT3RoZXIpLmFkZChyYXlUb3dhcmRzT3RoZXIuZGlyLnNjYWxlKDAuMSkpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNGYWNlID0gcG9seWdvbi5nZXRDbG9zZXN0RmFjZSh0aGlzUG9pbnQpO1xyXG4gICAgICAgIC8vIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzRmFjZS5mYWNlLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IHUgPSB0aGlzRmFjZS5mYWNlLmdldEVkZ2UoKTtcclxuICAgICAgICAvLyBMMiA9IFEodCkgPSBxMCArIHQgKiB2LCB3aGVyZSB0IGlzIHRpbWUgYW5kIHEwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IGVkZ2VMaW5lID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlZGdlU3RhcnQgPSBlZGdlTGluZS5iZWdpbjtcclxuICAgICAgICBjb25zdCBlZGdlVmVjdG9yID0gZWRnZUxpbmUuZ2V0RWRnZSgpO1xyXG4gICAgICAgIGNvbnN0IHEwID0gZWRnZVN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IHYgPSBlZGdlVmVjdG9yO1xyXG4gICAgICAgIHJldHVybiBDbG9zZXN0TGluZShwMCwgdSwgcTAsIHYpO1xyXG4gICAgfSxcclxuICAgIFBvbHlnb25DaXJjbGVDbG9zZXN0TGluZShwb2x5Z29uLCBjaXJjbGUpIHtcclxuICAgICAgICAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MTkxNzcvaG93LXRvLWZpbmQtcG9pbnQtb24tbGluZS1jbG9zZXN0LXRvLXNwaGVyZVxyXG4gICAgICAgIC8vIEZpbmQgdGhlIDIgY2xvc2VzdCBmYWNlcyBvbiBlYWNoIHBvbHlnb25cclxuICAgICAgICBjb25zdCBvdGhlcldvcmxkUG9zID0gY2lyY2xlLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRGlyZWN0aW9uID0gb3RoZXJXb3JsZFBvcy5zdWIocG9seWdvbi53b3JsZFBvcyk7XHJcbiAgICAgICAgY29uc3QgcmF5VG93YXJkc090aGVyID0gbmV3IFJheShwb2x5Z29uLndvcmxkUG9zLCBvdGhlckRpcmVjdGlvbi5ub3JtYWxpemUoKSk7XHJcbiAgICAgICAgY29uc3QgdGhpc1BvaW50ID0gcG9seWdvbi5yYXlDYXN0KHJheVRvd2FyZHNPdGhlcikuYWRkKHJheVRvd2FyZHNPdGhlci5kaXIuc2NhbGUoMC4xKSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0ZhY2UgPSBwb2x5Z29uLmdldENsb3Nlc3RGYWNlKHRoaXNQb2ludCk7XHJcbiAgICAgICAgLy8gTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBwMCA9IHRoaXNGYWNlLmZhY2UuYmVnaW47XHJcbiAgICAgICAgY29uc3QgdSA9IHRoaXNGYWNlLmZhY2UuZ2V0RWRnZSgpO1xyXG4gICAgICAgIC8vIFRpbWUgb2YgbWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGxldCB0ID0gKHUueCAqIChvdGhlcldvcmxkUG9zLnggLSBwMC54KSArIHUueSAqIChvdGhlcldvcmxkUG9zLnkgLSBwMC55KSkgLyAodS54ICogdS54ICsgdS55ICogdS55KTtcclxuICAgICAgICAvLyBJZiB0aW1lIG9mIG1pbmltdW0gaXMgcGFzdCB0aGUgZWRnZSBjbGFtcFxyXG4gICAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgICAgICB0ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1pbmltdW0gZGlzdGFuY2VcclxuICAgICAgICBjb25zdCBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHAwLnggKyB1LnggKiB0IC0gb3RoZXJXb3JsZFBvcy54LCAyKSArIE1hdGgucG93KHAwLnkgKyB1LnkgKiB0IC0gb3RoZXJXb3JsZFBvcy55LCAyKSkgLSBjaXJjbGUucmFkaXVzO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZXggPSAoKHAwLnggKyB1LnggKiB0IC0gb3RoZXJXb3JsZFBvcy54KSAqIGNpcmNsZS5yYWRpdXMpIC8gKGNpcmNsZS5yYWRpdXMgKyBkKTtcclxuICAgICAgICBjb25zdCBjaXJjbGV5ID0gKChwMC55ICsgdS55ICogdCAtIG90aGVyV29ybGRQb3MueSkgKiBjaXJjbGUucmFkaXVzKSAvIChjaXJjbGUucmFkaXVzICsgZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lU2VnbWVudCh1LnNjYWxlKHQpLmFkZChwMCksIG5ldyBWZWN0b3Iob3RoZXJXb3JsZFBvcy54ICsgY2lyY2xleCwgb3RoZXJXb3JsZFBvcy55ICsgY2lyY2xleSkpO1xyXG4gICAgfSxcclxuICAgIENpcmNsZUNpcmNsZUNsb3Nlc3RMaW5lKGNpcmNsZUEsIGNpcmNsZUIpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSAyIGNsb3Nlc3QgZmFjZXMgb24gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgY29uc3Qgb3RoZXJXb3JsZFBvcyA9IGNpcmNsZUIud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBvdGhlcldvcmxkUG9zLnN1YihjaXJjbGVBLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCB0aGlzV29ybGRQb3MgPSBjaXJjbGVBLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IHRoaXNEaXJlY3Rpb24gPSB0aGlzV29ybGRQb3Muc3ViKGNpcmNsZUIud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNPdGhlciA9IG5ldyBSYXkoY2lyY2xlQS53b3JsZFBvcywgb3RoZXJEaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNUaGlzID0gbmV3IFJheShjaXJjbGVCLndvcmxkUG9zLCB0aGlzRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aGlzUG9pbnQgPSBjaXJjbGVBLnJheUNhc3QocmF5VG93YXJkc090aGVyKTtcclxuICAgICAgICBjb25zdCBvdGhlclBvaW50ID0gY2lyY2xlQi5yYXlDYXN0KHJheVRvd2FyZHNUaGlzKTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KHRoaXNQb2ludCwgb3RoZXJQb2ludCk7XHJcbiAgICB9LFxyXG4gICAgQ2lyY2xlRWRnZUNsb3Nlc3RMaW5lKGNpcmNsZSwgZWRnZSkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkxOTE3Ny9ob3ctdG8tZmluZC1wb2ludC1vbi1saW5lLWNsb3Nlc3QtdG8tc3BoZXJlXHJcbiAgICAgICAgY29uc3QgY2lyY2xlV29ybFBvcyA9IGNpcmNsZS53b3JsZFBvcztcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IGVkZ2VMaW5lID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlZGdlU3RhcnQgPSBlZGdlTGluZS5iZWdpbjtcclxuICAgICAgICBjb25zdCBlZGdlVmVjdG9yID0gZWRnZUxpbmUuZ2V0RWRnZSgpO1xyXG4gICAgICAgIGNvbnN0IHAwID0gZWRnZVN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IHUgPSBlZGdlVmVjdG9yO1xyXG4gICAgICAgIC8vIFRpbWUgb2YgbWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGxldCB0ID0gKHUueCAqIChjaXJjbGVXb3JsUG9zLnggLSBwMC54KSArIHUueSAqIChjaXJjbGVXb3JsUG9zLnkgLSBwMC55KSkgLyAodS54ICogdS54ICsgdS55ICogdS55KTtcclxuICAgICAgICAvLyBJZiB0aW1lIG9mIG1pbmltdW0gaXMgcGFzdCB0aGUgZWRnZSBjbGFtcCB0byBlZGdlXHJcbiAgICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgICAgIHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDAueCArIHUueCAqIHQgLSBjaXJjbGVXb3JsUG9zLngsIDIpICsgTWF0aC5wb3cocDAueSArIHUueSAqIHQgLSBjaXJjbGVXb3JsUG9zLnksIDIpKSAtIGNpcmNsZS5yYWRpdXM7XHJcbiAgICAgICAgY29uc3QgY2lyY2xleCA9ICgocDAueCArIHUueCAqIHQgLSBjaXJjbGVXb3JsUG9zLngpICogY2lyY2xlLnJhZGl1cykgLyAoY2lyY2xlLnJhZGl1cyArIGQpO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZXkgPSAoKHAwLnkgKyB1LnkgKiB0IC0gY2lyY2xlV29ybFBvcy55KSAqIGNpcmNsZS5yYWRpdXMpIC8gKGNpcmNsZS5yYWRpdXMgKyBkKTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KHUuc2NhbGUodCkuYWRkKHAwKSwgbmV3IFZlY3RvcihjaXJjbGVXb3JsUG9zLnggKyBjaXJjbGV4LCBjaXJjbGVXb3JsUG9zLnkgKyBjaXJjbGV5KSk7XHJcbiAgICB9LFxyXG4gICAgRWRnZUVkZ2VDbG9zZXN0TGluZShlZGdlQSwgZWRnZUIpIHtcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IGVkZ2VMaW5lQSA9IGVkZ2VBLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VTdGFydEEgPSBlZGdlTGluZUEuYmVnaW47XHJcbiAgICAgICAgY29uc3QgZWRnZVZlY3RvckEgPSBlZGdlTGluZUEuZ2V0RWRnZSgpO1xyXG4gICAgICAgIGNvbnN0IHAwID0gZWRnZVN0YXJ0QTtcclxuICAgICAgICBjb25zdCB1ID0gZWRnZVZlY3RvckE7XHJcbiAgICAgICAgLy8gTDIgPSBRKHQpID0gcTAgKyB0ICogdiwgd2hlcmUgdCBpcyB0aW1lIGFuZCBxMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBlZGdlTGluZUIgPSBlZGdlQi5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlZGdlU3RhcnRCID0gZWRnZUxpbmVCLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VWZWN0b3JCID0gZWRnZUxpbmVCLmdldEVkZ2UoKTtcclxuICAgICAgICBjb25zdCBxMCA9IGVkZ2VTdGFydEI7XHJcbiAgICAgICAgY29uc3QgdiA9IGVkZ2VWZWN0b3JCO1xyXG4gICAgICAgIHJldHVybiBDbG9zZXN0TGluZShwMCwgdSwgcTAsIHYpO1xyXG4gICAgfVxyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ2lyY2xlQ29sbGlkZXIudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGNpcmNsZSBjb2xsaWRlciBmb3IgdGhlIGV4Y2FsaWJ1ciByaWdpZCBib2R5IHBoeXNpY3Mgc2ltdWxhdGlvblxyXG4gKi9cclxuY2xhc3MgQ2lyY2xlQ29sbGlkZXIgZXh0ZW5kcyBDb2xsaWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb3NpdGlvbiBvZiB0aGUgY2lyY2xlIHJlbGF0aXZlIHRvIHRoZSBjb2xsaWRlciwgYnkgZGVmYXVsdCAoMCwgMCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXggPSBBZmZpbmVNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcclxuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXgudHJhbnNsYXRlKHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxNYXRyaXguZ2V0UG9zaXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gICAgICovXHJcbiAgICBnZXQgcmFkaXVzKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxTY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLk9uZTtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgdHJhZGUgb2ZmLCB0aGUgYWx0ZXJuYXRpdmUgaXMgcmV0b29saW5nIGNpcmNsZXMgdG8gc3VwcG9ydCBlbGxpcHNlIGNvbGxpc2lvbnNcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmF0dXJhbFJhZGl1cyAqIE1hdGgubWluKHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKi9cclxuICAgIHNldCByYWRpdXModmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gKF9hID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFNjYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuT25lO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSB0cmFkZSBvZmYsIHRoZSBhbHRlcm5hdGl2ZSBpcyByZXRvb2xpbmcgY2lyY2xlcyB0byBzdXBwb3J0IGVsbGlwc2UgY29sbGlzaW9uc1xyXG4gICAgICAgIHRoaXMuX25hdHVyYWxSYWRpdXMgPSB2YWwgLyBNYXRoLm1pbihzY2FsZS54LCBzY2FsZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgc2hhcGUsIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXHJcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpZGVyIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbE1hdHJpeC5nZXRQb3NpdGlvbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBwb3MgPSAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcG9zLmRpc3RhbmNlKHBvaW50KTtcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gdGhpcy5yYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FzdHMgYSByYXkgYXQgdGhlIENpcmNsZSBjb2xsaWRlciBhbmQgcmV0dXJucyB0aGUgbmVhcmVzdCBwb2ludCBvZiBjb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSByYXlcclxuICAgICAqL1xyXG4gICAgcmF5Q2FzdChyYXksIG1heCA9IEluZmluaXR5KSB7XHJcbiAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzc3BoZXJlX2ludGVyc2VjdGlvblxyXG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICBjb25zdCBkaXIgPSByYXkuZGlyO1xyXG4gICAgICAgIGNvbnN0IG9yaWcgPSByYXkucG9zO1xyXG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IE1hdGguc3FydChNYXRoLnBvdyhkaXIuZG90KG9yaWcuc3ViKGMpKSwgMikgLSBNYXRoLnBvdyhvcmlnLnN1YihjKS5kaXN0YW5jZSgpLCAyKSArIE1hdGgucG93KHRoaXMucmFkaXVzLCAyKSk7XHJcbiAgICAgICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcclxuICAgICAgICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRvaSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRvaSA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2kgPiAwICYmIHRvaSA8IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQodG9pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9pMSA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKSArIGRpc2NyaW1pbmFudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvaTIgPSAtZGlyLmRvdChvcmlnLnN1YihjKSkgLSBkaXNjcmltaW5hbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGl2ZVRvaSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvaTEgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlVG9pLnB1c2godG9pMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9pMiA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVUb2kucHVzaCh0b2kyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbnRvaSA9IE1hdGgubWluKC4uLnBvc2l0aXZlVG9pKTtcclxuICAgICAgICAgICAgICAgIGlmIChtaW50b2kgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW50b2kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDbG9zZXN0TGluZUJldHdlZW4oc2hhcGUpIHtcclxuICAgICAgICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuQ2lyY2xlQ2lyY2xlQ2xvc2VzdExpbmUodGhpcywgc2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaGFwZSBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuUG9seWdvbkNpcmNsZUNsb3Nlc3RMaW5lKHNoYXBlLCB0aGlzKS5mbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5DaXJjbGVFZGdlQ2xvc2VzdExpbmUodGhpcywgc2hhcGUpLmZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2Ygc2hhcGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICBjb2xsaWRlKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlQ2lyY2xlKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlUG9seWdvbih0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUVkZ2UodGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjbGUgY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIENvbGxpc2lvblNoYXBlICR7dHlwZW9mIGNvbGxpZGVyfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgcG9pbnQgb24gdGhlIGNvbGxpZGVyIGZ1cnRoZXN0IGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgKi9cclxuICAgIGdldEZ1cnRoZXN0UG9pbnQoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmFkZChkaXJlY3Rpb24ubm9ybWFsaXplKCkuc2NhbGUodGhpcy5yYWRpdXMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgbG9jYWwgcG9pbnQgb24gdGhlIHNoYXBlIGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldEZ1cnRoZXN0TG9jYWxQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBkaXIgPSBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcmV0dXJuIGRpci5zY2FsZSh0aGlzLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBjb2xsaWRlciBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gKF9hID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFNjYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuT25lO1xyXG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gKF9iID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9ICgoX2MgPSB0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsUG9zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBWZWN0b3IuWmVybyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLm9mZnNldC54IC0gdGhpcy5fbmF0dXJhbFJhZGl1cywgdGhpcy5vZmZzZXQueSAtIHRoaXMuX25hdHVyYWxSYWRpdXMsIHRoaXMub2Zmc2V0LnggKyB0aGlzLl9uYXR1cmFsUmFkaXVzLCB0aGlzLm9mZnNldC55ICsgdGhpcy5fbmF0dXJhbFJhZGl1cykucm90YXRlKHJvdGF0aW9uKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHBvcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBjb2xsaWRlciBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLm9mZnNldC54IC0gdGhpcy5fbmF0dXJhbFJhZGl1cywgdGhpcy5vZmZzZXQueSAtIHRoaXMuX25hdHVyYWxSYWRpdXMsIHRoaXMub2Zmc2V0LnggKyB0aGlzLl9uYXR1cmFsUmFkaXVzLCB0aGlzLm9mZnNldC55ICsgdGhpcy5fbmF0dXJhbFJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBheGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBjaXJjbGVzLCBzaW5jZSB0aGVyZSBhcmUgaW5maW5pdGUgYXhpcyBpbiBhIGNpcmNsZVxyXG4gICAgICovXHJcbiAgICBnZXQgYXhlcygpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1vbWVudCBvZiBpbmVydGlhIG9mIGEgY2lyY2xlIGdpdmVuIGl0J3MgbWFzc1xyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAqL1xyXG4gICAgZ2V0SW5lcnRpYShtYXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIChtYXNzICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykgLyAyO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHVwZGF0ZSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbE1hdCA9IChfYSA9IHRyYW5zZm9ybS5tYXRyaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2dsb2JhbE1hdHJpeDtcclxuICAgICAgICBnbG9iYWxNYXQuY2xvbmUodGhpcy5fZ2xvYmFsTWF0cml4KTtcclxuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXgudHJhbnNsYXRlKHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0IHRoZSBjaXJjbGUgYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwcm9qZWN0KGF4aXMpIHtcclxuICAgICAgICBjb25zdCBzY2FsYXJzID0gW107XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICBjb25zdCBkb3RQcm9kdWN0ID0gcG9pbnQuZG90KGF4aXMpO1xyXG4gICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0KTtcclxuICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCAtIHRoaXMucmFkaXVzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4LCBjb2xvcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxTY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLk9uZTtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IChfYiA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxSb3RhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICBjb25zdCBwb3MgPSAoKF9jID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFBvcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogVmVjdG9yLlplcm8pO1xyXG4gICAgICAgIGV4LnNhdmUoKTtcclxuICAgICAgICBleC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcclxuICAgICAgICBleC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgIGV4LnNjYWxlKHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgICAgIGV4LmRyYXdDaXJjbGUoKChfZCA9IHRoaXMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBWZWN0b3IuWmVybyksIHRoaXMuX25hdHVyYWxSYWRpdXMsIENvbG9yLlRyYW5zcGFyZW50LCBjb2xvciwgMik7XHJcbiAgICAgICAgZXgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0RldGVjdGlvbi9Db2xsaXNpb25Db250YWN0LnRzXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENvbGxpc2lvbiBjb250YWN0cyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IEV4Y2FsaWJ1ciB0byByZXNvbHZlIGNvbGxpc2lvbiBiZXR3ZWVuIGNvbGxpZGVycy4gVGhpc1xyXG4gKiBQYWlyIHByZXZlbnRzIGNvbGxpc2lvbnMgZnJvbSBiZWluZyBldmFsdWF0ZWQgbW9yZSB0aGFuIG9uZSB0aW1lXHJcbiAqL1xyXG5jbGFzcyBDb2xsaXNpb25Db250YWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyQSwgY29sbGlkZXJCLCBtdHYsIG5vcm1hbCwgdGFuZ2VudCwgcG9pbnRzLCBsb2NhbFBvaW50cywgaW5mbykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyQSA9IGNvbGxpZGVyQTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyQiA9IGNvbGxpZGVyQjtcclxuICAgICAgICB0aGlzLm10diA9IG10djtcclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICB0aGlzLnRhbmdlbnQgPSB0YW5nZW50O1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIHRoaXMubG9jYWxQb2ludHMgPSBsb2NhbFBvaW50cztcclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gICAgICAgIHRoaXMuaWQgPSBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGNvbGxpZGVyQS5pZCwgY29sbGlkZXJCLmlkKTtcclxuICAgICAgICBpZiAoY29sbGlkZXJBLl9fY29tcG9zaXRlQ29sbGlkZXJJZCB8fCBjb2xsaWRlckIuX19jb21wb3NpdGVDb2xsaWRlcklkKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCBvbiB0aGUgcGFyZW50IGNvbXBvc2l0ZSBwYWlyIGZvciBzdGFydC9lbmQgY29udGFjdFxyXG4gICAgICAgICAgICB0aGlzLmlkICs9ICd8JyArIFBhaXIuY2FsY3VsYXRlUGFpckhhc2goKF9hID0gY29sbGlkZXJBLl9fY29tcG9zaXRlQ29sbGlkZXJJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sbGlkZXJBLmlkLCAoX2IgPSBjb2xsaWRlckIuX19jb21wb3NpdGVDb2xsaWRlcklkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb2xsaWRlckIuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2ggY29udGFjdCBhd2FrZSBzdGF0ZSwgZXhjZXB0IGlmIGJvZHkncyBhcmUgRml4ZWRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hBd2FrZSgpIHtcclxuICAgICAgICBjb25zdCBib2R5QSA9IHRoaXMuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBjb25zdCBib2R5QiA9IHRoaXMuY29sbGlkZXJCLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLnNsZWVwaW5nICE9PSBib2R5Qi5zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLnNsZWVwaW5nICYmIGJvZHlBLmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUIuc2xlZXBNb3Rpb24gPj0gUGh5c2ljcy53YWtlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuc2V0U2xlZXBpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLnNsZWVwaW5nICYmIGJvZHlCLmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUEuc2xlZXBNb3Rpb24gPj0gUGh5c2ljcy53YWtlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuc2V0U2xlZXBpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDYW5jZWxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsZWQ7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9TZXBhcmF0aW5nQXhpcy50c1xuY2xhc3MgU2VwYXJhdGluZ0F4aXMge1xyXG4gICAgc3RhdGljIGZpbmRQb2x5Z29uUG9seWdvblNlcGFyYXRpb24ocG9seUEsIHBvbHlCKSB7XHJcbiAgICAgICAgbGV0IGJlc3RTZXBhcmF0aW9uID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcclxuICAgICAgICBsZXQgYmVzdEF4aXMgPSBudWxsO1xyXG4gICAgICAgIGxldCBiZXN0U2lkZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RPdGhlclBvaW50ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHBvbHlBLmdldFNpZGVzKCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWxTaWRlcyA9IHBvbHlBLmdldExvY2FsU2lkZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBzaWRlc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgYXhpcyA9IHNpZGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRCID0gcG9seUIuZ2V0RnVydGhlc3RQb2ludChheGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgLy8gU2VwYXJhdGlvbiBvbiBzaWRlIGkncyBheGlzXHJcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciB0aGUgbGFyZ2VzdCBzZXBhcmF0aW9uIGJldHdlZW4gcG9seSBBJ3Mgc2lkZXNcclxuICAgICAgICAgICAgY29uc3QgdmVydFNlcGFyYXRpb24gPSBzaWRlLmRpc3RhbmNlVG9Qb2ludCh2ZXJ0QiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0U2VwYXJhdGlvbiA+IGJlc3RTZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHZlcnRTZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGUgPSBzaWRlO1xyXG4gICAgICAgICAgICAgICAgYmVzdEF4aXMgPSBheGlzO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGVJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBiZXN0T3RoZXJQb2ludCA9IHZlcnRCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyOiBwb2x5QSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogYmVzdEF4aXMgPyBiZXN0U2VwYXJhdGlvbiA6IDk5LFxyXG4gICAgICAgICAgICBheGlzOiBiZXN0QXhpcyxcclxuICAgICAgICAgICAgc2lkZTogYmVzdFNpZGUsXHJcbiAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlc1tiZXN0U2lkZUluZGV4XSxcclxuICAgICAgICAgICAgc2lkZUlkOiBiZXN0U2lkZUluZGV4LFxyXG4gICAgICAgICAgICBwb2ludDogYmVzdE90aGVyUG9pbnQsXHJcbiAgICAgICAgICAgIGxvY2FsUG9pbnQ6IGJlc3RBeGlzID8gcG9seUIuZ2V0RnVydGhlc3RMb2NhbFBvaW50KGJlc3RBeGlzLm5lZ2F0ZSgpKSA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRDaXJjbGVQb2x5Z29uU2VwYXJhdGlvbihjaXJjbGUsIHBvbHlnb24pIHtcclxuICAgICAgICBjb25zdCBheGVzID0gcG9seWdvbi5heGVzO1xyXG4gICAgICAgIGNvbnN0IHBjID0gcG9seWdvbi5jZW50ZXI7XHJcbiAgICAgICAgLy8gU3BlY2lhbCBTQVQgd2l0aCBjaXJjbGVzXHJcbiAgICAgICAgY29uc3QgcG9seURpciA9IHBjLnN1YihjaXJjbGUud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludE9uUG9seSA9IHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludChwb2x5RGlyLm5lZ2F0ZSgpKTtcclxuICAgICAgICBheGVzLnB1c2goY2xvc2VzdFBvaW50T25Qb2x5LnN1YihjaXJjbGUud29ybGRQb3MpLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICBsZXQgbWluT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1pbkF4aXMgPSBudWxsO1xyXG4gICAgICAgIGxldCBtaW5JbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qMSA9IHBvbHlnb24ucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvajIgPSBjaXJjbGUucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ29sbGlzaW9uSnVtcFRhYmxlLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IENvbGxpc2lvbkp1bXBUYWJsZSA9IHtcclxuICAgIENvbGxpZGVDaXJjbGVDaXJjbGUoY2lyY2xlQSwgY2lyY2xlQikge1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZUFQb3MgPSBjaXJjbGVBLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZUJQb3MgPSBjaXJjbGVCLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkUmFkaXVzID0gY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cztcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNpcmNsZUFQb3MuZGlzdGFuY2UoY2lyY2xlQlBvcyk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gY29tYmluZWRSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuZWdhdGl2ZSBtZWFucyBvdmVybGFwXHJcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNvbWJpbmVkUmFkaXVzIC0gZGlzdGFuY2U7XHJcbiAgICAgICAgLy8gTm9ybWFsIHBvaW50cyBmcm9tIEEgLT4gQlxyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGNpcmNsZUJQb3Muc3ViKGNpcmNsZUFQb3MpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHRhbmdlbnQgPSBub3JtYWwucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIGNvbnN0IG12dCA9IG5vcm1hbC5zY2FsZShzZXBhcmF0aW9uKTtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGNpcmNsZUEuZ2V0RnVydGhlc3RQb2ludChub3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gY2lyY2xlQS5nZXRGdXJ0aGVzdExvY2FsUG9pbnQobm9ybWFsKTtcclxuICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICBjb2xsaWRlcjogY2lyY2xlQSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbixcclxuICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbbmV3IENvbGxpc2lvbkNvbnRhY3QoY2lyY2xlQSwgY2lyY2xlQiwgbXZ0LCBub3JtYWwsIHRhbmdlbnQsIFtwb2ludF0sIFtsb2NhbF0sIGluZm8pXTtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlQ2lyY2xlUG9seWdvbihjaXJjbGUsIHBvbHlnb24pIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCBtaW5BeGlzID0gU2VwYXJhdGluZ0F4aXMuZmluZENpcmNsZVBvbHlnb25TZXBhcmF0aW9uKGNpcmNsZSwgcG9seWdvbik7XHJcbiAgICAgICAgaWYgKCFtaW5BeGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIG1pbkF4aXMgaXMgcG9pbnRpbmcgYXdheSBmcm9tIGNpcmNsZVxyXG4gICAgICAgIGNvbnN0IHNhbWVkaXIgPSBtaW5BeGlzLmRvdChwb2x5Z29uLmNlbnRlci5zdWIoY2lyY2xlLmNlbnRlcikpO1xyXG4gICAgICAgIG1pbkF4aXMgPSBzYW1lZGlyIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gY2lyY2xlLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcyk7XHJcbiAgICAgICAgY29uc3QgeGYgPSAoX2IgPSAoX2EgPSBjaXJjbGUub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0geGYuYXBwbHlJbnZlcnNlKHBvaW50KTtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBtaW5BeGlzLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgIHNlcGFyYXRpb246IC1taW5BeGlzLnNpemUsXHJcbiAgICAgICAgICAgIGF4aXM6IG5vcm1hbCxcclxuICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxyXG4gICAgICAgICAgICBsb2NhbFBvaW50OiBsb2NhbCxcclxuICAgICAgICAgICAgc2lkZTogcG9seWdvbi5maW5kU2lkZShub3JtYWwubmVnYXRlKCkpLFxyXG4gICAgICAgICAgICBsb2NhbFNpZGU6IHBvbHlnb24uZmluZExvY2FsU2lkZShub3JtYWwubmVnYXRlKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gW25ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgcG9seWdvbiwgbWluQXhpcywgbm9ybWFsLCBub3JtYWwucGVycGVuZGljdWxhcigpLCBbcG9pbnRdLCBbbG9jYWxdLCBpbmZvKV07XHJcbiAgICB9LFxyXG4gICAgQ29sbGlkZUNpcmNsZUVkZ2UoY2lyY2xlLCBlZGdlKSB7XHJcbiAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSB0aGlzIGFjdHVhbGx5IGFiaWRlcyBieSBsb2NhbC93b3JsZCBjb2xsaXNpb25zXHJcbiAgICAgICAgLy8gQXJlIGVkZ2UuYmVnaW4gYW5kIGVkZ2UuZW5kIGxvY2FsIHNwYWNlIG9yIHdvcmxkIHNwYWNlPyBJIHRoaW5rIHRoZXkgc2hvdWxkIGJlIGxvY2FsXHJcbiAgICAgICAgLy8gY2VudGVyIG9mIHRoZSBjaXJjbGUgaW4gd29ybGQgcG9zXHJcbiAgICAgICAgY29uc3QgY2MgPSBjaXJjbGUuY2VudGVyO1xyXG4gICAgICAgIC8vIHZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlXHJcbiAgICAgICAgY29uc3QgZWRnZVdvcmxkID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlID0gZWRnZVdvcmxkLmVuZC5zdWIoZWRnZVdvcmxkLmJlZ2luKTtcclxuICAgICAgICAvLyBhbW91bnQgb2Ygb3ZlcmxhcCB3aXRoIHRoZSBjaXJjbGUncyBjZW50ZXIgYWxvbmcgdGhlIGVkZ2UgZGlyZWN0aW9uXHJcbiAgICAgICAgY29uc3QgdSA9IGUuZG90KGVkZ2VXb3JsZC5lbmQuc3ViKGNjKSk7XHJcbiAgICAgICAgY29uc3QgdiA9IGUuZG90KGNjLnN1YihlZGdlV29ybGQuYmVnaW4pKTtcclxuICAgICAgICBjb25zdCBzaWRlID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBsb2NhbFNpZGUgPSBlZGdlLmFzTG9jYWxMaW5lKCk7XHJcbiAgICAgICAgLy8gUG90ZW50aWFsIHJlZ2lvbiBBIGNvbGxpc2lvbiAoY2lyY2xlIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVkZ2UsIGJlZm9yZSB0aGUgYmVnaW5uaW5nKVxyXG4gICAgICAgIGlmICh2IDw9IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGEgPSBlZGdlV29ybGQuYmVnaW4uc3ViKGNjKTtcclxuICAgICAgICAgICAgY29uc3QgZGRhID0gZGEuZG90KGRhKTsgLy8gcXVpY2sgYW5kIGRpcnR5IHdheSBvZiBjYWxjJ24gZGlzdGFuY2UgaW4gcl4yIHRlcm1zIHNhdmVzIHNvbWUgc3FydHNcclxuICAgICAgICAgICAgLy8gc2F2ZSBzb21lIHNxcnRzXHJcbiAgICAgICAgICAgIGlmIChkZGEgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSBkYS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRhKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uOiBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHNpZGUuYmVnaW4sXHJcbiAgICAgICAgICAgICAgICBzaWRlOiBzaWRlLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxTaWRlOiBsb2NhbFNpZGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgbm9ybWFsLnNjYWxlKHNlcGFyYXRpb24pLCBub3JtYWwsIG5vcm1hbC5wZXJwZW5kaWN1bGFyKCksIFtzaWRlLmJlZ2luXSwgW2xvY2FsU2lkZS5iZWdpbl0sIGluZm8pXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvdGVudGlhbCByZWdpb24gQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZWRnZSwgYWZ0ZXIgdGhlIGVuZClcclxuICAgICAgICBpZiAodSA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRiID0gZWRnZVdvcmxkLmVuZC5zdWIoY2MpO1xyXG4gICAgICAgICAgICBjb25zdCBkZGIgPSBkYi5kb3QoZGIpO1xyXG4gICAgICAgICAgICBpZiAoZGRiID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSBkYi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRiKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uOiBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHNpZGUuZW5kLFxyXG4gICAgICAgICAgICAgICAgc2lkZTogc2lkZSxcclxuICAgICAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG5vcm1hbC5zY2FsZShzZXBhcmF0aW9uKSwgbm9ybWFsLCBub3JtYWwucGVycGVuZGljdWxhcigpLCBbc2lkZS5lbmRdLCBbbG9jYWxTaWRlLmVuZF0sIGluZm8pXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBwb3RlbnRpYWwgcmVnaW9uIEFCIGNvbGxpc2lvbiAoY2lyY2xlIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIGVkZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQpXHJcbiAgICAgICAgY29uc3QgZGVuID0gZS5kb3QoZSk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRPbkVkZ2UgPSBlZGdlV29ybGQuYmVnaW5cclxuICAgICAgICAgICAgLnNjYWxlKHUpXHJcbiAgICAgICAgICAgIC5hZGQoZWRnZVdvcmxkLmVuZC5zY2FsZSh2KSlcclxuICAgICAgICAgICAgLnNjYWxlKDEgLyBkZW4pO1xyXG4gICAgICAgIGNvbnN0IGQgPSBjYy5zdWIocG9pbnRPbkVkZ2UpO1xyXG4gICAgICAgIGNvbnN0IGRkID0gZC5kb3QoZCk7XHJcbiAgICAgICAgaWYgKGRkID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vcm1hbCA9IGUucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIC8vIGZsaXAgY29ycmVjdCBkaXJlY3Rpb25cclxuICAgICAgICBpZiAobm9ybWFsLmRvdChjYy5zdWIoZWRnZVdvcmxkLmJlZ2luKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbC54ID0gLW5vcm1hbC54O1xyXG4gICAgICAgICAgICBub3JtYWwueSA9IC1ub3JtYWwueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9ybWFsID0gbm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb24gPSBjaXJjbGUucmFkaXVzIC0gTWF0aC5zcXJ0KGRkKTtcclxuICAgICAgICBjb25zdCBtdnQgPSBub3JtYWwuc2NhbGUoc2VwYXJhdGlvbik7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgY29sbGlkZXI6IGNpcmNsZSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogc2VwYXJhdGlvbixcclxuICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnRPbkVkZ2UsXHJcbiAgICAgICAgICAgIHNpZGU6IHNpZGUsXHJcbiAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG12dCwgbm9ybWFsLm5lZ2F0ZSgpLCBub3JtYWwubmVnYXRlKCkucGVycGVuZGljdWxhcigpLCBbcG9pbnRPbkVkZ2VdLCBbcG9pbnRPbkVkZ2Uuc3ViKGVkZ2Uud29ybGRQb3MpXSwgaW5mbylcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVFZGdlRWRnZSgpIHtcclxuICAgICAgICAvLyBFZGdlLWVkZ2UgY29sbGlzaW9uIGRvZXNuJ3QgbWFrZSBzZW5zZVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlUG9seWdvbkVkZ2UocG9seWdvbiwgZWRnZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBwYyA9IHBvbHlnb24uY2VudGVyO1xyXG4gICAgICAgIGNvbnN0IGVjID0gZWRnZS5jZW50ZXI7XHJcbiAgICAgICAgY29uc3QgZGlyID0gZWMuc3ViKHBjKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAvLyBidWlsZCBhIHRlbXBvcmFyeSBwb2x5Z29uIGZyb20gdGhlIGVkZ2UgdG8gdXNlIFNBVFxyXG4gICAgICAgIGNvbnN0IGxpbmVQb2x5ID0gbmV3IFBvbHlnb25Db2xsaWRlcih7XHJcbiAgICAgICAgICAgIHBvaW50czogW2VkZ2UuYmVnaW4sIGVkZ2UuZW5kLCBlZGdlLmVuZC5hZGQoZGlyLnNjYWxlKDEwMCkpLCBlZGdlLmJlZ2luLmFkZChkaXIuc2NhbGUoMTAwKSldLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGVkZ2Uub2Zmc2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGluZVBvbHkub3duZXIgPSBlZGdlLm93bmVyO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gKF9hID0gZWRnZS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIGlmICh0eCkge1xyXG4gICAgICAgICAgICBsaW5lUG9seS51cGRhdGUoZWRnZS5vd25lci5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5nZXQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdyb3NzIGhhY2sgYnV0IHBvbHktcG9seSB3b3JrcyB3ZWxsXHJcbiAgICAgICAgY29uc3QgY29udGFjdCA9IHRoaXMuQ29sbGlkZVBvbHlnb25Qb2x5Z29uKHBvbHlnb24sIGxpbmVQb2x5KTtcclxuICAgICAgICBpZiAoY29udGFjdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gRnVkZ2UgdGhlIGNvbnRhY3QgYmFjayB0byBlZGdlXHJcbiAgICAgICAgICAgIGNvbnRhY3RbMF0uY29sbGlkZXJCID0gZWRnZTtcclxuICAgICAgICAgICAgY29udGFjdFswXS5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2gocG9seWdvbi5pZCwgZWRnZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWN0O1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVQb2x5Z29uUG9seWdvbihwb2x5QSwgcG9seUIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgLy8gTXVsdGkgY29udGFjdCBmcm9tIFNBVFxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2FtZWRldi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTExMzkwL211bHRpcGxlLWNvbnRhY3RzLWZvci1zYXQtY29sbGlzaW9uLWRldGVjdGlvblxyXG4gICAgICAgIC8vIGRvIGEgU0FUIHRlc3QgdG8gZmluZCBhIG1pbiBheGlzIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb25BID0gU2VwYXJhdGluZ0F4aXMuZmluZFBvbHlnb25Qb2x5Z29uU2VwYXJhdGlvbihwb2x5QSwgcG9seUIpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG92ZXJsYXAgZnJvbSBib3hBJ3MgcGVyc3BlY3RpdmUgd2UgY2FuIGVuZCBlYXJseVxyXG4gICAgICAgIGlmIChzZXBhcmF0aW9uQS5zZXBhcmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb25CID0gU2VwYXJhdGluZ0F4aXMuZmluZFBvbHlnb25Qb2x5Z29uU2VwYXJhdGlvbihwb2x5QiwgcG9seUEpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG92ZXJsYXAgZnJvbSBib3hCJ3MgcGVyc3BlY3RpdmUgZXhpdCBub3dcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkIuc2VwYXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXBhcmF0aW9ucyBhcmUgYm90aCBuZWdhdGl2ZSwgd2Ugd2FudCB0byBwaWNrIHRoZSBsZWFzdCBuZWdhdGl2ZSAobWluaW1hbCBtb3ZlbWVudClcclxuICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gc2VwYXJhdGlvbkEuc2VwYXJhdGlvbiA+IHNlcGFyYXRpb25CLnNlcGFyYXRpb24gPyBzZXBhcmF0aW9uQSA6IHNlcGFyYXRpb25CO1xyXG4gICAgICAgIC8vIFRoZSBpbmNpZGVudCBzaWRlIGlzIHRoZSBtb3N0IG9wcG9zaXRlIGZyb20gdGhlIGF4ZXMgb2YgY29sbGlzaW9uIG9uIHRoZSBvdGhlciBjb2xsaWRlclxyXG4gICAgICAgIGNvbnN0IG90aGVyID0gc2VwYXJhdGlvbi5jb2xsaWRlciA9PT0gcG9seUEgPyBwb2x5QiA6IHBvbHlBO1xyXG4gICAgICAgIGNvbnN0IGluY2lkZW50ID0gb3RoZXIuZmluZFNpZGUoc2VwYXJhdGlvbi5heGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAvLyBDbGlwIGluY2lkZW50IHNpZGUgYnkgdGhlIHBlcnBlbmRpY3VsYXIgbGluZXMgYXQgZWFjaCBlbmQgb2YgdGhlIHJlZmVyZW5jZSBzaWRlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtXHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VwYXJhdGlvbi5zaWRlO1xyXG4gICAgICAgIGNvbnN0IHJlZkRpciA9IHJlZmVyZW5jZS5kaXIoKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAvLyBGaW5kIG91ciBjb250YWN0IHBvaW50cyBieSBjbGlwcGluZyB0aGUgaW5jaWRlbnQgYnkgdGhlIGNvbGxpc2lvbiBzaWRlXHJcbiAgICAgICAgY29uc3QgY2xpcFJpZ2h0ID0gaW5jaWRlbnQuY2xpcChyZWZEaXIubmVnYXRlKCksIC1yZWZEaXIuZG90KHJlZmVyZW5jZS5iZWdpbikpO1xyXG4gICAgICAgIGxldCBjbGlwTGVmdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNsaXBSaWdodCkge1xyXG4gICAgICAgICAgICBjbGlwTGVmdCA9IGNsaXBSaWdodC5jbGlwKHJlZkRpciwgcmVmRGlyLmRvdChyZWZlcmVuY2UuZW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlZnQgdGhlcmUgaXMgbm8gY29sbGlzaW9uXHJcbiAgICAgICAgaWYgKGNsaXBMZWZ0KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBjbGlwIHBvaW50cyBiZWxvdyB0aGUgcmVmZXJlbmNlIGVkZ2UsIGRpc2NhcmQgdGhlIG90aGVyc1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBjbGlwTGVmdC5nZXRQb2ludHMoKS5maWx0ZXIoKHApID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2UuYmVsb3cocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsID0gc2VwYXJhdGlvbi5heGlzO1xyXG4gICAgICAgICAgICBsZXQgdGFuZ2VudCA9IG5vcm1hbC5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgIC8vIFBvaW50IENvbnRhY3QgQSAtPiBCXHJcbiAgICAgICAgICAgIGlmIChwb2x5Qi5jZW50ZXIuc3ViKHBvbHlBLmNlbnRlcikuZG90KG5vcm1hbCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBub3JtYWwubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0YW5nZW50ID0gbm9ybWFsLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQb2ludHMgYXJlIGNsaXBwZWQgZnJvbSBpbmNpZGVudCB3aGljaCBpcyB0aGUgb3RoZXIgY29sbGlkZXJcclxuICAgICAgICAgICAgLy8gU3RvcmUgdGhvc2UgYXMgbG9jYWxzXHJcbiAgICAgICAgICAgIGxldCBsb2NhbFBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbi5jb2xsaWRlciA9PT0gcG9seUEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhmID0gKF9iID0gKF9hID0gcG9seUIub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgbG9jYWxQb2ludHMgPSBwb2ludHMubWFwKChwKSA9PiB4Zi5hcHBseUludmVyc2UocCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeGYgPSAoX2QgPSAoX2MgPSBwb2x5QS5vd25lcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFBvaW50cyA9IHBvaW50cy5tYXAoKHApID0+IHhmLmFwcGx5SW52ZXJzZShwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtuZXcgQ29sbGlzaW9uQ29udGFjdChwb2x5QSwgcG9seUIsIG5vcm1hbC5zY2FsZSgtc2VwYXJhdGlvbi5zZXBhcmF0aW9uKSwgbm9ybWFsLCB0YW5nZW50LCBwb2ludHMsIGxvY2FsUG9pbnRzLCBzZXBhcmF0aW9uKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0sXHJcbiAgICBGaW5kQ29udGFjdFNlcGFyYXRpb24oY29udGFjdCwgbG9jYWxQb2ludCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCBzaGFwZUEgPSBjb250YWN0LmNvbGxpZGVyQTtcclxuICAgICAgICBjb25zdCB0eEEgPSAoX2IgPSAoX2EgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgY29uc3Qgc2hhcGVCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgY29uc3QgdHhCID0gKF9kID0gKF9jID0gY29udGFjdC5jb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgIC8vIGJvdGggYXJlIGNpcmNsZXNcclxuICAgICAgICBpZiAoc2hhcGVBIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIgJiYgc2hhcGVCIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tYmluZWRSYWRpdXMgPSBzaGFwZUEucmFkaXVzICsgc2hhcGVCLnJhZGl1cztcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0eEEucG9zLmRpc3RhbmNlKHR4Qi5wb3MpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gY29tYmluZWRSYWRpdXMgLSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgcmV0dXJuIC1zZXBhcmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBib3RoIGFyZSBwb2x5Z29uc1xyXG4gICAgICAgIGlmIChzaGFwZUEgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIgJiYgc2hhcGVCIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8ubG9jYWxTaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2lkZTtcclxuICAgICAgICAgICAgICAgIGxldCB3b3JsZFBvaW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuaW5mby5jb2xsaWRlciA9PT0gc2hhcGVBKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9IG5ldyBMaW5lU2VnbWVudCh0eEEuYXBwbHkoY29udGFjdC5pbmZvLmxvY2FsU2lkZS5iZWdpbiksIHR4QS5hcHBseShjb250YWN0LmluZm8ubG9jYWxTaWRlLmVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlID0gbmV3IExpbmVTZWdtZW50KHR4Qi5hcHBseShjb250YWN0LmluZm8ubG9jYWxTaWRlLmJlZ2luKSwgdHhCLmFwcGx5KGNvbnRhY3QuaW5mby5sb2NhbFNpZGUuZW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRQb2ludCA9IHR4QS5hcHBseShsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwb2x5Z29uIHYgY2lyY2xlXHJcbiAgICAgICAgaWYgKChzaGFwZUEgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIgJiYgc2hhcGVCIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHx8XHJcbiAgICAgICAgICAgIChzaGFwZUIgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIgJiYgc2hhcGVBIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSB0eEEuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3QuaW5mby5zaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwb2x5Z29uIHYgZWRnZVxyXG4gICAgICAgIGlmICgoc2hhcGVBIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyICYmIHNoYXBlQiBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikgfHxcclxuICAgICAgICAgICAgKHNoYXBlQiBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlciAmJiBzaGFwZUEgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGxldCB3b3JsZFBvaW50O1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5pbmZvLmNvbGxpZGVyID09PSBzaGFwZUEpIHtcclxuICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFBvaW50ID0gdHhBLmFwcGx5KGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3QuaW5mby5zaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaXJjbGUgdiBlZGdlXHJcbiAgICAgICAgaWYgKChzaGFwZUEgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlciAmJiBzaGFwZUIgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHx8XHJcbiAgICAgICAgICAgIChzaGFwZUIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlciAmJiBzaGFwZUEgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIExvY2FsIHBvaW50IGlzIGFsd2F5cyBvbiB0aGUgZWRnZSB3aGljaCBpcyBhbHdheXMgc2hhcGVCXHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGxldCBjaXJjbGVQb2ludDtcclxuICAgICAgICAgICAgaWYgKHNoYXBlQSBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjaXJjbGVQb2ludCA9IHNoYXBlQS5nZXRGdXJ0aGVzdFBvaW50KGNvbnRhY3Qubm9ybWFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gd29ybGRQb2ludC5kaXN0YW5jZShjaXJjbGVQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3QgPiAwID8gLWRpc3QgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvRWRnZUNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVkZ2UgaXMgYSBzaW5nbGUgbGluZSBjb2xsaWRlciB0byBjcmVhdGUgY29sbGlzaW9ucyB3aXRoIGEgc2luZ2xlIGxpbmUuXHJcbiAqL1xyXG5jbGFzcyBFZGdlQ29sbGlkZXIgZXh0ZW5kcyBDb2xsaWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4ID0gQWZmaW5lTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgdGhpcy5iZWdpbiA9IG9wdGlvbnMuYmVnaW4gfHwgVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5lbmQgPSBvcHRpb25zLmVuZCB8fCBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IChfYSA9IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRWRnZSwgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFZGdlQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBiZWdpbjogdGhpcy5iZWdpbi5jbG9uZSgpLFxyXG4gICAgICAgICAgICBlbmQ6IHRoaXMuZW5kLmNsb25lKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCB3b3JsZFBvcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MuYWRkKHRoaXMub2Zmc2V0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgY29uc3QgcG9zID0gYmVnaW4uYXZlcmFnZShlbmQpO1xyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9XHJcbiAgICBfZ2V0VHJhbnNmb3JtZWRCZWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsTWF0cml4Lm11bHRpcGx5KHRoaXMuYmVnaW4pO1xyXG4gICAgfVxyXG4gICAgX2dldFRyYW5zZm9ybWVkRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxNYXRyaXgubXVsdGlwbHkodGhpcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXRTbG9wZSgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGdldExlbmd0aCgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlzaW9uIGFyZWFcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICByYXlDYXN0KHJheSwgbWF4ID0gSW5maW5pdHkpIHtcclxuICAgICAgICBjb25zdCBudW1lcmF0b3IgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkuc3ViKHJheS5wb3MpO1xyXG4gICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xyXG4gICAgICAgIGlmIChyYXkuZGlyLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHJheS5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICBjb25zdCBkaXZpc29yID0gcmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpO1xyXG4gICAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ID0gbnVtZXJhdG9yLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSBtYXgpIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG51bWVyYXRvci5jcm9zcyhyYXkuZGlyKSAvIGRpdmlzb3IgLyB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2xvc2VzIGxpbmUgYmV0d2VlbiB0aGlzIGFuZCBhbm90aGVyIGNvbGxpZGVyLCBmcm9tIHRoaXMgLT4gY29sbGlkZXJcclxuICAgICAqIEBwYXJhbSBzaGFwZVxyXG4gICAgICovXHJcbiAgICBnZXRDbG9zZXN0TGluZUJldHdlZW4oc2hhcGUpIHtcclxuICAgICAgICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuQ2lyY2xlRWRnZUNsb3Nlc3RMaW5lKHNoYXBlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25FZGdlQ2xvc2VzdExpbmUoc2hhcGUsIHRoaXMpLmZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLkVkZ2VFZGdlQ2xvc2VzdExpbmUodGhpcywgc2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBzaGFwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoc2hhcGUpIHtcclxuICAgICAgICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVFZGdlKHNoYXBlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvbkVkZ2Uoc2hhcGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaGFwZSBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVFZGdlRWRnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFZGdlIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBzaGFwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBjb2xsaWRlciBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRFbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24uZG90KHRyYW5zZm9ybWVkQmVnaW4pID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCZWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEVuZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYm91bmRzRnJvbUJlZ2luRW5kKGJlZ2luLCBlbmQsIHBhZGRpbmcgPSAxMCkge1xyXG4gICAgICAgIC8vIEEgcGVyZmVjdGx5IHZlcnRpY2FsIG9yIGhvcml6b250YWwgZWRnZSB3b3VsZCBoYXZlIGEgYm91bmRzIDAgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgLy8gdGhpcyBjYXVzZXMgcHJvYmxlbXMgZm9yIHRoZSBjb2xsaXNpb24gc3lzdGVtIHNvIHdlIGdpdmUgdGhlbSBzb21lIHBhZGRpbmdcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KE1hdGgubWluKGJlZ2luLngsIGVuZC54KSAtIHBhZGRpbmcsIE1hdGgubWluKGJlZ2luLnksIGVuZC55KSAtIHBhZGRpbmcsIE1hdGgubWF4KGJlZ2luLngsIGVuZC54KSArIHBhZGRpbmcsIE1hdGgubWF4KGJlZ2luLnksIGVuZC55KSArIHBhZGRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBlZGdlIGNvbGxpZGVyIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kc0Zyb21CZWdpbkVuZCh0cmFuc2Zvcm1lZEJlZ2luLCB0cmFuc2Zvcm1lZEVuZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGVkZ2UgY29sbGlkZXIgaW4gbG9jYWwgc3BhY2VcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNGcm9tQmVnaW5FbmQodGhpcy5iZWdpbiwgdGhpcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgZWRnZSByZXByZXNlbnRlZCBhcyBhIGxpbmUgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgYXNMaW5lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZVNlZ21lbnQodGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLCB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoaXMgZWRnZSBhcyBhIGxpbmUgaW4gbG9jYWwgbGluZSBjb29yZGluYXRlcyAocmVsYXRpdmUgdG8gdGhlIHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBhc0xvY2FsTGluZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KHRoaXMuYmVnaW4sIHRoaXMuZW5kKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWRnZVxyXG4gICAgICovXHJcbiAgICBnZXQgYXhlcygpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKS5zdWIodGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpKTtcclxuICAgICAgICBjb25zdCBlZGdlTm9ybWFsID0gZS5ub3JtYWwoKTtcclxuICAgICAgICBjb25zdCBheGVzID0gW107XHJcbiAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwpO1xyXG4gICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5lZ2F0ZSgpKTtcclxuICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5ub3JtYWwoKSk7XHJcbiAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubm9ybWFsKCkubmVnYXRlKCkpO1xyXG4gICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1vbWVudCBvZiBpbmVydGlhIGZvciBhbiBlZGdlXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICovXHJcbiAgICBnZXRJbmVydGlhKG1hc3MpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikuZGlzdGFuY2UoKSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIG1hc3MgKiBsZW5ndGggKiBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbE1hdCA9IChfYSA9IHRyYW5zZm9ybS5tYXRyaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2dsb2JhbE1hdHJpeDtcclxuICAgICAgICBnbG9iYWxNYXQuY2xvbmUodGhpcy5fZ2xvYmFsTWF0cml4KTtcclxuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXgudHJhbnNsYXRlKHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0IHRoZSBlZGdlIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHJvamVjdChheGlzKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGFycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFt0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCksIHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCldO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2gocG9pbnRzW2ldLmRvdChheGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICBleC5kcmF3TGluZShiZWdpbiwgZW5kLCBjb2xvciwgMik7XHJcbiAgICAgICAgZXguZHJhd0NpcmNsZShiZWdpbiwgMiwgY29sb3IpO1xyXG4gICAgICAgIGV4LmRyYXdDaXJjbGUoZW5kLCAyLCBjb2xvcik7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL1BvbHlnb25Db2xsaWRlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUG9seWdvbiBjb2xsaWRlciBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnNcclxuICovXHJcbmNsYXNzIFBvbHlnb25Db2xsaWRlciBleHRlbmRzIENvbGxpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9zaWRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU2lkZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9nbG9iYWxNYXRyaXggPSBBZmZpbmVNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50c0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9zaWRlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9sb2NhbFNpZGVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKF9hID0gb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMuX2dsb2JhbE1hdHJpeC50cmFuc2xhdGUodGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSk7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSAoX2IgPSBvcHRpb25zLnBvaW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IHRoaXMuX2lzQ291bnRlckNsb2Nrd2lzZVdpbmRpbmcodGhpcy5wb2ludHMpO1xyXG4gICAgICAgIGlmICghY291bnRlckNsb2Nrd2lzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbnZleCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdFeGNhbGlidXIgb25seSBzdXBwb3J0cyBjb252ZXggcG9seWdvbiBjb2xsaWRlcnMgYW5kIHdpbGwgbm90IGJlaGF2ZSBwcm9wZXJseS4nICtcclxuICAgICAgICAgICAgICAgICdDYWxsIFBvbHlnb25Db2xsaWRlci50cmlhbmd1bGF0ZSgpIHRvIGJ1aWxkIGEgbmV3IGNvbGxpZGVyIGNvbXBvc2VkIG9mIHNtYWxsZXIgY29udmV4IHRyaWFuZ2xlcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBvaW50cyBpbiB0aGUgcG9seWdvbiBpbiBvcmRlciBhcm91bmQgdGhlIHBlcmltZXRlciBpbiBsb2NhbCBjb29yZGluYXRlcy4gVGhlc2UgYXJlIHJlbGF0aXZlIGZyb20gdGhlIGJvZHkgdHJhbnNmb3JtIHBvc2l0aW9uLlxyXG4gICAgICogRXhjYWxpYnVyIHN0b3JlcyB0aGVzZSBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlclxyXG4gICAgICovXHJcbiAgICBzZXQgcG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU2lkZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc2lkZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludHMgaW4gdGhlIHBvbHlnb24gaW4gb3JkZXIgYXJvdW5kIHRoZSBwZXJpbWV0ZXIgaW4gbG9jYWwgY29vcmRpbmF0ZXMuIFRoZXNlIGFyZSByZWxhdGl2ZSBmcm9tIHRoZSBib2R5IHRyYW5zZm9ybSBwb3NpdGlvbi5cclxuICAgICAqIEV4Y2FsaWJ1ciBzdG9yZXMgdGhlc2UgaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXJcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xyXG4gICAgfVxyXG4gICAgX2lzQ291bnRlckNsb2Nrd2lzZVdpbmRpbmcocG9pbnRzKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExNjU5NDNcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gKHBvaW50c1soaSArIDEpICUgcG9pbnRzLmxlbmd0aF0ueCAtIHBvaW50c1tpXS54KSAqIChwb2ludHNbKGkgKyAxKSAlIHBvaW50cy5sZW5ndGhdLnkgKyBwb2ludHNbaV0ueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW0gPCAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBwb2x5Z29uIGNvbGxpZGVyIGlzIGNvbnZleCwgRXhjYWxpYnVyIGRvZXMgbm90IGhhbmRsZSBub24tY29udmV4IGNvbGxpc2lvbiBzaGFwZXMuXHJcbiAgICAgKiBDYWxsIFtbUG9seWdvbi50cmlhbmd1bGF0ZV1dIHRvIGdlbmVyYXRlIGEgW1tDb21wb3NpdGVDb2xsaWRlcl1dIGZyb20gdGhpcyBub24tY29udmV4IHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGlzQ29udmV4KCkge1xyXG4gICAgICAgIC8vIEZyb20gU086IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTM3MjAyNVxyXG4gICAgICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG9sZFBvaW50ID0gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgbGV0IG5ld1BvaW50ID0gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IE1hdGguYXRhbjIobmV3UG9pbnQueSAtIG9sZFBvaW50LnksIG5ld1BvaW50LnggLSBvbGRQb2ludC54KTtcclxuICAgICAgICBsZXQgb2xkRGlyZWN0aW9uID0gMDtcclxuICAgICAgICBsZXQgb3JpZW50YXRpb24gPSAwO1xyXG4gICAgICAgIGxldCBhbmdsZVN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaSwgcG9pbnRdIG9mIHRoaXMucG9pbnRzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBvbGRQb2ludCA9IG5ld1BvaW50O1xyXG4gICAgICAgICAgICBvbGREaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbiAgICAgICAgICAgIG5ld1BvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IE1hdGguYXRhbjIobmV3UG9pbnQueSAtIG9sZFBvaW50LnksIG5ld1BvaW50LnggLSBvbGRQb2ludC54KTtcclxuICAgICAgICAgICAgaWYgKG9sZFBvaW50LmVxdWFscyhuZXdQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcmVwZWF0IHBvaW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFuZ2xlID0gZGlyZWN0aW9uIC0gb2xkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBpZiAoYW5nbGUgPD0gLU1hdGguUEkpIHtcclxuICAgICAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFuZ2xlID4gTWF0aC5QSSkge1xyXG4gICAgICAgICAgICAgICAgYW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA9PT0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSBhbmdsZSA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gKiBhbmdsZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuZ2xlU3VtICs9IGFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoTWF0aC5yb3VuZChhbmdsZVN1bSAvIChNYXRoLlBJICogMikpKSA9PT0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzc2VsbGF0ZXMgdGhlIHBvbHlnb24gaW50byBhIHRyaWFuZ2xlIGZhbiBhcyBhIFtbQ29tcG9zaXRlQ29sbGlkZXJdXSBvZiB0cmlhbmdsZSBwb2x5Z29uc1xyXG4gICAgICovXHJcbiAgICB0ZXNzZWxsYXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHBvbHlnb25zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgcG9seWdvbnMucHVzaChbdGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzW2kgKyAxXSwgdGhpcy5wb2ludHNbaSArIDJdXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvbHlnb25zLnB1c2goW3RoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSwgdGhpcy5wb2ludHNbMl1dKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUNvbGxpZGVyKHBvbHlnb25zLm1hcChwb2ludHMgPT4gU2hhcGUuUG9seWdvbihwb2ludHMpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ3VsYXRlIHRoZSBwb2x5Z29uIGNvbGxpZGVyIHVzaW5nIHRoZSBcIkVhciBDbGlwcGluZ1wiIGFsZ29yaXRobS5cclxuICAgICAqIFJldHVybnMgYSBuZXcgW1tDb21wb3NpdGVDb2xsaWRlcl1dIG1hZGUgdXAgb2Ygc21hbGxlciB0cmlhbmdsZXMuXHJcbiAgICAgKi9cclxuICAgIHRyaWFuZ3VsYXRlKCkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9aFRKRmNIdXRsczhcclxuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBwb2x5Z29uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhlbHBlciB0byBnZXQgYSB2ZXJ0ZXggaW4gdGhlIGxpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRJdGVtKGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBsaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaW5kZXggJSBsaXN0Lmxlbmd0aF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpbmRleCAlIGxpc3QubGVuZ3RoICsgbGlzdC5sZW5ndGhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFF1aWNrIHRlc3QgZm9yIHBvaW50IGluIHRyaWFuZ2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb2ludEluVHJpYW5nbGUocG9pbnQsIGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgY29uc3QgYWIgPSBiLnN1YihhKTtcclxuICAgICAgICAgICAgY29uc3QgYmMgPSBjLnN1YihiKTtcclxuICAgICAgICAgICAgY29uc3QgY2EgPSBhLnN1YihjKTtcclxuICAgICAgICAgICAgY29uc3QgYXAgPSBwb2ludC5zdWIoYSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJwID0gcG9pbnQuc3ViKGIpO1xyXG4gICAgICAgICAgICBjb25zdCBjcCA9IHBvaW50LnN1YihjKTtcclxuICAgICAgICAgICAgY29uc3QgY3Jvc3MxID0gYWIuY3Jvc3MoYXApO1xyXG4gICAgICAgICAgICBjb25zdCBjcm9zczIgPSBiYy5jcm9zcyhicCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzMyA9IGNhLmNyb3NzKGNwKTtcclxuICAgICAgICAgICAgaWYgKGNyb3NzMSA+IDAgfHwgY3Jvc3MyID4gMCB8fCBjcm9zczMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gWy4uLnRoaXMucG9pbnRzXTtcclxuICAgICAgICBjb25zdCBpbmRpY2VzID0gcmFuZ2UoMCwgdGhpcy5wb2ludHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgLy8gMS4gTG9vcCB0aHJvdWdoIHZlcnRpY2VzIGNsb2Nrd2lzZVxyXG4gICAgICAgIC8vICAgIGlmIHRoZSB2ZXJ0ZXggaXMgY29udmV4IChpbnRlcmlvciBhbmdsZSBpcyA8IDE4MCkgKGNyb3NzIHByb2R1Y3QgcG9zaXRpdmUpXHJcbiAgICAgICAgLy8gICAgaWYgdGhlIHBvbHlnb24gZm9ybWVkIGJ5IGl0J3MgZWRnZXMgZG9lc24ndCBjb250YWluIHRoZSBwb2ludHNcclxuICAgICAgICAvLyAgICAgICAgIGl0J3MgYW4gZWFyIGFkZCBpdCB0byBvdXIgbGlzdCBvZiB0cmlhbmdsZXMsIGFuZCByZXN0YXJ0XHJcbiAgICAgICAgd2hpbGUgKGluZGljZXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGdldEl0ZW0oaSAtIDEsIGluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGdldEl0ZW0oaSArIDEsIGluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSB2ZXJ0aWNlc1thXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZiID0gdmVydGljZXNbYl07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YyA9IHZlcnRpY2VzW2NdO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgY29udmV4aXR5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QXJtID0gdmIuc3ViKHZhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0QXJtID0gdmMuc3ViKHZhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29udmV4ID0gcmlnaHRBcm0uY3Jvc3MobGVmdEFybSkgPiAwOyAvLyBwb3NpdGl2ZSBjcm9zcyBtZWFucyBjb252ZXhcclxuICAgICAgICAgICAgICAgIGlmICghaXNDb252ZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBpc0VhciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IGlmIGFueSB2ZXJ0aWNlcyBhcmUgaW4gdGhlIHRyaWFuZ2xlIGEsIGIsIGNcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRJbmRleCA9IGluZGljZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgdGhlc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVydEluZGV4ID09PSBhIHx8IHZlcnRJbmRleCA9PT0gYiB8fCB2ZXJ0SW5kZXggPT09IGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdmVydGljZXNbdmVydEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2ludEluVHJpYW5nbGUocG9pbnQsIHZiLCB2YSwgdmMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRWFyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBlYXIgdG8gcG9seWdvbiBsaXN0IGFuZCByZW1vdmUgZnJvbSBsaXN0XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChbdmIsIHZhLCB2Y10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWFuZ2xlcy5wdXNoKFt2ZXJ0aWNlc1tpbmRpY2VzWzBdXSwgdmVydGljZXNbaW5kaWNlc1sxXV0sIHZlcnRpY2VzW2luZGljZXNbMl1dXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVDb2xsaWRlcih0cmlhbmdsZXMubWFwKHBvaW50cyA9PiBTaGFwZS5Qb2x5Z29uKHBvaW50cykpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29udmV4UG9seWdvbiwgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXHJcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5wb2ludHMubWFwKChwKSA9PiBwLmNsb25lKCkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBjb2xsaWRlciwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgYm9keSB0cmFuc2Zvcm0gcGx1cyBhbnkgZGVmaW5lZCBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybS5wb3MuYWRkKHRoaXMub2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHMuY2VudGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB1bmRlcmx5aW5nIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGJvZHkgcmVsYXRpdmUgc3BhY2UgdG8gd29ybGQgc3BhY2VcclxuICAgICAqL1xyXG4gICAgX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDsgLy8gY2xlYXIgb3V0IG9sZCB0cmFuc2Zvcm1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzW2ldID0gdGhpcy5fZ2xvYmFsTWF0cml4Lm11bHRpcGx5KHBvaW50c1tpXS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvaW50cyB0aGF0IG1ha2UgdXAgdGhlIHBvbHlnb24gaW4gd29ybGQgc3BhY2UsIGZyb20gYWN0b3IgcmVsYXRpdmUgc3BhY2UgKGlmIHNwZWNpZmllZClcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNmb3JtZWRQb2ludHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRQb2ludHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHNpZGVzIG9mIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldFNpZGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaWRlc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aW5kaW5nIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChuZXcgTGluZVNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbKGkgKyAxKSAlIGxlbl0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaWRlcyA9IGxpbmVzO1xyXG4gICAgICAgICAgICB0aGlzLl9zaWRlc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzcGFjZSBzaWRlc1xyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbFNpZGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFNpZGVzRGlydHkpIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2luZGluZyBpcyBpbXBvcnRhbnRcclxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVTZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzWyhpICsgMSkgJSBsZW5dKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxTaWRlcyA9IGxpbmVzO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFNpZGVzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU2lkZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgZGlyZWN0aW9uIHZlY3RvciBmaW5kIHRoZSB3b3JsZCBzcGFjZSBzaWRlIHRoYXQgaXMgbW9zdCBpbiB0aGF0IGRpcmVjdGlvblxyXG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBmaW5kU2lkZShkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBsZXQgYmVzdFNpZGUgPSBzaWRlc1swXTtcclxuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBmb3IgKGxldCBzaWRlID0gMDsgc2lkZSA8IHNpZGVzLmxlbmd0aDsgc2lkZSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlID0gc2lkZXNbc2lkZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGVOb3JtYWwgPSBjdXJyZW50U2lkZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9zdERpcmVjdGlvbiA9IHNpZGVOb3JtYWwuZG90KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChtb3N0RGlyZWN0aW9uID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaWRlID0gY3VycmVudFNpZGU7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IG1vc3REaXJlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlc3RTaWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGRpcmVjdGlvbiB2ZWN0b3IgZmluZCB0aGUgbG9jYWwgc3BhY2Ugc2lkZSB0aGF0IGlzIG1vc3QgaW4gdGhhdCBkaXJlY3Rpb25cclxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZmluZExvY2FsU2lkZShkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0TG9jYWxTaWRlcygpO1xyXG4gICAgICAgIGxldCBiZXN0U2lkZSA9IHNpZGVzWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IHNpZGUgPSAwOyBzaWRlIDwgc2lkZXMubGVuZ3RoOyBzaWRlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGUgPSBzaWRlc1tzaWRlXTtcclxuICAgICAgICAgICAgY29uc3Qgc2lkZU5vcm1hbCA9IGN1cnJlbnRTaWRlLm5vcm1hbCgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3N0RGlyZWN0aW9uID0gc2lkZU5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKG1vc3REaXJlY3Rpb24gPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGUgPSBjdXJyZW50U2lkZTtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gbW9zdERpcmVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdFNpZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbnZleCBwb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGdldCBheGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGF4ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGF4ZXMucHVzaChzaWRlc1tpXS5ub3JtYWwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gZm9yIHRoZSBjb2xsaXNpb24gZ2VvbWV0cnlcclxuICAgICAqXHJcbiAgICAgKiBDb2xsaXNpb24gZ2VvbWV0cnkgKHBvaW50cy9ib3VuZHMpIHdpbGwgbm90IGNoYW5nZSB1bnRpbCB0aGlzIGlzIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc2lkZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgLy8gVGhpcyBjaGFuZ2UgbWVhbnMgYW4gdXBkYXRlIG11c3QgYmUgcGVyZm9ybWVkIGluIG9yZGVyIGZvciBnZW9tZXRyeSB0byB1cGRhdGVcclxuICAgICAgICBjb25zdCBnbG9iYWxNYXQgPSAoX2EgPSB0cmFuc2Zvcm0ubWF0cml4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9nbG9iYWxNYXRyaXg7XHJcbiAgICAgICAgZ2xvYmFsTWF0LmNsb25lKHRoaXMuX2dsb2JhbE1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4LnRyYW5zbGF0ZSh0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaWRlciBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhwb2ludCkge1xyXG4gICAgICAgIC8vIEFsd2F5cyBjYXN0IHRvIHRoZSByaWdodCwgYXMgbG9uZyBhcyB3ZSBjYXN0IGluIGEgY29uc2lzdGVudCBmaXhlZCBkaXJlY3Rpb24gd2VcclxuICAgICAgICAvLyB3aWxsIGJlIGZpbmVcclxuICAgICAgICBjb25zdCB0ZXN0UmF5ID0gbmV3IFJheShwb2ludCwgbmV3IFZlY3RvcigxLCAwKSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0Q291bnQgPSB0aGlzLmdldFNpZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgc2lkZSkge1xyXG4gICAgICAgICAgICBpZiAodGVzdFJheS5pbnRlcnNlY3Qoc2lkZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25DaXJjbGVDbG9zZXN0TGluZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uUG9seWdvbkNsb3Nlc3RMaW5lKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25FZGdlQ2xvc2VzdExpbmUodGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBjb2xsaWRlcn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb2xsaXNpb24gY29udGFjdCBpZiB0aGUgMiBjb2xsaWRlcnMgY29sbGlkZSwgb3RoZXJ3aXNlIGNvbGxpZGUgd2lsbFxyXG4gICAgICogcmV0dXJuIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY29sbGlkZShjb2xsaWRlcikge1xyXG4gICAgICAgIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZVBvbHlnb24oY29sbGlkZXIsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uUG9seWdvbih0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2YgY29sbGlkZXJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgY29sbGlkZXIgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBwdHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgbGV0IGZ1cnRoZXN0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlyZWN0aW9uLmRvdChwdHNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwdHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1cnRoZXN0UG9pbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGxvY2FsIHBvaW50IG9uIHRoZSBjb2xsaWRlciBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdExvY2FsUG9pbnQoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcHRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgbGV0IGZ1cnRoZXN0UG9pbnQgPSBwdHNbMF07XHJcbiAgICAgICAgbGV0IG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXJlY3Rpb24uZG90KHB0c1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgZnVydGhlc3RQb2ludCA9IHB0c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVydGhlc3RQb2ludDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGNsb3NlcyBmYWNlIHRvIHRoZSBwb2ludCB1c2luZyBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgcG9pbnQgdG8gdGVzdCBhZ2FpbnN0IHBvbHlnb25cclxuICAgICAqL1xyXG4gICAgZ2V0Q2xvc2VzdEZhY2UocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIGxldCBmYWNlSW5kZXggPSAtMTtcclxuICAgICAgICBsZXQgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBzaWRlc1tpXS5kaXN0YW5jZVRvUG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgbWluID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIGZhY2VJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhY2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBzaWRlc1tmYWNlSW5kZXhdLm5vcm1hbCgpLnNjYWxlKGRpc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgIGZhY2U6IHNpZGVzW2ZhY2VJbmRleF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIHBvbHlnb24gY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEJvdW5kcy50cmFuc2Zvcm0odGhpcy5fZ2xvYmFsTWF0cml4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgcG9seWdvbiBjb2xsaWRlciBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsQm91bmRzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHRoaXMucG9pbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxCb3VuZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGFyYml0cmFyeSBwb2x5Z29uXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICovXHJcbiAgICBnZXRJbmVydGlhKG1hc3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVkTWFzcyA9PT0gbWFzcyAmJiB0aGlzLl9jYWNoZWRJbmVydGlhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbmVydGlhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbnVtZXJhdG9yID0gMDtcclxuICAgICAgICBsZXQgZGVub21pbmF0b3IgPSAwO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlwbHVzb25lID0gKGkgKyAxKSAlIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzVGVybSA9IHBvaW50c1tpcGx1c29uZV0uY3Jvc3MocG9pbnRzW2ldKTtcclxuICAgICAgICAgICAgbnVtZXJhdG9yICs9XHJcbiAgICAgICAgICAgICAgICBjcm9zc1Rlcm0gKlxyXG4gICAgICAgICAgICAgICAgICAgIChwb2ludHNbaV0uZG90KHBvaW50c1tpXSkgKyBwb2ludHNbaV0uZG90KHBvaW50c1tpcGx1c29uZV0pICsgcG9pbnRzW2lwbHVzb25lXS5kb3QocG9pbnRzW2lwbHVzb25lXSkpO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciArPSBjcm9zc1Rlcm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhY2hlZE1hc3MgPSBtYXNzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbmVydGlhID0gKG1hc3MgLyA2KSAqIChudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGEgcmF5IGludG8gdGhlIHBvbHlnb24gYW5kIHJldHVybnMgYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBwb2ludCBvZiBjb250YWN0IChpbiB3b3JsZCBzcGFjZSkgb3IgbnVsbCBpZiBubyBjb2xsaXNpb24uXHJcbiAgICAgKi9cclxuICAgIHJheUNhc3QocmF5LCBtYXggPSBJbmZpbml0eSkge1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gY29udGFjdCB0aW1lIGdyZWF0ZXIgdGhhbiAwXHJcbiAgICAgICAgLy8gY29udGFjdCB0aW1lcyBsZXNzIHRoYW4gMCBhcmUgYmVoaW5kIHRoZSByYXkgYW5kIHdlIGRvbid0IHdhbnQgdGhvc2VcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBzaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IG1pbkNvbnRhY3RUaW1lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgY29udGFjdEluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0VGltZSA9IHJheS5pbnRlcnNlY3Qoc2lkZXNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdFRpbWUgPj0gMCAmJiBjb250YWN0VGltZSA8IG1pbkNvbnRhY3RUaW1lICYmIGNvbnRhY3RUaW1lIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWluQ29udGFjdFRpbWUgPSBjb250YWN0VGltZTtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29udGFjdCB3YXMgZm91bmRcclxuICAgICAgICBpZiAoY29udGFjdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW5Db250YWN0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5vIGNvbnRhY3QgZm91bmRcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdCB0aGUgZWRnZXMgb2YgdGhlIHBvbHlnb24gYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwcm9qZWN0KGF4aXMpIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBwb2ludHNbaV0uZG90KGF4aXMpO1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNjYWxhcik7XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc2NhbGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uKG1pbiwgbWF4KTtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKClbMF07XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW2ZpcnN0UG9pbnQsIC4uLnRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKSwgZmlyc3RQb2ludF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4LmRyYXdMaW5lKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgY29sb3IsIDIpO1xyXG4gICAgICAgICAgICBleC5kcmF3Q2lyY2xlKHBvaW50c1tpXSwgMiwgY29sb3IpO1xyXG4gICAgICAgICAgICBleC5kcmF3Q2lyY2xlKHBvaW50c1tpICsgMV0sIDIsIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL1NoYXBlLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEV4Y2FsaWJ1ciBoZWxwZXIgZm9yIGRlZmluaW5nIGNvbGxpZGVycyBxdWlja2x5XHJcbiAqL1xyXG5jbGFzcyBTaGFwZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBib3ggY29sbGlkZXIsIHVuZGVyIHRoZSBob29kIGRlZmluZXMgYSBbW1BvbHlnb25Db2xsaWRlcl1dIGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIGFuY2hvciBBbmNob3Igb2YgdGhlIGJveCAoZGVmYXVsdCAoLjUsIC41KSkgd2hpY2ggcG9zaXRpb25zIHRoZSBib3ggcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgY29sbGlkZXIncyBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBCb3god2lkdGgsIGhlaWdodCwgYW5jaG9yID0gVmVjdG9yLkhhbGYsIG9mZnNldCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBwb2ludHM6IG5ldyBCb3VuZGluZ0JveCgtd2lkdGggKiBhbmNob3IueCwgLWhlaWdodCAqIGFuY2hvci55LCB3aWR0aCAtIHdpZHRoICogYW5jaG9yLngsIGhlaWdodCAtIGhlaWdodCAqIGFuY2hvci55KS5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW1BvbHlnb25Db2xsaWRlcnxhcmJpdHJhcnkgcG9seWdvbl1dIGNvbGxpZGVyXHJcbiAgICAgKlxyXG4gICAgICogUG9seWdvbkNvbGxpZGVycyBhcmUgdXNlZnVsIGZvciBjcmVhdGluZyBjb252ZXggcG9seWdvbiBzaGFwZXNcclxuICAgICAqIEBwYXJhbSBwb2ludHMgUG9pbnRzIHNwZWNpZmllZCBpbiBjb3VudGVyIGNsb2Nrd2lzZVxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBQb2x5Z29uKHBvaW50cywgb2Zmc2V0ID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Db2xsaWRlcih7XHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtbQ2lyY2xlQ29sbGlkZXJ8Y2lyY2xlXV0gY29sbGlkZXJcclxuICAgICAqXHJcbiAgICAgKiBDaXJjbGUgY29sbGlkZXJzIGFyZSB1c2VmdWwgZm9yIGJhbGxzLCBvciB0byBtYWtlIGNvbGxpc2lvbnMgbW9yZSBmb3JnaXZpbmcgb24gc2hhcnAgZWRnZXNcclxuICAgICAqIEBwYXJhbSByYWRpdXMgUmFkaXVzIG9mIHRoZSBjaXJjbGUgY29sbGlkZXJcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT3B0aW9uYWwgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBjb2xsaWRlciBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgQ2lyY2xlKHJhZGl1cywgb2Zmc2V0ID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUNvbGxpZGVyKHtcclxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tFZGdlQ29sbGlkZXJ8ZWRnZV1dIGNvbGxpZGVyXHJcbiAgICAgKlxyXG4gICAgICogRWRnZSBjb2xsaWRlcnMgYXJlIHVzZWZ1bCBmb3IgIGZsb29ycywgd2FsbHMsIGFuZCBvdGhlciBiYXJyaWVyc1xyXG4gICAgICogQHBhcmFtIGJlZ2luIEJlZ2lubmluZyBvZiB0aGUgZWRnZSBpbiBsb2NhbCBjb29yZGluYXRlcyB0byB0aGUgY29sbGlkZXJcclxuICAgICAqIEBwYXJhbSBlbmQgRW5kaW5nIG9mIHRoZSBlZGdlIGluIGxvY2FsIGNvb3JkaW5hdGVzIHRvIHRoZSBjb2xsaWRlclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgRWRnZShiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFZGdlQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBiZWdpbjogYmVnaW4sXHJcbiAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2Fwc3VsZSBzaGFwZWQgW1tDb21wb3NpdGVDb2xsaWRlcl1dIHVzaW5nIDIgY2lyY2xlcyBhbmQgYSBib3hcclxuICAgICAqXHJcbiAgICAgKiBDYXBzdWxlIGNvbGxpZGVycyBhcmUgdXNlZnVsIGZvciBwbGF0Zm9ybWVycyB3aXRoIGluY2xpbmUgb3IgamFnZ2VkIGZsb29ycyB0byBoYXZlIGEgc21vb3RoXHJcbiAgICAgKiBwbGF5ZXIgZXhwZXJpZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT3B0aW9uYWwgb2Zmc2V0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBDYXBzdWxlKHdpZHRoLCBoZWlnaHQsIG9mZnNldCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0EgY2Fwc3VsZSBjb2xsaWRlciB3aXRoIGVxdWFsIHdpZHRoIGFuZCBoZWlnaHQgaXMgYSBjaXJjbGUsIGNvbnNpZGVyIHVzaW5nIGEgZXguU2hhcGUuQ2lyY2xlIG9yIGV4LkNpcmNsZUNvbGxpZGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsID0gaGVpZ2h0ID49IHdpZHRoO1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAvLyBoZWlnaHQgPiB3aWR0aCwgaWYgZXF1YWwgbWF5YmUgdXNlIGEgY2lyY2xlXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHN1bGUgPSBuZXcgQ29tcG9zaXRlQ29sbGlkZXIoW1xyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ2lyY2xlKHdpZHRoIC8gMiwgdmVjKDAsIC1oZWlnaHQgLyAyICsgd2lkdGggLyAyKS5hZGQob2Zmc2V0KSksXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5Cb3god2lkdGgsIGhlaWdodCAtIHdpZHRoLCBWZWN0b3IuSGFsZiwgb2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNpcmNsZSh3aWR0aCAvIDIsIHZlYygwLCBoZWlnaHQgLyAyIC0gd2lkdGggLyAyKS5hZGQob2Zmc2V0KSlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXBzdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2lkdGggPiBoZWlnaHQsIGlmIGVxdWFsIG1heWJlIHVzZSBhIGNpcmNsZVxyXG4gICAgICAgICAgICBjb25zdCBjYXBzdWxlID0gbmV3IENvbXBvc2l0ZUNvbGxpZGVyKFtcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNpcmNsZShoZWlnaHQgLyAyLCB2ZWMoLXdpZHRoIC8gMiArIGhlaWdodCAvIDIsIDApLmFkZChvZmZzZXQpKSxcclxuICAgICAgICAgICAgICAgIFNoYXBlLkJveCh3aWR0aCAtIGhlaWdodCwgaGVpZ2h0LCBWZWN0b3IuSGFsZiwgb2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNpcmNsZShoZWlnaHQgLyAyLCB2ZWMod2lkdGggLyAyIC0gaGVpZ2h0IC8gMiwgMCkuYWRkKG9mZnNldCkpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY2Fwc3VsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJDb21wb25lbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIENvbGxpZGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguY29sbGlkZXInO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9ic2VydmFibGUgdGhhdCBub3RpZmllcyB3aGVuIGEgY29sbGlkZXIgaXMgYWRkZWQgdG8gdGhlIGJvZHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLiRjb2xsaWRlckFkZGVkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRoYXQgbm90aWZpZXMgd2hlbiBhIGNvbGxpZGVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgYm9keVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuJGNvbGxpZGVyUmVtb3ZlZCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXQoY29sbGlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29sbGlkZXIgZ2VvbWV0cnlcclxuICAgICAqL1xyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb2xsaWRlciBnZW9tZXRyeVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgY29sbGlkZXIgeW91IHNldFxyXG4gICAgICovXHJcbiAgICBzZXQoY29sbGlkZXIpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyID0gY29sbGlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyLm93bmVyID0gdGhpcy5vd25lcjtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMud2lyZShjb2xsaWRlci5ldmVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLiRjb2xsaWRlckFkZGVkLm5vdGlmeUFsbChjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsaWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGNvbGxpZGVyIGdlb21ldHJ5IGZyb20gY29sbGlkZXIgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy51bndpcmUodGhpcy5fY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy4kY29sbGlkZXJSZW1vdmVkLm5vdGlmeUFsbCh0aGlzLl9jb2xsaWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyLm93bmVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHdvcmxkIHNwYWNlIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2NvbGxpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm91bmRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGxvY2FsIHNwYWNlIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fY29sbGlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbEJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgY29sbGlkZXIncyB0cmFuc2Zvcm1lZCBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlci5vd25lciA9IHRoaXMub3duZXI7XHJcbiAgICAgICAgICAgIGlmICh0eCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXIudXBkYXRlKHR4LmdldCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlkZSBjb21wb25lbnQgd2l0aCBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXJcclxuICAgICAqL1xyXG4gICAgY29sbGlkZShvdGhlcikge1xyXG4gICAgICAgIGxldCBjb2xsaWRlckEgPSB0aGlzLl9jb2xsaWRlcjtcclxuICAgICAgICBsZXQgY29sbGlkZXJCID0gb3RoZXIuX2NvbGxpZGVyO1xyXG4gICAgICAgIGlmICghY29sbGlkZXJBIHx8ICFjb2xsaWRlckIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY29tcG9zaXRlIGxlZnRoYW5kIHNpZGUgOihcclxuICAgICAgICAvLyBNaWdodCBiaXRlIHVzLCBidXQgdG8gYXZvaWQgdXBkYXRpbmcgYWxsIHRoZSBoYW5kbGVycyBtYWtlIGNvbXBvc2l0ZSBhbHdheXMgbGVmdCBzaWRlXHJcbiAgICAgICAgbGV0IGZsaXBwZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoY29sbGlkZXJCIGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29sbGlkZXJBID0gY29sbGlkZXJCO1xyXG4gICAgICAgICAgICBjb2xsaWRlckIgPSB0aGlzLl9jb2xsaWRlcjtcclxuICAgICAgICAgICAgZmxpcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0cyA9IGNvbGxpZGVyQS5jb2xsaWRlKGNvbGxpZGVyQik7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0cy5mb3JFYWNoKChjb250YWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QubXR2ID0gY29udGFjdC5tdHYubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3Qubm9ybWFsID0gY29udGFjdC5ub3JtYWwubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QudGFuZ2VudCA9IGNvbnRhY3Qubm9ybWFsLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEgPSB0aGlzLl9jb2xsaWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckIgPSBvdGhlci5fY29sbGlkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBvbkFkZChlbnRpdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2lyZSB1cCB0aGUgY29sbGlkZXIgZXZlbnRzIHRvIHRoZSBvd25pbmcgZW50aXR5XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3ByZWNvbGxpc2lvbicsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJlY29sbGlzaW9uID0gZXZ0O1xyXG4gICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBQcmVDb2xsaXNpb25FdmVudChwcmVjb2xsaXNpb24udGFyZ2V0Lm93bmVyLCBwcmVjb2xsaXNpb24ub3RoZXIub3duZXIsIHByZWNvbGxpc2lvbi5zaWRlLCBwcmVjb2xsaXNpb24uaW50ZXJzZWN0aW9uKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3Bvc3Rjb2xsaXNpb24nLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc3Rjb2xsaXNpb24gPSBldnQ7XHJcbiAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBQb3N0Q29sbGlzaW9uRXZlbnQocG9zdGNvbGxpc2lvbi50YXJnZXQub3duZXIsIHBvc3Rjb2xsaXNpb24ub3RoZXIub3duZXIsIHBvc3Rjb2xsaXNpb24uc2lkZSwgcG9zdGNvbGxpc2lvbi5pbnRlcnNlY3Rpb24pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignY29sbGlzaW9uc3RhcnQnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZXZ0O1xyXG4gICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IENvbGxpc2lvblN0YXJ0RXZlbnQoc3RhcnQudGFyZ2V0Lm93bmVyLCBzdGFydC5vdGhlci5vd25lciwgc3RhcnQuY29udGFjdCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjb2xsaXNpb25lbmQnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGV2dDtcclxuICAgICAgICAgICAgZW50aXR5LmV2ZW50cy5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgQ29sbGlzaW9uRW5kRXZlbnQoZW5kLnRhcmdldC5vd25lciwgZW5kLm90aGVyLm93bmVyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvblJlbW92ZSgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuJGNvbGxpZGVyUmVtb3ZlZC5ub3RpZnlBbGwodGhpcy5fY29sbGlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIGEgYm94IGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBjdXJyZW50IGJvdW5kcyBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvciBvZiB0aGlzIHBoeXNpY3MgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBubyB3aWR0aC9oZWlnaHQgYXJlIHNwZWNpZmllZCB0aGUgYm9keSB3aWxsIGF0dGVtcHQgdG8gdXNlIHRoZSBhc3NvY2lhdGVkIGFjdG9yJ3Mgd2lkdGgvaGVpZ2h0LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZUJveENvbGxpZGVyKHdpZHRoLCBoZWlnaHQsIGFuY2hvciA9IFZlY3Rvci5IYWxmLCBjZW50ZXIgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gU2hhcGUuQm94KHdpZHRoLCBoZWlnaHQsIGFuY2hvciwgY2VudGVyKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2V0KGNvbGxpZGVyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgYSBbW1BvbHlnb25Db2xsaWRlcnxwb2x5Z29uXV0gY29sbGlzaW9uIGdlb21ldHJ5IGJhc2VkIG9uIGEgbGlzdCBvZiBvZiBwb2ludHMgcmVsYXRpdmVcclxuICAgICAqICB0byB0aGUgYW5jaG9yIG9mIHRoZSBhc3NvY2lhdGVkIGFjdG9yXHJcbiAgICAgKiBvZiB0aGlzIHBoeXNpY3MgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IFtjb252ZXggcG9seWdvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmV4X3BvbHlnb24pIGRlZmluaXRpb25zIGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAqL1xyXG4gICAgdXNlUG9seWdvbkNvbGxpZGVyKHBvaW50cywgY2VudGVyID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBwb2x5ID0gU2hhcGUuUG9seWdvbihwb2ludHMsIGNlbnRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChwb2x5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgYSBbW0NpcmNsZXxjaXJjbGUgY29sbGlzaW9uIGdlb21ldHJ5XV0gYXMgdGhlIG9ubHkgY29sbGlkZXIgd2l0aCBhIHNwZWNpZmllZCByYWRpdXMgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZUNpcmNsZUNvbGxpZGVyKHJhZGl1cywgY2VudGVyID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlciA9IFNoYXBlLkNpcmNsZShyYWRpdXMsIGNlbnRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChjb2xsaWRlcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIGFuIFtbRWRnZXxlZGdlIGNvbGxpc2lvbiBnZW9tZXRyeV1dIHdpdGggYSBzdGFydCBwb2ludCBhbmQgYW4gZW5kIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3JcclxuICAgICAqIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZUVkZ2VDb2xsaWRlcihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSBTaGFwZS5FZGdlKGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zZXQoY29sbGlkZXIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0dXBzIHVwIGEgW1tDb21wb3NpdGVDb2xsaWRlcl1dIHdoaWNoIGNhbiBkZWZpbmUgYW55IGFyYml0cmFyeSBzZXQgb2YgZXhjYWxpYnVyIGNvbGxpZGVyc1xyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyc1xyXG4gICAgICovXHJcbiAgICB1c2VDb21wb3NpdGVDb2xsaWRlcihjb2xsaWRlcnMpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2V0KG5ldyBDb21wb3NpdGVDb2xsaWRlcihjb2xsaWRlcnMpKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQm9keUNvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIERlZ3JlZU9mRnJlZWRvbTtcclxuKGZ1bmN0aW9uIChEZWdyZWVPZkZyZWVkb20pIHtcclxuICAgIERlZ3JlZU9mRnJlZWRvbVtcIlJvdGF0aW9uXCJdID0gXCJyb3RhdGlvblwiO1xyXG4gICAgRGVncmVlT2ZGcmVlZG9tW1wiWFwiXSA9IFwieFwiO1xyXG4gICAgRGVncmVlT2ZGcmVlZG9tW1wiWVwiXSA9IFwieVwiO1xyXG59KShEZWdyZWVPZkZyZWVkb20gfHwgKERlZ3JlZU9mRnJlZWRvbSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBCb2R5IGRlc2NyaWJlcyBhbGwgdGhlIHBoeXNpY2FsIHByb3BlcnRpZXMgcG9zLCB2ZWwsIGFjYywgcm90YXRpb24sIGFuZ3VsYXIgdmVsb2NpdHkgZm9yIHRoZSBwdXJwb3NlIG9mXHJcbiAqIG9mIHBoeXNpY3Mgc2ltdWxhdGlvbi5cclxuICovXHJcbmNsYXNzIEJvZHlDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmJvZHknO1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW1RyYW5zZm9ybUNvbXBvbmVudCwgTW90aW9uQ29tcG9uZW50XTtcclxuICAgICAgICB0aGlzLmlkID0gY3JlYXRlSWQoJ2JvZHknLCBCb2R5Q29tcG9uZW50Ll9JRCsrKTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgICAgICB0aGlzLl9vbGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG9sZCB0cmFuc2Zvcm0gaGFzIGJlZW4gY2FwdHVyZWQgYXQgbGVhc3Qgb25jZSBmb3IgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX19vbGRUcmFuc2Zvcm1DYXB0dXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlZCB0aGUgZml4ZWQgdXBkYXRlIGludGVycG9sYXRpb24sIGJ5IGRlZmF1bHQgaW50ZXJwb2xhdGlvbiBpcyBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUZpeGVkVXBkYXRlSW50ZXJwb2xhdGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxpc2lvbiB0eXBlIGZvciB0aGUgcmlnaWRib2R5IHBoeXNpY3Mgc2ltdWxhdGlvbiwgYnkgZGVmYXVsdCBbW0NvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbl1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsaXNpb24gZ3JvdXAgZm9yIHRoZSBib2R5J3MgY29sbGlkZXJzLCBieSBkZWZhdWx0IGJvZHkgY29sbGlkZXJzIGNvbGxpZGUgd2l0aCBldmVyeXRoaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ncm91cCA9IENvbGxpc2lvbkdyb3VwLkFsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIG1hc3MgdGhlIGJvZHkgaGFzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbWFzcyA9IFBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW1vdW50IG9mIFwibW90aW9uXCIgdGhlIGJvZHkgaGFzIGJlZm9yZSBzbGVlcGluZy4gSWYgYmVsb3cgW1tQaHlzaWNzLnNsZWVwRXBzaWxvbl1dIGl0IGdvZXMgdG8gXCJzbGVlcFwiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IFBoeXNpY3Muc2xlZXBFcHNpbG9uICogNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW4gdGhpcyBib2R5IHNsZWVwLCBieSBkZWZhdWx0IGJvZGllcyBkbyBub3Qgc2xlZXBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhblNsZWVwID0gUGh5c2ljcy5ib2RpZXNDYW5TbGVlcEJ5RGVmYXVsdDtcclxuICAgICAgICB0aGlzLl9zbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbHNvIGtub3duIGFzIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvbiBvciB0aGVcclxuICAgICAgICAgKiBib3VuY2luZXNzLiBJZiAxLCBpdCBpcyAxMDAlIGJvdW5jeSwgMCBpdCBjb21wbGV0ZWx5IGFic29yYnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuY2luZXNzID0gMC4yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvbiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IDAuOTk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdWxkIHVzZSBnbG9iYWwgZ3Jhdml0eSBbW1BoeXNpY3MuZ3Jhdml0eV1dIGluIGl0J3MgcGh5c2ljcyBzaW11bGF0aW9uLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVzZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZ3JlZXMgb2YgZnJlZWRvbSB0byBsaW1pdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZTogdGhpcyBvbmx5IGxpbWl0cyByZXNwb25zZXMgaW4gdGhlIHJlYWxpc3RpYyBzb2x2ZXIsIGlmIHZlbG9jaXR5L2FuZ3VsYXJWZWxvY2l0eSBpcyBzZXQgdGhlIGFjdG9yIHdpbGwgc3RpbGwgcmVzcG9uZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWUgKHZ4LCB2eSkgaW4gcGl4ZWxzL3NlY29uZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2xkVmVsID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzL3NldHMgdGhlIGFjY2VsZXJhdGlvbiBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZS4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBnbG9iYWwgYWNjIFtbUGh5c2ljcy5hY2NdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZEFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IChfYSA9IG9wdGlvbnMudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jb2xsaXNpb25UeXBlO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwID0gKF9iID0gb3B0aW9ucy5ncm91cCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5ncm91cDtcclxuICAgICAgICAgICAgdGhpcy51c2VHcmF2aXR5ID0gKF9jID0gb3B0aW9ucy51c2VHcmF2aXR5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLnVzZUdyYXZpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG1hdHJpeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2V0KCkubWF0cml4O1xyXG4gICAgfVxyXG4gICAgZ2V0IG1hc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc3M7XHJcbiAgICB9XHJcbiAgICBzZXQgbWFzcyhuZXdNYXNzKSB7XHJcbiAgICAgICAgdGhpcy5fbWFzcyA9IG5ld01hc3M7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkSW5lcnRpYSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jYWNoZWRJbnZlcnNlSW5lcnRpYSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGludmVyc2UgbWFzcyAoMS9tYXNzKSBvZiB0aGUgYm9keS4gSWYgW1tDb2xsaXNpb25UeXBlLkZpeGVkXV0gdGhpcyBpcyAwLCBtZWFuaW5nIFwiaW5maW5pdGVcIiBtYXNzXHJcbiAgICAgKi9cclxuICAgIGdldCBpbnZlcnNlTWFzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyB0aGlzLm1hc3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBib2R5IGlzIHNsZWVwaW5nIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBnZXQgc2xlZXBpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsZWVwaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNsZWVwIHN0YXRlIG9mIHRoZSBib2R5XHJcbiAgICAgKiBAcGFyYW0gc2xlZXBpbmdcclxuICAgICAqL1xyXG4gICAgc2V0U2xlZXBpbmcoc2xlZXBpbmcpIHtcclxuICAgICAgICB0aGlzLl9zbGVlcGluZyA9IHNsZWVwaW5nO1xyXG4gICAgICAgIGlmICghc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIGtpY2sgdG8ga2VlcCBpdCBmcm9tIGZhbGxpbmcgYXNsZWVwIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSBQaHlzaWNzLnNsZWVwRXBzaWxvbiAqIDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICB0aGlzLmFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGJvZHkncyBbW0JvZHlDb21wb25lbnQuc2xlZXBNb3Rpb25dXSBmb3IgdGhlIHB1cnBvc2Ugb2Ygc2xlZXBpbmdcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTW90aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zbGVlcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNsZWVwaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJyZW50TW90aW9uID0gdGhpcy52ZWwuc2l6ZSAqIHRoaXMudmVsLnNpemUgKyBNYXRoLmFicyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcclxuICAgICAgICBjb25zdCBiaWFzID0gUGh5c2ljcy5zbGVlcEJpYXM7XHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IGJpYXMgKiB0aGlzLnNsZWVwTW90aW9uICsgKDEgLSBiaWFzKSAqIGN1cnJlbnRNb3Rpb247XHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IGNsYW1wKHRoaXMuc2xlZXBNb3Rpb24sIDAsIDEwICogUGh5c2ljcy5zbGVlcEVwc2lsb24pO1xyXG4gICAgICAgIGlmICh0aGlzLmNhblNsZWVwICYmIHRoaXMuc2xlZXBNb3Rpb24gPCBQaHlzaWNzLnNsZWVwRXBzaWxvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNsZWVwaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmcm9tIHRoZSBbW0NvbGxpZGVyQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZXJ0aWEoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZEluZXJ0aWEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEluZXJ0aWE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluZXJ0aWEgaXMgYSBwcm9wZXJ0eSBvZiB0aGUgZ2VvbWV0cnksIHNvIHRoaXMgaXMgYSBsaXR0bGUgZ29vZnkgYnV0IHNlZW1zIHRvIGJlIG9rYXk/XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLm93bmVyLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyLiRjb2xsaWRlckFkZGVkLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRJbmVydGlhID0gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyLiRjb2xsaWRlclJlbW92ZWQuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZEluZXJ0aWEgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVDb2xsaWRlciA9IGNvbGxpZGVyLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEluZXJ0aWEgPSBtYXliZUNvbGxpZGVyLmdldEluZXJ0aWEodGhpcy5tYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhbCBmcm9tIHRoZSBbW0NvbGxpZGVyQ29tcG9uZW50XV0uIElmIFtbQ29sbGlzaW9uVHlwZS5GaXhlZF1dIHRoaXMgaXMgMCwgbWVhbmluZyBcImluZmluaXRlXCIgbWFzc1xyXG4gICAgICovXHJcbiAgICBnZXQgaW52ZXJzZUluZXJ0aWEoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZEludmVyc2VJbmVydGlhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEludmVyc2VJbmVydGlhID0gdGhpcy5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyB0aGlzLmluZXJ0aWE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaWYgdGhlIG93bmVyIGlzIGFjdGl2ZVxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0aXZlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gISEoKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBnbG9iYWxQMHNcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxQb3M7XHJcbiAgICB9XHJcbiAgICBnZXQgdHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1vdGlvbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvcztcclxuICAgIH1cclxuICAgIHNldCBwb3ModmFsKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKHgsIHkpIHBvc2l0aW9uIG9mIHRoZSBhY3RvciB0aGlzIHdpbGwgYmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYWN0b3IgaWYgdGhlXHJcbiAgICAgKiBbW0FjdG9yLmFuY2hvcl1dIGlzIHNldCB0byAoMC41LCAwLjUpIHdoaWNoIGlzIGRlZmF1bHQuXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0aGUgKHgsIHkpIHBvc2l0aW9uIHRvIGJlIHRoZSB0b3AgbGVmdCBvZiB0aGUgYWN0b3Igc3BlY2lmeSBhbiBhbmNob3Igb2YgKDAsIDApLlxyXG4gICAgICovXHJcbiAgICBnZXQgZ2xvYmFsUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nbG9iYWxQb3M7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2xvYmFsUG9zKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFBvcyA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh4LCB5KSBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IG9sZFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2xkVHJhbnNmb3JtLnBvcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgdmVjdG9yICh2eCwgdnkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnZlbDtcclxuICAgIH1cclxuICAgIHNldCB2ZWwodmFsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBhY2NlbGVyYXRpb24gdmVjdG9yIChheCwgYXkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZC4gQW4gYWNjZWxlcmF0aW9uIHBvaW50aW5nIGRvd24gc3VjaCBhcyAoMCwgMTAwKSBtYXlcclxuICAgICAqIGJlIHVzZWZ1bCB0byBzaW11bGF0ZSBhIGdyYXZpdGF0aW9uYWwgZWZmZWN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgYWNjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi5hY2M7XHJcbiAgICB9XHJcbiAgICBzZXQgYWNjKHZhbCkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFjYyA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCB0b3JxdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnRvcnF1ZTtcclxuICAgIH1cclxuICAgIHNldCB0b3JxdWUodmFsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udG9ycXVlID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzL3NldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5IGZyb20gdGhlIGxhc3QgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBvbGRSb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2xkVHJhbnNmb3JtLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGJvZHkgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBnZXQgcm90YXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdGF0aW9uKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGUgdmVjdG9yIG9mIHRoZSBhY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmdsb2JhbFNjYWxlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjYWxlKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFNjYWxlID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGUgb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0IG9sZFNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vbGRUcmFuc2Zvcm0uc2NhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSByYXRlIG9mIGNoYW5nZSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCBzY2FsZUZhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uc2NhbGVGYWN0b3I7XHJcbiAgICB9XHJcbiAgICBzZXQgc2NhbGVGYWN0b3Ioc2NhbGVGYWN0b3IpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgZ2V0IGFuZ3VsYXJWZWxvY2l0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgc2V0IGFuZ3VsYXJWZWxvY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhIHNwZWNpZmljIGltcHVsc2UgdG8gdGhlIGJvZHlcclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICogQHBhcmFtIGltcHVsc2VcclxuICAgICAqL1xyXG4gICAgYXBwbHlJbXB1bHNlKHBvaW50LCBpbXB1bHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGFjdGl2ZSBvYmplY3RzIHBhcnRpY2lwYXRlIGluIHRoZSBzaW11bGF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbmFsSW1wdWxzZSA9IGltcHVsc2Uuc2NhbGUodGhpcy5pbnZlcnNlTWFzcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlgpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS54ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlkpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZWwuYWRkRXF1YWwoZmluYWxJbXB1bHNlKTtcclxuICAgICAgICBpZiAoIXRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlJvdGF0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBwb2ludC5zdWIodGhpcy5nbG9iYWxQb3MpO1xyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLmludmVyc2VJbmVydGlhICogZGlzdGFuY2VGcm9tQ2VudGVyLmNyb3NzKGltcHVsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgb25seSBsaW5lYXIgaW1wdWxzZSB0byB0aGUgYm9keVxyXG4gICAgICogQHBhcmFtIGltcHVsc2VcclxuICAgICAqL1xyXG4gICAgYXBwbHlMaW5lYXJJbXB1bHNlKGltcHVsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIG9ubHkgYWN0aXZlIG9iamVjdHMgcGFydGljaXBhdGUgaW4gdGhlIHNpbXVsYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmluYWxJbXB1bHNlID0gaW1wdWxzZS5zY2FsZSh0aGlzLmludmVyc2VNYXNzKTtcclxuICAgICAgICBpZiAodGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uWCkpIHtcclxuICAgICAgICAgICAgZmluYWxJbXB1bHNlLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uWSkpIHtcclxuICAgICAgICAgICAgZmluYWxJbXB1bHNlLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlbCA9IHRoaXMudmVsLmFkZChmaW5hbEltcHVsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBvbmx5IGFuZ3VsYXIgaW1wdWxzZSB0byB0aGUgYm9keVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gaW1wdWxzZVxyXG4gICAgICovXHJcbiAgICBhcHBseUFuZ3VsYXJJbXB1bHNlKHBvaW50LCBpbXB1bHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGFjdGl2ZSBvYmplY3RzIHBhcnRpY2lwYXRlIGluIHRoZSBzaW11bGF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uUm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IHBvaW50LnN1Yih0aGlzLmdsb2JhbFBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuaW52ZXJzZUluZXJ0aWEgKiBkaXN0YW5jZUZyb21DZW50ZXIuY3Jvc3MoaW1wdWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvbGQgdmVyc2lvbnMgb2YgcG9zLCB2ZWwsIGFjYywgYW5kIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBjYXB0dXJlT2xkVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIC8vIENhcHR1cmUgb2xkIHZhbHVlcyBiZWZvcmUgaW50ZWdyYXRpb24gc3RlcCB1cGRhdGVzIHRoZW1cclxuICAgICAgICB0aGlzLl9fb2xkVHJhbnNmb3JtQ2FwdHVyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdldCgpLmNsb25lKHRoaXMuX29sZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgdGhpcy5vbGRWZWwuc2V0VG8odGhpcy52ZWwueCwgdGhpcy52ZWwueSk7XHJcbiAgICAgICAgdGhpcy5vbGRBY2Muc2V0VG8odGhpcy5hY2MueCwgdGhpcy5hY2MueSk7XHJcbiAgICB9XHJcbn1cclxuQm9keUNvbXBvbmVudC5fSUQgPSAwO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9FbnRpdHkudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZGVkQ29tcG9uZW50IG1lc3NhZ2VcclxuICovXHJcbmNsYXNzIEFkZGVkQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDb21wb25lbnQgQWRkZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGtub3cgaWYgbWVzc2FnZSBpcyBmIGFuIEFkZGVkIENvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBZGRlZENvbXBvbmVudCh4KSB7XHJcbiAgICByZXR1cm4gISF4ICYmIHgudHlwZSA9PT0gJ0NvbXBvbmVudCBBZGRlZCc7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZWRDb21wb25lbnQgbWVzc2FnZVxyXG4gKi9cclxuY2xhc3MgUmVtb3ZlZENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnQ29tcG9uZW50IFJlbW92ZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGtub3cgaWYgbWVzc2FnZSBpcyBmb3IgYSBSZW1vdmVkIENvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZW1vdmVkQ29tcG9uZW50KHgpIHtcclxuICAgIHJldHVybiAhIXggJiYgeC50eXBlID09PSAnQ29tcG9uZW50IFJlbW92ZWQnO1xyXG59XHJcbi8qKlxyXG4gKiBBbiBFbnRpdHkgaXMgdGhlIGJhc2UgdHlwZSBvZiBhbnl0aGluZyB0aGF0IGNhbiBoYXZlIGJlaGF2aW9yIGluIEV4Y2FsaWJ1ciwgdGhleSBhcmUgcGFydCBvZiB0aGUgYnVpbHQgaW4gZW50aXR5IGNvbXBvbmVudCBzeXN0ZW1cclxuICpcclxuICogRW50aXRpZXMgY2FuIGJlIHN0cm9uZ2x5IHR5cGVkIHdpdGggdGhlIGNvbXBvbmVudHMgdGhleSBjb250YWluXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eTxDb21wb25lbnRBIHwgQ29tcG9uZW50Qj4oKTtcclxuICogZW50aXR5LmNvbXBvbmVudHMuYTsgLy8gVHlwZSBDb21wb25lbnRBXHJcbiAqIGVudGl0eS5jb21wb25lbnRzLmI7IC8vIFR5cGUgQ29tcG9uZW50QlxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIEVudGl0eSBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIG5hbWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGVudGl0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBFbnRpdHkuX0lEKys7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBlbnRpdHkgaXMgYWN0aXZlLCBpZiBzZXQgdG8gZmFsc2UgaXQgd2lsbCBiZSByZWNsYWltZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVja2V0IHRvIGhvbGQgb24gdG8gZGVmZXJyZWQgcmVtb3ZhbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jb21wb25lbnRzVG9SZW1vdmUgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RhZ3NNZW1vID0gW107XHJcbiAgICAgICAgdGhpcy5fdHlwZXNNZW1vID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IGtlZXBzIHRyYWNrIG9mIGNvbXBvbmVudCBhZGQgb3IgcmVtb3ZlIGNoYW5nZXMgb24gdGhlIGVudGl0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50QWRkZWQkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWQkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5BZGRlZCQgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5SZW1vdmVkJCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2V0TmFtZShuYW1lKTtcclxuICAgICAgICBpZiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldE5hbWUobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IGV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudERpc3BhdGNoZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEtpbGwgdGhlIGVudGl0eSwgbWVhbnMgaXQgd2lsbCBubyBsb25nZXIgYmUgdXBkYXRlZC4gS2lsbHMgYXJlIGRlZmVycmVkIHRvIHRoZSBlbmQgb2YgdGhlIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAga2lsbCgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNLaWxsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWNhbGx5IGdldCB0aGUgdGFncyBvbiB0aGUgZW50aXR5IGZyb20gW1tUYWdDb21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgdGFncygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFnc01lbW87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgdGFnIGV4aXN0cyBvbiB0aGUgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gdGFnIG5hbWUgdG8gY2hlY2sgZm9yXHJcbiAgICAgKi9cclxuICAgIGhhc1RhZyh0YWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWdzLmluY2x1ZGVzKHRhZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0YWcgdG8gYW4gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gdGFnXHJcbiAgICAgKiBAcmV0dXJucyBFbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHRhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbXBvbmVudChuZXcgVGFnQ29tcG9uZW50KHRhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgdGFnIG9uIHRoZSBlbnRpdHlcclxuICAgICAqXHJcbiAgICAgKiBSZW1vdmFscyBhcmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZCBvZiB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB0YWdcclxuICAgICAqIEBwYXJhbSBmb3JjZSBSZW1vdmUgY29tcG9uZW50IGltbWVkaWF0ZWx5LCBubyBkZWZlcnJlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWcodGFnLCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29tcG9uZW50KHRhZywgZm9yY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZXMgb2YgdGhlIGNvbXBvbmVudHMgb24gdGhlIEVudGl0eVxyXG4gICAgICovXHJcbiAgICBnZXQgdHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVzTWVtbztcclxuICAgIH1cclxuICAgIF9yZWJ1aWxkTWVtb3MoKSB7XHJcbiAgICAgICAgdGhpcy5fdGFnc01lbW8gPSBBcnJheS5mcm9tKHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UudmFsdWVzKCkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMgaW5zdGFuY2VvZiBUYWdDb21wb25lbnQpXHJcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IGMudHlwZSk7XHJcbiAgICAgICAgdGhpcy5fdHlwZXNNZW1vID0gQXJyYXkuZnJvbSh0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLmtleXMoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgX25vdGlmeUFkZENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLl9yZWJ1aWxkTWVtb3MoKTtcclxuICAgICAgICBjb25zdCBhZGRlZCA9IG5ldyBBZGRlZENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudCxcclxuICAgICAgICAgICAgZW50aXR5OiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRBZGRlZCQubm90aWZ5QWxsKGFkZGVkKTtcclxuICAgIH1cclxuICAgIF9ub3RpZnlSZW1vdmVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG5ldyBSZW1vdmVkQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBlbnRpdHk6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWQkLm5vdGlmeUFsbChyZW1vdmVkKTtcclxuICAgICAgICB0aGlzLl9yZWJ1aWxkTWVtb3MoKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5wYXJlbnRzIHRoaXMgZW50aXR5LCBpZiB0aGVyZSBpcyBhIHBhcmVudC4gT3RoZXJ3aXNlIGl0IGRvZXMgbm90aGluZy5cclxuICAgICAqL1xyXG4gICAgdW5wYXJlbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byBiZSBhIGNoaWxkIG9mIHRoaXMgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkucGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFuY2VzdG9ycygpLmluY2x1ZGVzKGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGUgZGV0ZWN0ZWQsIGNhbm5vdCBhZGQgZW50aXR5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuX3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5BZGRlZCQubm90aWZ5QWxsKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSBhbHJlYWR5IGhhcyBhIHBhcmVudCwgY2Fubm90IGFkZCB3aXRob3V0IHVucGFyZW50aW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZW50aXR5IGZyb20gY2hpbGRyZW4gaWYgaXQgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNoaWxkKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkucGFyZW50ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoZW50aXR5LCB0aGlzLl9jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIGVudGl0eS5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblJlbW92ZWQkLm5vdGlmeUFsbChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGVudGl0eVxyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxDaGlsZHJlbigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcGFyZW50IGVudGl0aWVzIHN0YXJ0aW5nIHdpdGggdGhlIHRvcG1vc3QgcGFyZW50LiBJbmNsdWRlcyB0aGUgY3VycmVudCBlbnRpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldEFuY2VzdG9ycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbdGhpc107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBlbnRpdGllcyB0aGF0IGRlc2NlbmQgZnJvbSB0aGlzIGVudGl0eS4gSW5jbHVkZXMgdGhlIGN1cnJlbnQgZW50aXR5LlxyXG4gICAgICovXHJcbiAgICBnZXREZXNjZW5kYW50cygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoaXNdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IFt0aGlzXTtcclxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyID0gcXVldWUucG9wKCk7XHJcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUuY29uY2F0KGN1cnIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGN1cnIuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBlbnRpdHkgYW5kIGEgY29weSBvZiBhbGwgaXRzIGNvbXBvbmVudHNcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3RW50aXR5ID0gbmV3IEVudGl0eSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnR5cGVzKSB7XHJcbiAgICAgICAgICAgIG5ld0VudGl0eS5hZGRDb21wb25lbnQodGhpcy5nZXQoYykuY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBuZXdFbnRpdHkuYWRkQ2hpbGQoY2hpbGQuY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdFbnRpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjb3B5IG9mIGFsbCB0aGUgY29tcG9uZW50cyBmcm9tIGFub3RoZXIgdGVtcGxhdGUgZW50aXR5IGFzIGEgXCJwcmVmYWJcIlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRW50aXR5IEVudGl0eSB0byB1c2UgYXMgYSB0ZW1wbGF0ZVxyXG4gICAgICogQHBhcmFtIGZvcmNlIEZvcmNlIGNvbXBvbmVudCByZXBsYWNlbWVudCBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgdGFyZ2V0IGVudGl0eVxyXG4gICAgICovXHJcbiAgICBhZGRUZW1wbGF0ZSh0ZW1wbGF0ZUVudGl0eSwgZm9yY2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0ZW1wbGF0ZUVudGl0eS5nZXRDb21wb25lbnRzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoYy5jbG9uZSgpLCBmb3JjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGVtcGxhdGVFbnRpdHkuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZC5jbG9uZSgpLmFkZFRlbXBsYXRlKGNoaWxkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY29tcG9uZW50IHRvIHRoZSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgQ29tcG9uZW50IG9yIEVudGl0eSB0byBhZGQgY29weSBvZiBjb21wb25lbnRzIGZyb21cclxuICAgICAqIEBwYXJhbSBmb3JjZSBPcHRpb25hbGx5IG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgY29tcG9uZW50cyBvZiB0aGUgc2FtZSB0eXBlXHJcbiAgICAgKi9cclxuICAgIGFkZENvbXBvbmVudChjb21wb25lbnQsIGZvcmNlID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBpZiBjb21wb25lbnQgYWxyZWFkeSBleGlzdHMsIHNraXAgaWYgbm90IGZvcmNlZFxyXG4gICAgICAgIGlmICh0aGlzLmhhcyhjb21wb25lbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgY29tcG9uZW50IHR5cGUgaWYgZXhpc3RzIHdoZW4gZm9yY2VkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZWFybHkgZXhpdCBjb21wb25lbnQgZXhpdHNcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzIHdpbGwgYmUgYSBwcm9ibGVtXHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5kZXBlbmRlbmNpZXMgJiYgY29tcG9uZW50LmRlcGVuZGVuY2llcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjdG9yIG9mIGNvbXBvbmVudC5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBjdG9yKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudC5vd25lciA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY29uc3R1Y3RvclR5cGUgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZVRvSW5zdGFuY2Uuc2V0KGNvbnN0dWN0b3JUeXBlLCBjb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2Uuc2V0KGNvbXBvbmVudC50eXBlLCBjb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQub25BZGQpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50Lm9uQWRkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ub3RpZnlBZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBmcm9tIHRoZSBlbnRpdHksIGJ5IGRlZmF1bHQgcmVtb3ZhbHMgYXJlIGRlZmVycmVkIHRvIHRoZSBlbmQgb2YgZW50aXR5IHVwZGF0ZSB0byBhdm9pZCBjb25zaXN0ZW5jeSBpc3N1ZXNcclxuICAgICAqXHJcbiAgICAgKiBDb21wb25lbnRzIGNhbiBiZSBmb3JjZSByZW1vdmVkIHdpdGggdGhlIGBmb3JjZWAgZmxhZywgdGhlIHJlbW92YWwgaXMgbm90IGRlZmVycmVkIGFuZCBoYXBwZW5zIGltbWVkaWF0ZWx5XHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50T3JUeXBlXHJcbiAgICAgKiBAcGFyYW0gZm9yY2VcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudE9yVHlwZSwgZm9yY2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9yVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbXBvbmVudEJ5VHlwZShjb21wb25lbnRPclR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudE9yVHlwZSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50QnlUeXBlKGNvbXBvbmVudE9yVHlwZS50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1RvUmVtb3ZlLnB1c2goY29tcG9uZW50T3JUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlQ29tcG9uZW50QnlUeXBlKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXModHlwZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5nZXQodHlwZSk7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5vd25lciA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQub25SZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vblJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjdG9yID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZS5kZWxldGUoY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UuZGVsZXRlKGNvbXBvbmVudC50eXBlKTtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5UmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0NvbXBvbmVudFJlbW92YWwoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnRPclR5cGUgb2YgdGhpcy5fY29tcG9uZW50c1RvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgY29tcG9uZW50T3JUeXBlID09PSAnc3RyaW5nJyA/IGNvbXBvbmVudE9yVHlwZSA6IGNvbXBvbmVudE9yVHlwZS50eXBlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDb21wb25lbnRCeVR5cGUodHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNUb1JlbW92ZS5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgaGFzKHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLmhhcyh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZS5oYXModHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLmdldCh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZS5nZXQodHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGFjdG9yIGlzIEluaXRpYWxpemVkXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIGVudGl0eSwgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBTY2VuZSBiZWZvcmUgZmlyc3QgdXBkYXRlIG5vdCBieSB1c2VycyBvZiBFeGNhbGlidXIuXHJcbiAgICAgKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgc3VwZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBJbml0aWFsaXplRXZlbnQoZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25QcmVVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25Qb3N0VXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3R1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0VXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgb25Jbml0aWFsaXplYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGVudGl0eS4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAqIG92ZXJyaWRkZW4uXHJcbiAgICAgKlxyXG4gICAgICogU3lub255bW91cyB3aXRoIHRoZSBldmVudCBoYW5kbGVyIGAub24oJ2luaXRpYWxpemUnLCAoZXZ0KSA9PiB7Li4ufSlgXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZVVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZVVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBlbnRpdHkgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25QcmVVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwb3N0dXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGFuIGVudGl0eSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEVudGl0eSB1cGRhdGUgbGlmZWN5Y2xlLCBjYWxsZWQgaW50ZXJuYWxseVxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQHBhcmFtIGVuZ2luZVxyXG4gICAgICogQHBhcmFtIGRlbHRhXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY2hpbGQudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG59XHJcbkVudGl0eS5fSUQgPSAwO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0dyYXBoaWNzQ29tcG9uZW50LnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiBhIEdyYXBoaWMgSGFzVGljayAodXNlZCBmb3IgZ3JhcGhpY3MgdGhhdCBjaGFuZ2Ugb3ZlciB0aW1lIGxpa2UgYW5pbWF0aW9ucylcclxuICogQHBhcmFtIGdyYXBoaWNcclxuICovXHJcbmZ1bmN0aW9uIGhhc0dyYXBoaWNzVGljayhncmFwaGljKSB7XHJcbiAgICByZXR1cm4gISFncmFwaGljLnRpY2s7XHJcbn1cclxuY2xhc3MgR3JhcGhpY3NMYXllciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb3B0aW9ucywgX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzID0gX2dyYXBoaWNzO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBbXTtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLm5hbWU7XHJcbiAgICB9XHJcbiAgICBoaWRlKG5hbWVPckdyYXBoaWMpIHtcclxuICAgICAgICBpZiAoIW5hbWVPckdyYXBoaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGdmeCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChuYW1lT3JHcmFwaGljIGluc3RhbmNlb2YgR3JhcGhpYykge1xyXG4gICAgICAgICAgICAgICAgZ2Z4ID0gbmFtZU9yR3JhcGhpYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdmeCA9IHRoaXMuX2dyYXBoaWNzLmdldEdyYXBoaWMobmFtZU9yR3JhcGhpYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcyA9IHRoaXMuZ3JhcGhpY3MuZmlsdGVyKChnKSA9PiBnLmdyYXBoaWMgIT09IGdmeCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnJlY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IGEgZ3JhcGhpYyBieSBuYW1lIG9yIGluc3RhbmNlIGF0IGFuIG9mZnNldCwgZ3JhcGhpY3MgYXJlIHNob3duIGluIHRoZSBvcmRlciBpbiB3aGljaCBgc2hvdygpYCBpcyBjYWxsZWQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHNob3coKWAgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZSBncmFwaGljIGl0IHdpbGwgYmUgc2hvd24gbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgKiBAcGFyYW0gbmFtZU9yR3JhcGhpY1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2hvdyhuYW1lT3JHcmFwaGljLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xyXG4gICAgICAgIGxldCBnZng7XHJcbiAgICAgICAgaWYgKG5hbWVPckdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljKSB7XHJcbiAgICAgICAgICAgIGdmeCA9IHRoaXMuX2dyYXBoaWNzLmNvcHlHcmFwaGljcyA/IG5hbWVPckdyYXBoaWMuY2xvbmUoKSA6IG5hbWVPckdyYXBoaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZnggPSB0aGlzLl9ncmFwaGljcy5nZXRHcmFwaGljKG5hbWVPckdyYXBoaWMpO1xyXG4gICAgICAgICAgICBpZiAoIWdmeCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoYE5vIHN1Y2ggZ3JhcGhpYyBhZGRlZCB0byBjb21wb25lbnQgbmFtZWQgJHtuYW1lT3JHcmFwaGljfS4gVGhlc2UgbmFtZWQgZ3JhcGhpY3MgYXJlIGF2YWlsYWJsZTogYCwgdGhpcy5fZ3JhcGhpY3MuZ2V0TmFtZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdmeCkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLnB1c2goeyBncmFwaGljOiBnZngsIG9wdGlvbnMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnJlY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBhIHNwZWNpZmljIGdyYXBoaWMsIHN3YXAgb3V0IGFueSBjdXJyZW50IGdyYXBoaWNzIGJlaW5nIHNob3duXHJcbiAgICAgKiBAcGFyYW0gbmFtZU9yR3JhcGhpY1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgdXNlKG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhuYW1lT3JHcmFwaGljLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBvcmRlciBvZiB0aGUgbGF5ZXIsIGhpZ2hlciBudW1iZXJzIGFyZSBvbiB0b3AsIGxvd2VyIG51bWJlcnMgYXJlIG9uIHRoZSBib3R0b20uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUgYSBsYXllciB3aXRoIGBvcmRlciA9IC0xYCB3b3VsZCBiZSB1bmRlciBhIGxheWVyIG9mIGBvcmRlciA9IDFgXHJcbiAgICAgKi9cclxuICAgIGdldCBvcmRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5vcmRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBvcmRlciBvZiB0aGUgbGF5ZXIsIGhpZ2hlciBudW1iZXJzIGFyZSBvbiB0b3AsIGxvd2VyIG51bWJlcnMgYXJlIG9uIHRoZSBib3R0b20uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUgYSBsYXllciB3aXRoIGBvcmRlciA9IC0xYCB3b3VsZCBiZSB1bmRlciBhIGxheWVyIG9mIGBvcmRlciA9IDFgXHJcbiAgICAgKi9cclxuICAgIHNldCBvcmRlcihvcmRlcikge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMub3JkZXIgPSBvcmRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgcGl4ZWwgb2Zmc2V0IGZyb20gdGhlIGxheWVyIGFuY2hvciBmb3IgYWxsIGdyYXBoaWNzIGluIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBnZXQgb2Zmc2V0KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgc2V0IG9mZnNldCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMub2Zmc2V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgY3VycmVudEtleXMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdhbm9ueW1vdXMnO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEdyYXBoaWNzTGF5ZXJzIHtcclxuICAgIGNvbnN0cnVjdG9yKF9jb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnQgPSBfY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuX2xheWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xheWVyTWFwID0ge307XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gbmV3IEdyYXBoaWNzTGF5ZXIoeyBuYW1lOiAnZGVmYXVsdCcsIG9yZGVyOiAwIH0sIF9jb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21heWJlQWRkTGF5ZXIodGhpcy5kZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBuZXcgR3JhcGhpY3NMYXllcihvcHRpb25zLCB0aGlzLl9jb21wb25lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXliZUFkZExheWVyKGxheWVyKTtcclxuICAgIH1cclxuICAgIGdldChuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExheWVyKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xyXG4gICAgfVxyXG4gICAgY3VycmVudEtleXMoKSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhpY3NMYXllcktleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuX2xheWVycykge1xyXG4gICAgICAgICAgICBncmFwaGljc0xheWVyS2V5cy5wdXNoKGxheWVyLmN1cnJlbnRLZXlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYXBoaWNzTGF5ZXJLZXlzO1xyXG4gICAgfVxyXG4gICAgaGFzKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzLl9sYXllck1hcDtcclxuICAgIH1cclxuICAgIF9tYXliZUFkZExheWVyKGxheWVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyTWFwW2xheWVyLm5hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gbG9nIHdhcm5pbmdcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyTWFwW2xheWVyLm5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXllck1hcFtsYXllci5uYW1lXSA9IGxheWVyO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5wdXNoKGxheWVyKTtcclxuICAgICAgICB0aGlzLl9sYXllcnMuc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuICAgIF9nZXRMYXllcihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb21wb25lbnQgdG8gbWFuYWdlIGRyYXdpbmdzLCB1c2luZyB3aXRoIHRoZSBwb3NpdGlvbiBjb21wb25lbnRcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5ncmFwaGljcyc7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgd2V0aGVyIGFueSBkcmF3aW5nIHNob3VsZCBiZSB2aXNpYmxlIGluIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIG9yIGdldHMgd2l0aGVyIGFsbCBkcmF3aW5ncyBzaG91bGQgaGF2ZSBhbiBvcGFjaXR5IGFwcGxpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9mZnNldCB0byBhcHBseSB0byBncmFwaGljcyBieSBkZWZhdWx0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmNob3IgdG8gYXBwbHkgdG8gZ3JhcGhpY3MgYnkgZGVmYXVsdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gVmVjdG9yLkhhbGY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUgZ3JhcGhpY3MgYWRkZWQgdG8gdGhlIGNvbXBvbmVudCB3aWxsIGJlIGNvcGllZC4gVGhpcyBjYW4gYWZmZWN0IHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb3B5R3JhcGhpY3MgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgLy8gRGVmYXVsdHNcclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXHJcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudCwgYW5jaG9yLCBvcGFjaXR5LCB2aXNpYmxlLCBncmFwaGljcywgb2Zmc2V0LCBjb3B5R3JhcGhpY3MsIG9uUHJlRHJhdywgb25Qb3N0RHJhdyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IGdyYXBoaWNzIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0ICE9PSBudWxsICYmIG9mZnNldCAhPT0gdm9pZCAwID8gb2Zmc2V0IDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB2b2lkIDAgPyBvcGFjaXR5IDogdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yICE9PSBudWxsICYmIGFuY2hvciAhPT0gdm9pZCAwID8gYW5jaG9yIDogdGhpcy5hbmNob3I7XHJcbiAgICAgICAgdGhpcy5jb3B5R3JhcGhpY3MgPSBjb3B5R3JhcGhpY3MgIT09IG51bGwgJiYgY29weUdyYXBoaWNzICE9PSB2b2lkIDAgPyBjb3B5R3JhcGhpY3MgOiB0aGlzLmNvcHlHcmFwaGljcztcclxuICAgICAgICB0aGlzLm9uUHJlRHJhdyA9IG9uUHJlRHJhdyAhPT0gbnVsbCAmJiBvblByZURyYXcgIT09IHZvaWQgMCA/IG9uUHJlRHJhdyA6IHRoaXMub25QcmVEcmF3O1xyXG4gICAgICAgIHRoaXMub25Qb3N0RHJhdyA9IG9uUG9zdERyYXcgIT09IG51bGwgJiYgb25Qb3N0RHJhdyAhPT0gdm9pZCAwID8gb25Qb3N0RHJhdyA6IHRoaXMub25Qb3N0RHJhdztcclxuICAgICAgICB0aGlzLnZpc2libGUgPSAhIXZpc2libGU7XHJcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhpY3NMYXllcnModGhpcyk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgdGhpcy5fZ3JhcGhpY3NbY3VycmVudF0pIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93KHRoaXMuX2dyYXBoaWNzW2N1cnJlbnRdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRHcmFwaGljKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NbbmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCByZWdpc3RlcmVkIGdyYXBoaWNzIG5hbWVzXHJcbiAgICAgKi9cclxuICAgIGdldE5hbWVzKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9ncmFwaGljcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZ3JhcGhpY3MgYW5kIHRoZWlyIG9mZnNldHMsIGVtcHR5IGFycmF5IGlmIGhpZGRlblxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZGVmYXVsdC5ncmFwaGljcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgZ3JhcGhpY3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGdldCBncmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3M7XHJcbiAgICB9XHJcbiAgICBhZGQobmFtZU9yR3JhcGhpYywgZ3JhcGhpYykge1xyXG4gICAgICAgIGxldCBuYW1lID0gJ2RlZmF1bHQnO1xyXG4gICAgICAgIGxldCBncmFwaGljVG9TZXQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yR3JhcGhpYyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckdyYXBoaWM7XHJcbiAgICAgICAgICAgIGdyYXBoaWNUb1NldCA9IGdyYXBoaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBncmFwaGljVG9TZXQgPSBuYW1lT3JHcmFwaGljO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc1tuYW1lXSA9IHRoaXMuY29weUdyYXBoaWNzID8gZ3JhcGhpY1RvU2V0LmNsb25lKCkgOiBncmFwaGljVG9TZXQ7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICB0aGlzLnNob3coJ2RlZmF1bHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYXBoaWNUb1NldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBhIGdyYXBoaWMgYnkgbmFtZSBvbiB0aGUgKipkZWZhdWx0KiogbGF5ZXIsIHJldHVybnMgdGhlIG5ldyBbW0dyYXBoaWNdXVxyXG4gICAgICovXHJcbiAgICBzaG93KG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmxheWVycy5kZWZhdWx0LnNob3cobmFtZU9yR3JhcGhpYywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBhIGdyYXBoaWMgb25seSwgc3dhcCBvdXQgYW55IGdyYXBoaWNzIG9uIHRoZSAqKmRlZmF1bHQqKiBsYXllciwgcmV0dXJucyB0aGUgbmV3IFtbR3JhcGhpY11dXHJcbiAgICAgKiBAcGFyYW0gbmFtZU9yR3JhcGhpY1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgdXNlKG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmxheWVycy5kZWZhdWx0LnVzZShuYW1lT3JHcmFwaGljLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhpZGUobmFtZU9yR3JhcGhpYykge1xyXG4gICAgICAgIHRoaXMubGF5ZXJzLmRlZmF1bHQuaGlkZShuYW1lT3JHcmFwaGljKTtcclxuICAgIH1cclxuICAgIHNldCBsb2NhbEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuICAgIHJlY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIGxldCBiYiA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMuZ2V0KCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMsIG9wdGlvbnMgfSBvZiBsYXllci5ncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBvcHRpb25zLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBncmFwaGljLmxvY2FsQm91bmRzO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IC1ib3VuZHMud2lkdGggKiBhbmNob3IueCArIG9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IC1ib3VuZHMuaGVpZ2h0ICogYW5jaG9yLnkgKyBvZmZzZXQueTtcclxuICAgICAgICAgICAgICAgIGJiID0gZ3JhcGhpYyA9PT0gbnVsbCB8fCBncmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncmFwaGljLmxvY2FsQm91bmRzLnRyYW5zbGF0ZSh2ZWMob2Zmc2V0WCArIGxheWVyLm9mZnNldC54LCBvZmZzZXRZICsgbGF5ZXIub2Zmc2V0LnkpKS5jb21iaW5lKGJiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IGJiO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHMgfHwgdGhpcy5fbG9jYWxCb3VuZHMuaGFzWmVyb0RpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbEJvdW5kcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHVuZGVybHlpbmcgZ3JhcGhpY3MgaWYgbmVjZXNhcnksIGNhbGxlZCBpbnRlcm5hbGx5XHJcbiAgICAgKiBAcGFyYW0gZWxhcHNlZFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbGFwc2VkLCBpZGVtcG90ZW5jeVRva2VuID0gMCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMuZ2V0KCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMgfSBvZiBsYXllci5ncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0dyYXBoaWNzVGljayhncmFwaGljKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy50aWNrKGVsYXBzZWQsIGlkZW1wb3RlbmN5VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUmVjdGFuZ2xlLnRzXG5cclxuLyoqXHJcbiAqIEEgUmVjdGFuZ2xlIFtbR3JhcGhpY11dIGZvciBkcmF3aW5nIHJlY3RhbmdsZXMgdG8gdGhlIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV1cclxuICovXHJcbmNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcclxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgLi4udGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCksXHJcbiAgICAgICAgICAgIC4uLnRoaXMuY2xvbmVSYXN0ZXJPcHRpb25zKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NpcmNsZS50c1xuXHJcblxyXG4vKipcclxuICogQSBjaXJjbGUgW1tHcmFwaGljXV0gZm9yIGRyYXdpbmcgY2lyY2xlcyB0byB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXVxyXG4gKlxyXG4gKiBDaXJjbGVzIGRlZmF1bHQgdG8gW1tJbWFnZUZpbHRlcmluZy5CbGVuZGVkXV1cclxuICovXHJcbmNsYXNzIENpcmNsZSBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSAwO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IChfYSA9IG9wdGlvbnMucGFkZGluZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjsgLy8gZGVmYXVsdCAyIHBhZGRpbmcgZm9yIGNpcmNsZXMgbG9va3MgbmljZVxyXG4gICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAoX2IgPSBvcHRpb25zLmZpbHRlcmluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSW1hZ2VGaWx0ZXJpbmcuQmxlbmRlZDtcclxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJhZGl1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgfVxyXG4gICAgc2V0IHJhZGl1cyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9yYWRpdXMgKiAyO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fcmFkaXVzICogMjtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGUoe1xyXG4gICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSxcclxuICAgICAgICAgICAgLi4udGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5yYWRpdXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cm9rZUNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9Qb2ludGVyQ29tcG9uZW50LnRzXG5cclxuLyoqXHJcbiAqIEFkZCB0aGlzIGNvbXBvbmVudCB0byBvcHRpb25hbGx5IGNvbmZpZ3VyZSBob3cgdGhlIHBvaW50ZXJcclxuICogc3lzdGVtIGRldGVjdHMgcG9pbnRlciBldmVudHMuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgdGhlIGNvbGxpZGVyIHNoYXBlIGlzIHVzZWQgYW5kIGdyYXBoaWNzIGJvdW5kcyBpcyBub3QuXHJcbiAqXHJcbiAqIElmIGJvdGggY29sbGlkZXIgc2hhcGUgYW5kIGdyYXBoaWNzIGJvdW5kcyBhcmUgZW5hYmxlZCBpdCB3aWxsIGZpcmUgZXZlbnRzIGlmIGVpdGhlciBvclxyXG4gKiBhcmUgaW50ZXJzZWN0aW5nIHRoZSBwb2ludGVyLlxyXG4gKi9cclxuY2xhc3MgUG9pbnRlckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5wb2ludGVyJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2UgYW55IGV4aXN0aW5nIENvbGxpZGVyIGNvbXBvbmVudCBnZW9tZXRyeSBmb3IgcG9pbnRlciBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50XHJcbiAgICAgICAgICogdXNlciBwb2ludGVyIGV2ZW50cyBvbmx5IHRvIHRyaWdnZXIgb24gdGhlIHNhbWUgY29sbGlzaW9uIGdlb21ldHJ5IHVzZWQgaW4gdGhlIGNvbGxpZGVyIGNvbXBvbmVudFxyXG4gICAgICAgICAqIGZvciBjb2xsaXNpb24gcmVzb2x1dGlvbi4gRGVmYXVsdCBpcyBgdHJ1ZWAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51c2VDb2xsaWRlclNoYXBlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2UgYW55IGV4aXN0aW5nIEdyYXBoaWNzIGNvbXBvbmVudCBib3VuZHMgZm9yIHBvaW50ZXJzLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0aGUgYXhpcyBhbGlnbmVkXHJcbiAgICAgICAgICogYm91bmRzIGFyb3VuZCB0aGUgZ3JhcGhpYyB0byB0cmlnZ2VyIHBvaW50ZXIgZXZlbnRzLiBEZWZhdWx0IGlzIGBmYWxzZWAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51c2VHcmFwaGljc0JvdW5kcyA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9FYXNpbmdGdW5jdGlvbnMudHNcblxyXG4vKipcclxuICogU3RhbmRhcmQgZWFzaW5nIGZ1bmN0aW9ucyBmb3IgbW90aW9uIGluIEV4Y2FsaWJ1ciwgZGVmaW5lZCBvbiBhIGRvbWFpbiBvZiBbMCwgZHVyYXRpb25dIGFuZCBhIHJhbmdlIGZyb20gWytzdGFydFZhbHVlLCtlbmRWYWx1ZV1cclxuICogR2l2ZW4gYSB0aW1lLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSB2YWx1ZSBmcm9tIHBvc2l0aXZlIHN0YXJ0VmFsdWUgdG8gcG9zaXRpdmUgZW5kVmFsdWUuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIExpbmVhciAodCkge1xyXG4gKiAgICByZXR1cm4gdCAqIHQ7XHJcbiAqIH1cclxuICpcclxuICogLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG4gKiBmdW5jdGlvbiBFYXNlSW5RdWFkICh0KSB7XHJcbiAqICAgIHJldHVybiB0ICogdDtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG4gKiBmdW5jdGlvbiBFYXNlT3V0UXVhZCAodCkge1xyXG4gKiAgICByZXR1cm4gdCAqICgyIC0gdCk7XHJcbiAqIH1cclxuICpcclxuICogLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbiAqIGZ1bmN0aW9uIEVhc2VJbk91dFF1YWQgKHQpIHtcclxuICogICAgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxuICogZnVuY3Rpb24gRWFzZUluQ3ViaWMgKHQpIHtcclxuICogICAgcmV0dXJuIHQgKiB0ICogdDtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG4gKiBmdW5jdGlvbiBFYXNlT3V0Q3ViaWMgKHQpIHtcclxuICogICAgcmV0dXJuICgtLXQpICogdCAqIHQgKyAxO1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxyXG4gKiBmdW5jdGlvbiBFYXNlSW5PdXRDdWJpYyAodCkge1xyXG4gKiAgICByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIEVhc2luZ0Z1bmN0aW9ucyB7XHJcbiAgICBzdGF0aWMgQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKGVhc2luZykge1xyXG4gICAgICAgIHJldHVybiAodGltZSwgc3RhcnQsIGVuZCwgZHVyYXRpb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgLSAoZWFzaW5nKHRpbWUsIGVuZCwgc3RhcnQsIGR1cmF0aW9uKSAtIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nKHRpbWUsIHN0YXJ0LCBlbmQsIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgQ3JlYXRlVmVjdG9yRWFzaW5nRnVuY3Rpb24oZWFzaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aW1lLCBzdGFydCwgZW5kLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihlYXNpbmcodGltZSwgc3RhcnQueCwgZW5kLngsIGR1cmF0aW9uKSwgZWFzaW5nKHRpbWUsIHN0YXJ0LnksIGVuZC55LCBkdXJhdGlvbikpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuRWFzaW5nRnVuY3Rpb25zLkxpbmVhciA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgcmV0dXJuIChlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lKSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5RdWFkID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRRdWFkID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgIHJldHVybiAtZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRRdWFkID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XHJcbiAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmRWYWx1ZSAvIDIpICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50VGltZS0tO1xyXG4gICAgcmV0dXJuICgtZW5kVmFsdWUgLyAyKSAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VJbkN1YmljID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZU91dEN1YmljID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcclxuICAgIGN1cnJlbnRUaW1lLS07XHJcbiAgICByZXR1cm4gZW5kVmFsdWUgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMSkgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XHJcbiAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmRWYWx1ZSAvIDIpICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRUaW1lIC09IDI7XHJcbiAgICByZXR1cm4gKGVuZFZhbHVlIC8gMikgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMikgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvblF1ZXVlLnRzXG4vKipcclxuICogQWN0aW9uIFF1ZXVlcyByZXByZXNlbnQgYW4gb3JkZXJlZCBzZXF1ZW5jZSBvZiBhY3Rpb25zXHJcbiAqXHJcbiAqIEFjdGlvbiBxdWV1ZXMgYXJlIHBhcnQgb2YgdGhlIFtbQWN0aW9uQ29udGV4dHxBY3Rpb24gQVBJXV0gYW5kXHJcbiAqIHN0b3JlIHRoZSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgZm9yIGFuIFtbQWN0b3JdXS5cclxuICpcclxuICogQWN0b3JzIGltcGxlbWVudCBbW0FjdG9yLmFjdGlvbnNdXSB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYnlcclxuICogYWR2YW5jZWQgdXNlcnMgdG8gYWRqdXN0IHRoZSBhY3Rpb25zIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZCBpbiB0aGVcclxuICogcXVldWUuXHJcbiAqL1xyXG5jbGFzcyBBY3Rpb25RdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFjdGlvbiB0byB0aGUgc2VxdWVuY2VcclxuICAgICAqIEBwYXJhbSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgYWRkKGFjdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gYWN0aW9uIGJ5IHJlZmVyZW5jZSBmcm9tIHRoZSBzZXF1ZW5jZVxyXG4gICAgICogQHBhcmFtIGFjdGlvblxyXG4gICAgICovXHJcbiAgICByZW1vdmUoYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9hY3Rpb25zLmluZGV4T2YoYWN0aW9uKTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGFjdGlvbnMgZnJvbSB0aGlzIHNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQWN0aW9ucygpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24uc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBsaXN0IG9mIGFjdGlvbnMgaW4gdGhpcyBzZXF1ZW5jZSBjb21wbGV0ZSBvciBub3RcclxuICAgICAqL1xyXG4gICAgZ2V0QWN0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5jb25jYXQodGhpcy5fY29tcGxldGVkQWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgYXJlIG1vcmUgYWN0aW9ucyB0byBwcm9jZXNzIGluIHRoZSBzZXF1ZW5jZVxyXG4gICAgICovXHJcbiAgICBoYXNOZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY3VycmVudCBzZXF1ZW5jZSBvZiBhY3Rpb25zIGlzIGRvbmVcclxuICAgICAqL1xyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgc2VxdWVuY2Ugb2YgYWN0aW9ucywgdGhpcyBpcyB1c2VkIHRvIHJlc3RhcnQgYSBzZXF1ZW5jZSBmcm9tIHRoZSBiZWdpbm5pbmdcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2FjdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uc1tpXS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgcXVldWUgd2hpY2ggdXBkYXRlcyBhY3Rpb25zIGFuZCBoYW5kbGVzIGNvbXBsZXRpbmcgYWN0aW9uc1xyXG4gICAgICogQHBhcmFtIGVsYXBzZWRNc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uc1swXTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi51cGRhdGUoZWxhcHNlZE1zKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3Rpb24uaXNDb21wbGV0ZSh0aGlzLl9lbnRpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9ucy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1JlcGVhdC50c1xuXHJcbmNsYXNzIFJlcGVhdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHJlcGVhdEJ1aWxkZXIsIHJlcGVhdCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyID0gcmVwZWF0QnVpbGRlcjtcclxuICAgICAgICB0aGlzLl9yZXBlYXRDb250ZXh0ID0gbmV3IEFjdGlvbkNvbnRleHQoZW50aXR5KTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZSA9IHRoaXMuX3JlcGVhdENvbnRleHQuZ2V0UXVldWUoKTtcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSByZXBlYXQ7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxSZXBlYXQgPSByZXBlYXQ7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlcih0aGlzLl9yZXBlYXRDb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9yZXBlYXQtLTsgLy8gY3VycmVudCBleGVjdXRpb24gaXMgdGhlIGZpcnN0IHJlcGVhdFxyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvblF1ZXVlLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlcih0aGlzLl9yZXBlYXRDb250ZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLl9yZXBlYXQgPD0gMCAmJiB0aGlzLl9hY3Rpb25RdWV1ZS5pc0NvbXBsZXRlKCkpO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHRoaXMuX29yaWdpbmFsUmVwZWF0O1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vUmVwZWF0Rm9yZXZlci50c1xuXHJcbi8qKlxyXG4gKiBSZXBlYXRGb3JldmVyIEFjdGlvbiBpbXBsZW1lbnRhdGlvbiwgaXQgaXMgcmVjb21tZW5kZWQgeW91IHVzZSB0aGUgZmx1ZW50IGFjdGlvblxyXG4gKiBjb250ZXh0IEFQSS5cclxuICpcclxuICpcclxuICovXHJcbmNsYXNzIFJlcGVhdEZvcmV2ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCByZXBlYXRCdWlsZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIgPSByZXBlYXRCdWlsZGVyO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdENvbnRleHQgPSBuZXcgQWN0aW9uQ29udGV4dChlbnRpdHkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlID0gdGhpcy5fcmVwZWF0Q29udGV4dC5nZXRRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIodGhpcy5fcmVwZWF0Q29udGV4dCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25RdWV1ZS5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIodGhpcy5fcmVwZWF0Q29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL01vdmVCeS50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIE1vdmVCeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIG9mZnNldFgsIG9mZnNldFksIHNwZWVkKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFZlY3RvcihvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgICAgICBpZiAoc3BlZWQgPD0gMCkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQXR0ZW1wdGVkIHRvIG1vdmVCeSB3aXRoIHNwZWVkIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIDogJyArIHNwZWVkKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVlZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHBpeGVscyBwZXIgc2Vjb25kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX3N0YXJ0LmFkZCh0aGlzLl9vZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX29mZnNldC5zaXplO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX3N0YXJ0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLl9lbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9lbmQueCwgdGhpcy5fZW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZShlbnRpdHkpIHtcclxuICAgICAgICBjb25zdCB0eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCB0eC5wb3MuZGlzdGFuY2UodGhpcy5fc3RhcnQpID49IHRoaXMuX2Rpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL01vdmVUby50c1xuXHJcblxyXG5cclxuY2xhc3MgTW92ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgZGVzdHgsIGRlc3R5LCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuZW50aXR5ID0gZW50aXR5O1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IG5ldyBWZWN0b3IoZGVzdHgsIGRlc3R5KTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc3RhcnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMobS54LCBtLnkpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5lbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9lbmQueCwgdGhpcy5fZW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgbmV3IFZlY3Rvcih0eC5wb3MueCwgdHgucG9zLnkpLmRpc3RhbmNlKHRoaXMuX3N0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL1JvdGF0aW9uVHlwZS50c1xuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHN0cmF0ZWdpZXMgdGhhdCByb3RhdGlvbiBhY3Rpb25zIGNhbiB1c2VcclxuICovXHJcbnZhciBSb3RhdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoUm90YXRpb25UeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgU2hvcnRlc3RQYXRoYCB3aWxsIHVzZSB0aGUgc21hbGxlc3QgYW5nbGVcclxuICAgICAqIGJldHdlZW4gdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLiBUaGlzIHN0cmF0ZWd5IGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiU2hvcnRlc3RQYXRoXCJdID0gMF0gPSBcIlNob3J0ZXN0UGF0aFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGlvbiB2aWEgYExvbmdlc3RQYXRoYCB3aWxsIHVzZSB0aGUgbGFyZ2VzdCBhbmdsZVxyXG4gICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJMb25nZXN0UGF0aFwiXSA9IDFdID0gXCJMb25nZXN0UGF0aFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGlvbiB2aWEgYENsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLFxyXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJDbG9ja3dpc2VcIl0gPSAyXSA9IFwiQ2xvY2t3aXNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgQ291bnRlckNsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ291bnRlckNsb2Nrd2lzZVwiXSA9IDNdID0gXCJDb3VudGVyQ2xvY2t3aXNlXCI7XHJcbn0pKFJvdGF0aW9uVHlwZSB8fCAoUm90YXRpb25UeXBlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Sb3RhdGVUby50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFJvdGF0ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gYW5nbGVSYWRpYW5zO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3R4LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgPSB0aGlzLl90eC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UxID0gTWF0aC5hYnModGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZTIgPSBUd29QSSAtIGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA+IGRpc3RhbmNlMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSA9ICh0aGlzLl9zdGFydCAtIHRoaXMuX2VuZCArIFR3b1BJKSAlIFR3b1BJID49IE1hdGguUEk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5Mb25nZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgKz0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQgKiAoX2RlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnJvdGF0aW9uID0gdGhpcy5fZW5kO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGVkID0gTWF0aC5hYnModGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IGRpc3RhbmNlVHJhdmVsZWQgPj0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Sb3RhdGVCeS50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFJvdGF0ZUJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBhbmdsZVJhZGlhbnNPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3R4LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgPSB0aGlzLl90eC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyB0aGlzLl9vZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMSA9IE1hdGguYWJzKHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UyID0gVHdvUEkgLSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPiBkaXN0YW5jZTIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUgPSAodGhpcy5fc3RhcnQgLSB0aGlzLl9lbmQgKyBUd29QSSkgJSBUd29QSSA+PSBNYXRoLlBJO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuTG9uZ2VzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLkNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydERpc3RhbmNlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlICs9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkICogKF9kZWx0YSAvIDEwMDApO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxlZCA9IE1hdGguYWJzKHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCBkaXN0YW5jZVRyYXZlbGVkID49IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1NjYWxlVG8udHNcblxyXG5cclxuXHJcbmNsYXNzIFNjYWxlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBzY2FsZVgsIHNjYWxlWSwgc3BlZWRYLCBzcGVlZFkpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuX2VuZFkgPSBzY2FsZVk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWRYID0gc3BlZWRYO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkWSA9IHNwZWVkWTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX3R4LnNjYWxlLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuX3R4LnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuX2VuZFggLSB0aGlzLl9zdGFydFgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRZIC0gdGhpcy5fc3RhcnRZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5fdHguc2NhbGUueCAtIHRoaXMuX3N0YXJ0WCkgPj0gdGhpcy5fZGlzdGFuY2VYKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25YID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSB0aGlzLl9zcGVlZFggKiBkaXJlY3Rpb25YO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLl90eC5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvblkgPSB0aGlzLl9lbmRZIDwgdGhpcy5fc3RhcnRZID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5zY2FsZSA9IHZlYyh0aGlzLl9lbmRYLCB0aGlzLl9lbmRZKTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3N0b3BwZWQgfHxcclxuICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX3R4LnNjYWxlLnkgLSB0aGlzLl9zdGFydFgpID49ICh0aGlzLl9kaXN0YW5jZVggLSAwLjAxKSAmJlxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5fdHguc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gKHRoaXMuX2Rpc3RhbmNlWSAtIDAuMDEpKSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vU2NhbGVCeS50c1xuXHJcblxyXG5cclxuY2xhc3MgU2NhbGVCeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHNjYWxlT2Zmc2V0WCwgc2NhbGVPZmZzZXRZLCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX29mZnNldCA9IG5ldyBWZWN0b3Ioc2NhbGVPZmZzZXRYLCBzY2FsZU9mZnNldFkpO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkWCA9IHRoaXMuX3NwZWVkWSA9IHNwZWVkO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTY2FsZSA9IHRoaXMuX3R4LnNjYWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZFNjYWxlID0gdGhpcy5fc3RhcnRTY2FsZS5hZGQodGhpcy5fb2Zmc2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5fZW5kU2NhbGUueCAtIHRoaXMuX3N0YXJ0U2NhbGUueCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuX2VuZFNjYWxlLnkgLSB0aGlzLl9zdGFydFNjYWxlLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25YID0gdGhpcy5fZW5kU2NhbGUueCA8IHRoaXMuX3N0YXJ0U2NhbGUueCA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uWSA9IHRoaXMuX2VuZFNjYWxlLnkgPCB0aGlzLl9zdGFydFNjYWxlLnkgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gdGhpcy5fc3BlZWRYICogdGhpcy5fZGlyZWN0aW9uWDtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IHRoaXMuX3NwZWVkWSAqIHRoaXMuX2RpcmVjdGlvblk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnNjYWxlID0gdGhpcy5fZW5kU2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdG9wcGVkIHx8XHJcbiAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl90eC5zY2FsZS54IC0gdGhpcy5fc3RhcnRTY2FsZS54KSA+PSAodGhpcy5fZGlzdGFuY2VYIC0gMC4wMSkgJiZcclxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuX3R4LnNjYWxlLnkgLSB0aGlzLl9zdGFydFNjYWxlLnkpID49ICh0aGlzLl9kaXN0YW5jZVkgLSAwLjAxKSkpO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0NhbGxNZXRob2QudHNcbmNsYXNzIENhbGxNZXRob2Qge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCgpO1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzQmVlbkNhbGxlZDtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9FYXNlVG8udHNcblxyXG5cclxuXHJcbmNsYXNzIEVhc2VUbyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcclxuICAgICAgICB0aGlzLmVhc2luZ0ZjbiA9IGVhc2luZ0ZjbjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEgKiAxMDAwOyAvLyAxIHNlY29uZFxyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgVmVjdG9yKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoKSB7XHJcbiAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IFZlY3Rvcih0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOZWVkIHRvIHVwZGF0ZSBsZXJwIHRpbWUgZmlyc3QsIG90aGVyd2lzZSB0aGUgZmlyc3QgdXBkYXRlIHdpbGwgYWx3YXlzIGJlIHplcm9cclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgbGV0IG5ld1ggPSB0aGlzLl90eC5wb3MueDtcclxuICAgICAgICBsZXQgbmV3WSA9IHRoaXMuX3R4LnBvcy55O1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdYID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQueCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1kgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydC55IC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBsZXJwIHBvc2l0aW9uIGZpZ3VyZSBvdXQgdGhlIHZlbG9jaXR5IGluIHBpeGVscyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoKG5ld1ggLSB0aGlzLl90eC5wb3MueCkgLyAoZGVsdGEgLyAxMDAwKSwgKG5ld1kgLSB0aGlzLl90eC5wb3MueSkgLyAoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCB0aGlzLl9jdXJyZW50TGVycFRpbWUgPj0gdGhpcy5fbGVycER1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0Vhc2VCeS50c1xuXHJcblxyXG5cclxuY2xhc3MgRWFzZUJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xyXG4gICAgICAgIHRoaXMuZWFzaW5nRmNuID0gZWFzaW5nRmNuO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMSAqIDEwMDA7IC8vIDEgc2Vjb25kXHJcbiAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFZlY3RvcihvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKCkge1xyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBWZWN0b3IodGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlcnBFbmQgPSB0aGlzLl9sZXJwU3RhcnQuYWRkKHRoaXMuX29mZnNldCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOZWVkIHRvIHVwZGF0ZSBsZXJwIHRpbWUgZmlyc3QsIG90aGVyd2lzZSB0aGUgZmlyc3QgdXBkYXRlIHdpbGwgYWx3YXlzIGJlIHplcm9cclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgbGV0IG5ld1ggPSB0aGlzLl90eC5wb3MueDtcclxuICAgICAgICBsZXQgbmV3WSA9IHRoaXMuX3R4LnBvcy55O1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdYID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQueCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1kgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydC55IC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBsZXJwIHBvc2l0aW9uIGZpZ3VyZSBvdXQgdGhlIHZlbG9jaXR5IGluIHBpeGVscyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoKG5ld1ggLSB0aGlzLl90eC5wb3MueCkgLyAoZGVsdGEgLyAxMDAwKSwgKG5ld1kgLSB0aGlzLl90eC5wb3MueSkgLyAoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCB0aGlzLl9jdXJyZW50TGVycFRpbWUgPj0gdGhpcy5fbGVycER1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0JsaW5rLnRzXG5cclxuY2xhc3MgQmxpbmsge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcyA9IDEpIHtcclxuICAgICAgICB0aGlzLl90aW1lVmlzaWJsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZU5vdFZpc2libGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSBlbnRpdHkuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl90aW1lVmlzaWJsZSA9IHRpbWVWaXNpYmxlO1xyXG4gICAgICAgIHRoaXMuX3RpbWVOb3RWaXNpYmxlID0gdGltZU5vdFZpc2libGU7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAodGltZVZpc2libGUgKyB0aW1lTm90VmlzaWJsZSkgKiBudW1CbGlua3M7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFwaGljcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsVGltZSArPSBkZWx0YTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JhcGhpY3MudmlzaWJsZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl90aW1lVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFwaGljcy52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVOb3RWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX3RvdGFsVGltZSA+PSB0aGlzLl9kdXJhdGlvbjtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IDA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9GYWRlLnRzXG5cclxuXHJcbmNsYXNzIEZhZGUge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBlbmRPcGFjaXR5LCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSBlbnRpdHkuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9lbmRPcGFjaXR5ID0gZW5kT3BhY2l0eTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IHRoaXMuX29nc3BlZWQgPSBzcGVlZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gdGhpcy5fb2dzcGVlZDtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGRpcmVjdGlvbiB3aGVuIHdlIHN0YXJ0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmRPcGFjaXR5IDwgdGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NwZWVkID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy5vcGFjaXR5ICs9ICh0aGlzLl9tdWx0aXBsaWVyICpcclxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl9ncmFwaGljcy5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgKiBkZWx0YSkpIC8gdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NwZWVkIC09IGRlbHRhO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy5vcGFjaXR5ID0gdGhpcy5fZW5kT3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1tBY3Rpb24gZmFkZV0gQWN0b3Igb3BhY2l0eTonLCB0aGlzLl9ncmFwaGljcy5vcGFjaXR5KTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgTWF0aC5hYnModGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSAtIHRoaXMuX2VuZE9wYWNpdHkpIDwgMC4wNTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRGVsYXkudHNcbmNsYXNzIERlbGF5IHtcclxuICAgIGNvbnN0cnVjdG9yKGRlbGF5KSB7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX2RlbGF5O1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRGllLnRzXG5cclxuY2xhc3MgRGllIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5LmdldChBY3Rpb25zQ29tcG9uZW50KS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkua2lsbCgpO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRm9sbG93LnRzXG5cclxuXHJcblxyXG5jbGFzcyBGb2xsb3cge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBlbnRpdHlUb0ZvbGxvdywgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9mb2xsb3dUeCA9IGVudGl0eVRvRm9sbG93LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2ZvbGxvd01vdGlvbiA9IGVudGl0eVRvRm9sbG93LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gbmV3IFZlY3Rvcih0aGlzLl9mb2xsb3dUeC5wb3MueCwgdGhpcy5fZm9sbG93VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX21heGltdW1EaXN0YW5jZSA9IGZvbGxvd0Rpc3RhbmNlICE9PSB1bmRlZmluZWQgPyBmb2xsb3dEaXN0YW5jZSA6IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdG9yVG9Gb2xsb3dTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLl9mb2xsb3dNb3Rpb24udmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fZm9sbG93TW90aW9uLnZlbC55LCAyKSk7XHJcbiAgICAgICAgaWYgKGFjdG9yVG9Gb2xsb3dTcGVlZCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHZlYyh0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IHZlYyh0aGlzLl9mb2xsb3dUeC5wb3MueCwgdGhpcy5fZm9sbG93VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZUJldHdlZW4gPj0gdGhpcy5fbWF4aW11bURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKG0ueCwgbS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fZW5kLngsIHRoaXMuX2VuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIC8vIHRoZSBhY3RvciBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIHN0b3AgdW5sZXNzIHNwZWNpZmllZCB0byBkbyBzb1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL01lZXQudHNcblxyXG5cclxuXHJcbmNsYXNzIE1lZXQge1xyXG4gICAgY29uc3RydWN0b3IoYWN0b3IsIGFjdG9yVG9NZWV0LCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGFjdG9yLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGFjdG9yLmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21lZXRUeCA9IGFjdG9yVG9NZWV0LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21lZXRNb3Rpb24gPSBhY3RvclRvTWVldC5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gbmV3IFZlY3Rvcih0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IG5ldyBWZWN0b3IodGhpcy5fbWVldFR4LnBvcy54LCB0aGlzLl9tZWV0VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQgfHwgMDtcclxuICAgICAgICBpZiAoc3BlZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY3RvclRvTWVldFNwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuX21lZXRNb3Rpb24udmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fbWVldE1vdGlvbi52ZWwueSwgMikpO1xyXG4gICAgICAgIGlmIChhY3RvclRvTWVldFNwZWVkICE9PSAwICYmICF0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9NZWV0U3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB2ZWModGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9lbmQgPSB2ZWModGhpcy5fbWVldFR4LnBvcy54LCB0aGlzLl9tZWV0VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMobS54LCBtLnkpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fZW5kLngsIHRoaXMuX2VuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA8PSAxO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbkNvbnRleHQudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBmbHVlbnQgQWN0aW9uIEFQSSBhbGxvd3MgeW91IHRvIHBlcmZvcm0gXCJhY3Rpb25zXCIgb25cclxuICogW1tBY3RvcnxBY3RvcnNdXSBzdWNoIGFzIGZvbGxvd2luZywgbW92aW5nLCByb3RhdGluZywgYW5kXHJcbiAqIG1vcmUuIFlvdSBjYW4gaW1wbGVtZW50IHlvdXIgb3duIGFjdGlvbnMgYnkgaW1wbGVtZW50aW5nXHJcbiAqIHRoZSBbW0FjdGlvbl1dIGludGVyZmFjZS5cclxuICovXHJcbmNsYXNzIEFjdGlvbkNvbnRleHQge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5ID0gZW50aXR5O1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IEFjdGlvblF1ZXVlKGVudGl0eSk7XHJcbiAgICB9XHJcbiAgICBnZXRRdWV1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWU7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUudXBkYXRlKGVsYXBzZWRNcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgcXVldWVkIGFjdGlvbnMgZnJvbSB0aGUgQWN0b3JcclxuICAgICAqL1xyXG4gICAgY2xlYXJBY3Rpb25zKCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgcnVuQWN0aW9uKGFjdGlvbikge1xyXG4gICAgICAgIGFjdGlvbi5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZWFzZVRvKC4uLmFyZ3MpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gMDtcclxuICAgICAgICBsZXQgZWFzaW5nRmNuID0gRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjtcclxuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICB4ID0gYXJnc1swXS54O1xyXG4gICAgICAgICAgICB5ID0gYXJnc1swXS55O1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGFyZ3NbMV07XHJcbiAgICAgICAgICAgIGVhc2luZ0ZjbiA9IChfYSA9IGFyZ3NbMl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVhc2luZ0ZjbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICB5ID0gYXJnc1sxXTtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBhcmdzWzJdO1xyXG4gICAgICAgICAgICBlYXNpbmdGY24gPSAoX2IgPSBhcmdzWzNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBlYXNpbmdGY247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRWFzZVRvKHRoaXMuX2VudGl0eSwgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0ZjbikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZWFzZUJ5KC4uLmFyZ3MpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gMDtcclxuICAgICAgICBsZXQgZWFzaW5nRmNuID0gRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjtcclxuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBvZmZzZXRYID0gYXJnc1swXS54O1xyXG4gICAgICAgICAgICBvZmZzZXRZID0gYXJnc1swXS55O1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGFyZ3NbMV07XHJcbiAgICAgICAgICAgIGVhc2luZ0ZjbiA9IChfYSA9IGFyZ3NbMl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVhc2luZ0ZjbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9mZnNldFggPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICBvZmZzZXRZID0gYXJnc1sxXTtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBhcmdzWzJdO1xyXG4gICAgICAgICAgICBlYXNpbmdGY24gPSAoX2IgPSBhcmdzWzNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBlYXNpbmdGY247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRWFzZUJ5KHRoaXMuX2VudGl0eSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZHVyYXRpb24sIGVhc2luZ0ZjbikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvKHhPclBvcywgeU9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGxldCBzcGVlZCA9IDA7XHJcbiAgICAgICAgaWYgKHhPclBvcyBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICB4ID0geE9yUG9zLng7XHJcbiAgICAgICAgICAgIHkgPSB4T3JQb3MueTtcclxuICAgICAgICAgICAgc3BlZWQgPSB5T3JTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSB4T3JQb3M7XHJcbiAgICAgICAgICAgIHkgPSB5T3JTcGVlZDtcclxuICAgICAgICAgICAgc3BlZWQgPSBzcGVlZE9yVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IE1vdmVUbyh0aGlzLl9lbnRpdHksIHgsIHksIHNwZWVkKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtb3ZlQnkoeE9mZnNldE9yVmVjdG9yLCB5T2Zmc2V0T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCB4T2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgeU9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHNwZWVkID0gMDtcclxuICAgICAgICBpZiAoeE9mZnNldE9yVmVjdG9yIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHhPZmZzZXQgPSB4T2Zmc2V0T3JWZWN0b3IueDtcclxuICAgICAgICAgICAgeU9mZnNldCA9IHhPZmZzZXRPclZlY3Rvci55O1xyXG4gICAgICAgICAgICBzcGVlZCA9IHlPZmZzZXRPclNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeE9mZnNldCA9IHhPZmZzZXRPclZlY3RvcjtcclxuICAgICAgICAgICAgeU9mZnNldCA9IHlPZmZzZXRPclNwZWVkO1xyXG4gICAgICAgICAgICBzcGVlZCA9IHNwZWVkT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgTW92ZUJ5KHRoaXMuX2VudGl0eSwgeE9mZnNldCwgeU9mZnNldCwgc3BlZWQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBhdCB0aGUgc3BlZWRcclxuICAgICAqIHNwZWNpZmllZCAoaW4gcmFkaWFucyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXHJcbiAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICAgIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kXHJcbiAgICAgKiBAcGFyYW0gcm90YXRpb25UeXBlICBUaGUgW1tSb3RhdGlvblR5cGVdXSB0byB1c2UgZm9yIHRoaXMgcm90YXRpb25cclxuICAgICAqL1xyXG4gICAgcm90YXRlVG8oYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBSb3RhdGVUbyh0aGlzLl9lbnRpdHksIGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlIG9mZnNldCwgZnJvbSBpdCdzIGN1cnJlbnQgcm90YXRpb24gZ2l2ZW4gYSBjZXJ0YWluIHNwZWVkXHJcbiAgICAgKiBpbiByYWRpYW5zL3NlYyBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0XHJcbiAgICAgKiBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zT2Zmc2V0ICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm90YXRpb25cclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICAgICBUaGUgc3BlZWQgaW4gcmFkaWFucy9zZWMgdGhlIGFjdG9yIHNob3VsZCByb3RhdGUgYXRcclxuICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvbiwgZGVmYXVsdCBpcyBzaG9ydGVzdCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUJ5KGFuZ2xlUmFkaWFuc09mZnNldCwgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgUm90YXRlQnkodGhpcy5fZW50aXR5LCBhbmdsZVJhZGlhbnNPZmZzZXQsIHNwZWVkLCByb3RhdGlvblR5cGUpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNjYWxlVG8oc2l6ZVhPclZlY3Rvciwgc2l6ZVlPclNwZWVkLCBzcGVlZFhPclVuZGVmaW5lZCwgc3BlZWRZT3JVbmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgc2l6ZVggPSAxO1xyXG4gICAgICAgIGxldCBzaXplWSA9IDE7XHJcbiAgICAgICAgbGV0IHNwZWVkWCA9IDA7XHJcbiAgICAgICAgbGV0IHNwZWVkWSA9IDA7XHJcbiAgICAgICAgaWYgKHNpemVYT3JWZWN0b3IgaW5zdGFuY2VvZiBWZWN0b3IgJiYgc2l6ZVlPclNwZWVkIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHNpemVYID0gc2l6ZVhPclZlY3Rvci54O1xyXG4gICAgICAgICAgICBzaXplWSA9IHNpemVYT3JWZWN0b3IueTtcclxuICAgICAgICAgICAgc3BlZWRYID0gc2l6ZVlPclNwZWVkLng7XHJcbiAgICAgICAgICAgIHNwZWVkWSA9IHNpemVZT3JTcGVlZC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNpemVYT3JWZWN0b3IgPT09ICdudW1iZXInICYmIHR5cGVvZiBzaXplWU9yU3BlZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHNpemVYID0gc2l6ZVhPclZlY3RvcjtcclxuICAgICAgICAgICAgc2l6ZVkgPSBzaXplWU9yU3BlZWQ7XHJcbiAgICAgICAgICAgIHNwZWVkWCA9IHNwZWVkWE9yVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBzcGVlZFkgPSBzcGVlZFlPclVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBTY2FsZVRvKHRoaXMuX2VudGl0eSwgc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2NhbGVCeShzaXplT2Zmc2V0WE9yVmVjdG9yLCBzaXplT2Zmc2V0WU9yU3BlZWQsIHNwZWVkKSB7XHJcbiAgICAgICAgbGV0IHNpemVPZmZzZXRYID0gMTtcclxuICAgICAgICBsZXQgc2l6ZU9mZnNldFkgPSAxO1xyXG4gICAgICAgIGlmIChzaXplT2Zmc2V0WE9yVmVjdG9yIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHNpemVPZmZzZXRYID0gc2l6ZU9mZnNldFhPclZlY3Rvci54O1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0WSA9IHNpemVPZmZzZXRYT3JWZWN0b3IueTtcclxuICAgICAgICAgICAgc3BlZWQgPSBzaXplT2Zmc2V0WU9yU3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZU9mZnNldFhPclZlY3RvciA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNpemVPZmZzZXRZT3JTcGVlZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgc2l6ZU9mZnNldFggPSBzaXplT2Zmc2V0WE9yVmVjdG9yO1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0WSA9IHNpemVPZmZzZXRZT3JTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBTY2FsZUJ5KHRoaXMuX2VudGl0eSwgc2l6ZU9mZnNldFgsIHNpemVPZmZzZXRZLCBzcGVlZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yIHRvIGJsaW5rIChiZWNvbWUgdmlzaWJsZSBhbmQgbm90XHJcbiAgICAgKiB2aXNpYmxlKS4gT3B0aW9uYWxseSwgeW91IG1heSBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgYmxpbmtzLiBTcGVjaWZ5IHRoZSBhbW91bnQgb2YgdGltZVxyXG4gICAgICogdGhlIGFjdG9yIHNob3VsZCBiZSB2aXNpYmxlIHBlciBibGluaywgYW5kIHRoZSBhbW91bnQgb2YgdGltZSBub3QgdmlzaWJsZS5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIHRpbWVWaXNpYmxlICAgICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSB0aW1lTm90VmlzaWJsZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgbm90IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIG51bUJsaW5rcyAgICAgICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGJsaW5rXHJcbiAgICAgKi9cclxuICAgIGJsaW5rKHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzID0gMSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgQmxpbmsodGhpcy5fZW50aXR5LCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxyXG4gICAgICogdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGJ5IGEgc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgZW5kaW5nIG9wYWNpdHlcclxuICAgICAqIEBwYXJhbSB0aW1lICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBmYWRlIHRoZSBhY3RvciAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICovXHJcbiAgICBmYWRlKG9wYWNpdHksIHRpbWUpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IEZhZGUodGhpcy5fZW50aXR5LCBvcGFjaXR5LCB0aW1lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZGVsYXkgdGhlIG5leHQgYWN0aW9uIGZyb20gZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cclxuICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gdGltZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgcXVldWUgZnJvbSBleGVjdXRpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGRlbGF5KHRpbWUpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IERlbGF5KHRpbWUpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgYW4gYWN0aW9uIHRvIHRoZSBxdWV1ZSB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhY3RvciBmcm9tIHRoZVxyXG4gICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyAgQW55IGFjdGlvbnMgb24gdGhlXHJcbiAgICAgKiBhY3Rpb24gcXVldWUgYWZ0ZXIgdGhpcyBhY3Rpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRpZSgpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IERpZSh0aGlzLl9lbnRpdHkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBjYWxsIGFuIGFyYml0cmFyeSBtZXRob2QgYXMgdGhlIG5leHQgYWN0aW9uIGluIHRoZVxyXG4gICAgICogYWN0aW9uIHF1ZXVlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBleGVjdXRlIGNvZGUgaW4gYWZ0ZXIgYSBzcGVjaWZpY1xyXG4gICAgICogYWN0aW9uLCBpLmUgQW4gYWN0b3IgYXJyaXZlcyBhdCBhIGRlc3RpbmF0aW9uIGFmdGVyIHRyYXZlcnNpbmcgYSBwYXRoXHJcbiAgICAgKi9cclxuICAgIGNhbGxNZXRob2QobWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBDYWxsTWV0aG9kKG1ldGhvZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBhY3Rpb25zIGJ1aWx0IGluXHJcbiAgICAgKiB0aGUgYHJlcGVhdEJ1aWxkZXJgIGNhbGxiYWNrLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcclxuICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxyXG4gICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gTW92ZSB1cCBpbiBhIHppZy16YWcgYnkgcmVwZWF0ZWQgbW92ZUJ5J3NcclxuICAgICAqIGFjdG9yLmFjdGlvbnMucmVwZWF0KHJlcGVhdEN0eCA9PiB7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgxMCwgMCwgMTApO1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMCwgMTAsIDEwKTtcclxuICAgICAqIH0sIDUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcGVhdEJ1aWxkZXIgVGhlIGJ1aWxkZXIgdG8gc3BlY2lmeSB0aGUgcmVwZWF0YWJsZSBsaXN0IG9mIGFjdGlvbnNcclxuICAgICAqIEBwYXJhbSB0aW1lcyAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYWxsIHRoZSBwcmV2aW91cyBhY3Rpb25zIGluIHRoZSBhY3Rpb24gcXVldWUuIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb25zXHJcbiAgICAgKiB3aWxsIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdChyZXBlYXRCdWlsZGVyLCB0aW1lcykge1xyXG4gICAgICAgIGlmICghdGltZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRGb3JldmVyKHJlcGVhdEJ1aWxkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBSZXBlYXQodGhpcy5fZW50aXR5LCByZXBlYXRCdWlsZGVyLCB0aW1lcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBhY3Rpb25zIGJ1aWx0IGluXHJcbiAgICAgKiB0aGUgYHJlcGVhdEJ1aWxkZXJgIGNhbGxiYWNrLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcclxuICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxyXG4gICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gTW92ZSB1cCBpbiBhIHppZy16YWcgYnkgcmVwZWF0ZWQgbW92ZUJ5J3NcclxuICAgICAqIGFjdG9yLmFjdGlvbnMucmVwZWF0KHJlcGVhdEN0eCA9PiB7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgxMCwgMCwgMTApO1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMCwgMTAsIDEwKTtcclxuICAgICAqIH0sIDUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcGVhdEJ1aWxkZXIgVGhlIGJ1aWxkZXIgdG8gc3BlY2lmeSB0aGUgcmVwZWF0YWJsZSBsaXN0IG9mIGFjdGlvbnNcclxuICAgICAqL1xyXG4gICAgcmVwZWF0Rm9yZXZlcihyZXBlYXRCdWlsZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBSZXBlYXRGb3JldmVyKHRoaXMuX2VudGl0eSwgcmVwZWF0QnVpbGRlcikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBlbnRpdHkgdG8gZm9sbG93IGFub3RoZXIgYXQgYSBzcGVjaWZpZWQgZGlzdGFuY2VcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgICAgICAgICAgIFRoZSBlbnRpdHkgdG8gZm9sbG93XHJcbiAgICAgKiBAcGFyYW0gZm9sbG93RGlzdGFuY2UgIFRoZSBkaXN0YW5jZSB0byBtYWludGFpbiB3aGVuIGZvbGxvd2luZywgaWYgbm90IHNwZWNpZmllZCB0aGUgYWN0b3Igd2lsbCBmb2xsb3cgYXQgdGhlIGN1cnJlbnQgZGlzdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGZvbGxvdyhlbnRpdHksIGZvbGxvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKGZvbGxvd0Rpc3RhbmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBGb2xsb3codGhpcy5fZW50aXR5LCBlbnRpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRm9sbG93KHRoaXMuX2VudGl0eSwgZW50aXR5LCBmb2xsb3dEaXN0YW5jZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgZW50aXR5IHRvIG1vdmUgdG93YXJkcyBhbm90aGVyIHVudGlsIHRoZXlcclxuICAgICAqIGNvbGxpZGUgXCJtZWV0XCIgYXQgYSBzcGVjaWZpZWQgc3BlZWQuXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5ICBUaGUgZW50aXR5IHRvIG1lZXRcclxuICAgICAqIEBwYXJhbSBzcGVlZCAgVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmUsIGlmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBtYXRjaCB0aGUgc3BlZWQgb2YgdGhlIG90aGVyIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIG1lZXQoZW50aXR5LCBzcGVlZCkge1xyXG4gICAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgTWVldCh0aGlzLl9lbnRpdHksIGVudGl0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBNZWV0KHRoaXMuX2VudGl0eSwgZW50aXR5LCBzcGVlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcclxuICAgICAqIGlzIGZpbmlzaGVkLlxyXG4gICAgICovXHJcbiAgICB0b1Byb21pc2UoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgQ2FsbE1ldGhvZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uc0NvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcbjtcclxuY2xhc3MgQWN0aW9uc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5hY3Rpb25zJztcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtUcmFuc2Zvcm1Db21wb25lbnQsIE1vdGlvbkNvbXBvbmVudF07XHJcbiAgICB9XHJcbiAgICBvbkFkZChlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9jdHggPSBuZXcgQWN0aW9uQ29udGV4dChlbnRpdHkpO1xyXG4gICAgfVxyXG4gICAgb25SZW1vdmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgYWN0aW9uIHF1ZXVlXHJcbiAgICAgKiBAcmV0dXJucyBhY3Rpb24gcXVldWVcclxuICAgICAqL1xyXG4gICAgZ2V0UXVldWUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9jdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRRdWV1ZSgpO1xyXG4gICAgfVxyXG4gICAgcnVuQWN0aW9uKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fY3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnVuQWN0aW9uKGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGFjdGlvbiBjb250ZXh0LCBwZXJmb3JtaW5nIGFjdGlvbiBhbmQgbW92aW5nIHRocm91Z2ggdGhlIGludGVybmFsIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gZWxhcHNlZE1zXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbGFwc2VkTXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2N0eCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZShlbGFwc2VkTXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQWN0aW9ucygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5fY3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICB9XHJcbiAgICBlYXNlVG8oLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZWFzZVRvLmFwcGx5KHRoaXMuX2N0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlYXNlQnkoLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZWFzZUJ5LmFwcGx5KHRoaXMuX2N0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBtb3ZlVG8oeE9yUG9zLCB5T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgubW92ZVRvLmFwcGx5KHRoaXMuX2N0eCwgW3hPclBvcywgeU9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWRdKTtcclxuICAgIH1cclxuICAgIG1vdmVCeSh4T2Zmc2V0T3JWZWN0b3IsIHlPZmZzZXRPclNwZWVkLCBzcGVlZE9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5tb3ZlQnkuYXBwbHkodGhpcy5fY3R4LCBbeE9mZnNldE9yVmVjdG9yLCB5T2Zmc2V0T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZF0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxyXG4gICAgICogc3BlY2lmaWVkIChpbiByYWRpYW5zIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBpbiByYWRpYW5zIHBlciBzZWNvbmRcclxuICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICovXHJcbiAgICByb3RhdGVUbyhhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnJvdGF0ZVRvKGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgb2Zmc2V0LCBmcm9tIGl0J3MgY3VycmVudCByb3RhdGlvbiBnaXZlbiBhIGNlcnRhaW4gc3BlZWRcclxuICAgICAqIGluIHJhZGlhbnMvc2VjIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcclxuICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnNPZmZzZXQgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFucyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgIFRoZSBzcGVlZCBpbiByYWRpYW5zL3NlYyB0aGUgYWN0b3Igc2hvdWxkIHJvdGF0ZSBhdFxyXG4gICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uLCBkZWZhdWx0IGlzIHNob3J0ZXN0IHBhdGhcclxuICAgICAqL1xyXG4gICAgcm90YXRlQnkoYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5yb3RhdGVCeShhbmdsZVJhZGlhbnNPZmZzZXQsIHNwZWVkLCByb3RhdGlvblR5cGUpO1xyXG4gICAgfVxyXG4gICAgc2NhbGVUbyhzaXplWE9yVmVjdG9yLCBzaXplWU9yU3BlZWQsIHNwZWVkWE9yVW5kZWZpbmVkLCBzcGVlZFlPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguc2NhbGVUby5hcHBseSh0aGlzLl9jdHgsIFtzaXplWE9yVmVjdG9yLCBzaXplWU9yU3BlZWQsIHNwZWVkWE9yVW5kZWZpbmVkLCBzcGVlZFlPclVuZGVmaW5lZF0pO1xyXG4gICAgfVxyXG4gICAgc2NhbGVCeShzaXplT2Zmc2V0WE9yVmVjdG9yLCBzaXplT2Zmc2V0WU9yU3BlZWQsIHNwZWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5zY2FsZUJ5LmFwcGx5KHRoaXMuX2N0eCwgW3NpemVPZmZzZXRYT3JWZWN0b3IsIHNpemVPZmZzZXRZT3JTcGVlZCwgc3BlZWRdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxyXG4gICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcclxuICAgICAqIHRoZSBhY3RvciBzaG91bGQgYmUgdmlzaWJsZSBwZXIgYmxpbmssIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgbm90IHZpc2libGUuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gdGltZU5vdFZpc2libGUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IG5vdCB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBudW1CbGlua3MgICAgICAgVGhlIG51bWJlciBvZiB0aW1lcyB0byBibGlua1xyXG4gICAgICovXHJcbiAgICBibGluayh0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguYmxpbmsodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxyXG4gICAgICogdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGJ5IGEgc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgZW5kaW5nIG9wYWNpdHlcclxuICAgICAqIEBwYXJhbSB0aW1lICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBmYWRlIHRoZSBhY3RvciAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICovXHJcbiAgICBmYWRlKG9wYWNpdHksIHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmZhZGUob3BhY2l0eSwgdGltZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZGVsYXkgdGhlIG5leHQgYWN0aW9uIGZyb20gZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cclxuICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gdGltZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgcXVldWUgZnJvbSBleGVjdXRpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGRlbGF5KHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmRlbGF5KHRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXHJcbiAgICAgKiBzY2VuZSBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgaXRzIHByZXZpb3VzICBBbnkgYWN0aW9ucyBvbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZSBhZnRlciB0aGlzIGFjdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgZGllKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZGllKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBjb2RlIGluIGFmdGVyIGEgc3BlY2lmaWNcclxuICAgICAqIGFjdGlvbiwgaS5lIEFuIGFjdG9yIGFycml2ZXMgYXQgYSBkZXN0aW5hdGlvbiBhZnRlciB0cmF2ZXJzaW5nIGEgcGF0aFxyXG4gICAgICovXHJcbiAgICBjYWxsTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguY2FsbE1ldGhvZChtZXRob2QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBhY3Rpb25zIGJ1aWx0IGluXHJcbiAgICAgKiB0aGUgYHJlcGVhdEJ1aWxkZXJgIGNhbGxiYWNrLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcclxuICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxyXG4gICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gTW92ZSB1cCBpbiBhIHppZy16YWcgYnkgcmVwZWF0ZWQgbW92ZUJ5J3NcclxuICAgICAqIGFjdG9yLmFjdGlvbnMucmVwZWF0KHJlcGVhdEN0eCA9PiB7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgxMCwgMCwgMTApO1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMCwgMTAsIDEwKTtcclxuICAgICAqIH0sIDUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcGVhdEJ1aWxkZXIgVGhlIGJ1aWxkZXIgdG8gc3BlY2lmeSB0aGUgcmVwZWF0YWJsZSBsaXN0IG9mIGFjdGlvbnNcclxuICAgICAqIEBwYXJhbSB0aW1lcyAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYWxsIHRoZSBwcmV2aW91cyBhY3Rpb25zIGluIHRoZSBhY3Rpb24gcXVldWUuIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb25zXHJcbiAgICAgKiB3aWxsIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdChyZXBlYXRCdWlsZGVyLCB0aW1lcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgucmVwZWF0KHJlcGVhdEJ1aWxkZXIsIHRpbWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgYWN0aW9ucyBidWlsdCBpblxyXG4gICAgICogdGhlIGByZXBlYXRCdWlsZGVyYCBjYWxsYmFjay4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE1vdmUgdXAgaW4gYSB6aWctemFnIGJ5IHJlcGVhdGVkIG1vdmVCeSdzXHJcbiAgICAgKiBhY3Rvci5hY3Rpb25zLnJlcGVhdChyZXBlYXRDdHggPT4ge1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMTAsIDAsIDEwKTtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDAsIDEwLCAxMCk7XHJcbiAgICAgKiB9LCA1KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXBlYXRCdWlsZGVyIFRoZSBidWlsZGVyIHRvIHNwZWNpZnkgdGhlIHJlcGVhdGFibGUgbGlzdCBvZiBhY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdEZvcmV2ZXIocmVwZWF0QnVpbGRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgucmVwZWF0Rm9yZXZlcihyZXBlYXRCdWlsZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgZW50aXR5IHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5ICAgICAgICAgICBUaGUgZW50aXR5IHRvIGZvbGxvd1xyXG4gICAgICogQHBhcmFtIGZvbGxvd0Rpc3RhbmNlICBUaGUgZGlzdGFuY2UgdG8gbWFpbnRhaW4gd2hlbiBmb2xsb3dpbmcsIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFjdG9yIHdpbGwgZm9sbG93IGF0IHRoZSBjdXJyZW50IGRpc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmb2xsb3coZW50aXR5LCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZm9sbG93KGVudGl0eSwgZm9sbG93RGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBlbnRpdHkgdG8gbW92ZSB0b3dhcmRzIGFub3RoZXIgdW50aWwgdGhleVxyXG4gICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cclxuICAgICAqIEBwYXJhbSBlbnRpdHkgIFRoZSBlbnRpdHkgdG8gbWVldFxyXG4gICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcclxuICAgICAqL1xyXG4gICAgbWVldChlbnRpdHksIHNwZWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5tZWV0KGVudGl0eSwgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xyXG4gICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgKi9cclxuICAgIHRvUHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRvUHJvbWlzZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvRm9udENvbW1vbi50c1xuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZm9udCBzaXplIHVuaXRzXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXNpemVcclxuICovXHJcbnZhciBGb250VW5pdDtcclxuKGZ1bmN0aW9uIChGb250VW5pdCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbSBpcyBhIHNjYWxhYmxlIHVuaXQsIDEgZW0gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZm9udCBzaXplIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIHBhcmVudCBlbGVtZW50cyBjYW4gZWZmZWN0IGVtIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBGb250VW5pdFtcIkVtXCJdID0gXCJlbVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW0gaXMgc2ltaWxhciB0byB0aGUgRW0sIGl0IGlzIGEgc2NhbGFibGUgdW5pdC4gMSByZW0gaXMgZXF1YWwgdG8gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgcm9vdCBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUmVtXCJdID0gXCJyZW1cIjtcclxuICAgIC8qKlxyXG4gICAgICogUGl4ZWwgaXMgYSB1bml0IG9mIGxlbmd0aCBpbiBzY3JlZW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUHhcIl0gPSBcInB4XCI7XHJcbiAgICAvKipcclxuICAgICAqIFBvaW50IGlzIGEgcGh5c2ljYWwgdW5pdCBsZW5ndGggKDEvNzIgb2YgYW4gaW5jaClcclxuICAgICAqL1xyXG4gICAgRm9udFVuaXRbXCJQdFwiXSA9IFwicHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGVyY2VudCBpcyBhIHNjYWxhYmxlIHVuaXQgc2ltaWxhciB0byBFbSwgdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGUgRW0gdW5pdHMgc2NhbGUgZmFzdGVyIHdoZW4gVGV4dC1TaXplIHN0dWZmXHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUGVyY2VudFwiXSA9IFwiJVwiO1xyXG59KShGb250VW5pdCB8fCAoRm9udFVuaXQgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50c1xyXG4gKi9cclxudmFyIFRleHRBbGlnbjtcclxuKGZ1bmN0aW9uIChUZXh0QWxpZ24pIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxyXG4gICAgICovXHJcbiAgICBUZXh0QWxpZ25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGlzIHJpZ2h0LWFsaWduZWQuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBpcyBjZW50ZXJlZC5cclxuICAgICAqL1xyXG4gICAgVGV4dEFsaWduW1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAqIHJpZ2h0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIlN0YXJ0XCJdID0gXCJzdGFydFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgZW5kIG9mIHRoZSBsaW5lIChyaWdodC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsXHJcbiAgICAgKiBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIkVuZFwiXSA9IFwiZW5kXCI7XHJcbn0pKFRleHRBbGlnbiB8fCAoVGV4dEFsaWduID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgYmFzZWxpbmUgdGV4dCBhbGlnbm1lbnRzXHJcbiAqL1xyXG52YXIgQmFzZUFsaWduO1xyXG4oZnVuY3Rpb24gKEJhc2VBbGlnbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgdG9wIG9mIHRoZSBlbSBzcXVhcmUuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIlRvcFwiXSA9IFwidG9wXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBoYW5naW5nIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGwgYWN0IGxpa2VcclxuICAgICAqIGFscGhhYmV0aWMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkhhbmdpbmdcIl0gPSBcImhhbmdpbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG1pZGRsZSBvZiB0aGUgZW0gc3F1YXJlLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJNaWRkbGVcIl0gPSBcIm1pZGRsZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbm9ybWFsIGFscGhhYmV0aWMgYmFzZWxpbmUuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkFscGhhYmV0aWNcIl0gPSBcImFscGhhYmV0aWNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lOyB0aGlzIGlzIHRoZSBib3R0b20gb2ZcclxuICAgICAqIHRoZSBib2R5IG9mIHRoZSBjaGFyYWN0ZXJzLCBpZiB0aGUgbWFpbiBib2R5IG9mIGNoYXJhY3RlcnMgcHJvdHJ1ZGVzXHJcbiAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcclxuICAgICAqIGFjdCBsaWtlIGFscGhhYmV0aWMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIklkZW9ncmFwaGljXCJdID0gXCJpZGVvZ3JhcGhpY1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBib3VuZGluZyBib3guICBUaGlzIGRpZmZlcnNcclxuICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXHJcbiAgICAgKiBkb2Vzbid0IGNvbnNpZGVyIGRlc2NlbmRlcnMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XHJcbn0pKEJhc2VBbGlnbiB8fCAoQmFzZUFsaWduID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgcG9zc2libGUgZm9udCBzdHlsZXNcclxuICovXHJcbnZhciBGb250U3R5bGU7XHJcbihmdW5jdGlvbiAoRm9udFN0eWxlKSB7XHJcbiAgICBGb250U3R5bGVbXCJOb3JtYWxcIl0gPSBcIm5vcm1hbFwiO1xyXG4gICAgRm9udFN0eWxlW1wiSXRhbGljXCJdID0gXCJpdGFsaWNcIjtcclxuICAgIEZvbnRTdHlsZVtcIk9ibGlxdWVcIl0gPSBcIm9ibGlxdWVcIjtcclxufSkoRm9udFN0eWxlIHx8IChGb250U3R5bGUgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIHRleHQgZGlyZWN0aW9uLCB1c2VmdWwgZm9yIG90aGVyIGxhbmd1YWdlcywgb3Igd3JpdGluZyB0ZXh0IGluIHJldmVyc2VcclxuICovXHJcbnZhciBEaXJlY3Rpb247XHJcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XHJcbiAgICBEaXJlY3Rpb25bXCJMZWZ0VG9SaWdodFwiXSA9IFwibHRyXCI7XHJcbiAgICBEaXJlY3Rpb25bXCJSaWdodFRvTGVmdFwiXSA9IFwicnRsXCI7XHJcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Gb250LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBzeXN0ZW0gb3Igd2ViIGZvbnQgaW4gRXhjYWxpYnVyXHJcbiAqXHJcbiAqIElmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB0aGUgc3lzdGVtIHNhbnMtc2VyaWYgMTAgcGl4ZWwgaXMgdXNlZFxyXG4gKlxyXG4gKiBJZiBsb2FkaW5nIGEgY3VzdG9tIHdlYiBmb250IGJlIHN1cmUgdG8gaGF2ZSB0aGUgZm9udCBsb2FkZWQgYmVmb3JlIHlvdSB1c2UgaXQgaHR0cHM6Ly9lcmlrb25hcmhlaW0uY29tL3Bvc3RzL2RvbnQtdGVzdC1mb250cy9cclxuICovXHJcbmNsYXNzIEZvbnQgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTsgLy8gPC0gR3JhcGhpY3MgcHJvcGVydGllc1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgZm9udCBmaWx0ZXJpbmcgbW9kZSwgYnkgZGVmYXVsdCBzZXQgdG8gW1tJbWFnZUZpbHRlcmluZy5CbGVuZGVkXV0gcmVnYXJkbGVzcyBvZiB0aGUgZW5naW5lIGRlZmF1bHQgc21vb3RoaW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiB5b3UgaGF2ZSBhIHBpeGVsIHN0eWxlIGZvbnQgdGhhdCBtYXkgYmUgYSByZWFzb24gdG8gc3dpdGNoIHRoaXMgdG8gW1tJbWFnZUZpbHRlcmluZy5QaXhlbF1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBJbWFnZUZpbHRlcmluZy5CbGVuZGVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvbnQgcXVhbGl0eSBkZXRlcm1pbmVzIHRoZSBzaXplIG9mIHRoZSB1bmRlcmx5aW5nIHJhc3RlciB0ZXh0LCBoaWdoZXIgcXVhbGl0eSBtZWFucyBsZXNzIGphZ2dlZCBlZGdlcy5cclxuICAgICAgICAgKiBJZiBxdWFsaXR5IGlzIHNldCB0byAxLCB0aGVuIGp1c3QgZW5vdWdoIHJhc3RlciBiaXRtYXAgaXMgZ2VuZXJhdGVkIHRvIHJlbmRlciB0aGUgdGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFlvdSBjYW4gdGhpbmsgb2YgcXVhbGl0eSBhcyBob3cgem9vbWVkIGluIHRvIHRoZSB0ZXh0IHlvdSBjYW4gZ2V0IGJlZm9yZSBzZWVpbmcgamFnZ2VkIGVkZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogKERlZmF1bHQgMilcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1YWxpdHkgPSAyO1xyXG4gICAgICAgIC8vIFJhc3RlciBwcm9wZXJ0aWVzIGZvciBmb250c1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDI7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBDb2xvci5CbGFjaztcclxuICAgICAgICB0aGlzLmZhbWlseSA9ICdzYW5zLXNlcmlmJztcclxuICAgICAgICB0aGlzLnN0eWxlID0gRm9udFN0eWxlLk5vcm1hbDtcclxuICAgICAgICB0aGlzLmJvbGQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSBGb250VW5pdC5QeDtcclxuICAgICAgICB0aGlzLnRleHRBbGlnbiA9IFRleHRBbGlnbi5MZWZ0O1xyXG4gICAgICAgIHRoaXMuYmFzZUFsaWduID0gQmFzZUFsaWduLkFscGhhYmV0aWM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uTGVmdFRvUmlnaHQ7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMTA7XHJcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RleHRCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICB0aGlzLl9jYWNoZWRUZXh0TWVhc3VyZW1lbnQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwVG9UZXh0TWVhc3VyZW1lbnQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dFRvQml0bWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2JpdG1hcFVzYWdlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RleHRGcmFnbWVudHMgPSBbXTtcclxuICAgICAgICAvLyBSYXN0ZXIgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNtb290aGluZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zbW9vdGhpbmc7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZGRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMucGFkZGluZztcclxuICAgICAgICB0aGlzLmNvbG9yID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3Ryb2tlQ29sb3IpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuc3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaCA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW5lRGFzaCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5saW5lRGFzaDtcclxuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW5lV2lkdGgpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyaW5nID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlcmluZykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5maWx0ZXJpbmc7XHJcbiAgICAgICAgLy8gRm9udCBzcGVjaWZpYyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5mYW1pbHkgPSAoX2ggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFtaWx5KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB0aGlzLmZhbWlseTtcclxuICAgICAgICB0aGlzLnN0eWxlID0gKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiB0aGlzLnN0eWxlO1xyXG4gICAgICAgIHRoaXMuYm9sZCA9IChfayA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib2xkKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiB0aGlzLmJvbGQ7XHJcbiAgICAgICAgdGhpcy5zaXplID0gKF9sID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHRoaXMuc2l6ZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSAoX20gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudW5pdCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogdGhpcy51bml0O1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gKF9vID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleHRBbGlnbikgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogdGhpcy50ZXh0QWxpZ247XHJcbiAgICAgICAgdGhpcy5iYXNlQWxpZ24gPSAoX3AgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZUFsaWduKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiB0aGlzLmJhc2VBbGlnbjtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChfcSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXJlY3Rpb24pICE9PSBudWxsICYmIF9xICE9PSB2b2lkIDAgPyBfcSA6IHRoaXMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IChfciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWFsaXR5KSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiB0aGlzLnF1YWxpdHk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaGFkb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuYmx1ciA9IChfcyA9IG9wdGlvbnMuc2hhZG93LmJsdXIpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IHRoaXMuc2hhZG93LmJsdXI7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Lm9mZnNldCA9IChfdCA9IG9wdGlvbnMuc2hhZG93Lm9mZnNldCkgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdGhpcy5zaGFkb3cub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jb2xvciA9IChfdSA9IG9wdGlvbnMuc2hhZG93LmNvbG9yKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0aGlzLnNoYWRvdy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZvbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSxcclxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxyXG4gICAgICAgICAgICB1bml0OiB0aGlzLnVuaXQsXHJcbiAgICAgICAgICAgIGZhbWlseTogdGhpcy5mYW1pbHksXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxyXG4gICAgICAgICAgICBib2xkOiB0aGlzLmJvbGQsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgIGJhc2VBbGlnbjogdGhpcy5iYXNlQWxpZ24sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIHNoYWRvdzogdGhpcy5zaGFkb3dcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IHRoaXMuc2hhZG93LmJsdXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLnNoYWRvdy5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuc2hhZG93LmNvbG9yXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBmb250U3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLnN0eWxlfSAke3RoaXMuYm9sZCA/ICdib2xkJyA6ICcnfSAke3RoaXMuc2l6ZX0ke3RoaXMudW5pdH0gJHt0aGlzLmZhbWlseX1gO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0Qm91bmRzO1xyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShfZXgsIF94LCBfeSkge1xyXG4gICAgICAgIC8vIFRPRE8gd2VpcmQgdmVzdGlnaWFsIGRyYXdpbWFnZVxyXG4gICAgfVxyXG4gICAgX3JvdGF0ZShleCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBUT0RPIHRoaXMgbmVlZHMgdG8gY2hhbmdlIGRlcGVuZGluZyBvbiB0aGUgYm91bmRpbmcgYm94Li4uXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gKF9hID0gdGhpcy5vcmlnaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX3RleHRCb3VuZHMuY2VudGVyO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZShvcmlnaW4ueCwgb3JpZ2luLnkpO1xyXG4gICAgICAgIGV4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICBleC50cmFuc2xhdGUoLW9yaWdpbi54LCAtb3JpZ2luLnkpO1xyXG4gICAgfVxyXG4gICAgX2ZsaXAoZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBleC50cmFuc2xhdGUodGhpcy5fdGV4dEJvdW5kcy53aWR0aCAvIHRoaXMuc2NhbGUueCwgMCk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSgwLCAtdGhpcy5fdGV4dEJvdW5kcy5oZWlnaHQgLyAyIC8gdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgZXguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEJvdW5kaW5nQm94IHRoYXQgaXMgdGhlIHRvdGFsIHNpemUgb2YgdGhlIHRleHQgaW5jbHVkaW5nIG11bHRpcGxlIGxpbmVzXHJcbiAgICAgKlxyXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSBhbnkgcGFkZGluZyBvciBhZGp1c3RtZW50XHJcbiAgICAgKiBAcGFyYW0gdGV4dFxyXG4gICAgICogQHJldHVybnMgQm91bmRpbmdCb3hcclxuICAgICAqL1xyXG4gICAgbWVhc3VyZVRleHQodGV4dCkge1xyXG4gICAgICAgIGxldCBtZWFzdXJlbWVudERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZFRleHRNZWFzdXJlbWVudC5nZXQodGV4dCk7XHJcbiAgICAgICAgaWYgKCFjYWNoZWQpIHtcclxuICAgICAgICAgICAgbWVhc3VyZW1lbnREaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJhc3RlclByb3BzID0gdGhpcy5fZ2V0UmFzdGVyUHJvcGVydGllc0hhc2goKTtcclxuICAgICAgICBpZiAoIWNhY2hlZCB8fCByYXN0ZXJQcm9wcyAhPT0gY2FjaGVkLnJhc3RlclByb3BzKSB7XHJcbiAgICAgICAgICAgIG1lYXN1cmVtZW50RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVhc3VyZW1lbnREaXJ0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhXaWR0aExpbmUgPSBsaW5lcy5yZWR1Y2UoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRUZXh0Qml0bWFwKHRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvbnQoY3R4KTsgLy8gZm9udCBtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRleHQgdG8gbWVhc3VyZSBpdFxyXG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KG1heFdpZHRoTGluZSk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gbGluZWhlaWdodCBtYWtlcyB0aGUgdGV4dCBib3VuZHMgd29ua3lcclxuICAgICAgICAgICAgY29uc3QgbGluZUFkanVzdGVkSGVpZ2h0ID0gdGV4dEhlaWdodCAqIGxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGV4dEhlaWdodCA9IGxpbmVBZGp1c3RlZEhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgYm90dG9tQm91bmRzID0gbGluZUFkanVzdGVkSGVpZ2h0IC0gTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gMDtcclxuICAgICAgICAgICAgLy8gdGhpcy5fY2FjaGVkVGV4dCA9IHRleHQ7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX2NhY2hlZFJhc3RlclByb3BzID0gcmFzdGVyUHJvcHM7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX21lYXN1cmVtZW50RGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbWVhc3VyZW1lbnQgPSBuZXcgQm91bmRpbmdCb3goe1xyXG4gICAgICAgICAgICAgICAgbGVmdDogeCAtIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSAtIHRoaXMucGFkZGluZyxcclxuICAgICAgICAgICAgICAgIHRvcDogeSAtIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQpIC0gdGhpcy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiB5ICsgYm90dG9tQm91bmRzICsgdGhpcy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHggKyBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQpICsgdGhpcy5wYWRkaW5nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYWNoZWQgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgcmFzdGVyUHJvcHMsXHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlbWVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRUZXh0TWVhc3VyZW1lbnQuc2V0KHRleHQsIGNhY2hlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpdG1hcFRvVGV4dE1lYXN1cmVtZW50LnNldChjdHgsIGNhY2hlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQubWVhc3VyZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkLm1lYXN1cmVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXREaW1lbnNpb24odGV4dEJvdW5kcywgYml0bWFwKSB7XHJcbiAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2xlYXJzIHRoZSBjb250ZXh0IHByb3BlcnRpZXNcclxuICAgICAgICAvLyBXZSBkb3VibGUgdGhlIGJpdG1hcCB3aWR0aCB0byBhY2NvdW50IGZvciBhbGwgcG9zc2libGUgYWxpZ25tZW50XHJcbiAgICAgICAgLy8gV2Ugc2NhbGUgYnkgXCJxdWFsaXR5XCIgc28gd2UgcmVuZGVyIHRleHQgd2l0aG91dCBqYWdnaWVzXHJcbiAgICAgICAgYml0bWFwLmNhbnZhcy53aWR0aCA9ICh0ZXh0Qm91bmRzLndpZHRoICsgdGhpcy5wYWRkaW5nICogMikgKiAyICogdGhpcy5xdWFsaXR5O1xyXG4gICAgICAgIGJpdG1hcC5jYW52YXMuaGVpZ2h0ID0gKHRleHRCb3VuZHMuaGVpZ2h0ICsgdGhpcy5wYWRkaW5nICogMikgKiAyICogdGhpcy5xdWFsaXR5O1xyXG4gICAgfVxyXG4gICAgX3Bvc3REcmF3KGV4KSB7XHJcbiAgICAgICAgZXgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBuZWVkIHRvIGlkZW50aWZ5IGJpdG1hcHMgd2l0aCBtb3JlIHRoYW4ganVzdCB0aGUgdGV4dCBjb250ZW50XHJcbiAgICAgKlxyXG4gICAgICogQW55IHByb3BlcnRpZXMgdGhhdCBjYW4gY2hhbmdlIHRoZSByZW5kZXJpbmcgb2YgdGhlIHRleHRcclxuICAgICAqL1xyXG4gICAgX2dldFJhc3RlclByb3BlcnRpZXNIYXNoKGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBoYXNoID0gJ19faGFzaGNvZGVfXycgK1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRTdHJpbmcgK1xyXG4gICAgICAgICAgICB0aGlzLnNob3dEZWJ1ZyArXHJcbiAgICAgICAgICAgIHRoaXMudGV4dEFsaWduICtcclxuICAgICAgICAgICAgdGhpcy5iYXNlQWxpZ24gK1xyXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiArXHJcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuc2hhZG93KSArXHJcbiAgICAgICAgICAgICh0aGlzLnBhZGRpbmcudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNtb290aGluZy50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZVdpZHRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lRGFzaC50b1N0cmluZygpICtcclxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgK1xyXG4gICAgICAgICAgICAgICAgKGNvbG9yID8gY29sb3IudG9TdHJpbmcoKSA6IChfYiA9IHRoaXMuY29sb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKS50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICAgIF9hcHBseVJhc3RlclByb3BlcnRpZXMoY3R4LCBjb2xvcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wYWRkaW5nLCB0aGlzLnBhZGRpbmcpO1xyXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0aGlzLnNtb290aGluZztcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKChfYSA9IHRoaXMubGluZURhc2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5nZXRMaW5lRGFzaCgpKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAoX2IgPSB0aGlzLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3IgPyBjb2xvci50b1N0cmluZygpIDogKF9jID0gdGhpcy5jb2xvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHlGb250KGN0eCkge1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wYWRkaW5nICsgY3R4LmNhbnZhcy53aWR0aCAvIDIsIHRoaXMucGFkZGluZyArIGN0eC5jYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMucXVhbGl0eSwgdGhpcy5xdWFsaXR5KTtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuYmFzZUFsaWduO1xyXG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250U3RyaW5nO1xyXG4gICAgICAgIGN0eC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5zaGFkb3cpIHtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3cuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyO1xyXG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldC54O1xyXG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93Lm9mZnNldC55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3VGV4dChjdHgsIHRleHQsIGNvbG9yT3ZlcnJpZGUsIGxpbmVIZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UmFzdGVyUHJvcGVydGllcyhjdHgsIGNvbG9yT3ZlcnJpZGUpO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5Rm9udChjdHgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIDAsIGkgKiBsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgMCwgaSAqIGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNob3dEZWJ1Zykge1xyXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmVcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgbGluZShjdHgsIENvbG9yLlJlZCwgLWN0eC5jYW52YXMud2lkdGggLyAyLCAwLCBjdHguY2FudmFzLndpZHRoIC8gMiwgMCwgMik7XHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgbGluZShjdHgsIENvbG9yLlJlZCwgMCwgLWN0eC5jYW52YXMuaGVpZ2h0IC8gMiwgMCwgY3R4LmNhbnZhcy5oZWlnaHQgLyAyLCAyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0VGV4dEJpdG1hcCh0ZXh0LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IHRleHRBbmRIYXNoID0gdGV4dCArIHRoaXMuX2dldFJhc3RlclByb3BlcnRpZXNIYXNoKGNvbG9yKTtcclxuICAgICAgICBjb25zdCBiaXRtYXAgPSB0aGlzLl90ZXh0VG9CaXRtYXAuZ2V0KHRleHRBbmRIYXNoKTtcclxuICAgICAgICBpZiAoYml0bWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaXRtYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuX3RleHRUb0JpdG1hcC5zZXQodGV4dEFuZEhhc2gsIGN0eCk7XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxuICAgIF9zcGxpdFRleHRCaXRtYXAoYml0bWFwKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dEltYWdlcyA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50WCA9IDA7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRZID0gMDtcclxuICAgICAgICAvLyA0ayBpcyB0aGUgbWF4IGZvciBtb2JpbGUgZGV2aWNlc1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oNDA5NiwgYml0bWFwLmNhbnZhcy53aWR0aCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oNDA5NiwgYml0bWFwLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIC8vIFNwbGl0cyB0aGUgb3JpZ2luYWwgYml0bWFwIGludG8gNGsgbWF4IGNodW5rc1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50WCA8IGJpdG1hcC5jYW52YXMud2lkdGgpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRZIDwgYml0bWFwLmNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgYml0bWFwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBjdXJyZW50IHNsaWNlIHRvIG5ldyBiaXRtYXAgaW4gPCA0ayBjaHVua3NcclxuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLmNhbnZhcywgY3VycmVudFgsIGN1cnJlbnRZLCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRleHRJbWFnZXMucHVzaCh7IHg6IGN1cnJlbnRYLCB5OiBjdXJyZW50WSwgY2FudmFzIH0pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFkgKz0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRYICs9IHdpZHRoO1xyXG4gICAgICAgICAgICBjdXJyZW50WSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0SW1hZ2VzO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKGV4LCB0ZXh0LCBjb2xvck92ZXJyaWRlLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoZWNrQW5kQ2xlYXJDYWNoZSgpO1xyXG4gICAgICAgIC8vIEdldCBiaXRtYXAgZm9yIHJhc3RlcmluZyB0ZXh0LCB0aGlzIGlzIGNhY2hlZCBieSByYXN0ZXIgcHJvcGVydGllc1xyXG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IHRoaXMuX2dldFRleHRCaXRtYXAodGV4dCwgY29sb3JPdmVycmlkZSk7XHJcbiAgICAgICAgY29uc3QgaXNOZXdCaXRtYXAgPSAhdGhpcy5fYml0bWFwVXNhZ2UuZ2V0KGJpdG1hcCk7XHJcbiAgICAgICAgLy8gQm91bmRzIG9mIHRoZSB0ZXh0XHJcbiAgICAgICAgdGhpcy5fdGV4dEJvdW5kcyA9IHRoaXMubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgaWYgKGlzTmV3Qml0bWFwKSB7XHJcbiAgICAgICAgICAgIC8vIFNldHRpbmcgZGltZW5zaW9uIGlzIGV4cGVuc2l2ZSBiZWNhdXNlIGl0IGludmFsaWRhdGVzIHRoZSBiaXRtYXBcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGltZW5zaW9uKHRoaXMuX3RleHRCb3VuZHMsIGJpdG1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGx5IGFmZmluZSB0cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICB0aGlzLl9wcmVEcmF3KGV4LCB4LCB5KTtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLl90ZXh0Qm91bmRzLmhlaWdodCAvIGxpbmVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaXNOZXdCaXRtYXApIHtcclxuICAgICAgICAgICAgLy8gZHJhd3MgdGhlIHRleHQgdG8gdGhlIGJpdG1hcFxyXG4gICAgICAgICAgICB0aGlzLl9kcmF3VGV4dChiaXRtYXAsIHRleHQsIGNvbG9yT3ZlcnJpZGUsIGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBhbnkgZXhpc3RpbmcgZnJhZ21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZyBvZiB0aGlzLl90ZXh0RnJhZ21lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBUZXh0dXJlTG9hZGVyW1wiZGVsZXRlXCJdKGZyYWcuY2FudmFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90ZXh0RnJhZ21lbnRzID0gdGhpcy5fc3BsaXRUZXh0Qml0bWFwKGJpdG1hcCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZyBvZiB0aGlzLl90ZXh0RnJhZ21lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBUZXh0dXJlTG9hZGVyLmxvYWQoZnJhZy5jYW52YXMsIHRoaXMuZmlsdGVyaW5nLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkcmF3cyB0aGUgYml0bWFwIGZyYWdtZW50cyB0byBleGNhbGlidXIgZ3JhcGhpY3MgY29udGV4dFxyXG4gICAgICAgIGZvciAoY29uc3QgZnJhZyBvZiB0aGlzLl90ZXh0RnJhZ21lbnRzKSB7XHJcbiAgICAgICAgICAgIGV4LmRyYXdJbWFnZShmcmFnLmNhbnZhcywgMCwgMCwgZnJhZy5jYW52YXMud2lkdGgsIGZyYWcuY2FudmFzLmhlaWdodCwgZnJhZy54IC8gdGhpcy5xdWFsaXR5ICsgeCAtIGJpdG1hcC5jYW52YXMud2lkdGggLyB0aGlzLnF1YWxpdHkgLyAyLCBmcmFnLnkgLyB0aGlzLnF1YWxpdHkgKyB5IC0gYml0bWFwLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnF1YWxpdHkgLyAyLCBmcmFnLmNhbnZhcy53aWR0aCAvIHRoaXMucXVhbGl0eSwgZnJhZy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5xdWFsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9zdERyYXcoZXgpO1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBiaXRtYXAgZm9yIGNlcnRhaW4gYW1vdW50IG9mIHRpbWVcclxuICAgICAgICB0aGlzLl9iaXRtYXBVc2FnZS5zZXQoYml0bWFwLCBwZXJmb3JtYW5jZS5ub3coKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW50ZXJuYWwgY2FjaGUgc2l6ZSBvZiB0aGUgZm9udFxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBkZWJ1Z2dpbmcgbWVtb3J5IHVzYWdlLCB0aGVzZSBudW1iZXJzIGluZGljYXRlIHRoZSBudW1iZXIgb2YgY2FjaGVkIGluIG1lbW9yeSB0ZXh0IGJpdG1hcHNcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhY2hlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYml0bWFwVXNhZ2Uuc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2UgY2xlYXIgYWxsIGNhY2hlZCB0ZXh0IGJpdG1hcHNcclxuICAgICAqL1xyXG4gICAgY2xlYXJDYWNoZSgpIHtcclxuICAgICAgICB0aGlzLl9iaXRtYXBVc2FnZS5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW55IGV4cGlyZWQgY2FjaGVkIHRleHQgYml0bWFwc1xyXG4gICAgICovXHJcbiAgICBjaGVja0FuZENsZWFyQ2FjaGUoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBbYml0bWFwLCB0aW1lXSBvZiB0aGlzLl9iaXRtYXBVc2FnZS5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgYml0bWFwIGhhc24ndCBiZWVuIHVzZWQgaW4gMSBzZWNvbmQgY2xlYXIgaXRcclxuICAgICAgICAgICAgaWYgKHRpbWUgKyAxMDAwIDwgcGVyZm9ybWFuY2Uubm93KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JpdG1hcFVzYWdlLmRlbGV0ZShiaXRtYXApO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW51cCBtZWFzdXJlbWVudHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gdGhpcy5fYml0bWFwVG9UZXh0TWVhc3VyZW1lbnQuZ2V0KGJpdG1hcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRUZXh0TWVhc3VyZW1lbnQuZGVsZXRlKG1lYXN1cmVtZW50LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JpdG1hcFRvVGV4dE1lYXN1cmVtZW50LmRlbGV0ZShiaXRtYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVGV4dHVyZUxvYWRlcltcImRlbGV0ZVwiXShiaXRtYXAuY2FudmFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1RleHQudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgVGV4dCBncmFwaGljcyBpbiBleGNhbGlidXJcclxuICpcclxuICogVXNlZnVsIGZvciBpbiBnYW1lIGxhYmVscywgdWksIG9yIG92ZXJsYXlzXHJcbiAqL1xyXG5jbGFzcyBUZXh0IGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl90ZXh0ID0gJyc7XHJcbiAgICAgICAgdGhpcy5fdGV4dFdpZHRoID0gMDtcclxuICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvLyBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCBmb250LCBjb2xvciwgdGhlbiB0ZXh0XHJcbiAgICAgICAgdGhpcy5mb250ID0gKF9hID0gb3B0aW9ucy5mb250KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRm9udCgpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAoX2IgPSBvcHRpb25zLmNvbG9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNvbG9yO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0KHtcclxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LnNsaWNlKCksXHJcbiAgICAgICAgICAgIGNvbG9yOiAoX2IgPSAoX2EgPSB0aGlzLmNvbG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvbmUoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogQ29sb3IuQmxhY2ssXHJcbiAgICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udC5jbG9uZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcclxuICAgIH1cclxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9IHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZm9udC5tZWFzdXJlVGV4dCh0aGlzLl90ZXh0KTtcclxuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSBib3VuZHMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgZm9udCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcclxuICAgIH1cclxuICAgIHNldCBmb250KGZvbnQpIHtcclxuICAgICAgICB0aGlzLl9mb250ID0gZm9udDtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dFdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZURpbWVuc2lvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dFdpZHRoICogdGhpcy5zY2FsZS54O1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dEhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVEaW1lbnNpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRIZWlnaHQgKiB0aGlzLnNjYWxlLnk7XHJcbiAgICB9XHJcbiAgICBfY2FsY3VsYXRlRGltZW5zaW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5mb250Lm1lYXN1cmVUZXh0KHRoaXMuX3RleHQpO1xyXG4gICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5tZWFzdXJlVGV4dCh0aGlzLl90ZXh0KS5zY2FsZSh0aGlzLnNjYWxlKTtcclxuICAgIH1cclxuICAgIF9yb3RhdGUoX2V4KSB7XHJcbiAgICAgICAgLy8gTm9uZSB0aGlzIGlzIGRlbGVnYXRlZCB0byBmb250XHJcbiAgICAgICAgLy8gVGhpcyBvdmVycmlkZSBlcmFzZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3JcclxuICAgIH1cclxuICAgIF9mbGlwKF9leCkge1xyXG4gICAgICAgIC8vIE5vbmUgdGhpcyBpcyBkZWxlZ2F0ZWQgdG8gZm9udFxyXG4gICAgICAgIC8vIFRoaXMgb3ZlcnJpZGUgZXJhc2VzIHRoZSBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJsYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmZvbnQgaW5zdGFuY2VvZiBGb250KSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gKF9hID0gdGhpcy5jb2xvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5mb250LmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1N0YWxlKCkgfHwgdGhpcy5mb250LmlzU3RhbGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvbnQuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnQuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgICAgIHRoaXMuZm9udC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZm9udC5vcmlnaW4gPSB0aGlzLm9yaWdpbjtcclxuICAgICAgICAgICAgdGhpcy5mb250Lm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZm9udC50aW50ID0gdGhpcy50aW50O1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5mb250Lm1lYXN1cmVUZXh0KHRoaXMuX3RleHQpO1xyXG4gICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5mb250LnJlbmRlcihleCwgdGhpcy5fdGV4dCwgY29sb3IsIHgsIHkpO1xyXG4gICAgICAgIGlmICh0aGlzLmZvbnQuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgIGV4LmRlYnVnLmRyYXdSZWN0KHggLSB3aWR0aCwgeSAtIGhlaWdodCwgd2lkdGggKiAyLCBoZWlnaHQgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rvci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiBzb21ldGhpbmcgaXMgYW4gQWN0b3JcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIGlzQWN0b3IoeCkge1xyXG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBBY3RvcjtcclxufVxyXG4vKipcclxuICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gYEFjdG9yYC4gQW55dGhpbmcgdGhhdFxyXG4gKiBjYW4gbW92ZSBvbiB0aGUgc2NyZWVuLCBjb2xsaWRlIHdpdGggYW5vdGhlciBgQWN0b3JgLCByZXNwb25kIHRvIGV2ZW50cyxcclxuICogb3IgaW50ZXJhY3Qgd2l0aCB0aGUgY3VycmVudCBzY2VuZSwgbXVzdCBiZSBhbiBhY3Rvci4gQW4gYEFjdG9yYCAqKm11c3QqKlxyXG4gKiBiZSBwYXJ0IG9mIGEgW1tTY2VuZV1dIGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxyXG4gKi9cclxuY2xhc3MgQWN0b3IgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmNob3IgdG8gYXBwbHkgYWxsIGFjdG9yIHJlbGF0ZWQgdHJhbnNmb3JtYXRpb25zIGxpa2Ugcm90YXRpb24sXHJcbiAgICAgICAgICogdHJhbnNsYXRpb24sIGFuZCBzY2FsaW5nLiBCeSBkZWZhdWx0IHRoZSBhbmNob3IgaXMgaW4gdGhlIGNlbnRlciBvZlxyXG4gICAgICAgICAqIHRoZSBhY3Rvci4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdGhlIGNlbnRlciBvZiB0aGUgYWN0b3IgKC41LCAuNSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFuIGFuY2hvciBvZiAoLjUsIC41KSB3aWxsIGVuc3VyZSB0aGF0IGRyYXdpbmdzIGFyZSBjZW50ZXJlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFVzZSBgYW5jaG9yLnNldFRvYCB0byBzZXQgdGhlIGFuY2hvciB0byBhIGRpZmZlcmVudCBwb2ludCB1c2luZ1xyXG4gICAgICAgICAqIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuIEZvciBleGFtcGxlLCBhbmNob3JpbmcgdG8gdGhlIHRvcC1sZWZ0IHdvdWxkIGJlXHJcbiAgICAgICAgICogYEFjdG9yLmFuY2hvci5zZXRUbygwLCAwKWAgYW5kIHRvcC1yaWdodCB3b3VsZCBiZSBgQWN0b3IuYW5jaG9yLnNldFRvKDAsIDEpYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hbmNob3IgPSB3YXRjaChWZWN0b3IuSGFsZiwgKHYpID0+IHRoaXMuX2hhbmRsZUFuY2hvckNoYW5nZSh2KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgbG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2NlbmUgdGhhdCB0aGUgYWN0b3IgaXMgaW5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmFnZ2FibGUgaGVscGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyRHJhZ1N0YXJ0SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRyYWdFbmRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRyYWdNb3ZlSGFuZGxlciA9IChwZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gcGUud29ybGRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJEcmFnTGVhdmVIYW5kbGVyID0gKHBlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBwZS53b3JsZFBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgeyBuYW1lLCB4LCB5LCBwb3MsIGNvb3JkUGxhbmUsIHNjYWxlLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGNvbGxpZGVyLCB2ZWwsIGFjYywgcm90YXRpb24sIGFuZ3VsYXJWZWxvY2l0eSwgeiwgY29sb3IsIHZpc2libGUsIGFuY2hvciwgY29sbGlzaW9uVHlwZSwgY29sbGlzaW9uR3JvdXAgfSA9IHtcclxuICAgICAgICAgICAgLi4uY29uZmlnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zZXROYW1lKG5hbWUpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yICE9PSBudWxsICYmIGFuY2hvciAhPT0gdm9pZCAwID8gYW5jaG9yIDogQWN0b3IuZGVmYXVsdHMuYW5jaG9yLmNsb25lKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQodHgpO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogdmVjKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwID8geCA6IDAsIHkgIT09IG51bGwgJiYgeSAhPT0gdm9pZCAwID8geSA6IDApO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbiAhPT0gbnVsbCAmJiByb3RhdGlvbiAhPT0gdm9pZCAwID8gcm90YXRpb24gOiAwO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZSAhPT0gbnVsbCAmJiBzY2FsZSAhPT0gdm9pZCAwID8gc2NhbGUgOiB2ZWMoMSwgMSk7XHJcbiAgICAgICAgdGhpcy56ID0geiAhPT0gbnVsbCAmJiB6ICE9PSB2b2lkIDAgPyB6IDogMDtcclxuICAgICAgICB0eC5jb29yZFBsYW5lID0gY29vcmRQbGFuZSAhPT0gbnVsbCAmJiBjb29yZFBsYW5lICE9PSB2b2lkIDAgPyBjb29yZFBsYW5lIDogQ29vcmRQbGFuZS5Xb3JsZDtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgUG9pbnRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEdyYXBoaWNzQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvclxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgTW90aW9uQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMudmVsID0gdmVsICE9PSBudWxsICYmIHZlbCAhPT0gdm9pZCAwID8gdmVsIDogVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5hY2MgPSBhY2MgIT09IG51bGwgJiYgYWNjICE9PSB2b2lkIDAgPyBhY2MgOiBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IGFuZ3VsYXJWZWxvY2l0eSAhPT0gbnVsbCAmJiBhbmd1bGFyVmVsb2NpdHkgIT09IHZvaWQgMCA/IGFuZ3VsYXJWZWxvY2l0eSA6IDA7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEFjdGlvbnNDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEJvZHlDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpc2lvblR5cGUgPSBjb2xsaXNpb25UeXBlICE9PSBudWxsICYmIGNvbGxpc2lvblR5cGUgIT09IHZvaWQgMCA/IGNvbGxpc2lvblR5cGUgOiBDb2xsaXNpb25UeXBlLlBhc3NpdmU7XHJcbiAgICAgICAgaWYgKGNvbGxpc2lvbkdyb3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5ncm91cCA9IGNvbGxpc2lvbkdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENvbGxpZGVyQ29tcG9uZW50KGNvbGxpZGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ29sbGlkZXJDb21wb25lbnQoU2hhcGUuQ2lyY2xlKHJhZGl1cykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENvbGxpZGVyQ29tcG9uZW50KFNoYXBlLkJveCh3aWR0aCwgaGVpZ2h0LCB0aGlzLmFuY2hvcikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudCgpKTsgLy8gbm8gY29sbGlkZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyYXBoaWNzLnZpc2libGUgPSB2aXNpYmxlICE9PSBudWxsICYmIHZpc2libGUgIT09IHZvaWQgMCA/IHZpc2libGUgOiB0cnVlO1xyXG4gICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWRkKG5ldyBSZWN0YW5nbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWRkKG5ldyBDaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXNcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBoeXNpY3MgYm9keSB0aGUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0b3IuIFRoZSBib2R5IGlzIHRoZSBjb250YWluZXIgZm9yIGFsbCBwaHlzaWNhbCBwcm9wZXJ0aWVzLCBsaWtlIHBvc2l0aW9uLCB2ZWxvY2l0eSxcclxuICAgICAqIGFjY2VsZXJhdGlvbiwgbWFzcywgaW5lcnRpYSwgZXRjLlxyXG4gICAgICovXHJcbiAgICBnZXQgYm9keSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0aGUgQWN0b3IncyBidWlsdCBpbiBbW1RyYW5zZm9ybUNvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCB0cmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0aGUgQWN0b3IncyBidWlsdCBpbiBbW01vdGlvbkNvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCBtb3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0byB0aGUgQWN0b3IncyBidWlsdCBpbiBbW0dyYXBoaWNzQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGdyYXBoaWNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0byB0aGUgQWN0b3IncyBidWlsdCBpbiBbW0NvbGxpZGVyQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGNvbGxpZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0byB0aGUgQWN0b3IncyBidWlsdCBpbiBbW1BvaW50ZXJDb21wb25lbnRdXSBjb25maWdcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvaW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFBvaW50ZXJDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VmdWwgZm9yIHF1aWNrbHkgc2NyaXB0aW5nIGFjdG9yIGJlaGF2aW9yLCBsaWtlIG1vdmluZyB0byBhIHBsYWNlLCBwYXRyb2xsaW5nIGJhY2sgYW5kIGZvcnRoLCBibGlua2luZywgZXRjLlxyXG4gICAgICpcclxuICAgICAqICBBY2Nlc3MgdG8gdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tBY3Rpb25zQ29tcG9uZW50XV0gd2hpY2ggZm9yd2FyZHMgdG8gdGhlXHJcbiAgICAgKiBbW0FjdGlvbkNvbnRleHR8QWN0aW9uIGNvbnRleHRdXSBvZiB0aGUgYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCBhY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChBY3Rpb25zQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBzZXQgcG9zKHRoZVBvcykge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvcyA9IHRoZVBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0IG9sZFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm9sZFBvcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBzZXQgb2xkUG9zKHRoZVBvcykge1xyXG4gICAgICAgIHRoaXMuYm9keS5vbGRQb3Muc2V0VG8odGhlUG9zLngsIHRoZVBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnZlbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgKi9cclxuICAgIHNldCB2ZWwodGhlVmVsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udmVsID0gdGhlVmVsLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkVmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkVmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2V0IG9sZFZlbCh0aGVWZWwpIHtcclxuICAgICAgICB0aGlzLmJvZHkub2xkVmVsLnNldFRvKHRoZVZlbC54LCB0aGVWZWwueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kLiBBbiBhY2NlbGVyYXRpb24gcG9pbnRpbmcgZG93biBzdWNoIGFzICgwLCAxMDApIG1heSBiZVxyXG4gICAgICogdXNlZnVsIHRvIHNpbXVsYXRlIGEgZ3Jhdml0YXRpb25hbCBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIGdldCBhY2MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFjYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0ZWggYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgc2V0IGFjYyh0aGVBY2MpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hY2MgPSB0aGVBY2MuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGdsb2JhbCBhY2MgW1tQaHlzaWNzLmFjY11dLlxyXG4gICAgICovXHJcbiAgICBzZXQgb2xkQWNjKHRoZUFjYykge1xyXG4gICAgICAgIHRoaXMuYm9keS5vbGRBY2Muc2V0VG8odGhlQWNjLngsIHRoZUFjYy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGdsb2JhbCBhY2MgW1tQaHlzaWNzLmFjY11dLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkQWNjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkQWNjO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy4gMSByYWRpYW4gPSAxODAvUEkgRGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMuIDEgcmFkaWFuID0gMTgwL1BJIERlZ3JlZXMuXHJcbiAgICAgKi9cclxuICAgIHNldCByb3RhdGlvbih0aGVBbmdsZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdGhlQW5nbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCBhbmd1bGFyVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNcclxuICAgICAqL1xyXG4gICAgc2V0IGFuZ3VsYXJWZWxvY2l0eShhbmd1bGFyVmVsb2NpdHkpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSBhbmd1bGFyVmVsb2NpdHk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuc2NhbGU7XHJcbiAgICB9XHJcbiAgICBzZXQgc2NhbGUoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9XHJcbiAgICBnZXQgYW5jaG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3I7XHJcbiAgICB9XHJcbiAgICBzZXQgYW5jaG9yKHZlYykge1xyXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IHdhdGNoKHZlYywgKHYpID0+IHRoaXMuX2hhbmRsZUFuY2hvckNoYW5nZSh2KSk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlQW5jaG9yQ2hhbmdlKHZlYyk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlQW5jaG9yQ2hhbmdlKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5ncmFwaGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmFuY2hvciA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYWN0b3IgaXMgcGh5c2ljYWxseSBpbiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzT2ZmU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZygnZXgub2Zmc2NyZWVuJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgZHJhZ2dhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcmFnZ2FibGU7XHJcbiAgICB9XHJcbiAgICBzZXQgZHJhZ2dhYmxlKGlzRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgaWYgKGlzRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiAhdGhpcy5fZHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdwb2ludGVyZHJhZ3N0YXJ0JywgdGhpcy5fcG9pbnRlckRyYWdTdGFydEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncG9pbnRlcmRyYWdlbmQnLCB0aGlzLl9wb2ludGVyRHJhZ0VuZEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncG9pbnRlcmRyYWdtb3ZlJywgdGhpcy5fcG9pbnRlckRyYWdNb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdwb2ludGVyZHJhZ2xlYXZlJywgdGhpcy5fcG9pbnRlckRyYWdMZWF2ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdwb2ludGVyZHJhZ3N0YXJ0JywgdGhpcy5fcG9pbnRlckRyYWdTdGFydEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ3BvaW50ZXJkcmFnZW5kJywgdGhpcy5fcG9pbnRlckRyYWdFbmRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdwb2ludGVyZHJhZ21vdmUnLCB0aGlzLl9wb2ludGVyRHJhZ01vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdwb2ludGVyZHJhZ2xlYXZlJywgdGhpcy5fcG9pbnRlckRyYWdMZWF2ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnYWJsZSA9IGlzRHJhZ2dhYmxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIGFjdG9yJ3MgY3VycmVudCBncmFwaGljXHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3Iodikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IHYuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0TGF5ZXIgPSB0aGlzLmdyYXBoaWNzLmxheWVycy5kZWZhdWx0O1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRHcmFwaGljID0gKF9hID0gZGVmYXVsdExheWVyLmdyYXBoaWNzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JhcGhpYztcclxuICAgICAgICBpZiAoY3VycmVudEdyYXBoaWMgaW5zdGFuY2VvZiBSYXN0ZXIgfHwgY3VycmVudEdyYXBoaWMgaW5zdGFuY2VvZiBUZXh0KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcmFwaGljLmNvbG9yID0gdGhpcy5fY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgb25Jbml0aWFsaXplYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXHJcbiAgICAgKlxyXG4gICAgICogU3lub255bW91cyB3aXRoIHRoZSBldmVudCBoYW5kbGVyIGAub24oJ2luaXRpYWxpemUnLCAoZXZ0KSA9PiB7Li4ufSlgXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBhY3RvciBhbmQgYWxsIGl0J3MgY2hpbGQgYWN0b3JzLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIFNjZW5lIGJlZm9yZSBmaXJzdCB1cGRhdGUgbm90IGJ5IHVzZXJzIG9mIEV4Y2FsaWJ1ci5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjaGlsZC5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJla2lsbCBoYW5kbGVyIGZvciBbW29uUHJlS2lsbF1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmVraWxsKF9zY2VuZSkge1xyXG4gICAgICAgIHN1cGVyLmVtaXQoJ3ByZWtpbGwnLCBuZXcgUHJlS2lsbEV2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlS2lsbChfc2NlbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlS2lsbCBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZWtpbGwnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVLaWxsYCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGFuIGFjdG9yIGlzIGtpbGxlZCBhbmQgcmVtb3ZlZCBmcm9tIGl0cyBjdXJyZW50IFtbU2NlbmVdXS5cclxuICAgICAqL1xyXG4gICAgb25QcmVLaWxsKF9zY2VuZSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZWtpbGwgaGFuZGxlciBmb3IgW1tvblBvc3RLaWxsXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3RraWxsKF9zY2VuZSkge1xyXG4gICAgICAgIHN1cGVyLmVtaXQoJ3Bvc3RraWxsJywgbmV3IFBvc3RLaWxsRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0S2lsbChfc2NlbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdEtpbGwgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwb3N0a2lsbCcsIChldnQpID0+IHsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0S2lsbGAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGFuIGFjdG9yIGlzIGtpbGxlZCBhbmQgcmVtb3ZlIGZyb20gaXRzIGN1cnJlbnQgW1tTY2VuZV1dLlxyXG4gICAgICovXHJcbiAgICBvblBvc3RLaWxsKF9zY2VuZSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBjdXJyZW50IGFjdG9yIGlzIGEgbWVtYmVyIG9mIHRoZSBzY2VuZSwgdGhpcyB3aWxsIHJlbW92ZVxyXG4gICAgICogaXQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGtpbGwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJla2lsbCh0aGlzLnNjZW5lKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdraWxsJywgbmV3IEtpbGxFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHN1cGVyLmtpbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9zdGtpbGwodGhpcy5zY2VuZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDYW5ub3Qga2lsbCBhY3RvciwgaXQgd2FzIG5ldmVyIGFkZGVkIHRvIHRoZSBTY2VuZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3IgaXMga2lsbGVkLCBpdCB3aWxsIG5vdyBub3QgYmUga2lsbGVkLlxyXG4gICAgICovXHJcbiAgICB1bmtpbGwoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBoYXMgYmVlbiBraWxsZWQuXHJcbiAgICAgKi9cclxuICAgIGlzS2lsbGVkKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IuIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICogQWN0b3JzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd24gb24gdG9wIG9mIGFjdG9ycyB3aXRoIGEgbG93ZXIgei1pbmRleFxyXG4gICAgICovXHJcbiAgICBnZXQgeigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS56O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6LWluZGV4IG9mIGFuIGFjdG9yIGFuZCB1cGRhdGVzIGl0IGluIHRoZSBkcmF3aW5nIGxpc3QgZm9yIHRoZSBzY2VuZS5cclxuICAgICAqIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICogQWN0b3JzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd24gb24gdG9wIG9mIGFjdG9ycyB3aXRoIGEgbG93ZXIgei1pbmRleFxyXG4gICAgICogQHBhcmFtIG5ld1ogbmV3IHotaW5kZXggdG8gYXNzaWduXHJcbiAgICAgKi9cclxuICAgIHNldCB6KG5ld1opIHtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLnogPSBuZXdaO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBvZiBhbiBhY3RvciAoZ2xvYmFsIHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbFBvcyA9IHRoaXMuZ2V0R2xvYmFsUG9zKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoZ2xvYmFsUG9zLnggKyB0aGlzLndpZHRoIC8gMiAtIHRoaXMuYW5jaG9yLnggKiB0aGlzLndpZHRoLCBnbG9iYWxQb3MueSArIHRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuYW5jaG9yLnkgKiB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbG9jYWwgY2VudGVyIHBvaW50IG9mIGFuIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbENlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnBvcy54ICsgdGhpcy53aWR0aCAvIDIgLSB0aGlzLmFuY2hvci54ICogdGhpcy53aWR0aCwgdGhpcy5wb3MueSArIHRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuYW5jaG9yLnkgKiB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXIubG9jYWxCb3VuZHMud2lkdGggKiB0aGlzLmdldEdsb2JhbFNjYWxlKCkueDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXIubG9jYWxCb3VuZHMuaGVpZ2h0ICogdGhpcy5nZXRHbG9iYWxTY2FsZSgpLnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhpcyBhY3RvcidzIHJvdGF0aW9uIHRha2luZyBpbnRvIGFjY291bnQgYW55IHBhcmVudCByZWxhdGlvbnNoaXBzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBnZXRHbG9iYWxSb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5nbG9iYWxSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBhY3RvcidzIHdvcmxkIHBvc2l0aW9uIHRha2luZyBpbnRvIGFjY291bnQgcGFyZW50IHJlbGF0aW9uc2hpcHMsIHNjYWxpbmcsIHJvdGF0aW9uLCBhbmQgdHJhbnNsYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXRHbG9iYWxQb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuZ2xvYmFsUG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnbG9iYWwgc2NhbGUgb2YgdGhlIEFjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldEdsb2JhbFNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLmdsb2JhbFNjYWxlO1xyXG4gICAgfVxyXG4gICAgLy8gI3JlZ2lvbiBDb2xsaXNpb25cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgd2hldGhlciB0aGUgeC95IHNwZWNpZmllZCBhcmUgY29udGFpbmVkIGluIHRoZSBhY3RvclxyXG4gICAgICogQHBhcmFtIHggIFggY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSB5ICBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0gcmVjdXJzZSBjaGVja3Mgd2hldGhlciB0aGUgeC95IGFyZSBjb250YWluZWQgaW4gYW55IGNoaWxkIGFjdG9ycyAoaWYgdGhleSBleGlzdCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHksIHJlY3Vyc2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdmVjKHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbGxpZGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGdlb20gPSBjb2xsaWRlci5nZXQoKTtcclxuICAgICAgICBpZiAoIWdlb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250YWlubWVudCA9IGdlb20uY29udGFpbnMocG9pbnQpO1xyXG4gICAgICAgIGlmIChyZWN1cnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29udGFpbm1lbnQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29udGFpbnMoeCwgeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWlubWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYWN0b3IuY29sbGlkZXIncyBzdXJmYWNlcyBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgZnJvbSBlYWNoIG90aGVyXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgICAgIEFjdG9yIHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSBkaXN0YW5jZSAgRGlzdGFuY2UgaW4gcGl4ZWxzIHRvIHRlc3RcclxuICAgICAqL1xyXG4gICAgd2l0aGluKGFjdG9yLCBkaXN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ29sbGlkZXIgPSBhY3Rvci5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1lID0gY29sbGlkZXIuZ2V0KCk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBvdGhlckNvbGxpZGVyLmdldCgpO1xyXG4gICAgICAgIGlmIChtZSAmJiBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWUuZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKG90aGVyKS5nZXRMZW5ndGgoKSA8PSBkaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gICAgLy8gI3JlZ2lvbiBVcGRhdGVcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLl9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlVXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlVXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGFuIGFjdG9yIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncG9zdHVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3RVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhbiBhY3RvciBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25QcmVVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25Qb3N0VXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3R1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbn1cclxuLy8gI3JlZ2lvbiBQcm9wZXJ0aWVzXHJcbi8qKlxyXG4gKiBTZXQgZGVmYXVsdHMgZm9yIGFsbCBBY3RvcnNcclxuICovXHJcbkFjdG9yLmRlZmF1bHRzID0ge1xyXG4gICAgYW5jaG9yOiBWZWN0b3IuSGFsZlxyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1NjcmVlbkVsZW1lbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8gZGV0ZWN0IGEgc2NyZWVuIGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzU2NyZWVuRWxlbWVudChhY3Rvcikge1xyXG4gICAgcmV0dXJuIGFjdG9yIGluc3RhbmNlb2YgU2NyZWVuRWxlbWVudDtcclxufVxyXG4vKipcclxuICogSGVscGVyIFtbQWN0b3JdXSBwcmltaXRpdmUgZm9yIGRyYXdpbmcgVUkncywgb3B0aW1pemVkIGZvciBVSSBkcmF3aW5nLiBEb2VzXHJcbiAqIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLiBEcmF3biBvbiB0b3Agb2YgYWxsIG90aGVyIGFjdG9ycy5cclxuICovXHJcbmNsYXNzIFNjcmVlbkVsZW1lbnQgZXh0ZW5kcyBBY3RvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcih7IC4uLmNvbmZpZyB9KTtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLmNvb3JkUGxhbmUgPSBDb29yZFBsYW5lLlNjcmVlbjtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyLnVzZUJveENvbGxpZGVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmFuY2hvcik7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKHgsIHksIHVzZVdvcmxkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh1c2VXb3JsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuY29udGFpbnMoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuX2VuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IFZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbnRhaW5zKGNvb3Jkcy54LCBjb29yZHMueSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UaW1lci50c1xuXHJcblxyXG4vKipcclxuICogVGhlIEV4Y2FsaWJ1ciB0aW1lciBob29rcyBpbnRvIHRoZSBpbnRlcm5hbCB0aW1lciBhbmQgZmlyZXMgY2FsbGJhY2tzLFxyXG4gKiBhZnRlciBhIGNlcnRhaW4gaW50ZXJ2YWwsIG9wdGlvbmFsbHkgcmVwZWF0aW5nLlxyXG4gKi9cclxuY2xhc3MgVGltZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmNuLCBpbnRlcnZhbCwgcmVwZWF0cywgbnVtYmVyT2ZSZXBlYXRzLCByYW5kb21SYW5nZSwgcmFuZG9tKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlID0gMDtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDEwO1xyXG4gICAgICAgIHRoaXMucmVwZWF0cyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzID0gLTE7XHJcbiAgICAgICAgdGhpcy5yYW5kb21SYW5nZSA9IFswLCAwXTtcclxuICAgICAgICB0aGlzLl9iYXNlSW50ZXJ2YWwgPSAxMDtcclxuICAgICAgICB0aGlzLl9nZW5lcmF0ZVJhbmRvbUludGVydmFsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUludGVydmFsICsgdGhpcy5yYW5kb20uaW50ZWdlcih0aGlzLnJhbmRvbVJhbmdlWzBdLCB0aGlzLnJhbmRvbVJhbmdlWzFdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmY24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGZjbjtcclxuICAgICAgICAgICAgZmNuID0gb3B0aW9ucy5mY247XHJcbiAgICAgICAgICAgIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbDtcclxuICAgICAgICAgICAgcmVwZWF0cyA9IG9wdGlvbnMucmVwZWF0cztcclxuICAgICAgICAgICAgbnVtYmVyT2ZSZXBlYXRzID0gb3B0aW9ucy5udW1iZXJPZlJlcGVhdHM7XHJcbiAgICAgICAgICAgIHJhbmRvbVJhbmdlID0gb3B0aW9ucy5yYW5kb21SYW5nZTtcclxuICAgICAgICAgICAgcmFuZG9tID0gb3B0aW9ucy5yYW5kb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIW51bWJlck9mUmVwZWF0cyAmJiBudW1iZXJPZlJlcGVhdHMgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heE51bWJlck9mUmVwZWF0cyA9IG51bWJlck9mUmVwZWF0cztcclxuICAgICAgICAgICAgaWYgKCFyZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGVhdHMgbXVzdCBiZSBzZXQgdG8gdHJ1ZSBpZiBudW1iZXJPZlJlcGVhdHMgaXMgc2V0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pZCA9IFRpbWVyLl9NQVhfSUQrKztcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9iYXNlSW50ZXJ2YWwgPSB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKCEhcmFuZG9tUmFuZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHJhbmRvbVJhbmdlWzBdID4gcmFuZG9tUmFuZ2VbMV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWluIHZhbHVlIG11c3QgYmUgbG93ZXIgdGhhbiBtYXggdmFsdWUgZm9yIHJhbmdlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9XZSB1c2UgdGhlIGluc3RhbmNlIG9mIGV4LlJhbmRvbSB0byBnZW5lcmF0ZSB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgdGhpcy5yYW5kb20gPSByYW5kb20gIT09IG51bGwgJiYgcmFuZG9tICE9PSB2b2lkIDAgPyByYW5kb20gOiBuZXcgUmFuZG9tKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmFuZG9tUmFuZ2UgPSByYW5kb21SYW5nZTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHRoaXMuX2dlbmVyYXRlUmFuZG9tSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgdGhpcy5vbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsID0gdGhpcy5fZ2VuZXJhdGVSYW5kb21JbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xyXG4gICAgICAgIGlmIChmY24pIHtcclxuICAgICAgICAgICAgdGhpcy5vbihmY24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgY2FsbGJhY2sgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlXHJcbiAgICAgKiBAcGFyYW0gZmNuIFRoZSBjYWxsYmFjayB0byBiZSBhZGRlZCB0byB0aGUgY2FsbGJhY2sgbGlzdCwgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBvbihmY24pIHtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChmY24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgY2FsbGJhY2sgbGlzdCB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXHJcbiAgICAgKiBAcGFyYW0gZmNuIFRoZSBjYWxsYmFjayB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbGxiYWNrIGxpc3QsIHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgb2ZmKGZjbikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY2FsbGJhY2tzLmluZGV4T2YoZmNuKTtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdGltZXIgYWZ0ZXIgYSBjZXJ0YWluIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgZW5naW5lLlxyXG4gICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgZWxhcHNlZCBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fcnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1heE51bWJlck9mUmVwZWF0cyA+IC0xICYmIHRoaXMuX251bWJlck9mVGlja3MgPj0gdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5pbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX251bWJlck9mVGlja3MrKztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSB0aW1lciBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQsIGFuZCBvcHRpb25hbGx5IHJlY29uZmlndXJlIHRoZSB0aW1lcnMgaW50ZXJ2YWwuXHJcbiAgICAgKlxyXG4gICAgICogV2FybmluZyoqIHlvdSBtYXkgbmVlZCB0byBjYWxsIGB0aW1lci5zdGFydCgpYCBhZ2FpbiBpZiB0aGUgdGltZXIgaGFkIGNvbXBsZXRlZFxyXG4gICAgICogQHBhcmFtIG5ld0ludGVydmFsIElmIHNwZWNpZmllZCwgc2V0cyBhIG5ldyBub24tbmVnYXRpdmUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIHRvIHJlZmlyZSB0aGUgY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBuZXdOdW1iZXJPZlJlcGVhdHMgSWYgc3BlY2lmaWVkLCBzZXRzIGEgbmV3IG5vbi1uZWdhdGl2ZSB1cHBlciBsaW1pdCB0byB0aGUgbnVtYmVyIG9mIHRpbWUgdGhpcyB0aW1lciBleGVjdXRlc1xyXG4gICAgICovXHJcbiAgICByZXNldChuZXdJbnRlcnZhbCwgbmV3TnVtYmVyT2ZSZXBlYXRzKSB7XHJcbiAgICAgICAgaWYgKCEhbmV3SW50ZXJ2YWwgJiYgbmV3SW50ZXJ2YWwgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlSW50ZXJ2YWwgPSB0aGlzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzICYmIHRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgPSBuZXdOdW1iZXJPZlJlcGVhdHM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGVhdHMgbXVzdCBiZSBzZXQgdG8gdHJ1ZSBpZiBudW1iZXJPZlJlcGVhdHMgaXMgc2V0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgdGltZXNSZXBlYXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZUaWNrcztcclxuICAgIH1cclxuICAgIGdldFRpbWVSdW5uaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRpbWVBbGl2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgbWlsbGlzZWNvbmRzIHVudGlsIHRoZSBuZXh0IGFjdGlvbiBjYWxsYmFjaywgaWYgY29tcGxldGUgd2lsbCByZXR1cm4gMFxyXG4gICAgICovXHJcbiAgICBnZXQgdGltZVRvTmV4dEFjdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgLSB0aGlzLl9lbGFwc2VkVGltZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgbWlsbGlzZWNvbmRzIGVsYXBzZWQgdG93YXJkIHRoZSBuZXh0IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgdGltZUVsYXBzZWRUb3dhcmROZXh0QWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGFwc2VkVGltZTtcclxuICAgIH1cclxuICAgIGdldCBpc1J1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyB0aGUgdGltZXIsIHRpbWUgd2lsbCBubyBsb25nZXIgaW5jcmVtZW50IHRvd2FyZHMgdGhlIG5leHQgY2FsbFxyXG4gICAgICovXHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3VtZXMgdGhlIHRpbWVyLCB0aW1lIHdpbGwgbm93IGluY3JlbWVudCB0b3dhcmRzIHRoZSBuZXh0IGNhbGwuXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSB0aW1lciwgaWYgdGhlIHRpbWVyIHdhcyBjb21wbGV0ZSBpdCB3aWxsIHJlc3RhcnQgdGhlIHRpbWVyIGFuZCByZXNldCB0aGUgZWxhcHNlZCB0aW1lIGNvdW50ZXJcclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdDYW5ub3Qgc3RhcnQgYSB0aW1lciBub3QgcGFydCBvZiBhIHNjZW5lLCB0aW1lciB3b250IHN0YXJ0IHVudGlsIGFkZGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgdGltZXIgYW5kIHJlc2V0cyB0aGUgZWxhcHNlZCB0aW1lIGNvdW50ZXIgdG93YXJkcyB0aGUgbmV4dCBhY3Rpb24gaW52b2NhdGlvblxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGFueSBmdXJ0aGVyIGV4ZWN1dGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuVGltZXIuX01BWF9JRCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUGFyYWxsYXhDb21wb25lbnQudHNcblxyXG5cclxuY2xhc3MgUGFyYWxsYXhDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocGFyYWxsYXhGYWN0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5wYXJhbGxheCc7XHJcbiAgICAgICAgdGhpcy5wYXJhbGxheEZhY3RvciA9IHZlYygxLjAsIDEuMCk7XHJcbiAgICAgICAgdGhpcy5wYXJhbGxheEZhY3RvciA9IHBhcmFsbGF4RmFjdG9yICE9PSBudWxsICYmIHBhcmFsbGF4RmFjdG9yICE9PSB2b2lkIDAgPyBwYXJhbGxheEZhY3RvciA6IHRoaXMucGFyYWxsYXhGYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9EZWJ1Z0dyYXBoaWNzQ29tcG9uZW50LnRzXG5cclxuLyoqXHJcbiAqIFByb3ZpZGUgYXJiaXRyYXJ5IGRyYXdpbmcgZm9yIHRoZSBwdXJwb3NlcyBvZiBkZWJ1Z2dpbmcgeW91ciBnYW1lXHJcbiAqXHJcbiAqIFdpbGwgb25seSBzaG93IHdoZW4gdGhlIEVuZ2luZSBpcyBzZXQgdG8gZGVidWcgbW9kZSBbW0VuZ2luZS5zaG93RGVidWddXSBvciBbW0VuZ2luZS50b2dnbGVEZWJ1Z11dXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBEZWJ1Z0dyYXBoaWNzQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGRyYXcsIHVzZVRyYW5zZm9ybSA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZHJhdyA9IGRyYXc7XHJcbiAgICAgICAgdGhpcy51c2VUcmFuc2Zvcm0gPSB1c2VUcmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmRlYnVnZ3JhcGhpY3MnO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVGlsZU1hcC9UaWxlTWFwLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFRpbGVNYXAgcHJvdmlkZXMgYSBtZWNoYW5pc20gZm9yIGRvaW5nIGZsYXQgMkQgdGlsZXMgcmVuZGVyZWQgaW4gYSBncmlkLlxyXG4gKlxyXG4gKiBUaWxlTWFwcyBhcmUgdXNlZnVsIGZvciB0b3AgZG93biBvciBzaWRlIHNjcm9sbGluZyBncmlkIG9yaWVudGVkIGdhbWVzLlxyXG4gKi9cclxuY2xhc3MgVGlsZU1hcCBleHRlbmRzIEVudGl0eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHN1cGVyKG51bGwsIG9wdGlvbnMubmFtZSk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW4gPSAwO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy50aWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Jvd3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb2xzID0gW107XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGcm9tVG9wT2ZHcmFwaGljID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT2Zmc2V0cyA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgTW90aW9uQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBCb2R5Q29tcG9uZW50KHtcclxuICAgICAgICAgICAgdHlwZTogQ29sbGlzaW9uVHlwZS5GaXhlZFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgR3JhcGhpY3NDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBvblBvc3REcmF3OiAoY3R4LCBkZWx0YSkgPT4gdGhpcy5kcmF3KGN0eCwgZGVsdGEpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBEZWJ1Z0dyYXBoaWNzQ29tcG9uZW50KChjdHgpID0+IHRoaXMuZGVidWcoY3R4KSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IHRoaXMuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IHRoaXMuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXIgPSB0aGlzLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlID0gdGhpcy5fY29sbGlkZXIudXNlQ29tcG9zaXRlQ29sbGlkZXIoW10pO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wb3MgPSAoX2EgPSBvcHRpb25zLnBvcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5fb2xkUG9zID0gdGhpcy5fdHJhbnNmb3JtLnBvcztcclxuICAgICAgICB0aGlzLnJlbmRlckZyb21Ub3BPZkdyYXBoaWMgPSAoX2IgPSBvcHRpb25zLnJlbmRlckZyb21Ub3BPZkdyYXBoaWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMucmVuZGVyRnJvbVRvcE9mR3JhcGhpYztcclxuICAgICAgICB0aGlzLnRpbGVXaWR0aCA9IG9wdGlvbnMudGlsZVdpZHRoO1xyXG4gICAgICAgIHRoaXMudGlsZUhlaWdodCA9IG9wdGlvbnMudGlsZUhlaWdodDtcclxuICAgICAgICB0aGlzLnJvd3MgPSBvcHRpb25zLnJvd3M7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5zO1xyXG4gICAgICAgIHRoaXMudGlsZXMgPSBuZXcgQXJyYXkodGhpcy5yb3dzICogdGhpcy5jb2x1bW5zKTtcclxuICAgICAgICB0aGlzLl9yb3dzID0gbmV3IEFycmF5KHRoaXMucm93cyk7XHJcbiAgICAgICAgdGhpcy5fY29scyA9IG5ldyBBcnJheSh0aGlzLmNvbHVtbnMpO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q29sID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMucm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZCA9IG5ldyBUaWxlKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGosXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwOiB0aGlzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNkLm1hcCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVzW2kgKyBqICogdGhpcy5jb2x1bW5zXSA9IGNkO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudENvbC5wdXNoKGNkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcm93c1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvd3Nbal0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvd3Nbal0ucHVzaChjZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29sc1tpXSA9IGN1cnJlbnRDb2w7XHJcbiAgICAgICAgICAgIGN1cnJlbnRDb2wgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MubG9jYWxCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3goe1xyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmNvbHVtbnMgKiB0aGlzLnRpbGVXaWR0aCxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnJvd3MgKiB0aGlzLnRpbGVIZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZsYWdDb2xsaWRlcnNEaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX3RyYW5zZm9ybS5wb3MueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgIH1cclxuICAgIHNldCB4KHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkucG9zID0gdmVjKHZhbCwgdGhpcy55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgIH1cclxuICAgIHNldCB5KHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wb3MgPSB2ZWModGhpcy54LCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB6KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fdHJhbnNmb3JtLnopICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICB9XHJcbiAgICBzZXQgeih2YWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS56ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCByb3RhdGlvbigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb3RhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbih2YWwpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5PbmU7XHJcbiAgICB9XHJcbiAgICBzZXQgc2NhbGUodmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0uc2NhbGUgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLnBvcztcclxuICAgIH1cclxuICAgIHNldCBwb3ModmFsKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnBvcyA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdGlvbi52ZWw7XHJcbiAgICB9XHJcbiAgICBzZXQgdmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgIH1cclxuICAgIF9nZXRPclNldENvbGxpZGVyT3JpZ2luYWxPZmZzZXQoY29sbGlkZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29yaWdpbmFsT2Zmc2V0cy5oYXMoY29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsT2Zmc2V0ID0gY29sbGlkZXIub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE9mZnNldHMuc2V0KGNvbGxpZGVyLCBvcmlnaW5hbE9mZnNldCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbE9mZnNldHMuZ2V0KGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRpbGVzIGNvbGxpZGVycyBiYXNlZCBvbiB0aGUgc29saWQgdGlsZXMgaW4gdGhlIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlLmNsZWFyQ29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlID0gdGhpcy5fY29sbGlkZXIudXNlQ29tcG9zaXRlQ29sbGlkZXIoW10pO1xyXG4gICAgICAgIGxldCBjdXJyZW50O1xyXG4gICAgICAgIC8vIEJhZCBzcXVhcmUgdGVzc2VsYXRpb24gYWxnb1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gU2NhbiBjb2x1bW4gZm9yIGNvbGxpZGVyc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMucm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb2x1bW5zIHN0YXJ0IHdpdGggYSBuZXcgY29sbGlkZXJcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy50aWxlc1tpICsgaiAqIHRoaXMuY29sdW1uc107XHJcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHRpbGUgaW4gY29sdW1uIGlzIHNvbGlkIGJ1aWxkIHVwIGN1cnJlbnQgY29sbGlkZXJcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlLnNvbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSBjb2xsaWRlciBvdGhlcndpc2UgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGUuZ2V0Q29sbGlkZXJzKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIHRpbGUuZ2V0Q29sbGlkZXJzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsT2Zmc2V0ID0gdGhpcy5fZ2V0T3JTZXRDb2xsaWRlck9yaWdpbmFsT2Zmc2V0KGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVyLm9mZnNldCA9IHZlYyh0aWxlLnggKiB0aGlzLnRpbGVXaWR0aCwgdGlsZS55ICogdGhpcy50aWxlSGVpZ2h0KS5hZGQob3JpZ2luYWxPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlkZXIub3duZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlLmFkZENvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRpbGUuYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY29tYmluZSh0aWxlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc29saWQgc2tpcCBhbmQgY3V0IG9mZiB0aGUgY3VycmVudCBjb2xsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZnRlciBhIGNvbHVtbiBpcyBjb21wbGV0ZSBjaGVjayB0byBzZWUgaWYgaXQgY2FuIGJlIG1lcmdlZCBpbnRvIHRoZSBsYXN0IG9uZVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgaXMgdGhlIHNhbWUgY29tYmluZSBpdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGNvbGxpZGVyc1tjb2xsaWRlcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnRvcCA9PT0gY3VycmVudC50b3AgJiYgcHJldi5ib3R0b20gPT09IGN1cnJlbnQuYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJzW2NvbGxpZGVycy5sZW5ndGggLSAxXSA9IHByZXYuY29tYmluZShjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgbmV3IGNvbGxpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJzLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IFNoYXBlLkJveChjLndpZHRoLCBjLmhlaWdodCwgVmVjdG9yLlplcm8sIHZlYyhjLmxlZnQgLSB0aGlzLnBvcy54LCBjLnRvcCAtIHRoaXMucG9zLnkpKTtcclxuICAgICAgICAgICAgY29sbGlkZXIub3duZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb3NpdGUuYWRkQ29sbGlkZXIoY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb2xsaWRlci51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgW1tUaWxlXV0gYnkgaW5kZXggKHJvdyBtYWpvciBvcmRlcilcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZUJ5SW5kZXgoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1tpbmRleF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbVGlsZV1dIGJ5IGl0cyB4IGFuZCB5IGludGVnZXIgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZSh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2x1bW5zIHx8IHkgPj0gdGhpcy5yb3dzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1t4ICsgeSAqIHRoaXMuY29sdW1uc107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbVGlsZV1dIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyxcclxuICAgICAqIHJldHVybnMgYG51bGxgIGlmIG5vIFRpbGUgd2FzIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQnlQb2ludChwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKChwb2ludC54IC0gdGhpcy5wb3MueCkgLyB0aGlzLnRpbGVXaWR0aCk7XHJcbiAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoKHBvaW50LnkgLSB0aGlzLnBvcy55KSAvIHRoaXMudGlsZUhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuZ2V0VGlsZSh4LCB5KTtcclxuICAgICAgICBpZiAoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2x1bW5zICYmIHkgPCB0aGlzLnJvd3MgJiYgdGlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRSb3dzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dzO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sdW1ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29scztcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vbGRQb3MuZXF1YWxzKHRoaXMucG9zKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbGVzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlc1tpXS5mbGFnRGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY29sbGlkZXJzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sbGlkZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Rva2VuKys7XHJcbiAgICAgICAgY29uc3Qgd29ybGRCb3VuZHMgPSBlbmdpbmUuZ2V0V29ybGRCb3VuZHMoKTtcclxuICAgICAgICBjb25zdCB3b3JsZENvb3Jkc1VwcGVyTGVmdCA9IHZlYyh3b3JsZEJvdW5kcy5sZWZ0LCB3b3JsZEJvdW5kcy50b3ApO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkQ29vcmRzTG93ZXJSaWdodCA9IHZlYyh3b3JsZEJvdW5kcy5yaWdodCwgd29ybGRCb3VuZHMuYm90dG9tKTtcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XHJcbiAgICAgICAgY29uc3QgbWF5YmVQYXJhbGxheCA9IHRoaXMuZ2V0KFBhcmFsbGF4Q29tcG9uZW50KTtcclxuICAgICAgICBsZXQgcGFyYWxsYXhPZmZzZXQgPSBWZWN0b3IuT25lO1xyXG4gICAgICAgIGlmIChtYXliZVBhcmFsbGF4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uZU1pbnVzRmFjdG9yID0gVmVjdG9yLk9uZS5zdWIobWF5YmVQYXJhbGxheC5wYXJhbGxheEZhY3Rvcik7XHJcbiAgICAgICAgICAgIHBhcmFsbGF4T2Zmc2V0ID0gZW5naW5lLmN1cnJlbnRTY2VuZS5jYW1lcmEucG9zLnNjYWxlKG9uZU1pbnVzRmFjdG9yKTtcclxuICAgICAgICAgICAgcG9zID0gcG9zLmFkZChwYXJhbGxheE9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueCAtIHBvcy54KSAvIHRoaXMudGlsZVdpZHRoKSAtIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueSAtIHBvcy55KSAvIHRoaXMudGlsZUhlaWdodCkgLSAyLCAwKTtcclxuICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc0xvd2VyUmlnaHQueCAtIHBvcy54KSAvIHRoaXMudGlsZVdpZHRoKSArIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC55IC0gcG9zLnkpIC8gdGhpcy50aWxlSGVpZ2h0KSArIDIsIDApO1xyXG4gICAgICAgIC8vIHdoeSBhcmUgd2UgcmVzZXR0aW5nIHBvcz9cclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucG9zID0gdmVjKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHRpbGUgbWFwIHRvIHRoZSBzY3JlZW4uIENhbGxlZCBieSB0aGUgW1tTY2VuZV1dLlxyXG4gICAgICogQHBhcmFtIGN0eCBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xyXG4gICAgICovXHJcbiAgICBkcmF3KGN0eCwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTsgLy8gVE9ETyBmaXggZXZlbnRcclxuICAgICAgICBsZXQgeCA9IHRoaXMuX29uU2NyZWVuWFN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IHhFbmQgPSBNYXRoLm1pbih0aGlzLl9vblNjcmVlblhFbmQsIHRoaXMuY29sdW1ucyk7XHJcbiAgICAgICAgbGV0IHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDtcclxuICAgICAgICBjb25zdCB5RW5kID0gTWF0aC5taW4odGhpcy5fb25TY3JlZW5ZRW5kLCB0aGlzLnJvd3MpO1xyXG4gICAgICAgIGxldCBncmFwaGljcywgZ3JhcGhpY3NJbmRleCwgZ3JhcGhpY3NMZW47XHJcbiAgICAgICAgZm9yICh4OyB4IDwgeEVuZDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoeTsgeSA8IHlFbmQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IG5vbi1uZWdhdGl2ZSB0aWxlIHNwcml0ZXNcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzID0gdGhpcy5nZXRUaWxlKHgsIHkpLmdldEdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGdyYXBoaWNzSW5kZXggPSAwLCBncmFwaGljc0xlbiA9IGdyYXBoaWNzLmxlbmd0aDsgZ3JhcGhpY3NJbmRleCA8IGdyYXBoaWNzTGVuOyBncmFwaGljc0luZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IHNwcml0ZSwgd2FybmluZyBpZiBzcHJpdGUgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYXBoaWMgPSBncmFwaGljc1tncmFwaGljc0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGhpYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzR3JhcGhpY3NUaWNrKGdyYXBoaWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMudGljayhkZWx0YSwgdGhpcy5fdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSB0aGlzLnJlbmRlckZyb21Ub3BPZkdyYXBoaWMgPyAwIDogKGdyYXBoaWMuaGVpZ2h0IC0gdGhpcy50aWxlSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kcmF3KGN0eCwgeCAqIHRoaXMudGlsZVdpZHRoLCB5ICogdGhpcy50aWxlSGVpZ2h0IC0gb2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBQb3N0RHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgIH1cclxuICAgIGRlYnVnKGdmeCkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy50aWxlV2lkdGggKiB0aGlzLmNvbHVtbnM7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0ICogdGhpcy5yb3dzO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5yb3dzICsgMTsgcisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSB2ZWMoMCwgciAqIHRoaXMudGlsZUhlaWdodCk7XHJcbiAgICAgICAgICAgIGdmeC5kcmF3TGluZShwb3MuYWRkKHlPZmZzZXQpLCBwb3MuYWRkKHZlYyh3aWR0aCwgeU9mZnNldC55KSksIENvbG9yLlJlZCwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jb2x1bW5zICsgMTsgYysrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHhPZmZzZXQgPSB2ZWMoYyAqIHRoaXMudGlsZVdpZHRoLCAwKTtcclxuICAgICAgICAgICAgZ2Z4LmRyYXdMaW5lKHBvcy5hZGQoeE9mZnNldCksIHBvcy5hZGQodmVjKHhPZmZzZXQueCwgaGVpZ2h0KSksIENvbG9yLlJlZCwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuX2NvbXBvc2l0ZS5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBncmF5aXNoID0gQ29sb3IuR3JheTtcclxuICAgICAgICAgICAgZ3JheWlzaC5hID0gMC41O1xyXG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBjb2xsaWRlci5sb2NhbEJvdW5kcztcclxuICAgICAgICAgICAgY29uc3QgcG9zID0gY29sbGlkZXIud29ybGRQb3Muc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAgICAgZ2Z4LmRyYXdSZWN0YW5nbGUocG9zLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIGdyYXlpc2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGlsZU1hcCBUaWxlXHJcbiAqXHJcbiAqIEEgbGlnaHQtd2VpZ2h0IG9iamVjdCB0aGF0IG9jY3VwaWVzIGEgc3BhY2UgaW4gYSBjb2xsaXNpb24gbWFwLiBHZW5lcmFsbHlcclxuICogY3JlYXRlZCBieSBhIFtbVGlsZU1hcF1dLlxyXG4gKlxyXG4gKiBUaWxlcyBjYW4gZHJhdyBtdWx0aXBsZSBzcHJpdGVzLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIGRyYXdpbmcgaXMgdGhlIG9yZGVyXHJcbiAqIG9mIHRoZSBzcHJpdGVzIGluIHRoZSBhcnJheSBzbyB0aGUgbGFzdCBvbmUgd2lsbCBiZSBkcmF3biBvbiB0b3AuIFlvdSBjYW5cclxuICogdXNlIHRyYW5zcGFyZW5jeSB0byBjcmVhdGUgbGF5ZXJzIHRoaXMgd2F5LlxyXG4gKi9cclxuY2xhc3MgVGlsZSBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3Bvc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc29saWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgbGlzdCBvZiBjb2xsaWRlcnMgZm9yIHRoaXMgdGlsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFyYml0cmFyeSBkYXRhIHN0b3JhZ2UgcGVyIHRpbGUsIHVzZWZ1bCBmb3IgYW55IGdhbWUgc3BlY2lmaWMgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnggPSBvcHRpb25zLng7XHJcbiAgICAgICAgdGhpcy55ID0gb3B0aW9ucy55O1xyXG4gICAgICAgIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMubWFwLnRpbGVXaWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMubWFwLnRpbGVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5zb2xpZCA9IChfYSA9IG9wdGlvbnMuc29saWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc29saWQ7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSAoX2IgPSBvcHRpb25zLmdyYXBoaWNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gcHJpdmF0ZSBfdHJhbnNmb3JtOiBUcmFuc2Zvcm1Db21wb25lbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wb3NEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXZXRoZXIgdGhpcyB0aWxlIHNob3VsZCBiZSB0cmVhdGVkIGFzIHNvbGlkIGJ5IHRoZSB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIGdldCBzb2xpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc29saWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdldGhlciB0aGlzIHRpbGUgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgc29saWQgYnkgdGhlIHRpbGVtYXBcclxuICAgICAqL1xyXG4gICAgc2V0IHNvbGlkKHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLm1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX3NvbGlkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGxpc3Qgb2YgZ3JhcGhpY3MgZm9yIHRoaXMgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXRHcmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbm90aGVyIFtbR3JhcGhpY11dIHRvIHRoaXMgVGlsZU1hcCB0aWxlXHJcbiAgICAgKiBAcGFyYW0gZ3JhcGhpY1xyXG4gICAgICovXHJcbiAgICBhZGRHcmFwaGljKGdyYXBoaWMpIHtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcy5wdXNoKGdyYXBoaWMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gaW5zdGFuY2Ugb2YgYSBbW0dyYXBoaWNdXSBmcm9tIHRoaXMgdGlsZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVHcmFwaGljKGdyYXBoaWMpIHtcclxuICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGdyYXBoaWMsIHRoaXMuX2dyYXBoaWNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoaWNzIGZyb20gdGhpcyB0aWxlXHJcbiAgICAgKi9cclxuICAgIGNsZWFyR3JhcGhpY3MoKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBjb2xsaWRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0Q29sbGlkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaWRlcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjdXN0b20gY29sbGlkZXIgdG8gdGhlIFtbVGlsZV1dIHRvIHVzZSBpbnN0ZWFkIG9mIGl0J3MgYm91bmRzXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gY29sbGlkZXIgaXMgc2V0IGJ1dCBbW1RpbGUuc29saWRdXSBpcyBzZXQsIHRoZSB0aWxlIGJvdW5kcyBhcmUgdXNlZCBhcyBhIGNvbGxpZGVyLlxyXG4gICAgICpcclxuICAgICAqICoqTm90ZSEqKiB0aGUgW1tUaWxlLnNvbGlkXV0gbXVzdCBiZSBzZXQgdG8gdHJ1ZSBmb3IgaXQgdG8gYWN0IGFzIGEgXCJmaXhlZFwiIGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgYWRkQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMucHVzaChjb2xsaWRlcik7XHJcbiAgICAgICAgdGhpcy5tYXAuZmxhZ0NvbGxpZGVyc0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb2xsaWRlciBmcm9tIHRoZSBbW1RpbGVdXVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jb2xsaWRlcnMuaW5kZXhPZihjb2xsaWRlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFwLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIGNvbGxpZGVycyBmcm9tIHRoZSBbW1RpbGVdXVxyXG4gICAgICovXHJcbiAgICBjbGVhckNvbGxpZGVycygpIHtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLm1hcC5mbGFnQ29sbGlkZXJzRGlydHkoKTtcclxuICAgIH1cclxuICAgIGZsYWdEaXJ0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3JlY2FsY3VsYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX3BvcyA9IHRoaXMubWFwLnBvcy5hZGQodmVjKHRoaXMueCAqIHRoaXMubWFwLnRpbGVXaWR0aCwgdGhpcy55ICogdGhpcy5tYXAudGlsZUhlaWdodCkpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCh0aGlzLl9wb3MueCwgdGhpcy5fcG9zLnksIHRoaXMuX3Bvcy54ICsgdGhpcy53aWR0aCwgdGhpcy5fcG9zLnkgKyB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fcG9zRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Bvc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wb3NEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl9wb3MueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLl9wb3MueSArIHRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9DYW1lcmEudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb250YWluZXIgdG8gaG91c2UgY29udmVuaWVuY2Ugc3RyYXRlZ3kgbWV0aG9kc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFN0cmF0ZWd5Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmEuXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICovXHJcbiAgICBsb2NrVG9BY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5KGFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gbG9jayB0aGUgY2FtZXJhIHRvXHJcbiAgICAgKiBAcGFyYW0gYXhpcyBUaGUgYXhpcyB0byBmb2xsb3cgdGhlIGFjdG9yIG9uXHJcbiAgICAgKi9cclxuICAgIGxvY2tUb0FjdG9yQXhpcyhhY3RvciwgYXhpcykge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneShhY3RvciwgYXhpcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW5nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yIFRhcmdldCBhY3RvciB0byBlbGFzdGljYWxseSBmb2xsb3dcclxuICAgICAqIEBwYXJhbSBjYW1lcmFFbGFzdGljaXR5IFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBlbGFzdGljaXR5IHRoZSBtb3JlIGZvcmNlIHRoYXQgd2lsbCBkcml2ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICogQHBhcmFtIGNhbWVyYUZyaWN0aW9uIFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBmcmljdGlvbiB0aGUgbW9yZSB0aGF0IHRoZSBjYW1lcmEgd2lsbCByZXNpc3QgbW90aW9uIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICovXHJcbiAgICBlbGFzdGljVG9BY3RvcihhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgRWxhc3RpY1RvQWN0b3JTdHJhdGVneShhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgVGFyZ2V0IGFjdG9yIHRvIGZvbGxvdyB3aGVuIGl0IGlzIFwicmFkaXVzXCIgcGl4ZWxzIGF3YXlcclxuICAgICAqIEBwYXJhbSByYWRpdXMgTnVtYmVyIG9mIHBpeGVscyBhd2F5IGJlZm9yZSB0aGUgY2FtZXJhIHdpbGwgZm9sbG93XHJcbiAgICAgKi9cclxuICAgIHJhZGl1c0Fyb3VuZEFjdG9yKGFjdG9yLCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneShhY3RvciwgcmFkaXVzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICogQHBhcmFtIGJveCBUaGUgYm91bmRpbmcgYm94IHRvIGxpbWl0IHRoZSBjYW1lcmEgdG8uXHJcbiAgICAgKi9cclxuICAgIGxpbWl0Q2FtZXJhQm91bmRzKGJveCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5KGJveCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYW1lcmEgYXhpcyBlbnVtXHJcbiAqL1xyXG52YXIgQXhpcztcclxuKGZ1bmN0aW9uIChBeGlzKSB7XHJcbiAgICBBeGlzW0F4aXNbXCJYXCJdID0gMF0gPSBcIlhcIjtcclxuICAgIEF4aXNbQXhpc1tcIllcIl0gPSAxXSA9IFwiWVwiO1xyXG59KShBeGlzIHx8IChBeGlzID0ge30pKTtcclxuLyoqXHJcbiAqIExvY2sgYSBjYW1lcmEgdG8gdGhlIGV4YWN0IHgveSBwb3NpdGlvbiBvZiBhbiBhY3Rvci5cclxuICovXHJcbmNsYXNzIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSAodGFyZ2V0LCBfY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBMb2NrIGEgY2FtZXJhIHRvIGEgc3BlY2lmaWMgYXhpcyBhcm91bmQgYW4gYWN0b3IuXHJcbiAqL1xyXG5jbGFzcyBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGF4aXMpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09IEF4aXMuWCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoY2VudGVyLngsIGN1cnJlbnRGb2N1cy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGN1cnJlbnRGb2N1cy54LCBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2luZyBbSG9vaydzIGxhd10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXcpLCBlbGFzdGljYWxseSBtb3ZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0IGFjdG9yLlxyXG4gKi9cclxuY2xhc3MgRWxhc3RpY1RvQWN0b3JTdHJhdGVneSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW5nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhRWxhc3RpY2l0eSBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZWxhc3RpY2l0eSB0aGUgbW9yZSBmb3JjZSB0aGF0IHdpbGwgZHJpdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjYW1lcmFFbGFzdGljaXR5LCBjYW1lcmFGcmljdGlvbikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhRWxhc3RpY2l0eSA9IGNhbWVyYUVsYXN0aWNpdHk7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFGcmljdGlvbiA9IGNhbWVyYUZyaWN0aW9uO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0YXJnZXQuY2VudGVyO1xyXG4gICAgICAgICAgICBsZXQgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgbGV0IGNhbWVyYVZlbCA9IGNhbS52ZWwuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdHJldGNoIHZlY3RvciwgdXNpbmcgdGhlIHNwcmluZyBlcXVhdGlvblxyXG4gICAgICAgICAgICAvLyBGID0ga1hcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXdcclxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmV0Y2ggPSBwb3NpdGlvbi5zdWIoZm9jdXMpLnNjYWxlKHRoaXMuY2FtZXJhRWxhc3RpY2l0eSk7IC8vIHN0cmV0Y2ggaXMgWFxyXG4gICAgICAgICAgICBjYW1lcmFWZWwgPSBjYW1lcmFWZWwuYWRkKHN0cmV0Y2gpO1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyaWN0aW9uICgtMSB0byBhcHBseSBhIGZvcmNlIGluIHRoZSBvcHBvc2l0aW9uIG9mIG1vdGlvbilcclxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IGZyaWN0aW9uID0gY2FtZXJhVmVsLnNjYWxlKC0xKS5zY2FsZSh0aGlzLmNhbWVyYUZyaWN0aW9uKTtcclxuICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChmcmljdGlvbik7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBieSB2ZWxvY2l0eSBkZWx0YXNcclxuICAgICAgICAgICAgZm9jdXMgPSBmb2N1cy5hZGQoY2FtZXJhVmVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIE51bWJlciBvZiBwaXhlbHMgYXdheSBiZWZvcmUgdGhlIGNhbWVyYSB3aWxsIGZvbGxvd1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0YXJnZXQuY2VudGVyO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBwb3NpdGlvbi5zdWIoZm9jdXMpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpcmVjdGlvbi5zaXplO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPj0gdGhpcy5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGRpc3RhbmNlIC0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXMuYWRkKGRpcmVjdGlvbi5ub3JtYWxpemUoKS5zY2FsZShvZmZzZXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm9jdXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJldmVudCBhIGNhbWVyYSBmcm9tIGdvaW5nIGJleW9uZCB0aGUgZ2l2ZW4gY2FtZXJhIGRpbWVuc2lvbnMuXHJcbiAqL1xyXG5jbGFzcyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgbGltaXRpbmcgdGhlIGNhbWVyYSB0byBhIFtbVGlsZU1hcF1dJ3MgZGltZW5zaW9ucywgb3IgYSBzcGVjaWZpYyBhcmVhIGluc2lkZSB0aGUgbWFwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgc3RyYXRlZ3kgZG9lcyBub3QgcGVyZm9ybSBhbnkgbW92ZW1lbnQgYnkgaXRzZWxmLlxyXG4gICAgICAgICAqIEl0IG9ubHkgc2V0cyB0aGUgY2FtZXJhIHBvc2l0aW9uIHRvIHdpdGhpbiB0aGUgZ2l2ZW4gYm91bmRzIHdoZW4gdGhlIGNhbWVyYSBoYXMgZ29uZSBiZXlvbmQgdGhlbS5cclxuICAgICAgICAgKiBUaHVzLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBjb21iaW5lIGl0IHdpdGggb3RoZXIgY2FtZXJhIHN0cmF0ZWdpZXMgYW5kIHNldCB0aGlzIHN0cmF0ZWd5IGFzIHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBjYW1lcmEgYm91bmRzIGFyZSBhdCBsZWFzdCBhcyBsYXJnZSBhcyB0aGUgdmlld3BvcnQgc2l6ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIGJvdW5kaW5nIGJveCB0byBsaW1pdCB0aGUgY2FtZXJhIHRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuZFNpemVDaGVja2VkID0gZmFsc2U7IC8vIENoZWNrIGFuZCB3YXJuIG9ubHkgb25jZVxyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmJvdW5kU2l6ZUNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuYm90dG9tIC0gdGFyZ2V0LnRvcCA8IF9lbmcuZHJhd0hlaWdodCB8fCB0YXJnZXQucmlnaHQgLSB0YXJnZXQubGVmdCA8IF9lbmcuZHJhd1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2FtZXJhIGJvdW5kcyBzaG91bGQgbm90IGJlIHNtYWxsZXIgdGhhbiB0aGUgZW5naW5lIHZpZXdwb3J0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kU2l6ZUNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmb2N1c1ggPSBmb2N1cy54O1xyXG4gICAgICAgICAgICBsZXQgZm9jdXNZID0gZm9jdXMueTtcclxuICAgICAgICAgICAgaWYgKGZvY3VzLnggPCB0YXJnZXQubGVmdCArIF9lbmcuaGFsZkRyYXdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNYID0gdGFyZ2V0LmxlZnQgKyBfZW5nLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9jdXMueCA+IHRhcmdldC5yaWdodCAtIF9lbmcuaGFsZkRyYXdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNYID0gdGFyZ2V0LnJpZ2h0IC0gX2VuZy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb2N1cy55IDwgdGFyZ2V0LnRvcCArIF9lbmcuaGFsZkRyYXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzWSA9IHRhcmdldC50b3AgKyBfZW5nLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzLnkgPiB0YXJnZXQuYm90dG9tIC0gX2VuZy5oYWxmRHJhd0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNZID0gdGFyZ2V0LmJvdHRvbSAtIF9lbmcuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZlYyhmb2N1c1gsIGZvY3VzWSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FtZXJhc1xyXG4gKlxyXG4gKiBbW0NhbWVyYV1dIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRXhjYWxpYnVyIGNhbWVyYXMuIENhbWVyYXMgYXJlIHVzZWRcclxuICogdG8gbW92ZSBhcm91bmQgeW91ciBnYW1lIGFuZCBzZXQgZm9jdXMuIFRoZXkgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAqIHdoYXQgaXMgXCJvZmYgc2NyZWVuXCIgYW5kIGNhbiBiZSB1c2VkIHRvIHNjYWxlIHRoZSBnYW1lLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgQ2FtZXJhIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIHRoaXMuaW52ZXJzZSA9IEFmZmluZU1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gbmV3IFN0cmF0ZWd5Q29udGFpbmVyKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvciBzZXQgY3VycmVudCB6b29tIG9mIHRoZSBjYW1lcmEsIGRlZmF1bHRzIHRvIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl96ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IHJhdGUgb2YgY2hhbmdlIGluIHpvb20sIGRlZmF1bHRzIHRvIDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmR6ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IHpvb20gYWNjZWxlcmF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5heiA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCByb3RhdGlvbiBvZiB0aGUgY2FtZXJhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Bvc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb3MgPSB3YXRjaEFueShWZWN0b3IuWmVybywgKCkgPT4gKHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZFxyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgLy9jYW1lcmEgZWZmZWN0c1xyXG4gICAgICAgIHRoaXMuX2lzU2hha2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gMDtcclxuICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgIHRoaXMuX3lTaGFrZSA9IDA7XHJcbiAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gMTtcclxuICAgICAgICB0aGlzLl96b29tRW5kID0gMTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Wm9vbVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3pvb21EdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fem9vbUVhc2luZyA9IEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYztcclxuICAgICAgICB0aGlzLl9lYXNpbmcgPSBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7XHJcbiAgICAgICAgdGhpcy5faGFsZldpZHRoID0gMDtcclxuICAgICAgICB0aGlzLl9oYWxmSGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XHJcbiAgICB9XHJcbiAgICBzZXQgem9vbSh2YWwpIHtcclxuICAgICAgICB0aGlzLl96ID0gdmFsO1xyXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFsZldpZHRoID0gdGhpcy5fZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZIZWlnaHQgPSB0aGlzLl9lbmdpbmUuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyBhbmd1bGFyIHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIGdldCBhbmd1bGFyVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBhbmd1bGFyVmVsb2NpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9hbmd1bGFyVmVsb2NpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcztcclxuICAgIH1cclxuICAgIHNldCBwb3ModmVjKSB7XHJcbiAgICAgICAgdGhpcy5fcG9zID0gd2F0Y2hBbnkodmVjLCAoKSA9PiAodGhpcy5fcG9zQ2hhbmdlZCA9IHRydWUpKTtcclxuICAgICAgICB0aGlzLl9wb3NDaGFuZ2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjYW1lcmEncyB4IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcy54O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSdzIHggcG9zaXRpb24gKGNhbm5vdCBiZSBzZXQgd2hlbiBmb2xsb3dpbmcgYW4gW1tBY3Rvcl1dIG9yIHdoZW4gbW92aW5nKVxyXG4gICAgICovXHJcbiAgICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZm9sbG93ICYmICF0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB2ZWModmFsdWUsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcy55O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSdzIHkgcG9zaXRpb24gKGNhbm5vdCBiZSBzZXQgd2hlbiBmb2xsb3dpbmcgYW4gW1tBY3Rvcl1dIG9yIHdoZW4gbW92aW5nKVxyXG4gICAgICovXHJcbiAgICBzZXQgeSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZm9sbG93ICYmICF0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB2ZWModGhpcy5wb3MueCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgeCB2ZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICBnZXQgZHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVsLng7XHJcbiAgICB9XHJcbiAgICBzZXQgZHgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZlbCA9IHZlYyh2YWx1ZSwgdGhpcy52ZWwueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIHkgdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlbC55O1xyXG4gICAgfVxyXG4gICAgc2V0IGR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52ZWwgPSB2ZWModGhpcy52ZWwueCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyB4IGFjY2VsZXJhdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgYXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjLng7XHJcbiAgICB9XHJcbiAgICBzZXQgYXgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmFjYyA9IHZlYyh2YWx1ZSwgdGhpcy5hY2MueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIHkgYWNjZWxlcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY2MueTtcclxuICAgIH1cclxuICAgIHNldCBheSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYWNjID0gdmVjKHRoaXMuYWNjLngsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZm9jYWwgcG9pbnQgb2YgdGhlIGNhbWVyYSwgYSBuZXcgcG9pbnQgZ2l2aW5nIHRoZSB4IGFuZCB5IHBvc2l0aW9uIG9mIHRoZSBjYW1lcmFcclxuICAgICAqL1xyXG4gICAgZ2V0Rm9jdXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1vdmVzIHRoZSBjYW1lcmEgZm9jYWwgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiB1c2luZyBzcGVjaWZpZWQgZWFzaW5nIGZ1bmN0aW9uLiBDYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBBY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gbW92ZSB0b1xyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdGhlIG1vdmUgc2hvdWxkIGxhc3RcclxuICAgICAqIEBwYXJhbSBbZWFzaW5nRm5dIEFuIG9wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiAoW1tleC5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWNdXSBieSBkZWZhdWx0KVxyXG4gICAgICogQHJldHVybnMgQSBbW1Byb21pc2VdXSB0aGF0IHJlc29sdmVzIHdoZW4gbW92ZW1lbnQgaXMgZmluaXNoZWQsIGluY2x1ZGluZyBpZiBpdCdzIGludGVycnVwdGVkLlxyXG4gICAgICogICAgICAgICAgVGhlIFtbUHJvbWlzZV1dIHZhbHVlIGlzIHRoZSBbW1ZlY3Rvcl1dIG9mIHRoZSB0YXJnZXQgcG9zaXRpb24uIEl0IHdpbGwgYmUgcmVqZWN0ZWQgaWYgYSBtb3ZlIGNhbm5vdCBiZSBtYWRlLlxyXG4gICAgICovXHJcbiAgICBtb3ZlKHBvcywgZHVyYXRpb24sIGVhc2luZ0ZuID0gRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmdGbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyAnUGxlYXNlIHNwZWNpZnkgYW4gRWFzaW5nRnVuY3Rpb24nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW5ub3QgbW92ZSB3aGVuIGZvbGxvd2luZyBhbiBhY3RvclxyXG4gICAgICAgIGlmICh0aGlzLl9mb2xsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgZXhpc3RpbmcgcHJvbWlzZSwgaWYgYW55XHJcbiAgICAgICAgaWYgKHRoaXMuX2xlcnBQcm9taXNlICYmIHRoaXMuX2xlcnBSZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBSZXNvbHZlKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xlcnBQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbGVycFJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IHRoaXMuZ2V0Rm9jdXMoKS5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2xlcnBFbmQgPSBwb3M7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2Vhc2luZyA9IGVhc2luZ0ZuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sZXJwUHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY2FtZXJhIHRvIHNoYWtlIGF0IHRoZSBzcGVjaWZpZWQgbWFnbml0dWRlcyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxyXG4gICAgICogQHBhcmFtIG1hZ25pdHVkZVggIFRoZSB4IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcclxuICAgICAqIEBwYXJhbSBtYWduaXR1ZGVZICBUaGUgeSBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXHJcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBzaGFrZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgc2hha2UobWFnbml0dWRlWCwgbWFnbml0dWRlWSwgZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IG1hZ25pdHVkZVg7XHJcbiAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gbWFnbml0dWRlWTtcclxuICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFpvb21zIHRoZSBjYW1lcmEgaW4gb3Igb3V0IGJ5IHRoZSBzcGVjaWZpZWQgc2NhbGUgb3ZlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxyXG4gICAgICogSWYgbm8gZHVyYXRpb24gaXMgc3BlY2lmaWVkLCBpdCB0YWtlIGVmZmVjdCBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSBzY2FsZSAgICBUaGUgc2NhbGUgb2YgdGhlIHpvb21cclxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHpvb20gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHpvb21PdmVyVGltZShzY2FsZSwgZHVyYXRpb24gPSAwLCBlYXNpbmdGbiA9IEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYykge1xyXG4gICAgICAgIHRoaXMuX3pvb21Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fem9vbVJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChkdXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl96b29tRWFzaW5nID0gZWFzaW5nRm47XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRab29tVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21EdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl96b29tU3RhcnQgPSB0aGlzLnpvb207XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21FbmQgPSBzY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnpvb20gPSBzY2FsZTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHZpZXdwb3J0IG9mIHRoaXMgY2FtZXJhIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCB2aWV3cG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmlld3BvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGNhbWVyYSBzdHJhdGVneSB0byB0aGlzIGNhbWVyYVxyXG4gICAgICogQHBhcmFtIGNhbWVyYVN0cmF0ZWd5IEluc3RhbmNlIG9mIGFuIFtbQ2FtZXJhU3RyYXRlZ3ldXVxyXG4gICAgICovXHJcbiAgICBhZGRTdHJhdGVneShjYW1lcmFTdHJhdGVneSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMucHVzaChjYW1lcmFTdHJhdGVneSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjYW1lcmEgc3RyYXRlZ3kgYnkgcmVmZXJlbmNlXHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhU3RyYXRlZ3kgSW5zdGFuY2Ugb2YgYW4gW1tDYW1lcmFTdHJhdGVneV1dXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVN0cmF0ZWd5KGNhbWVyYVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShjYW1lcmFTdHJhdGVneSwgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgY2FtZXJhIHN0cmF0ZWdpZXMgZnJvbSB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQWxsU3RyYXRlZ2llcygpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUHJlVXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYSBzY2VuZSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkYWJsZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25Qb3N0VXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3R1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0VXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdFVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3RVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhIHNjZW5lIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdFVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkYWJsZVxyXG4gICAgfVxyXG4gICAgZ2V0IGlzSW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gX2VuZ2luZTtcclxuICAgICAgICAgICAgdGhpcy5fc2NyZWVuID0gX2VuZ2luZS5zY3JlZW47XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXMgPSB0aGlzLl9zY3JlZW4ucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgbGV0IGNlbnRlciA9IHZlYyhjdXJyZW50UmVzLndpZHRoIC8gMiwgY3VycmVudFJlcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbmdpbmUubG9hZGluZ0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBsb2FkaW5nIHNjcmVlbiwgd2UgcGVlayB0aGUgY29uZmlndXJlZCByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9zY3JlZW4ucGVla1Jlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSB2ZWMocmVzLndpZHRoIC8gMiwgcmVzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZXaWR0aCA9IGNlbnRlci54O1xyXG4gICAgICAgICAgICB0aGlzLl9oYWxmSGVpZ2h0ID0gY2VudGVyLnk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBjYW1lcmEgcG9zLCBhcHBseSBkZWZhdWx0IGNlbnRlciBzY3JlZW4gcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wb3NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGNlbnRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaXJzdCBmcmFtZSBib290c3RyYXBcclxuICAgICAgICAgICAgLy8gRW5zdXJlIGNhbWVyYSB0eCBpcyBjb3JyZWN0XHJcbiAgICAgICAgICAgIC8vIFJ1biB1cGRhdGUgdHdpY2UgdG8gZW5zdXJlIHByb3BlcnRpZXMgYXJlIGluaXQnZFxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAvLyBSdW4gc3RyYXRlZ2llcyBmb3IgZmlyc3QgZnJhbWVcclxuICAgICAgICAgICAgdGhpcy5ydW5TdHJhdGVnaWVzKF9lbmdpbmUsIF9lbmdpbmUuY2xvY2suZWxhcHNlZCgpKTtcclxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIGZpcnN0IGZyYW1lIHZpZXdwb3J0XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoKTtcclxuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoZSBjYW1lcmEgYWZ0ZXIgc3RyYXRlZ2llc1xyXG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGppdHRlclxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShfZW5naW5lKTtcclxuICAgICAgICAgICAgc3VwZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBJbml0aWFsaXplRXZlbnQoX2VuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkYWJsZVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgcnVuU3RyYXRlZ2llcyhlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBzLmFjdGlvbi5jYWxsKHMsIHMudGFyZ2V0LCB0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWaWV3cG9ydCgpIHtcclxuICAgICAgICAvLyByZWNhbGMgdmlld3BvcnRcclxuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG5ldyBCb3VuZGluZ0JveCh0aGlzLnggLSB0aGlzLl9oYWxmV2lkdGgsIHRoaXMueSAtIHRoaXMuX2hhbGZIZWlnaHQsIHRoaXMueCArIHRoaXMuX2hhbGZXaWR0aCwgdGhpcy55ICsgdGhpcy5faGFsZkhlaWdodCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKF9lbmdpbmUpO1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShfZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucG9zLmFkZCh0aGlzLnZlbC5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB0aGlzLnpvb20gKz0gKHRoaXMuZHogKiBkZWx0YSkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMudmVsID0gdGhpcy52ZWwuYWRkKHRoaXMuYWNjLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgIHRoaXMuZHogKz0gKHRoaXMuYXogKiBkZWx0YSkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gKz0gKHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZGVsdGEpIC8gMTAwMDtcclxuICAgICAgICBpZiAodGhpcy5faXNab29taW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50Wm9vbVRpbWUgPCB0aGlzLl96b29tRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21FYXNpbmcgPSB0aGlzLl96b29tRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Wm9vbSA9IHpvb21FYXNpbmcodGhpcy5fY3VycmVudFpvb21UaW1lLCB0aGlzLl96b29tU3RhcnQsIHRoaXMuX3pvb21FbmQsIHRoaXMuX3pvb21EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvb21UaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tRW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvb21UaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pvb21SZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZUVhc2luZyA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVWZWN0b3JFYXNpbmdGdW5jdGlvbih0aGlzLl9lYXNpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVycFBvaW50ID0gbW92ZUVhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydCwgdGhpcy5fbGVycEVuZCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbGVycFBvaW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLl9sZXJwRW5kO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fbGVycEVuZC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgbWF0dGVycyBoZXJlLCByZXNvbHZlIHNob3VsZCBiZSBsYXN0IHNvIGFueSBjaGFpbiBwcm9taXNlcyBoYXZlIGEgY2xlYW4gc2xhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBSZXNvbHZlKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRG9uZVNoYWtpbmcoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl95U2hha2UgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gKChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVYKSB8IDApICsgMTtcclxuICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gKChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVZKSB8IDApICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ydW5TdHJhdGVnaWVzKF9lbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KCk7XHJcbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoZSBjYW1lcmEgYWZ0ZXIgc3RyYXRlZ2llc1xyXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgaml0dGVyXHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLl9wb3N0dXBkYXRlKF9lbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcmVsZXZhbnQgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBnYW1lIGNhbnZhcyB0byBcIm1vdmVcIiBvciBhcHBseSBlZmZlY3RzIHRvIHRoZSBDYW1lcmFcclxuICAgICAqIEBwYXJhbSBjdHggQ2FudmFzIGNvbnRleHQgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgY3R4Lm11bHRpcGx5KHRoaXMudHJhbnNmb3JtKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcclxuICAgICAgICAvLyBjZW50ZXIgdGhlIGNhbWVyYVxyXG4gICAgICAgIGNvbnN0IG5ld0NhbnZhc1dpZHRoID0gdGhpcy5fc2NyZWVuLnJlc29sdXRpb24ud2lkdGggLyB0aGlzLnpvb207XHJcbiAgICAgICAgY29uc3QgbmV3Q2FudmFzSGVpZ2h0ID0gdGhpcy5fc2NyZWVuLnJlc29sdXRpb24uaGVpZ2h0IC8gdGhpcy56b29tO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYVBvcyA9IHZlYygtdGhpcy54ICsgbmV3Q2FudmFzV2lkdGggLyAyICsgdGhpcy5feFNoYWtlLCAtdGhpcy55ICsgbmV3Q2FudmFzSGVpZ2h0IC8gMiArIHRoaXMuX3lTaGFrZSk7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNhbWVyYSB0cmFuc2Zvcm1cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlKHRoaXMuem9vbSwgdGhpcy56b29tKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS50cmFuc2xhdGUoY2FtZXJhUG9zLngsIGNhbWVyYVBvcy55KTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnNlKHRoaXMuaW52ZXJzZSk7XHJcbiAgICB9XHJcbiAgICBfaXNEb25lU2hha2luZygpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2lzU2hha2luZyB8fCB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID49IHRoaXMuX3NoYWtlRHVyYXRpb247XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UcmlnZ2VyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHRyaWdnZXJEZWZhdWx0cyA9IHtcclxuICAgIHBvczogVmVjdG9yLlplcm8sXHJcbiAgICB3aWR0aDogMTAsXHJcbiAgICBoZWlnaHQ6IDEwLFxyXG4gICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICBhY3Rpb246ICgpID0+IHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9LFxyXG4gICAgZmlsdGVyOiAoKSA9PiB0cnVlLFxyXG4gICAgcmVwZWF0OiAtMVxyXG59O1xyXG4vKipcclxuICogVHJpZ2dlcnMgYXJlIGEgbWV0aG9kIG9mIGZpcmluZyBhcmJpdHJhcnkgY29kZSBvbiBjb2xsaXNpb24uIFRoZXNlIGFyZSB1c2VmdWxcclxuICogYXMgJ2J1dHRvbnMnLCAnc3dpdGNoZXMnLCBvciB0byB0cmlnZ2VyIGVmZmVjdHMgaW4gYSBnYW1lLiBCeSBkZWZhdWx0IHRyaWdnZXJzXHJcbiAqIGFyZSBpbnZpc2libGUsIGFuZCBjYW4gb25seSBiZSBzZWVuIHdoZW4gW1tUcmlnZ2VyLnZpc2libGVdXSBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cclxuY2xhc3MgVHJpZ2dlciBleHRlbmRzIEFjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRzIFRyaWdnZXIgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIoeyB4OiBvcHRzLnBvcy54LCB5OiBvcHRzLnBvcy55LCB3aWR0aDogb3B0cy53aWR0aCwgaGVpZ2h0OiBvcHRzLmhlaWdodCB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3Rpb24gdG8gZmlyZSB3aGVuIHRyaWdnZXJlZCBieSBjb2xsaXNpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlsdGVyIHRvIGFkZCBhZGRpdGlvbmFsIGdyYW51bGFyaXR5IHRvIGFjdGlvbiBkaXNwYXRjaCwgaWYgYSBmaWx0ZXIgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb24gd2lsbCBvbmx5IGZpcmUgd2hlblxyXG4gICAgICAgICAqIGZpbHRlciByZXR1cm4gdHJ1ZSBmb3IgdGhlIGNvbGxpZGVkIGFjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gKCkgPT4gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGJlZm9yZSBraWxsaW5nIHRoZSB0cmlnZ2VyLFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gLTE7XHJcbiAgICAgICAgb3B0cyA9IHtcclxuICAgICAgICAgICAgLi4udHJpZ2dlckRlZmF1bHRzLFxyXG4gICAgICAgICAgICAuLi5vcHRzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IG9wdHMuZmlsdGVyIHx8IHRoaXMuZmlsdGVyO1xyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gb3B0cy5yZXBlYXQgfHwgdGhpcy5yZXBlYXQ7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBvcHRzLmFjdGlvbiB8fCB0aGlzLmFjdGlvbjtcclxuICAgICAgICBpZiAob3B0cy50YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBvcHRzLnRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy52aXNpYmxlID0gb3B0cy52aXNpYmxlO1xyXG4gICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlO1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjb2xsaXNpb25zdGFydCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyKGV2dC5vdGhlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZW50ZXInLCBuZXcgRW50ZXJUcmlnZ2VyRXZlbnQodGhpcywgZXZ0Lm90aGVyKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRyaWdnZXIgaWYgaXRzIGRvbmUsIC0xIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjb2xsaXNpb25lbmQnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcihldnQub3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2V4aXQnLCBuZXcgRXhpdFRyaWdnZXJFdmVudCh0aGlzLCBldnQub3RoZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0IHRhcmdldCh0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSAoYWN0b3IpID0+IGFjdG9yID09PSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoQWN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcGVhdCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdC0tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9TeXN0ZW0udHNcbi8qKlxyXG4gKiBFbnVtIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHJ1biB0aGUgc3lzdGVtIGluIHRoZSB1cGRhdGUgb3IgZHJhdyBwaGFzZVxyXG4gKi9cclxudmFyIFN5c3RlbVR5cGU7XHJcbihmdW5jdGlvbiAoU3lzdGVtVHlwZSkge1xyXG4gICAgU3lzdGVtVHlwZVtcIlVwZGF0ZVwiXSA9IFwidXBkYXRlXCI7XHJcbiAgICBTeXN0ZW1UeXBlW1wiRHJhd1wiXSA9IFwiZHJhd1wiO1xyXG59KShTeXN0ZW1UeXBlIHx8IChTeXN0ZW1UeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEFuIEV4Y2FsaWJ1ciBbW1N5c3RlbV1dIHRoYXQgdXBkYXRlcyBlbnRpdGllcyBvZiBjZXJ0YWluIHR5cGVzLlxyXG4gKiBTeXN0ZW1zIGFyZSBzY2VuZSBzcGVjaWZpY1xyXG4gKlxyXG4gKiBFeGNhbGlidXIgU3lzdGVtcyBjdXJyZW50bHkgcmVxdWlyZSBhdCBsZWFzdCAxIENvbXBvbmVudCB0eXBlIHRvIG9wZXJhdGVkXHJcbiAqXHJcbiAqIE11bHRpcGxlIHR5cGVzIGFyZSBkZWNsYXJlZCBhcyBhIHR5cGUgdW5pb25cclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW08Q29tcG9uZW50QSB8IENvbXBvbmVudEI+IHtcclxuICogICBwdWJsaWMgcmVhZG9ubHkgdHlwZXMgPSBbJ2EnLCAnYiddIGFzIGNvbnN0O1xyXG4gKiAgIHB1YmxpYyByZWFkb25seSBzeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAqICAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5PENvbXBvbmVudEEgfCBDb21wb25lbnRCPikge1xyXG4gKiAgICAgIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTeXN0ZW0gY2FuIGV4ZWN1dGUgaW4gcHJpb3JpdHkgb3JkZXIsIGJ5IGRlZmF1bHQgYWxsIHN5c3RlbXMgYXJlIHByaW9yaXR5IDAuIExvd2VyIHZhbHVlcyBpbmRpY2F0ZWQgaGlnaGVyIHByaW9yaXR5LlxyXG4gICAgICAgICAqIEZvciBhIHN5c3RlbSB0byBleGVjdXRlIGJlZm9yZSBhbGwgb3RoZXIgYSBsb3dlciBwcmlvcml0eSB2YWx1ZSAoLTEgZm9yIGV4YW1wbGUpIG11c3QgYmUgc2V0LlxyXG4gICAgICAgICAqIEZvciBhIHN5c3RlbSB0byBleGVjdXRlIGFmdGVyIGFsbCBvdGhlciBhIGhpZ2hlciBwcmlvcml0eSB2YWx1ZSAoMTAgZm9yIGV4YW1wbGUpIG11c3QgYmUgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTeXN0ZW1zIG9ic2VydmUgd2hlbiBlbnRpdGllcyBtYXRjaCB0aGVpciB0eXBlcyBvciBubyBsb25nZXIgbWF0Y2ggdGhlaXIgdHlwZXMsIG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gX2VudGl0eUFkZGVkT3JSZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeShfZW50aXR5QWRkZWRPclJlbW92ZWQpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBbW0VudGl0eV1dIHdpdGggW1tDb21wb25lbnRdXSB0eXBlcyB0aGF0IG1hdGNoZXMgYSBbW1N5c3RlbV1dIHR5cGVzIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY2VuZS5cclxuICovXHJcbmNsYXNzIEFkZGVkRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdFbnRpdHkgQWRkZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGZvciBBZGRlZEVudGl0eSBtZXNzYWdlc1xyXG4gKiBAcGFyYW0geFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBZGRlZFN5c3RlbUVudGl0eSh4KSB7XHJcbiAgICByZXR1cm4gISF4ICYmIHgudHlwZSA9PT0gJ0VudGl0eSBBZGRlZCc7XHJcbn1cclxuLyoqXHJcbiAqIEFuIFtbRW50aXR5XV0gd2l0aCBbW0NvbXBvbmVudF1dIHR5cGVzIHRoYXQgbm8gbG9uZ2VyIG1hdGNoZXMgYSBbW1N5c3RlbV1dIHR5cGVzIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY2VuZS5cclxuICovXHJcbmNsYXNzIFJlbW92ZWRFbnRpdHkge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0VudGl0eSBSZW1vdmVkJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogdHlwZSBndWFyZCB0byBjaGVjayBmb3IgdGhlIFJlbW92ZWRFbnRpdHkgbWVzc2FnZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZW1vdmVTeXN0ZW1FbnRpdHkoeCkge1xyXG4gICAgcmV0dXJuICEheCAmJiB4LnR5cGUgPT09ICdFbnRpdHkgUmVtb3ZlZCc7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vRW50aXR5TWFuYWdlci50c1xuXHJcblxyXG4vLyBBZGQvUmVtb3ZlIGVudGl0aWVzIGFuZCBjb21wb25lbnRzXHJcbmNsYXNzIEVudGl0eU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgdGhpcy5lbnRpdGllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eUluZGV4ID0ge307XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXNUb1JlbW92ZSA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSBlbnRpdHkgbGlmZWN5Y2xlXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRleHRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRW50aXRpZXMoX2NvbnRleHQsIGVsYXBzZWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaXMgdGhpcyByaWdodD9cclxuICAgICAgICAgICAgZW50aXR5LnVwZGF0ZShfY29udGV4dC5lbmdpbmUsIGVsYXBzZWQpO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kRW50aXRpZXNGb3JSZW1vdmFsKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFlbnRpdHkuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnRpdHlNYW5hZ2VyIG9ic2VydmVzIGNoYW5nZXMgb24gZW50aXRpZXNcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRDb21wb25lbnQobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgY29tcG9uZW50LCBpdCdzIGFscmVhZHkgb24gdGhlIGVudGl0eVxyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuYWRkRW50aXR5KG1lc3NhZ2UuZGF0YS5lbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZW1vdmVkQ29tcG9uZW50KG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5yZW1vdmVDb21wb25lbnQobWVzc2FnZS5kYXRhLmVudGl0eSwgbWVzc2FnZS5kYXRhLmNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byBiZSB0cmFja2VkIGJ5IHRoZSBFbnRpdHlNYW5hZ2VyXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFkZEVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBlbnRpdHkuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZW50aXR5ICYmICF0aGlzLl9lbnRpdHlJbmRleFtlbnRpdHkuaWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eUluZGV4W2VudGl0eS5pZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuYWRkRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jb21wb25lbnRBZGRlZCQucmVnaXN0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jb21wb25lbnRSZW1vdmVkJC5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gaWYgZW50aXR5IGhhcyBjaGlsZHJlblxyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gdGhpcy5hZGRFbnRpdHkoYykpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW5BZGRlZCQucmVnaXN0ZXIoe1xyXG4gICAgICAgICAgICAgICAgbm90aWZ5OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50aXR5KGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZW50aXR5LmNoaWxkcmVuUmVtb3ZlZCQucmVnaXN0ZXIoe1xyXG4gICAgICAgICAgICAgICAgbm90aWZ5OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlRW50aXR5KGlkT3JFbnRpdHksIGRlZmVycmVkID0gdHJ1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgaWQgPSAwO1xyXG4gICAgICAgIGlmIChpZE9yRW50aXR5IGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlkID0gaWRPckVudGl0eS5pZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlkID0gaWRPckVudGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5fZW50aXR5SW5kZXhbaWRdO1xyXG4gICAgICAgIGlmIChlbnRpdHkgJiYgZW50aXR5LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBlbnRpdHkua2lsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5ICYmIGRlZmVycmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0aWVzVG9SZW1vdmUucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9lbnRpdHlJbmRleFtpZF07XHJcbiAgICAgICAgaWYgKGVudGl0eSkge1xyXG4gICAgICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGVudGl0eSwgdGhpcy5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5yZW1vdmVFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXR5LmNvbXBvbmVudEFkZGVkJC51bnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY29tcG9uZW50UmVtb3ZlZCQudW5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gaWYgZW50aXR5IGhhcyBjaGlsZHJlblxyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gdGhpcy5yZW1vdmVFbnRpdHkoYywgZGVmZXJyZWQpKTtcclxuICAgICAgICAgICAgZW50aXR5LmNoaWxkcmVuQWRkZWQkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jaGlsZHJlblJlbW92ZWQkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIC8vIHN0YXRzXHJcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLl93b3JsZC5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZC5jb250ZXh0LmVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmtpbGxlZCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0VudGl0eVJlbW92YWxzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuX2VudGl0aWVzVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2Nlc3NDb21wb25lbnRSZW1vdmFscygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5wcm9jZXNzQ29tcG9uZW50UmVtb3ZhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEJ5SWQoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW50aXR5SW5kZXhbaWRdO1xyXG4gICAgfVxyXG4gICAgZ2V0QnlOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRpdGllcy5maWx0ZXIoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9VdGlsLnRzXG5jb25zdCBidWlsZFR5cGVLZXkgPSAodHlwZXMpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IFsuLi50eXBlc10uc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKS5qb2luKCcrJyk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9RdWVyeS50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBxdWVyeSBmb3IgZW50aXRpZXMgdGhhdCBtYXRjaCBhIGxpc3Qgb2YgdHlwZXMgdGhhdCBpcyBjYWNoZWQgYW5kIG9ic2VydmFibGVcclxuICpcclxuICogUXVlcmllcyBjYW4gYmUgc3Ryb25nbHkgdHlwZWQgYnkgc3VwcGx5aW5nIGEgdHlwZSB1bmlvbiBpbiB0aGUgb3B0aW9uYWwgdHlwZSBwYXJhbWV0ZXJcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBxdWVyeUFCID0gbmV3IGV4LlF1ZXJ5PENvbXBvbmVudFR5cGVBIHwgQ29tcG9uZW50VHlwZUI+KFsnQScsICdCJ10pO1xyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXMgPSBbXTtcclxuICAgICAgICBpZiAodHlwZXNbMF0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXMubWFwKFQgPT4gKG5ldyBUKS50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPSBidWlsZFR5cGVLZXkodGhpcy50eXBlcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbnRpdGllcyB0aGF0IG1hdGNoIHRoZSBxdWVyeVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzb3J0IE9wdGlvbmFsIHNvcnRpbmcgZnVuY3Rpb24gdG8gc29ydCBlbnRpdGllcyByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBnZXRFbnRpdGllcyhzb3J0KSB7XHJcbiAgICAgICAgaWYgKHNvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGl0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gZW50aXR5IHRvIHRoZSBxdWVyeSwgd2lsbCBvbmx5IGJlIGFkZGVkIGlmIHRoZSBlbnRpdHkgbWF0Y2hlcyB0aGUgcXVlcnkgdHlwZXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGlmICghY29udGFpbnModGhpcy5fZW50aXRpZXMsIGVudGl0eSkgJiYgdGhpcy5tYXRjaGVzKGVudGl0eSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFsbChuZXcgQWRkZWRFbnRpdHkoZW50aXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgZW50aXR5IGlzIHBhcnQgb2YgdGhlIHF1ZXJ5IGl0IHdpbGwgYmUgcmVtb3ZlZCByZWdhcmRsZXNzIG9mIHR5cGVzXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBpZiAocmVtb3ZlSXRlbUZyb21BcnJheShlbnRpdHksIHRoaXMuX2VudGl0aWVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFsbChuZXcgUmVtb3ZlZEVudGl0eShlbnRpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGVudGl0aWVzIGFuZCBvYnNlcnZlcnMgZnJvbSB0aGUgcXVlcnlcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcihvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyh0eXBlc09yRW50aXR5KSB7XHJcbiAgICAgICAgbGV0IHR5cGVzID0gW107XHJcbiAgICAgICAgaWYgKHR5cGVzT3JFbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlc09yRW50aXR5LnR5cGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlc09yRW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2hlcyA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcclxuICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMgJiYgdHlwZXMuaW5kZXhPZih0eXBlKSA+IC0xO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcclxuICAgIH1cclxuICAgIGNvbnRhaW4odHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9RdWVyeU1hbmFnZXIudHNcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBxdWVyeSBtYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBhbGwgcXVlcmllcyB3aGVuIGVudGl0aWVzL2NvbXBvbmVudHMgY2hhbmdlXHJcbiAqL1xyXG5jbGFzcyBRdWVyeU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgdGhpcy5fcXVlcmllcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcXVlcnkgdG8gdGhlIG1hbmFnZXIgYW5kIHBvcHVsYXRlcyB3aXRoIGFueSBlbnRpdGllcyB0aGF0IG1hdGNoXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlcclxuICAgICAqL1xyXG4gICAgX2FkZFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5fcXVlcmllc1tidWlsZFR5cGVLZXkocXVlcnkudHlwZXMpXSA9IHF1ZXJ5O1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuX3dvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgcXVlcnkuYWRkRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBxdWVyeSBpZiB0aGVyZSBhcmUgbm8gb2JzZXJ2ZXJzIGxlZnRcclxuICAgICAqIEBwYXJhbSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBtYXliZVJlbW92ZVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Lm9ic2VydmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcXVlcnkuY2xlYXIoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXJpZXNbYnVpbGRUeXBlS2V5KHF1ZXJ5LnR5cGVzKV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBlbnRpdHkgdG8gYW55IG1hdGNoaW5nIHF1ZXJ5IGluIHRoZSBxdWVyeSBtYW5hZ2VcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnlUeXBlIGluIHRoaXMuX3F1ZXJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXJpZXNbcXVlcnlUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcmllc1txdWVyeVR5cGVdLmFkZEVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHF1ZXJpZXMgaWYgdGhlIHJlbW92ZWQgY29tcG9uZW50IGRpc3F1YWxpZmllcyBpdFxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICByZW1vdmVDb21wb25lbnQoZW50aXR5LCBjb21wb25lbnQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5VHlwZSBpbiB0aGlzLl9xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgYmVpbmcgcmVtb3ZlZCBmcm9tIGFuIGVudGl0eSBpcyBhIHBhcnQgb2YgYSBxdWVyeSxcclxuICAgICAgICAgICAgLy8gaXQgaXMgbm93IGRpc3F1YWxpZmllZCBmcm9tIHRoYXQgcXVlcnksIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcXVlcmllc1txdWVyeVR5cGVdLmNvbnRhaW4oY29tcG9uZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0ucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gYWxsIHF1ZXJpZXMgaXQgaXMgY3VycmVudGx5IGEgcGFydCBvZlxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBxdWVyeVR5cGUgaW4gdGhpcy5fcXVlcmllcykge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0ucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9wdWxhdGVkIHF1ZXJ5IGFuZCByZXR1cm5zLCBpZiB0aGUgcXVlcnkgYWxyZWFkeSBleGlzdHMgdGhhdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYSBuZXcgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB0eXBlc1xyXG4gICAgICovXHJcbiAgICBjcmVhdGVRdWVyeSh0eXBlcykge1xyXG4gICAgICAgIGNvbnN0IG1heWJlRXhpc3RpbmdRdWVyeSA9IHRoaXMuZ2V0UXVlcnkodHlwZXMpO1xyXG4gICAgICAgIGlmIChtYXliZUV4aXN0aW5nUXVlcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heWJlRXhpc3RpbmdRdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkodHlwZXMpO1xyXG4gICAgICAgIHRoaXMuX2FkZFF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbiBleGlzdGluZyBxdWVyeSBieSB0eXBlcyBpZiBpdCBleGlzdHMgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxyXG4gICAgICogQHBhcmFtIHR5cGVzXHJcbiAgICAgKi9cclxuICAgIGdldFF1ZXJ5KHR5cGVzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYnVpbGRUeXBlS2V5KHR5cGVzKTtcclxuICAgICAgICBpZiAodGhpcy5fcXVlcmllc1trZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL1N5c3RlbU1hbmFnZXIudHNcblxyXG4vKipcclxuICogVGhlIFN5c3RlbU1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIGtlZXBpbmcgdHJhY2sgb2YgYWxsIHN5c3RlbXMgaW4gYSBzY2VuZS5cclxuICogU3lzdGVtcyBhcmUgc2NlbmUgc3BlY2lmaWNcclxuICovXHJcbmNsYXNzIFN5c3RlbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBzeXN0ZW1zLCB0byBhZGQgYSBuZXcgc3lzdGVtIGNhbGwgW1tTeXN0ZW1NYW5hZ2VyLmFkZFN5c3RlbV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zeXN0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBzeXN0ZW0gcmVnaXN0ZXJlZCBpbiB0aGUgbWFuYWdlciBieSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gc3lzdGVtVHlwZVxyXG4gICAgICovXHJcbiAgICBnZXQoc3lzdGVtVHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN5c3RlbXMuZmluZCgocykgPT4gcyBpbnN0YW5jZW9mIHN5c3RlbVR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc3lzdGVtIHRvIHRoZSBtYW5hZ2VyLCBpdCB3aWxsIG5vdyBiZSB1cGRhdGVkIGV2ZXJ5IGZyYW1lXHJcbiAgICAgKiBAcGFyYW0gc3lzdGVtXHJcbiAgICAgKi9cclxuICAgIGFkZFN5c3RlbShzeXN0ZW0pIHtcclxuICAgICAgICAvLyB2YWxpZGF0ZSBzeXN0ZW0gaGFzIHR5cGVzXHJcbiAgICAgICAgaWYgKCFzeXN0ZW0udHlwZXMgfHwgc3lzdGVtLnR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBhZGQgYSBTeXN0ZW0gd2l0aG91dCBhbnkgdHlwZXNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuY3JlYXRlUXVlcnkoc3lzdGVtLnR5cGVzKTtcclxuICAgICAgICB0aGlzLnN5c3RlbXMucHVzaChzeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtcy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XHJcbiAgICAgICAgcXVlcnkucmVnaXN0ZXIoc3lzdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCAmJiBzeXN0ZW0uaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgICAgICBzeXN0ZW0uaW5pdGlhbGl6ZSh0aGlzLl93b3JsZC5jb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBzeXN0ZW0gZnJvbSB0aGUgbWFuYWdlciwgaXQgd2lsbCBubyBsb25nZXIgYmUgdXBkYXRlZFxyXG4gICAgICogQHBhcmFtIHN5c3RlbVxyXG4gICAgICovXHJcbiAgICByZW1vdmVTeXN0ZW0oc3lzdGVtKSB7XHJcbiAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShzeXN0ZW0sIHRoaXMuc3lzdGVtcyk7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuZ2V0UXVlcnkoc3lzdGVtLnR5cGVzKTtcclxuICAgICAgICBpZiAocXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnkudW5yZWdpc3RlcihzeXN0ZW0pO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIubWF5YmVSZW1vdmVRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFsbCBzeXN0ZW1zIGluIHRoZSBtYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogU3lzdGVtcyBhZGRlZCBhZnRlciBpbml0aWFsaXplKCkgd2lsbCBiZSBpbml0aWFsaXplZCBvbiBhZGRcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnN5c3RlbXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLmluaXRpYWxpemUodGhpcy5fd29ybGQuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYWxsIHN5c3RlbXNcclxuICAgICAqIEBwYXJhbSB0eXBlIHdoZXRoZXIgdGhpcyBpcyBhbiB1cGRhdGUgb3IgZHJhdyBzeXN0ZW1cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IGNvbnRleHQgcmVmZXJlbmNlXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlU3lzdGVtcyh0eXBlLCBjb250ZXh0LCBkZWx0YSkge1xyXG4gICAgICAgIGNvbnN0IHN5c3RlbXMgPSB0aGlzLnN5c3RlbXMuZmlsdGVyKChzKSA9PiBzLnN5c3RlbVR5cGUgPT09IHR5cGUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnByZXVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcy5wcmV1cGRhdGUoY29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBlbnRpdGllcyB0aGF0IG1hdGNoIHRoZSBzeXN0ZW0gdHlwZXMsIHByZS1zb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLmdldFF1ZXJ5KHMudHlwZXMpLmdldEVudGl0aWVzKHMuc29ydCk7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgZW50aXRpZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgU2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5Ll9pbml0aWFsaXplKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5lbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMudXBkYXRlKGVudGl0aWVzLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnBvc3R1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHMucG9zdHVwZGF0ZShjb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTeXN0ZW0oc3lzdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vV29ybGQudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBXb3JsZCBpcyBhIHNlbGYtY29udGFpbmVkIGVudGl0eSBjb21wb25lbnQgc3lzdGVtIGZvciBhIHBhcnRpY3VsYXIgY29udGV4dC5cclxuICovXHJcbmNsYXNzIFdvcmxkIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnRleHQgdHlwZSBpcyBwYXNzZWQgdG8gdGhlIHN5c3RlbSB1cGRhdGVzXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlciA9IG5ldyBRdWVyeU1hbmFnZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyID0gbmV3IEVudGl0eU1hbmFnZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyID0gbmV3IFN5c3RlbU1hbmFnZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBzeXN0ZW1zIGJ5IHR5cGUgYW5kIHRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHR5cGUsIGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN5c3RlbVR5cGUuVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci51cGRhdGVFbnRpdGllcyh0aGlzLmNvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLnVwZGF0ZVN5c3RlbXModHlwZSwgdGhpcy5jb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLmZpbmRFbnRpdGllc0ZvclJlbW92YWwoKTtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIucHJvY2Vzc0NvbXBvbmVudFJlbW92YWxzKCk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLnByb2Nlc3NFbnRpdHlSZW1vdmFscygpO1xyXG4gICAgfVxyXG4gICAgYWRkKGVudGl0eU9yU3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eU9yU3lzdGVtIGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci5hZGRFbnRpdHkoZW50aXR5T3JTeXN0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBTeXN0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLmFkZFN5c3RlbShlbnRpdHlPclN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGVudGl0eU9yU3lzdGVtLCBkZWZlcnJlZCA9IHRydWUpIHtcclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLnJlbW92ZUVudGl0eShlbnRpdHlPclN5c3RlbSwgZGVmZXJyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBTeXN0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLnJlbW92ZVN5c3RlbShlbnRpdHlPclN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJFbnRpdGllcygpIHtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGNsZWFyU3lzdGVtcygpIHtcclxuICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9JbnRlZ3JhdG9yLnRzXG5cclxuY2xhc3MgRXVsZXJJbnRlZ3JhdG9yIHtcclxuICAgIHN0YXRpYyBpbnRlZ3JhdGUodHJhbnNmb3JtLCBtb3Rpb24sIHRvdGFsQWNjLCBlbGFwc2VkTXMpIHtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gZWxhcHNlZE1zIC8gMTAwMDtcclxuICAgICAgICAvLyBUaGlzIGNvZGUgbG9va3MgYSBsaXR0bGUgd2lsZCwgYnV0IGl0J3MgdG8gYXZvaWQgY3JlYXRpbmcgYW55IG5ldyBWZWN0b3IgaW5zdGFuY2VzXHJcbiAgICAgICAgLy8gaW50ZWdyYXRpb24gaXMgZG9uZSBpbiBhIHRpZ2h0IGxvb3Agc28gdGhpcyBpcyBrZXkgdG8gYXZvaWQgR0MnaW5nXHJcbiAgICAgICAgbW90aW9uLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzLCBFdWxlckludGVncmF0b3IuX0FDQykpO1xyXG4gICAgICAgIHRyYW5zZm9ybS5wb3NcclxuICAgICAgICAgICAgLmFkZChtb3Rpb24udmVsLnNjYWxlKHNlY29uZHMsIEV1bGVySW50ZWdyYXRvci5fVkVMKSwgRXVsZXJJbnRlZ3JhdG9yLl9QT1MpXHJcbiAgICAgICAgICAgIC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZSgwLjUgKiBzZWNvbmRzICogc2Vjb25kcywgRXVsZXJJbnRlZ3JhdG9yLl9WRUxfQUNDKSk7XHJcbiAgICAgICAgbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSArPSBtb3Rpb24udG9ycXVlICogKDEuMCAvIG1vdGlvbi5pbmVydGlhKSAqIHNlY29uZHM7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb24gKyBtb3Rpb24uYW5ndWxhclZlbG9jaXR5ICogc2Vjb25kcztcclxuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUuYWRkKG1vdGlvbi5zY2FsZUZhY3Rvci5zY2FsZShzZWNvbmRzLCB0aGlzLl9TQ0FMRV9GQUNUT1IpLCBFdWxlckludGVncmF0b3IuX1NDQUxFKTtcclxuICAgICAgICBjb25zdCB0eCA9IHRyYW5zZm9ybS5nZXQoKTtcclxuICAgICAgICB0eC5zZXRUcmFuc2Zvcm0oRXVsZXJJbnRlZ3JhdG9yLl9QT1MsIHJvdGF0aW9uLCBFdWxlckludGVncmF0b3IuX1NDQUxFKTtcclxuICAgIH1cclxufVxyXG4vLyBTY3JhdGNoIHZlY3RvcnMgdG8gYXZvaWQgYWxsb2NhdGlvblxyXG5FdWxlckludGVncmF0b3IuX1BPUyA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbkV1bGVySW50ZWdyYXRvci5fU0NBTEUgPSBuZXcgVmVjdG9yKDEsIDEpO1xyXG5FdWxlckludGVncmF0b3IuX0FDQyA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbkV1bGVySW50ZWdyYXRvci5fVkVMID0gbmV3IFZlY3RvcigwLCAwKTtcclxuRXVsZXJJbnRlZ3JhdG9yLl9WRUxfQUNDID0gbmV3IFZlY3RvcigwLCAwKTtcclxuRXVsZXJJbnRlZ3JhdG9yLl9TQ0FMRV9GQUNUT1IgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Nb3Rpb25TeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBNb3Rpb25TeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nLCAnZXgubW90aW9uJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVudGl0aWVzLCBlbGFwc2VkTXMpIHtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBtb3Rpb247XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRpdGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBlbnRpdGllc1tpXS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgbW90aW9uID0gZW50aXRpZXNbaV0uZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbmFsQm9keSA9IGVudGl0aWVzW2ldLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS5zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG90YWxBY2MgPSBtb3Rpb24uYWNjLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmICgob3B0aW9uYWxCb2R5ID09PSBudWxsIHx8IG9wdGlvbmFsQm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uYWxCb2R5LmNvbGxpc2lvblR5cGUpID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSAmJiAob3B0aW9uYWxCb2R5ID09PSBudWxsIHx8IG9wdGlvbmFsQm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uYWxCb2R5LnVzZUdyYXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEFjYy5hZGRFcXVhbChQaHlzaWNzLmdyYXZpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS5jYXB0dXJlT2xkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm0gYW5kIG1vdGlvbiBiYXNlZCBvbiBFdWxlciBsaW5lYXIgYWxnZWJyYVxyXG4gICAgICAgICAgICBFdWxlckludGVncmF0b3IuaW50ZWdyYXRlKHRyYW5zZm9ybSwgbW90aW9uLCB0b3RhbEFjYywgZWxhcHNlZE1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU29sdmVyL0FyY2FkZVNvbHZlci50c1xuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBcmNhZGVTb2x2ZXIgaXMgdGhlIGRlZmF1bHQgaW4gRXhjYWxpYnVyLiBJdCBzb2x2ZXMgY29sbGlzaW9ucyBzbyB0aGF0IHRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiBjb250YWN0cyxcclxuICogYW5kIG5lZ2F0ZXMgdmVsb2NpdHkgYWxvbmcgdGhlIGNvbGxpc2lvbiBub3JtYWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdXN1YWxseSB0aGUgdHlwZSBvZiBjb2xsaXNpb25zIHVzZWQgZm9yIDJEIGdhbWVzIHRoYXQgZG9uJ3QgbmVlZCBhIG1vcmUgcmVhbGlzdGljIGNvbGxpc2lvbiBzaW11bGF0aW9uLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgQXJjYWRlU29sdmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBzb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIC8vIEV2ZW50cyBhbmQgaW5pdFxyXG4gICAgICAgIHRoaXMucHJlU29sdmUoY29udGFjdHMpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgY2FuY2VsZWQgY29udGFjdHNcclxuICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLmZpbHRlcihjID0+ICFjLmlzQ2FuY2VsZWQoKSk7XHJcbiAgICAgICAgLy8gU29ydCBjb250YWN0cyBieSBkaXN0YW5jZSB0byBhdm9pZCBhcnRpZmFjdHMgd2l0aCBzZWFtc1xyXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHNvbHZlIGluIGEgc3BlY2lmaWMgb3JkZXJcclxuICAgICAgICBjb250YWN0cy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFEaXN0ID0gdGhpcy5kaXN0YW5jZU1hcC5nZXQoYS5pZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJEaXN0ID0gdGhpcy5kaXN0YW5jZU1hcC5nZXQoYi5pZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhRGlzdCAtIGJEaXN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICAvLyBTb2x2ZSBwb3NpdGlvbiBmaXJzdCBpbiBhcmNhZGVcclxuICAgICAgICAgICAgdGhpcy5zb2x2ZVBvc2l0aW9uKGNvbnRhY3QpO1xyXG4gICAgICAgICAgICAvLyBTb2x2ZSB2ZWxvY2l0eSBzZWNvbmQgaW4gYXJjYWRlXHJcbiAgICAgICAgICAgIHRoaXMuc29sdmVWZWxvY2l0eShjb250YWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXZlbnRzIGFuZCBhbnkgY29udGFjdCBob3VzZS1rZWVwaW5nIHRoZSBzb2x2ZXIgbmVlZHNcclxuICAgICAgICB0aGlzLnBvc3RTb2x2ZShjb250YWN0cyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgcHJlU29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2lkZSA9IFNpZGUuZnJvbURpcmVjdGlvbihjb250YWN0Lm10dik7XHJcbiAgICAgICAgICAgIGNvbnN0IG10diA9IGNvbnRhY3QubXR2Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbnRhY3QuY29sbGlkZXJBLndvcmxkUG9zLnNxdWFyZURpc3RhbmNlKGNvbnRhY3QuY29sbGlkZXJCLndvcmxkUG9zKTtcclxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZU1hcC5zZXQoY29udGFjdC5pZCwgZGlzdGFuY2UpO1xyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBQcmVDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIG10dikpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJCLCBjb250YWN0LmNvbGxpZGVyQSwgU2lkZS5nZXRPcHBvc2l0ZShzaWRlKSwgbXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zdFNvbHZlKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3QuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckEgPSBjb250YWN0LmNvbGxpZGVyQTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBTaWRlLmZyb21EaXJlY3Rpb24oY29udGFjdC5tdHYpO1xyXG4gICAgICAgICAgICBjb25zdCBtdHYgPSBjb250YWN0Lm10di5uZWdhdGUoKTtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIG10dikpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBQb3N0Q29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBtdHYubmVnYXRlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzb2x2ZVBvc2l0aW9uKGNvbnRhY3QpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSAuMDAwMTtcclxuICAgICAgICAvLyBpZiBib3VuZHMgbm8gbG9uZ2VyIGludGVyc2VjdCBza2lwIHRvIHRoZSBuZXh0XHJcbiAgICAgICAgLy8gdGhpcyByZW1vdmVzIGppdHRlciBmcm9tIG92ZXJsYXBwaW5nL3N0YWNrZWQgc29saWQgdGlsZXMgb3IgYSB3YWxsIG9mIHNvbGlkIHRpbGVzXHJcbiAgICAgICAgaWYgKCFjb250YWN0LmNvbGxpZGVyQS5ib3VuZHMub3ZlcmxhcHMoY29udGFjdC5jb2xsaWRlckIuYm91bmRzLCBlcHNpbG9uKSkge1xyXG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIGNvbnRhY3QgdG8gcHJldmVudCBhbmQgc29sdmluZ1xyXG4gICAgICAgICAgICBjb250YWN0LmNhbmNlbCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhjb250YWN0Lm10di54KSA8IGVwc2lsb24gJiYgTWF0aC5hYnMoY29udGFjdC5tdHYueSkgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgIC8vIENhbmNlbCBuZWFyIDAgbXR2IGNvbGxpc2lvbnNcclxuICAgICAgICAgICAgY29udGFjdC5jYW5jZWwoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbXR2ID0gY29udGFjdC5tdHY7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJBID0gY29udGFjdC5jb2xsaWRlckE7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlICYmIGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBvdmVybGFwcyBpZiBib3RoIGFyZSBBY3RpdmVcclxuICAgICAgICAgICAgICAgIG10diA9IG10di5zY2FsZSgwLjUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlc29sdmUgb3ZlcmxhcHNcclxuICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5nbG9iYWxQb3MueCAtPSBtdHYueDtcclxuICAgICAgICAgICAgICAgIGJvZHlBLmdsb2JhbFBvcy55IC09IG10di55O1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJBLnVwZGF0ZShib2R5QS50cmFuc2Zvcm0uZ2V0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgYm9keUIuZ2xvYmFsUG9zLnggKz0gbXR2Lng7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5nbG9iYWxQb3MueSArPSBtdHYueTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi51cGRhdGUoYm9keUIudHJhbnNmb3JtLmdldCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNvbHZlVmVsb2NpdHkoY29udGFjdCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKGNvbnRhY3QuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJBID0gY29udGFjdC5jb2xsaWRlckE7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gY29udGFjdC5ub3JtYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlID0gbm9ybWFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRqdXN0IHZlbG9jaXR5IGlmIHRoZSBjb250YWN0IG5vcm1hbCBpcyBvcHBvc2l0ZSB0byB0aGUgY3VycmVudCB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgY2F0Y2hpbmcgZWRnZXMgb24gYSBwbGF0Zm9ybSB3aGVuIHNsaWRpbmcgb2ZmXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEudmVsLm5vcm1hbGl6ZSgpLmRvdChvcHBvc2l0ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIG91dCB2ZWxvY2l0eSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2YgY29sbGlzaW9uIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlbEFkaiA9IG5vcm1hbC5zY2FsZShub3JtYWwuZG90KGJvZHlBLnZlbC5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnZlbCA9IGJvZHlBLnZlbC5hZGQodmVsQWRqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRqdXN0IHZlbG9jaXR5IGlmIHRoZSBjb250YWN0IG5vcm1hbCBpcyBvcHBvc2l0ZSB0byB0aGUgY3VycmVudCB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgY2F0Y2hpbmcgZWRnZXMgb24gYSBwbGF0Zm9ybVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLnZlbC5ub3JtYWxpemUoKS5kb3Qobm9ybWFsKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWxBZGogPSBvcHBvc2l0ZS5zY2FsZShvcHBvc2l0ZS5kb3QoYm9keUIudmVsLm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZCh2ZWxBZGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL1NvbHZlci9Db250YWN0Q29uc3RyYWludFBvaW50LnRzXG5cclxuXHJcbi8qKlxyXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBjb250YWN0IHBvaW50cywgbWVhbnQgdG8gYmUgcmV1c2VkIG92ZXIgbXVsdGlwbGUgZnJhbWVzIG9mIGNvbnRhY3RcclxuICovXHJcbmNsYXNzIENvbnRhY3RDb25zdHJhaW50UG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IocG9pbnQsIGxvY2FsLCBjb250YWN0KSB7XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcHVsc2UgYWNjdW11bGF0ZWQgb3ZlciB0aW1lIGluIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcHVsc2UgYWNjdW11bGF0ZWQgb3ZlciB0aW1lIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmVjdGl2ZSBtYXNzIHNlZW4gaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vcm1hbE1hc3MgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmVjdGl2ZSBtYXNzIHNlZW4gaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YW5nZW50TWFzcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlyZWN0aW9uIGZyb20gY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgdG8gY29udGFjdCBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYVRvQ29udGFjdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlyZWN0aW9uIGZyb20gY2VudGVyIG9mIG1hc3Mgb2YgYm9keUIgdG8gY29udGFjdCBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYlRvQ29udGFjdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3JpZ2luYWwgY29udGFjdCB2ZWxvY2l0eSBjb21iaW5lZCB3aXRoIGJvdW5jaW5lc3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9yaWdpbmFsVmVsb2NpdHlBbmRSZXN0aXR1dGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgY29udGFjdCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IHRoaXMuY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSB0aGlzLmNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSB0aGlzLmNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gdGhpcy5jb250YWN0LnRhbmdlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYVRvQ29udGFjdCA9IHRoaXMucG9pbnQuc3ViKGJvZHlBLmdsb2JhbFBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYlRvQ29udGFjdCA9IHRoaXMucG9pbnQuc3ViKGJvZHlCLmdsb2JhbFBvcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFUb0NvbnRhY3ROb3JtYWwgPSB0aGlzLmFUb0NvbnRhY3QuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdE5vcm1hbCA9IHRoaXMuYlRvQ29udGFjdC5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbE1hc3MgPVxyXG4gICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3ROb3JtYWwgKiBhVG9Db250YWN0Tm9ybWFsICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIGJUb0NvbnRhY3ROb3JtYWwgKiBiVG9Db250YWN0Tm9ybWFsO1xyXG4gICAgICAgICAgICBjb25zdCBhVG9Db250YWN0VGFuZ2VudCA9IHRoaXMuYVRvQ29udGFjdC5jcm9zcyh0YW5nZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdFRhbmdlbnQgPSB0aGlzLmJUb0NvbnRhY3QuY3Jvc3ModGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudE1hc3MgPVxyXG4gICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3RUYW5nZW50ICogYVRvQ29udGFjdFRhbmdlbnQgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VJbmVydGlhICogYlRvQ29udGFjdFRhbmdlbnQgKiBiVG9Db250YWN0VGFuZ2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHZlbG9jaXR5IGJldHdlZW4gYm9keUEgYW5kIGJvZHlCXHJcbiAgICAgKi9cclxuICAgIGdldFJlbGF0aXZlVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IHRoaXMuY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSB0aGlzLmNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBpbiBsaW5lYXIgdGVybXNcclxuICAgICAgICAgICAgLy8gQW5ndWxhciB0byBsaW5lYXIgdmVsb2NpdHkgZm9ybXVsYSAtPiBvbWVnYSA9IHZlbG9jaXR5L3JhZGl1cyBzbyBvbWVnYSB4IHJhZGl1cyA9IHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IHZlbEEgPSBib2R5QS52ZWwuYWRkKFZlY3Rvci5jcm9zcyhib2R5QS5hbmd1bGFyVmVsb2NpdHksIHRoaXMuYVRvQ29udGFjdCkpO1xyXG4gICAgICAgICAgICBjb25zdCB2ZWxCID0gYm9keUIudmVsLmFkZChWZWN0b3IuY3Jvc3MoYm9keUIuYW5ndWxhclZlbG9jaXR5LCB0aGlzLmJUb0NvbnRhY3QpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlbEIuc3ViKHZlbEEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU29sdmVyL1JlYWxpc3RpY1NvbHZlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBSZWFsaXN0aWNTb2x2ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVDb250YWN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyBtYXAgY29udGFjdCBpZCB0byBjb250YWN0IHBvaW50c1xyXG4gICAgICAgIHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50ID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29udGFjdENvbnN0cmFpbnRzKGlkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgIH1cclxuICAgIHNvbHZlKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgLy8gRXZlbnRzIGFuZCBpbml0XHJcbiAgICAgICAgdGhpcy5wcmVTb2x2ZShjb250YWN0cyk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBjYW5jZWxlZCBjb250YWN0c1xyXG4gICAgICAgIGNvbnRhY3RzID0gY29udGFjdHMuZmlsdGVyKGMgPT4gIWMuaXNDYW5jZWxlZCgpKTtcclxuICAgICAgICAvLyBTb2x2ZSB2ZWxvY2l0eSBmaXJzdFxyXG4gICAgICAgIHRoaXMuc29sdmVWZWxvY2l0eShjb250YWN0cyk7XHJcbiAgICAgICAgLy8gU29sdmUgcG9zaXRpb24gbGFzdCBiZWNhdXNlIG5vbi1vdmVybGFwIGlzIHRoZSBtb3N0IGltcG9ydGFudFxyXG4gICAgICAgIHRoaXMuc29sdmVQb3NpdGlvbihjb250YWN0cyk7XHJcbiAgICAgICAgLy8gRXZlbnRzIGFuZCBhbnkgY29udGFjdCBob3VzZS1rZWVwaW5nIHRoZSBzb2x2ZXIgbmVlZHNcclxuICAgICAgICB0aGlzLnBvc3RTb2x2ZShjb250YWN0cyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgcHJlU29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBTaWRlLmZyb21EaXJlY3Rpb24oY29udGFjdC5tdHYpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQS5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgY29udGFjdC5tdHYpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2JlZm9yZWNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUHJlU29sdmVFdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2LCBjb250YWN0KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgUHJlQ29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBjb250YWN0Lm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgnYmVmb3JlY29sbGlzaW9ucmVzb2x2ZScsIG5ldyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50KGNvbnRhY3QuY29sbGlkZXJCLCBjb250YWN0LmNvbGxpZGVyQSwgU2lkZS5nZXRPcHBvc2l0ZShzaWRlKSwgY29udGFjdC5tdHYubmVnYXRlKCksIGNvbnRhY3QpKTtcclxuICAgICAgICAgICAgLy8gTWF0Y2ggYXdha2Ugc3RhdGUgZm9yIHNsZWVwaW5nXHJcbiAgICAgICAgICAgIGNvbnRhY3QubWF0Y2hBd2FrZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGNvbnRhY3RzIHRoYXQgZG9uZVxyXG4gICAgICAgIGNvbnN0IGZpbmlzaGVkQ29udGFjdElkcyA9IEFycmF5LmZyb20odGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQua2V5cygpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjdXJyZW50IGNvbnRhY3RzIHRoYXQgYXJlIG5vdCBkb25lXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluaXNoZWRDb250YWN0SWRzLmluZGV4T2YoY29udGFjdC5pZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5pc2hlZENvbnRhY3RJZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0UG9pbnRzID0gKF9hID0gdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuZ2V0KGNvbnRhY3QuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgbGV0IHBvaW50SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0LnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSBjb250YWN0LnRhbmdlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVRvQ29udGFjdCA9IHBvaW50LnN1Yihib2R5QS5nbG9iYWxQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3QgPSBwb2ludC5zdWIoYm9keUIuZ2xvYmFsUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVG9Db250YWN0Tm9ybWFsID0gYVRvQ29udGFjdC5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3ROb3JtYWwgPSBiVG9Db250YWN0LmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsTWFzcyA9IGJvZHlBLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3ROb3JtYWwgKiBhVG9Db250YWN0Tm9ybWFsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZUluZXJ0aWEgKiBiVG9Db250YWN0Tm9ybWFsICogYlRvQ29udGFjdE5vcm1hbDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVG9Db250YWN0VGFuZ2VudCA9IGFUb0NvbnRhY3QuY3Jvc3ModGFuZ2VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdFRhbmdlbnQgPSBiVG9Db250YWN0LmNyb3NzKHRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRNYXNzID0gYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlTWFzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLmludmVyc2VJbmVydGlhICogYVRvQ29udGFjdFRhbmdlbnQgKiBhVG9Db250YWN0VGFuZ2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VJbmVydGlhICogYlRvQ29udGFjdFRhbmdlbnQgKiBiVG9Db250YWN0VGFuZ2VudDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBub3JtYWwvdGFuZ2VudCBpbXB1bHNlIGJ5IHJlLXVzaW5nIHRoZSBjb250YWN0IHBvaW50IGlmIGl0J3MgY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdFBvaW50c1twb2ludEluZGV4XSAmJiAoKF9jID0gKF9iID0gY29udGFjdFBvaW50c1twb2ludEluZGV4XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBvaW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3F1YXJlRGlzdGFuY2UocG9pbnQpKSA8IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLmxvY2FsID0gY29udGFjdC5sb2NhbFBvaW50c1twb2ludEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBjb250YWN0IGlmIGl0J3Mgbm90IGNsb3NlIG9yIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XSA9IG5ldyBDb250YWN0Q29uc3RyYWludFBvaW50KHBvaW50LCBjb250YWN0LmxvY2FsUG9pbnRzW3BvaW50SW5kZXhdLCBjb250YWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgcG9pbnQgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5hVG9Db250YWN0ID0gYVRvQ29udGFjdDtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLmJUb0NvbnRhY3QgPSBiVG9Db250YWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0ubm9ybWFsTWFzcyA9IDEuMCAvIG5vcm1hbE1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS50YW5nZW50TWFzcyA9IDEuMCAvIHRhbmdlbnRNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBiZWZvcmUgc29sdmluZyB0byBhY2N1cmF0ZWx5IGRvIHJlc3RpdHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdGl0dXRpb24gPSBib2R5QS5ib3VuY2luZXNzID4gYm9keUIuYm91bmNpbmVzcyA/IGJvZHlBLmJvdW5jaW5lc3MgOiBib2R5Qi5ib3VuY2luZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlVmVsb2NpdHkgPSBjb250YWN0Lm5vcm1hbC5kb3QoY29udGFjdFBvaW50c1twb2ludEluZGV4XS5nZXRSZWxhdGl2ZVZlbG9jaXR5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0ub3JpZ2luYWxWZWxvY2l0eUFuZFJlc3RpdHV0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVWZWxvY2l0eSA8IC0wLjEpIHsgLy8gVE9ETyB3aGF0J3MgYSBnb29kIHRocmVzaG9sZCBoZXJlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLm9yaWdpbmFsVmVsb2NpdHlBbmRSZXN0aXR1dGlvbiA9IC1yZXN0aXR1dGlvbiAqIHJlbGF0aXZlVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5zZXQoY29udGFjdC5pZCwgY29udGFjdFBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBjb250YWN0cyB0aGF0IGRpZCBub3Qgb2NjdXIgbGFzdCBmcmFtZVxyXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZmluaXNoZWRDb250YWN0SWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50LmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhcm0gY29udGFjdHMgd2l0aCBhY2N1bXVsYXRlZCBpbXB1bHNlXHJcbiAgICAgICAgLy8gVXNlZnVsIGZvciB0YWxsIHN0YWNrc1xyXG4gICAgICAgIGlmIChQaHlzaWNzLndhcm1TdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLndhcm1TdGFydChjb250YWN0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RQb2ludHMgPSB0aGlzLmdldENvbnRhY3RDb25zdHJhaW50cyhjb250YWN0LmlkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdFBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvc3RTb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwb3N0IHNvbHZlIGZvciBhY3RpdmUrcGFzc2l2ZSBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1vdGlvbiB2YWx1ZXMgZm9yIHNsZWVwaW5nXHJcbiAgICAgICAgICAgICAgICBib2R5QS51cGRhdGVNb3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnVwZGF0ZU1vdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlID0gU2lkZS5mcm9tRGlyZWN0aW9uKGNvbnRhY3QubXR2KTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgUG9zdENvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgY29udGFjdC5tdHYpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2FmdGVyY29sbGlzaW9ucmVzb2x2ZScsIG5ldyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2LCBjb250YWN0KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQiwgY29udGFjdC5jb2xsaWRlckEsIFNpZGUuZ2V0T3Bwb3NpdGUoc2lkZSksIGNvbnRhY3QubXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdhZnRlcmNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBjb250YWN0Lm10di5uZWdhdGUoKSwgY29udGFjdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdG9yZSBjb250YWN0c1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQ29udGFjdHMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0RnJhbWVDb250YWN0cy5zZXQoYy5pZCwgYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXJtIHVwIGJvZHkncyBiYXNlZCBvbiBwcmV2aW91cyBmcmFtZSBjb250YWN0IHBvaW50c1xyXG4gICAgICogQHBhcmFtIGNvbnRhY3RzXHJcbiAgICAgKi9cclxuICAgIHdhcm1TdGFydChjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RQb2ludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0UG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3Mud2FybVN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbC5zY2FsZShwb2ludC5ub3JtYWxJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFuZ2VudEltcHVsc2UgPSBjb250YWN0LnRhbmdlbnQuc2NhbGUocG9pbnQudGFuZ2VudEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbm9ybWFsSW1wdWxzZS5hZGQodGFuZ2VudEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQubm9ybWFsSW1wdWxzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGl2ZWx5IHNvbHZlIHRoZSBwb3NpdGlvbiBvdmVybGFwIGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSBjb250YWN0c1xyXG4gICAgICovXHJcbiAgICBzb2x2ZVBvc2l0aW9uKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQaHlzaWNzLnBvc2l0aW9uSXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29udGFjdC5jb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNvbHZpbmcgYWN0aXZlK3Bhc3NpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gY29udGFjdC5ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRpb24gPSBDb2xsaXNpb25KdW1wVGFibGUuRmluZENvbnRhY3RTZXBhcmF0aW9uKGNvbnRhY3QsIHBvaW50LmxvY2FsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlZXJpbmdDb25zdGFudCA9IFBoeXNpY3Muc3RlZXJpbmdGYWN0b3I7IC8vMC4yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhDb3JyZWN0aW9uID0gLTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3AgPSBQaHlzaWNzLnNsb3A7IC8vMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xhbXAgdG8gYXZvaWQgb3Zlci1jb3JyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgd2UgYXJlIHNob290aW5nIGZvciAwIG92ZXJsYXAgaW4gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVlcmluZ0ZvcmNlID0gY2xhbXAoc3RlZXJpbmdDb25zdGFudCAqIChzZXBhcmF0aW9uICsgc2xvcCksIG1heENvcnJlY3Rpb24sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbm9ybWFsLnNjYWxlKC1zdGVlcmluZ0ZvcmNlICogcG9pbnQubm9ybWFsTWFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwc2V1ZG8gaW1wdWxzZSwgbWVhbmluZyB3ZSBhcmVuJ3QgZG9pbmcgYSByZWFsIGltcHVsc2UgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWRqdXN0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBpbnN0ZWFkIG9mIGRvaW5nIHRoZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBhcHBseVBzZXVkb0ltcHVsc2UgZnVuY3Rpb24/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXB1bHNlRm9yY2UgPSBpbXB1bHNlLm5lZ2F0ZSgpLnNjYWxlKGJvZHlBLmludmVyc2VNYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uWCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlRm9yY2UueCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZUZvcmNlLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuZ2xvYmFsUG9zID0gYm9keUEuZ2xvYmFsUG9zLmFkZChpbXB1bHNlRm9yY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5QS5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uUm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucm90YXRpb24gLT0gcG9pbnQuYVRvQ29udGFjdC5jcm9zcyhpbXB1bHNlKSAqIGJvZHlBLmludmVyc2VJbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wdWxzZUZvcmNlID0gaW1wdWxzZS5zY2FsZShib2R5Qi5pbnZlcnNlTWFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUIubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZUZvcmNlLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlCLmxpbWl0RGVncmVlT2ZGcmVlZG9tLmluY2x1ZGVzKERlZ3JlZU9mRnJlZWRvbS5ZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2VGb3JjZS55ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmdsb2JhbFBvcyA9IGJvZHlCLmdsb2JhbFBvcy5hZGQoaW1wdWxzZUZvcmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYm9keUIubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlJvdGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnJvdGF0aW9uICs9IHBvaW50LmJUb0NvbnRhY3QuY3Jvc3MoaW1wdWxzZSkgKiBib2R5Qi5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNvbHZlVmVsb2NpdHkoY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBoeXNpY3MudmVsb2NpdHlJdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgc29sdmluZyBhY3RpdmUrcGFzc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmljdGlvbiA9IE1hdGgubWluKGJvZHlBLmZyaWN0aW9uLCBib2R5Qi5mcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZyaWN0aW9uIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlVmVsb2NpdHkgPSBwb2ludC5nZXRSZWxhdGl2ZVZlbG9jaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZ2F0ZSB2ZWxvY2l0eSBpbiB0YW5nZW50IGRpcmVjdGlvbiB0byBzaW11bGF0ZSBmcmljdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50VmVsb2NpdHkgPSAtcmVsYXRpdmVWZWxvY2l0eS5kb3QoY29udGFjdC50YW5nZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcHVsc2VEZWx0YSA9IHRhbmdlbnRWZWxvY2l0eSAqIHBvaW50LnRhbmdlbnRNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcGluZyBiYXNlZCBpbiBFcmluIENhdHRvJ3MgR0RDIDIwMDYgdGFsa1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IGNsYW1waW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9lcmluY2F0dG8vYm94MmQtbGl0ZS9ibG9iL21hc3Rlci9kb2NzL0dEQzIwMDZfQ2F0dG9fRXJpbl9QaHlzaWNzVHV0b3JpYWwucGRmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVkIGZpY3Rpb24gaW1wdWxzZSBpcyBhbHdheXMgYmV0d2VlbiAtdU1heEZyaWN0aW9uIDwgZFQgPCB1TWF4RnJpY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGRlbHRhcyBjYW4gdmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhGcmljdGlvbiA9IGZyaWN0aW9uICogcG9pbnQubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IGNsYW1wKHBvaW50LnRhbmdlbnRJbXB1bHNlICsgaW1wdWxzZURlbHRhLCAtbWF4RnJpY3Rpb24sIG1heEZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZURlbHRhID0gbmV3SW1wdWxzZSAtIHBvaW50LnRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC50YW5nZW50SW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcHVsc2UgPSBjb250YWN0LnRhbmdlbnQuc2NhbGUoaW1wdWxzZURlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm91bmNlIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVjYWxjIHJlbGF0aXZlIHZlbG9jaXR5IGJlY2F1c2UgdGhlIHByZXZpb3VzIHN0ZXAgY291bGQgaGF2ZSBjaGFuZ2VkIHZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVZlbG9jaXR5ID0gcG9pbnQuZ2V0UmVsYXRpdmVWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGltcHVsc2UgaW4gbm9ybWFsIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxWZWxvY2l0eSA9IHJlbGF0aXZlVmVsb2NpdHkuZG90KGNvbnRhY3Qubm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyIEVyaW4gaXQgaXMgYSBtaXN0YWtlIHRvIGFwcGx5IHRoZSByZXN0aXR1dGlvbiBpbnNpZGUgdGhlIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGcm9tIEVyaW4gQ2F0dG8ncyBCb3gyRCB3ZSBrZWVwIG9yaWdpbmFsIGNvbnRhY3QgdmVsb2NpdHkgYW5kIGFkanVzdCBieSBzbWFsbCBpbXB1bHNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1wdWxzZURlbHRhID0gLXBvaW50Lm5vcm1hbE1hc3MgKiAobm9ybWFsVmVsb2NpdHkgLSBwb2ludC5vcmlnaW5hbFZlbG9jaXR5QW5kUmVzdGl0dXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcGluZyBiYXNlZCBpbiBFcmluIENhdHRvJ3MgR0RDIDIwMTQgdGFsa1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlZCBpbXB1bHNlIHN0b3JlZCBpbiB0aGUgY29udGFjdCBpcyBhbHdheXMgcG9zaXRpdmUgKGRWID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGRlbHRhcyBjYW4gYmUgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IE1hdGgubWF4KHBvaW50Lm5vcm1hbEltcHVsc2UgKyBpbXB1bHNlRGVsdGEsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlRGVsdGEgPSBuZXdJbXB1bHNlIC0gcG9pbnQubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQubm9ybWFsSW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcHVsc2UgPSBjb250YWN0Lm5vcm1hbC5zY2FsZShpbXB1bHNlRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaXNpb25TeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4Lm1vdGlvbicsICdleC5jb2xsaWRlciddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuVXBkYXRlO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTtcclxuICAgICAgICB0aGlzLl9yZWFsaXN0aWNTb2x2ZXIgPSBuZXcgUmVhbGlzdGljU29sdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fYXJjYWRlU29sdmVyID0gbmV3IEFyY2FkZVNvbHZlcigpO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvciA9IG5ldyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvcigpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrQ29sbGlkZXIgPSAoYykgPT4gdGhpcy5fcHJvY2Vzc29yLnRyYWNrKGMpO1xyXG4gICAgICAgIHRoaXMuX3VudHJhY2tDb2xsaWRlciA9IChjKSA9PiB0aGlzLl9wcm9jZXNzb3IudW50cmFjayhjKTtcclxuICAgIH1cclxuICAgIG5vdGlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRTeXN0ZW1FbnRpdHkobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJDb21wb25lbnQgPSBtZXNzYWdlLmRhdGEuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29sbGlkZXJDb21wb25lbnQuJGNvbGxpZGVyQWRkZWQuc3Vic2NyaWJlKHRoaXMuX3RyYWNrQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICBjb2xsaWRlckNvbXBvbmVudC4kY29sbGlkZXJSZW1vdmVkLnN1YnNjcmliZSh0aGlzLl91bnRyYWNrQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IGNvbGxpZGVyQ29tcG9uZW50LmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3Nvci50cmFjayhjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQ29tcG9uZW50ID0gbWVzc2FnZS5kYXRhLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wb25lbnQuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlckNvbXBvbmVudCAmJiBjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc29yLnVudHJhY2soY29sbGlkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IHNjZW5lLmVuZ2luZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbnRpdGllcywgZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGlmICghUGh5c2ljcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29sbGVjdCB1cCBhbGwgdGhlIGNvbGxpZGVycyBhbmQgdXBkYXRlIHRoZW1cclxuICAgICAgICBsZXQgY29sbGlkZXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJDb21wID0gZW50aXR5LmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wID09PSBudWxsIHx8IGNvbGxpZGVyQ29tcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGlkZXJDb21wLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXJDb21wICYmICgoX2EgPSBjb2xsaWRlckNvbXAub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmUpICYmIGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckNvbXAudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZUNvbGxpZGVycyA9IGNvbGxpZGVyLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycyA9IGNvbGxpZGVycy5jb25jYXQoY29tcG9zaXRlQ29sbGlkZXJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycy5wdXNoKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNwYXRpYWwgcGFydGl0aW9uaW5nIGRhdGEgc3RydWN0dXJlc1xyXG4gICAgICAgIC8vIFRPRE8gaWYgY29sbGlkZXIgaW52YWxpZCBpdCB3aWxsIGJyZWFrIHRoZSBwcm9jZXNzb3JcclxuICAgICAgICAvLyBUT0RPIHJlbmFtZSBcInVwZGF0ZVwiIHRvIHNvbWV0aGluZyBtb3JlIHNwZWNpZmljXHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yLnVwZGF0ZShjb2xsaWRlcnMpO1xyXG4gICAgICAgIC8vIFJ1biBicm9hZHBoYXNlIG9uIGFsbCBjb2xsaWRlcnMgYW5kIGxvY2F0ZXMgcG90ZW50aWFsIGNvbGxpc2lvbnNcclxuICAgICAgICBjb25zdCBwYWlycyA9IHRoaXMuX3Byb2Nlc3Nvci5icm9hZHBoYXNlKGNvbGxpZGVycywgZWxhcHNlZE1zKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWVDb250YWN0cy5jbGVhcigpO1xyXG4gICAgICAgIC8vIEdpdmVuIHBvc3NpYmxlIHBhaXJzIGZpbmQgYWN0dWFsIGNvbnRhY3RzXHJcbiAgICAgICAgbGV0IGNvbnRhY3RzID0gdGhpcy5fcHJvY2Vzc29yLm5hcnJvd3BoYXNlKHBhaXJzLCAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLl9lbmdpbmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWJ1ZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY3VyckZyYW1lKTtcclxuICAgICAgICBjb25zdCBzb2x2ZXIgPSB0aGlzLmdldFNvbHZlcigpO1xyXG4gICAgICAgIC8vIFNvbHZlLCB0aGlzIHJlc29sdmVzIHRoZSBwb3NpdGlvbi92ZWxvY2l0eSBzbyBlbnRpdGllcyBhcmVuJ3Qgb3ZlcmxhcHBpbmdcclxuICAgICAgICBjb250YWN0cyA9IHNvbHZlci5zb2x2ZShjb250YWN0cyk7XHJcbiAgICAgICAgLy8gUmVjb3JkIGNvbnRhY3RzIGZvciBzdGFydC9lbmRcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBjb21wb3NpdGUgaWRzLCB0aGluZ3Mgd2l0aCB0aGUgc2FtZSBjb21wb3NpdGUgaWQgYXJlIHRyZWF0ZWQgYXMgdGhlIHNhbWUgY29sbGlkZXIgZm9yIHN0YXJ0L2VuZFxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRhY3QuaWQuaW5kZXhPZignfCcpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVJZCA9IGNvbnRhY3QuaWQuc3Vic3RyaW5nKGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWVDb250YWN0cy5zZXQoY29tcG9zaXRlSWQsIGNvbnRhY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lQ29udGFjdHMuc2V0KGNvbnRhY3QuaWQsIGNvbnRhY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVtaXQgY29udGFjdCBzdGFydC9lbmQgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5ydW5Db250YWN0U3RhcnRFbmQoKTtcclxuICAgICAgICAvLyByZXNldCB0aGUgbGFzdCBmcmFtZSBjYWNoZVxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBjb2xsaXNpb25zIGNvbnRhY3RzIHRoYXQgaGF2ZSBzdGFydGVkIG9yIGVuZGVkXHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lQ29udGFjdHMgPSBuZXcgTWFwKHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzKTtcclxuICAgIH1cclxuICAgIGdldFNvbHZlcigpIHtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPT09IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWMgPyB0aGlzLl9yZWFsaXN0aWNTb2x2ZXIgOiB0aGlzLl9hcmNhZGVTb2x2ZXI7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCkge1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3Nvci5kZWJ1ZyhleCk7XHJcbiAgICB9XHJcbiAgICBydW5Db250YWN0U3RhcnRFbmQoKSB7XHJcbiAgICAgICAgLy8gQ29tcG9zaXRlIGNvbGxpZGVyIGNvbGxpc2lvbnMgbWF5IGhhdmUgYSBkdXBsaWNhdGUgaWQgYmVjYXVzZSB3ZSB3YW50IHRvIHRyZWF0IHRob3NlIGFzIGEgc2luZ3VsYXIgc3RhcnQvZW5kXHJcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGNdIG9mIHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb250YWN0c1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGMuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gYy5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IENvbGxpc2lvblN0YXJ0RXZlbnQoY29sbGlkZXJBLCBjb2xsaWRlckIsIGMpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQS5ldmVudHMuZW1pdCgnY29udGFjdHN0YXJ0JywgbmV3IENvbnRhY3RTdGFydEV2ZW50KGNvbGxpZGVyQSwgY29sbGlkZXJCLCBjKSk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckIuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IENvbGxpc2lvblN0YXJ0RXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEsIGMpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5ldmVudHMuZW1pdCgnY29udGFjdHN0YXJ0JywgbmV3IENvbnRhY3RTdGFydEV2ZW50KGNvbGxpZGVyQiwgY29sbGlkZXJBLCBjKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluZCBhbGwgY29udGFjdHMgdGhhdCBoYXZlIGNlYXNlZFxyXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBjXSBvZiB0aGlzLl9sYXN0RnJhbWVDb250YWN0cykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGMuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gYy5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBDb2xsaXNpb25FbmRFdmVudChjb2xsaWRlckEsIGNvbGxpZGVyQikpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdjb250YWN0ZW5kJywgbmV3IENvbnRhY3RFbmRFdmVudChjb2xsaWRlckEsIGNvbGxpZGVyQikpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgQ29sbGlzaW9uRW5kRXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5ldmVudHMuZW1pdCgnY29udGFjdGVuZCcsIG5ldyBDb250YWN0RW5kRXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0FuaW1hdGlvbi50c1xuXHJcblxyXG5cclxuXHJcbnZhciBBbmltYXRpb25EaXJlY3Rpb247XHJcbihmdW5jdGlvbiAoQW5pbWF0aW9uRGlyZWN0aW9uKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBpcyBwbGF5aW5nIGZvcndhcmRzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkRpcmVjdGlvbltcIkZvcndhcmRcIl0gPSBcImZvcndhcmRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGlzIHBsYXkgYmFja3dhcmRzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvbkRpcmVjdGlvbltcIkJhY2t3YXJkXCJdID0gXCJiYWNrd2FyZFwiO1xyXG59KShBbmltYXRpb25EaXJlY3Rpb24gfHwgKEFuaW1hdGlvbkRpcmVjdGlvbiA9IHt9KSk7XHJcbnZhciBBbmltYXRpb25TdHJhdGVneTtcclxuKGZ1bmN0aW9uIChBbmltYXRpb25TdHJhdGVneSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gZW5kcyB3aXRob3V0IGRpc3BsYXlpbmcgYW55dGhpbmdcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uU3RyYXRlZ3lbXCJFbmRcIl0gPSBcImVuZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gbG9vcHMgdG8gdGhlIGZpcnN0IGZyYW1lIGFmdGVyIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblN0cmF0ZWd5W1wiTG9vcFwiXSA9IFwibG9vcFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gcGxheXMgdG8gdGhlIGxhc3QgZnJhbWUsIHRoZW4gYmFja3dhcmRzIHRvIHRoZSBmaXJzdCBmcmFtZSwgdGhlbiByZXBlYXRzXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblN0cmF0ZWd5W1wiUGluZ1BvbmdcIl0gPSBcInBpbmdwb25nXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBlbmRzIHN0b3BwaW5nIG9uIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblN0cmF0ZWd5W1wiRnJlZXplXCJdID0gXCJmcmVlemVcIjtcclxufSkoQW5pbWF0aW9uU3RyYXRlZ3kgfHwgKEFuaW1hdGlvblN0cmF0ZWd5ID0ge30pKTtcclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBBbmltYXRpb24gZ2l2ZW4gYSBsaXN0IG9mIFtbRnJhbWV8ZnJhbWVzXV0gaW4gW1tBbmltYXRpb25PcHRpb25zXV1cclxuICpcclxuICogVG8gY3JlYXRlIGFuIEFuaW1hdGlvbiBmcm9tIGEgW1tTcHJpdGVTaGVldF1dLCB1c2UgW1tBbmltYXRpb24uZnJvbVNwcml0ZVNoZWV0XV1cclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbiBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7IC8vIFRPRE8gcmVwbGFjZSB3aXRoIG5ldyBFbWl0dGVyXHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcDtcclxuICAgICAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSAxMDA7XHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPSAtMTtcclxuICAgICAgICB0aGlzLl9maXJzdFRpY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxOyAvLyBUT0RPIG9ubHkgdXNlZCBpbiBwaW5nLXBvbmdcclxuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IG9wdGlvbnMuZnJhbWVzO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAoX2EgPSBvcHRpb25zLnN0cmF0ZWd5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IG9wdGlvbnMudG90YWxEdXJhdGlvbiA/IG9wdGlvbnMudG90YWxEdXJhdGlvbiAvIHRoaXMuZnJhbWVzLmxlbmd0aCA6IChfYiA9IG9wdGlvbnMuZnJhbWVEdXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5mcmFtZUR1cmF0aW9uO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ29Ub0ZyYW1lKDApO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oe1xyXG4gICAgICAgICAgICBmcmFtZXM6IHRoaXMuZnJhbWVzLm1hcCgoZikgPT4gKHsgLi4uZiB9KSksXHJcbiAgICAgICAgICAgIGZyYW1lRHVyYXRpb246IHRoaXMuZnJhbWVEdXJhdGlvbixcclxuICAgICAgICAgICAgcmV2ZXJzZTogdGhpcy5fcmV2ZXJzZWQsXHJcbiAgICAgICAgICAgIHN0cmF0ZWd5OiB0aGlzLnN0cmF0ZWd5LFxyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIGNvbnN0IG1heWJlRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICBpZiAobWF5YmVGcmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF5YmVGcmFtZS5ncmFwaGljLndpZHRoICogdGhpcy5zY2FsZS54KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIGNvbnN0IG1heWJlRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICBpZiAobWF5YmVGcmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobWF5YmVGcmFtZS5ncmFwaGljLmhlaWdodCAqIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gQW5pbWF0aW9uIGZyb20gYSBbW1Nwcml0ZVNoZWV0XV0sIGEgbGlzdCBvZiBpbmRpY2VzIGludG8gdGhlIHNwcml0ZSBzaGVldCwgYSBkdXJhdGlvbiBwZXIgZnJhbWVcclxuICAgICAqIGFuZCBvcHRpb25hbCBbW0FuaW1hdGlvblN0cmF0ZWd5XV1cclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlOlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3Qgc3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2Uoey4uLn0pO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGFuaW0gPSBBbmltYXRpb24uZnJvbVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0LCByYW5nZSgwLCA1KSwgMjAwLCBBbmltYXRpb25TdHJhdGVneS5Mb29wKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcHJpdGVTaGVldFxyXG4gICAgICogQHBhcmFtIGZyYW1lSW5kaWNlc1xyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uUGVyRnJhbWVNc1xyXG4gICAgICogQHBhcmFtIHN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3ByaXRlU2hlZXQoc3ByaXRlU2hlZXQsIGZyYW1lSW5kaWNlcywgZHVyYXRpb25QZXJGcmFtZU1zLCBzdHJhdGVneSA9IEFuaW1hdGlvblN0cmF0ZWd5Lkxvb3ApIHtcclxuICAgICAgICBjb25zdCBtYXhJbmRleCA9IHNwcml0ZVNoZWV0LnNwcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBjb25zdCBpbnZhbGlkSW5kaWNlcyA9IGZyYW1lSW5kaWNlcy5maWx0ZXIoKGluZGV4KSA9PiBpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCk7XHJcbiAgICAgICAgaWYgKGludmFsaWRJbmRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBBbmltYXRpb24uX0xPR0dFUi53YXJuKGBJbmRpY2VzIGludG8gU3ByaXRlU2hlZXQgd2VyZSBwcm92aWRlZCB0aGF0IGRvblxcJ3QgZXhpc3Q6ICR7aW52YWxpZEluZGljZXMuam9pbignLCcpfSBubyBmcmFtZSB3aWxsIGJlIHNob3duYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKHtcclxuICAgICAgICAgICAgZnJhbWVzOiBzcHJpdGVTaGVldC5zcHJpdGVzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChfLCBpbmRleCkgPT4gZnJhbWVJbmRpY2VzLmluZGV4T2YoaW5kZXgpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAubWFwKChmKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYzogZixcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblBlckZyYW1lTXNcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBGcmFtZSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50RnJhbWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRGcmFtZSA+PSAwICYmIHRoaXMuX2N1cnJlbnRGcmFtZSA8IHRoaXMuZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXNbdGhpcy5fY3VycmVudEZyYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudEZyYW1lSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRGcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBpc1BsYXlpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldmVyc2VzIHRoZSBwbGF5IGRpcmVjdGlvbiBvZiB0aGUgQW5pbWF0aW9uLCB0aGlzIHByZXNlcnZlcyB0aGUgY3VycmVudCBmcmFtZVxyXG4gICAgICovXHJcbiAgICByZXZlcnNlKCkge1xyXG4gICAgICAgIC8vIERvbid0IG11dGF0ZSB3aXRoIHRoZSBvcmlnaW5hbCBmcmFtZSBsaXN0LCBjcmVhdGUgYSBjb3B5XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSB0aGlzLmZyYW1lcy5zbGljZSgpLnJldmVyc2UoKTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5IGRpcmVjdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBkaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gS2VlcCBsb2dpY2FsbHkgY29uc2lzdGVudCB3aXRoIHBpbmctcG9uZyBkaXJlY3Rpb25cclxuICAgICAgICAvLyBJZiBwaW5nLXBvbmcgaXMgZm9yd2FyZCA9IDEgYW5kIHJldmVyc2VkIGlzIHRydWUgdGhlbiB3ZSBhcmUgbG9naWNhbGx5IHJldmVyc2VkXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSAodGhpcy5fcmV2ZXJzZWQgJiYgdGhpcy5fZGlyZWN0aW9uID09PSAxKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmV2ZXJzZWQgPyBBbmltYXRpb25EaXJlY3Rpb24uQmFja3dhcmQgOiBBbmltYXRpb25EaXJlY3Rpb24uRm9yd2FyZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgb3IgcmVzdW1lcyB0aGUgYW5pbWF0aW9uIGZyb20gdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAqL1xyXG4gICAgcGxheSgpIHtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIHRoZSBhbmltYXRpb24gb24gdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAqL1xyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0VGljayA9IHRydWU7IC8vIGZpcnN0VGljayBtdXN0IGJlIHNldCB0byBlbWl0IHRoZSBwcm9wZXIgZnJhbWUgZXZlbnRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGFuaW1hdGlvbiBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIGluY2x1ZGluZyBpZiB0aGUgYW5pbWF0aW9uIHdlcmUgZG9uZVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZmlyc3RUaWNrID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uIGNhbiBlbmRcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbkZpbmlzaCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5FbmQ6XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuRnJlZXplOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhbmltYXRpb24gaXMgZG9uZSwgZm9yIGxvb3BpbmcgdHlwZSBhbmltYXRpb25zXHJcbiAgICAgKiBgZXguQW5pbWF0aW9uU3RyYXRlZ3kuUGluZ1BvbmdgIGFuZCBgZXguQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcGAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gYGZhbHNlYFxyXG4gICAgICpcclxuICAgICAqIFNlZSB0aGUgYGV4LkFuaW1hdGlvbi5jYW5GaW5pc2goKWAgbWV0aG9kIHRvIGtub3cgaWYgYW4gYW5pbWF0aW9uIHR5cGUgY2FuIGVuZFxyXG4gICAgICovXHJcbiAgICBnZXQgZG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9uZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSnVtcCB0aGUgYW5pbWF0aW9uIGltbWVkaWF0ZWx5IHRvIGEgc3BlY2lmaWMgZnJhbWUgaWYgaXQgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0gZnJhbWVOdW1iZXJcclxuICAgICAqL1xyXG4gICAgZ29Ub0ZyYW1lKGZyYW1lTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gdGhpcy5mcmFtZUR1cmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IG1heWJlRnJhbWUgPSB0aGlzLmZyYW1lc1t0aGlzLl9jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgIGlmIChtYXliZUZyYW1lICYmICF0aGlzLl9kb25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSA9IChtYXliZUZyYW1lID09PSBudWxsIHx8IG1heWJlRnJhbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlRnJhbWUuZHVyYXRpb24pIHx8IHRoaXMuZnJhbWVEdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnZnJhbWUnLCBtYXliZUZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbmV4dEZyYW1lKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcclxuICAgICAgICBpZiAodGhpcy5fZG9uZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dCA9IC0xO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdHJhdGVneSkge1xyXG4gICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0cmF0ZWd5Lkxvb3A6IHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSAoY3VycmVudEZyYW1lICsgMSkgJSB0aGlzLmZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2xvb3AnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuRW5kOiB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudEZyYW1lICsgMTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IHRoaXMuZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdlbmQnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuRnJlZXplOiB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gY2xhbXAoY3VycmVudEZyYW1lICsgMSwgMCwgdGhpcy5mcmFtZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSB0aGlzLmZyYW1lcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnZW5kJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0cmF0ZWd5LlBpbmdQb25nOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lICsgdGhpcy5fZGlyZWN0aW9uID49IHRoaXMuZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2xvb3AnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgKyB0aGlzLl9kaXJlY3Rpb24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb29wJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudEZyYW1lICsgKHRoaXMuX2RpcmVjdGlvbiAlIHRoaXMuZnJhbWVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGludGVybmFsbHkgYnkgRXhjYWxpYnVyIHRvIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGFuaW1hdGlvbiBwb3RlbnRpYWwgdXBkYXRlIHRoZSBjdXJyZW50IGZyYW1lXHJcbiAgICAgKiBAcGFyYW0gZWxhcHNlZE1pbGxpc2Vjb25kcyBNaWxsaXNlY29uZHMgZWxhcHNlZFxyXG4gICAgICogQHBhcmFtIGlkZW1wb3RlbmN5VG9rZW4gUHJldmVudHMgZG91YmxlIHRpY2tpbmcgaW4gYSBmcmFtZSBieSBwYXNzaW5nIGEgdW5pcXVlIHRva2VuIHRvIHRoZSBmcmFtZVxyXG4gICAgICovXHJcbiAgICB0aWNrKGVsYXBzZWRNaWxsaXNlY29uZHMsIGlkZW1wb3RlbmN5VG9rZW4gPSAwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPT09IGlkZW1wb3RlbmN5VG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pZGVtcG90ZW5jeVRva2VuID0gaWRlbXBvdGVuY3lUb2tlbjtcclxuICAgICAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBmcmFtZSBlbWl0IGZyYW1lIGV2ZW50XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0VGljaykge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJzdFRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnZnJhbWUnLCB0aGlzLmN1cnJlbnRGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSAtPSBlbGFwc2VkTWlsbGlzZWNvbmRzICogdGhpcy50aW1lU2NhbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ29Ub0ZyYW1lKHRoaXMuX25leHRGcmFtZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGN0eCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZS5ncmFwaGljLmRyYXcoY3R4LCB4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQW5pbWF0aW9uLl9MT0dHRVIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc0dyb3VwLnRzXG5cclxuXHJcblxyXG5jbGFzcyBHcmFwaGljc0dyb3VwIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gb3B0aW9ucy5tZW1iZXJzO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3NHcm91cCh7XHJcbiAgICAgICAgICAgIG1lbWJlcnM6IFsuLi50aGlzLm1lbWJlcnNdLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZURpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgbGV0IGJiID0gbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMsIHBvcyB9IG9mIHRoaXMubWVtYmVycykge1xyXG4gICAgICAgICAgICBiYiA9IGdyYXBoaWMubG9jYWxCb3VuZHMudHJhbnNsYXRlKHBvcykuY29tYmluZShiYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSBiYi53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGJiLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgbGV0IGJiID0gbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMsIHBvcyB9IG9mIHRoaXMubWVtYmVycykge1xyXG4gICAgICAgICAgICBiYiA9IGdyYXBoaWMubG9jYWxCb3VuZHMudHJhbnNsYXRlKHBvcykuY29tYmluZShiYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH1cclxuICAgIF9pc0FuaW1hdGlvbk9yR3JvdXAoZ3JhcGhpYykge1xyXG4gICAgICAgIHJldHVybiBncmFwaGljIGluc3RhbmNlb2YgQW5pbWF0aW9uIHx8IGdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljc0dyb3VwO1xyXG4gICAgfVxyXG4gICAgdGljayhlbGFwc2VkTWlsbGlzZWNvbmRzLCBpZGVtcG90ZW5jeVRva2VuKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQW5pbWF0aW9uID0gbWVtYmVyLmdyYXBoaWM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGlvbk9yR3JvdXAobWF5YmVBbmltYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBtYXliZUFuaW1hdGlvbi50aWNrKGVsYXBzZWRNaWxsaXNlY29uZHMsIGlkZW1wb3RlbmN5VG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQW5pbWF0aW9uID0gbWVtYmVyLmdyYXBoaWM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGlvbk9yR3JvdXAobWF5YmVBbmltYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBtYXliZUFuaW1hdGlvbi5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3ByZURyYXcoZXgsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgc3VwZXIuX3ByZURyYXcoZXgsIHgsIHkpO1xyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShleCwgeCwgeSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRoaXMubWVtYmVycykge1xyXG4gICAgICAgICAgICBleC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgbWVtYmVyLmdyYXBoaWMuZHJhdyhleCwgbWVtYmVyLnBvcy54LCBtZW1iZXIucG9zLnkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93RGVidWcpIHtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICBleC5kZWJ1Zy5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbmZpZ3VyYWJsZS50c1xuLyoqXHJcbiAqIENvbmZpZ3VyYWJsZSBoZWxwZXIgZXh0ZW5kcyBiYXNlIHR5cGUgYW5kIG1ha2VzIGFsbCBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBhcyBvcHRpb24gYmFnIGFyZ3VtZW50c1xyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGJhc2VcclxuICovXHJcbmZ1bmN0aW9uIENvbmZpZ3VyYWJsZShiYXNlKSB7XHJcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBiYXNlIHtcclxuICAgICAgICBhc3NpZ24ocHJvcHMpIHtcclxuICAgICAgICAgICAgLy9zZXQgdGhlIHZhbHVlIG9mIGV2ZXJ5IHByb3BlcnR5IHRoYXQgd2FzIHBhc3NlZCBpbixcclxuICAgICAgICAgICAgLy9pZiB0aGUgY29uc3RydWN0b3IgcHJldmlvdXNseSBzZXQgdGhpcyB2YWx1ZSwgaXQgd2lsbCBiZSBvdmVycmlkZGVuIGhlcmVcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1trXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNba10gPSBwcm9wc1trXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGF0IGFyZW4ndCB1bmRlZmluZWQuIFRTIHBhc3NlcyBhIHZhbHVlIHRvIGFsbCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIC8vb2Ygd2hhdGV2ZXIgY3RvciBpcyB0aGUgaW1wbGVtZW50YXRpb24sIHNvIGFyZ3MubGVuZ3RoIGRvZXNuJ3Qgd29yayBoZXJlLlxyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMSAmJiBhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhKGFyZ3NbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1BhcnRpY2xlcy50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSB0eXBlcyBvZiBlbWl0dGVyIG5venpsZXNcclxuICovXHJcbnZhciBFbWl0dGVyVHlwZTtcclxuKGZ1bmN0aW9uIChFbWl0dGVyVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdGFudCBmb3IgdGhlIGNpcmN1bGFyIGVtaXR0ZXIgdHlwZVxyXG4gICAgICovXHJcbiAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIkNpcmNsZVwiXSA9IDBdID0gXCJDaXJjbGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RhbnQgZm9yIHRoZSByZWN0YW5ndWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAqL1xyXG4gICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJSZWN0YW5nbGVcIl0gPSAxXSA9IFwiUmVjdGFuZ2xlXCI7XHJcbn0pKEVtaXR0ZXJUeXBlIHx8IChFbWl0dGVyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5jbGFzcyBQYXJ0aWNsZUltcGwgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgY29uc3RydWN0b3IoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAwO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5lbmRDb2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIC8vIExpZmUgaXMgY291bnRlZCBpbiBtc1xyXG4gICAgICAgIHRoaXMubGlmZSA9IDMwMDtcclxuICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQ29sb3IgdHJhbnNpdGlvbnNcclxuICAgICAgICB0aGlzLl9yUmF0ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5fZ1JhdGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2JSYXRlID0gMTtcclxuICAgICAgICB0aGlzLl9hUmF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IDU7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplUmF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzT2Zmc2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGVtaXR0ZXIgPSBlbWl0dGVyT3JDb25maWc7XHJcbiAgICAgICAgaWYgKGVtaXR0ZXIgJiYgIShlbWl0dGVyT3JDb25maWcgaW5zdGFuY2VvZiBQYXJ0aWNsZUVtaXR0ZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGVtaXR0ZXJPckNvbmZpZztcclxuICAgICAgICAgICAgZW1pdHRlciA9IGNvbmZpZy5lbWl0dGVyO1xyXG4gICAgICAgICAgICBsaWZlID0gY29uZmlnLmxpZmU7XHJcbiAgICAgICAgICAgIG9wYWNpdHkgPSBjb25maWcub3BhY2l0eTtcclxuICAgICAgICAgICAgZW5kQ29sb3IgPSBjb25maWcuZW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGJlZ2luQ29sb3IgPSBjb25maWcuYmVnaW5Db2xvcjtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gY29uZmlnLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICBhY2NlbGVyYXRpb24gPSBjb25maWcuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgICAgICBzdGFydFNpemUgPSBjb25maWcuc3RhcnRTaXplO1xyXG4gICAgICAgICAgICBlbmRTaXplID0gY29uZmlnLmVuZFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XHJcbiAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSB8fCB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5lbmRDb2xvciA9IGVuZENvbG9yIHx8IHRoaXMuZW5kQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikuYWRkKHRoaXMuZW1pdHRlci5wb3MpO1xyXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uIHx8IHRoaXMuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3JSYXRlID0gKHRoaXMuZW5kQ29sb3IuciAtIHRoaXMuYmVnaW5Db2xvci5yKSAvIHRoaXMubGlmZTtcclxuICAgICAgICB0aGlzLl9nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgdGhpcy5fYlJhdGUgPSAodGhpcy5lbmRDb2xvci5iIC0gdGhpcy5iZWdpbkNvbG9yLmIpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMuX2FSYXRlID0gdGhpcy5vcGFjaXR5IC8gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplIHx8IDA7XHJcbiAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSB8fCAwO1xyXG4gICAgICAgIGlmICh0aGlzLmVuZFNpemUgPiAwICYmIHRoaXMuc3RhcnRTaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gKHRoaXMuZW5kU2l6ZSAtIHRoaXMuc3RhcnRTaXplKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSB0aGlzLnN0YXJ0U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoKHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoKHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3NDb21wb25lbnQoKSkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvcyA9IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB0aGlzLmN1cnJlbnRSb3RhdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9IHZlYygxLCAxKTsgLy8gVE9ETyB3dXRcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MudXNlKHRoaXMucGFydGljbGVTcHJpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5sb2NhbEJvdW5kcyA9IEJvdW5kaW5nQm94LmZyb21EaW1lbnNpb24odGhpcy5wYXJ0aWNsZVNpemUsIHRoaXMucGFydGljbGVTaXplLCBWZWN0b3IuSGFsZik7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3Mub25Qb3N0RHJhdyA9IChjdHgpID0+IHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBDb2xvciA9IHRoaXMuX2N1cnJlbnRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdG1wQ29sb3IuYSA9IDE7XHJcbiAgICAgICAgICAgICAgICBjdHguZGVidWcuZHJhd1BvaW50KHZlYygwLCAwKSwgeyBjb2xvcjogdG1wQ29sb3IsIHNpemU6IHRoaXMucGFydGljbGVTaXplIH0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBraWxsKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5yZW1vdmVQYXJ0aWNsZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyICsgZGVsdGE7XHJcbiAgICAgICAgaWYgKHRoaXMubGlmZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZhZGVGbGFnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGNsYW1wKHRoaXMuX2FSYXRlICogdGhpcy5saWZlLCAwLjAwMDEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGFydFNpemUgPiAwICYmIHRoaXMuZW5kU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSBjbGFtcCh0aGlzLnNpemVSYXRlICogZGVsdGEgKyB0aGlzLnBhcnRpY2xlU2l6ZSwgTWF0aC5taW4odGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSksIE1hdGgubWF4KHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLnIgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuciArIHRoaXMuX3JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmcgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuZyArIHRoaXMuX2dSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmIgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuYiArIHRoaXMuX2JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBjbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYWNjZWwgPSB0aGlzLmZvY3VzXHJcbiAgICAgICAgICAgICAgICAuc3ViKHRoaXMucG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAubm9ybWFsaXplKClcclxuICAgICAgICAgICAgICAgIC5zY2FsZSh0aGlzLmZvY3VzQWNjZWwpXHJcbiAgICAgICAgICAgICAgICAuc2NhbGUoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKGFjY2VsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCh0aGlzLmFjY2VsZXJhdGlvbi5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHkuc2NhbGUoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAqIGRlbHRhKSAvIDEwMDApICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHRoaXMuY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlID0gdmVjKDEsIDEpOyAvLyB0b2RvIHd1dFxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3Mub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUGFydGljbGUgaXMgdXNlZCBpbiBhIFtbUGFydGljbGVFbWl0dGVyXV1cclxuICovXHJcbmNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgQ29uZmlndXJhYmxlKFBhcnRpY2xlSW1wbCkge1xyXG4gICAgY29uc3RydWN0b3IoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgIHN1cGVyKGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2luZyBhIHBhcnRpY2xlIGVtaXR0ZXIgaXMgYSBncmVhdCB3YXkgdG8gY3JlYXRlIGludGVyZXN0aW5nIGVmZmVjdHNcclxuICogaW4geW91ciBnYW1lLCBsaWtlIHNtb2tlLCBmaXJlLCB3YXRlciwgZXhwbG9zaW9ucywgZXRjLiBgUGFydGljbGVFbWl0dGVyYFxyXG4gKiBleHRlbmQgW1tBY3Rvcl1dIGFsbG93aW5nIHlvdSB0byB1c2UgYWxsIG9mIHRoZSBmZWF0dXJlcyB0aGF0IGNvbWUgd2l0aC5cclxuICovXHJcbmNsYXNzIFBhcnRpY2xlRW1pdHRlciBleHRlbmRzIEFjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyBwYXJ0aWNsZSBlbWl0dGVyIG9wdGlvbnMgYmFnXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgc3VwZXIoeyB3aWR0aDogKF9hID0gY29uZmlnLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCBoZWlnaHQ6IChfYiA9IGNvbmZpZy5oZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAgfSk7XHJcbiAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gMDtcclxuICAgICAgICB0aGlzLm51bVBhcnRpY2xlcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBwYXJ0aWNsZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gcGFydGljbGUgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pblZlbCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBmb3IgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluQW5nbGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhBbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWlzc2lvbiByYXRlIGZvciBwYXJ0aWNsZXMgKHBhcnRpY2xlcy9zZWMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IDE7IC8vcGFydGljbGVzL3NlY1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlmZSBvZiBlYWNoIHBhcnRpY2xlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFydGljbGVMaWZlID0gMjAwMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZhZGUgZmxhZyB3aGljaCBjYXVzZXMgcGFydGljbGVzIHRvIGdyYWR1YWxseSBmYWRlIG91dCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlaXIgbGlmZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBmb2N1cyB3aGVyZSBhbGwgcGFydGljbGVzIHNob3VsZCBhY2NlbGVyYXRlIHRvd2FyZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiBmb3IgZm9jdXNpbmcgcGFydGljbGVzIGlmIGEgZm9jdXMgaGFzIGJlZW4gc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBlbmRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5kU2l6ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluU2l6ZSA9IDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiZWdpbm5pbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuZENvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgdHlwZSBmb3IgdGhlIHBhcnRpY2xlIGVtaXR0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVtaXR0ZXJUeXBlID0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciByYWRpdXMsIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gdGhlIFtbZW1pdHRlclR5cGVdXSBpcyBbW0VtaXR0ZXJUeXBlLkNpcmNsZV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcGFydGljbGUgcm90YXRpb25hbCBzcGVlZCB2ZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHBhcnRpY2xlcyBzaG91bGQgc3RhcnQgd2l0aCBhIHJhbmRvbSByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmFuZG9tUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHBvcywgaXNFbWl0dGluZywgbWluVmVsLCBtYXhWZWwsIGFjY2VsZXJhdGlvbiwgbWluQW5nbGUsIG1heEFuZ2xlLCBlbWl0UmF0ZSwgcGFydGljbGVMaWZlLCBvcGFjaXR5LCBmYWRlRmxhZywgZm9jdXMsIGZvY3VzQWNjZWwsIHN0YXJ0U2l6ZSwgZW5kU2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBhcnRpY2xlU3ByaXRlLCBlbWl0dGVyVHlwZSwgcmFkaXVzLCBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSwgcmFuZG9tUm90YXRpb24sIHJhbmRvbSB9ID0geyAuLi5jb25maWcgfTtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcyAhPT0gbnVsbCAmJiBwb3MgIT09IHZvaWQgMCA/IHBvcyA6IHZlYyh4ICE9PSBudWxsICYmIHggIT09IHZvaWQgMCA/IHggOiAwLCB5ICE9PSBudWxsICYmIHkgIT09IHZvaWQgMCA/IHkgOiAwKTtcclxuICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSBpc0VtaXR0aW5nICE9PSBudWxsICYmIGlzRW1pdHRpbmcgIT09IHZvaWQgMCA/IGlzRW1pdHRpbmcgOiB0aGlzLmlzRW1pdHRpbmc7XHJcbiAgICAgICAgdGhpcy5taW5WZWwgPSBtaW5WZWwgIT09IG51bGwgJiYgbWluVmVsICE9PSB2b2lkIDAgPyBtaW5WZWwgOiB0aGlzLm1pblZlbDtcclxuICAgICAgICB0aGlzLm1heFZlbCA9IG1heFZlbCAhPT0gbnVsbCAmJiBtYXhWZWwgIT09IHZvaWQgMCA/IG1heFZlbCA6IHRoaXMubWF4VmVsO1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uICE9PSBudWxsICYmIGFjY2VsZXJhdGlvbiAhPT0gdm9pZCAwID8gYWNjZWxlcmF0aW9uIDogdGhpcy5hY2NlbGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5taW5BbmdsZSA9IG1pbkFuZ2xlICE9PSBudWxsICYmIG1pbkFuZ2xlICE9PSB2b2lkIDAgPyBtaW5BbmdsZSA6IHRoaXMubWluQW5nbGU7XHJcbiAgICAgICAgdGhpcy5tYXhBbmdsZSA9IG1heEFuZ2xlICE9PSBudWxsICYmIG1heEFuZ2xlICE9PSB2b2lkIDAgPyBtYXhBbmdsZSA6IHRoaXMubWF4QW5nbGU7XHJcbiAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IGVtaXRSYXRlICE9PSBudWxsICYmIGVtaXRSYXRlICE9PSB2b2lkIDAgPyBlbWl0UmF0ZSA6IHRoaXMuZW1pdFJhdGU7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUxpZmUgPSBwYXJ0aWNsZUxpZmUgIT09IG51bGwgJiYgcGFydGljbGVMaWZlICE9PSB2b2lkIDAgPyBwYXJ0aWNsZUxpZmUgOiB0aGlzLnBhcnRpY2xlTGlmZTtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5ICE9PSBudWxsICYmIG9wYWNpdHkgIT09IHZvaWQgMCA/IG9wYWNpdHkgOiB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhZGVGbGFnICE9PSBudWxsICYmIGZhZGVGbGFnICE9PSB2b2lkIDAgPyBmYWRlRmxhZyA6IHRoaXMuZmFkZUZsYWc7XHJcbiAgICAgICAgdGhpcy5mb2N1cyA9IGZvY3VzICE9PSBudWxsICYmIGZvY3VzICE9PSB2b2lkIDAgPyBmb2N1cyA6IHRoaXMuZm9jdXM7XHJcbiAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gZm9jdXNBY2NlbCAhPT0gbnVsbCAmJiBmb2N1c0FjY2VsICE9PSB2b2lkIDAgPyBmb2N1c0FjY2VsIDogdGhpcy5mb2N1c0FjY2VsO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplICE9PSBudWxsICYmIHN0YXJ0U2l6ZSAhPT0gdm9pZCAwID8gc3RhcnRTaXplIDogdGhpcy5zdGFydFNpemU7XHJcbiAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSAhPT0gbnVsbCAmJiBlbmRTaXplICE9PSB2b2lkIDAgPyBlbmRTaXplIDogdGhpcy5lbmRTaXplO1xyXG4gICAgICAgIHRoaXMubWluU2l6ZSA9IG1pblNpemUgIT09IG51bGwgJiYgbWluU2l6ZSAhPT0gdm9pZCAwID8gbWluU2l6ZSA6IHRoaXMubWluU2l6ZTtcclxuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplICE9PSBudWxsICYmIG1heFNpemUgIT09IHZvaWQgMCA/IG1heFNpemUgOiB0aGlzLm1heFNpemU7XHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gYmVnaW5Db2xvciAhPT0gbnVsbCAmJiBiZWdpbkNvbG9yICE9PSB2b2lkIDAgPyBiZWdpbkNvbG9yIDogdGhpcy5iZWdpbkNvbG9yO1xyXG4gICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciAhPT0gbnVsbCAmJiBlbmRDb2xvciAhPT0gdm9pZCAwID8gZW5kQ29sb3IgOiB0aGlzLmVuZENvbG9yO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBwYXJ0aWNsZVNwcml0ZSAhPT0gbnVsbCAmJiBwYXJ0aWNsZVNwcml0ZSAhPT0gdm9pZCAwID8gcGFydGljbGVTcHJpdGUgOiB0aGlzLnBhcnRpY2xlU3ByaXRlO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlclR5cGUgPSBlbWl0dGVyVHlwZSAhPT0gbnVsbCAmJiBlbWl0dGVyVHlwZSAhPT0gdm9pZCAwID8gZW1pdHRlclR5cGUgOiB0aGlzLmVtaXR0ZXJUeXBlO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzICE9PSBudWxsICYmIHJhZGl1cyAhPT0gdm9pZCAwID8gcmFkaXVzIDogdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IHBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICE9PSBudWxsICYmIHBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA6IHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk7XHJcbiAgICAgICAgdGhpcy5yYW5kb21Sb3RhdGlvbiA9IHJhbmRvbVJvdGF0aW9uICE9PSBudWxsICYmIHJhbmRvbVJvdGF0aW9uICE9PSB2b2lkIDAgPyByYW5kb21Sb3RhdGlvbiA6IHRoaXMucmFuZG9tUm90YXRpb247XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgdGhpcy5yYW5kb20gPSByYW5kb20gIT09IG51bGwgJiYgcmFuZG9tICE9PSB2b2lkIDAgPyByYW5kb20gOiBuZXcgUmFuZG9tKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwYXJ0aWNsZSBmcm9tIDAgdG8gMS4wXHJcbiAgICAgKi9cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5ncmFwaGljcy5vcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGFydGljbGUgZnJvbSAwIHRvIDEuMFxyXG4gICAgICovXHJcbiAgICBzZXQgb3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgc3VwZXIuZ3JhcGhpY3Mub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3ByaXRlIHRoYXQgYSBwYXJ0aWNsZSBzaG91bGQgdXNlXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJ0aWNsZVNwcml0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlO1xyXG4gICAgfVxyXG4gICAgc2V0IHBhcnRpY2xlU3ByaXRlKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZVBhcnRpY2xlKHBhcnRpY2xlKSB7XHJcbiAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLnB1c2gocGFydGljbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYXVzZXMgdGhlIGVtaXR0ZXIgdG8gZW1pdCBwYXJ0aWNsZXNcclxuICAgICAqIEBwYXJhbSBwYXJ0aWNsZUNvdW50ICBOdW1iZXIgb2YgcGFydGljbGVzIHRvIGVtaXQgcmlnaHQgbm93XHJcbiAgICAgKi9cclxuICAgIGVtaXRQYXJ0aWNsZXMocGFydGljbGVDb3VudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fY3JlYXRlUGFydGljbGUoKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaChwKTtcclxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5zY2VuZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLndvcmxkLmFkZChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyUGFydGljbGVzKCkge1xyXG4gICAgICAgIHRoaXMucGFydGljbGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIGEgbmV3IHBhcnRpY2xlIGdpdmVuIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgZW1pdHRlclxyXG4gICAgX2NyZWF0ZVBhcnRpY2xlKCkge1xyXG4gICAgICAgIC8vIHRvZG8gaW1wbGVtZW50IGVtaXR0ZXIgY29uc3RyYWludHM7XHJcbiAgICAgICAgbGV0IHJhblggPSAwO1xyXG4gICAgICAgIGxldCByYW5ZID0gMDtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IHJhbmRvbUluUmFuZ2UodGhpcy5taW5BbmdsZSwgdGhpcy5tYXhBbmdsZSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgIGNvbnN0IHZlbCA9IHJhbmRvbUluUmFuZ2UodGhpcy5taW5WZWwsIHRoaXMubWF4VmVsLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc3RhcnRTaXplIHx8IHJhbmRvbUluUmFuZ2UodGhpcy5taW5TaXplLCB0aGlzLm1heFNpemUsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICBjb25zdCBkeCA9IHZlbCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBkeSA9IHZlbCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJhblggPSByYW5kb21JblJhbmdlKDAsIHRoaXMud2lkdGgsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgcmFuWSA9IHJhbmRvbUluUmFuZ2UoMCwgdGhpcy5oZWlnaHQsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHJhbmRvbUluUmFuZ2UoMCwgdGhpcy5yYWRpdXMsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgcmFuWCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgcmFuWSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBWZWN0b3IocmFuWCwgcmFuWSksIG5ldyBWZWN0b3IoZHgsIGR5KSwgdGhpcy5hY2NlbGVyYXRpb24sIHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpO1xyXG4gICAgICAgIHAuZmFkZUZsYWcgPSB0aGlzLmZhZGVGbGFnO1xyXG4gICAgICAgIHAucGFydGljbGVTaXplID0gc2l6ZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICBwLnBhcnRpY2xlU3ByaXRlID0gdGhpcy5wYXJ0aWNsZVNwcml0ZTtcclxuICAgICAgICAgICAgcC5ncmFwaGljcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICBwLmdyYXBoaWNzLnVzZSh0aGlzLl9zcHJpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eTtcclxuICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICBwLmN1cnJlbnRSb3RhdGlvbiA9IHJhbmRvbUluUmFuZ2UoMCwgTWF0aC5QSSAqIDIsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgcC5mb2N1cyA9IHRoaXMuZm9jdXMuYWRkKG5ldyBWZWN0b3IodGhpcy5wb3MueCwgdGhpcy5wb3MueSkpO1xyXG4gICAgICAgICAgICBwLmZvY3VzQWNjZWwgPSB0aGlzLmZvY3VzQWNjZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1pdHRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA+IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UGFydGljbGVzKE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgLSBNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVmZXJyZWQgcmVtb3ZhbFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZWFkUGFydGljbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkodGhpcy5kZWFkUGFydGljbGVzW2ldLCB0aGlzLnBhcnRpY2xlcyk7XHJcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuc2NlbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53b3JsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS53b3JsZC5yZW1vdmUodGhpcy5kZWFkUGFydGljbGVzW2ldLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc1N5c3RlbS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgR3JhcGhpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nLCAnZXguZ3JhcGhpY3MnXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLkRyYXc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG9rZW4gPSAwO1xyXG4gICAgICAgIHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMgPSBbXTtcclxuICAgICAgICB0aGlzLl96SGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3pJbmRleFVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fekhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXQgc29ydGVkVHJhbnNmb3JtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc29ydGVkVHJhbnNmb3JtcztcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBzY2VuZS5jYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gc2NlbmUuZW5naW5lO1xyXG4gICAgfVxyXG4gICAgcHJldXBkYXRlKCkge1xyXG4gICAgICAgIC8vIEdyYXBoaWNzIGNvbnRleHQgY291bGQgYmUgc3dpdGNoZWQgdG8gZmFsbGJhY2sgaW4gYSBuZXcgZnJhbWVcclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQgPSB0aGlzLl9lbmdpbmUuZ3JhcGhpY3NDb250ZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLl96SGFzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWRUcmFuc2Zvcm1zLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl96SGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5vdGlmeShlbnRpdHlBZGRlZE9yUmVtb3ZlZCkge1xyXG4gICAgICAgIGlmIChpc0FkZGVkU3lzdGVtRW50aXR5KGVudGl0eUFkZGVkT3JSZW1vdmVkKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IGVudGl0eUFkZGVkT3JSZW1vdmVkLmRhdGEuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMucHVzaCh0eCk7XHJcbiAgICAgICAgICAgIHR4LnpJbmRleENoYW5nZWQkLnN1YnNjcmliZSh0aGlzLl96SW5kZXhVcGRhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl96SGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IGVudGl0eUFkZGVkT3JSZW1vdmVkLmRhdGEuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHR4LnpJbmRleENoYW5nZWQkLnVuc3Vic2NyaWJlKHRoaXMuX3pJbmRleFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc29ydGVkVHJhbnNmb3Jtcy5pbmRleE9mKHR4KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW50aXRpZXMsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5fdG9rZW4rKztcclxuICAgICAgICBsZXQgZ3JhcGhpY3M7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBlcmZvcm1hbmNlIGVuaGFuY2VtZW50LCBtb3N0IHRoaW5ncyBhcmUgaW4gd29ybGQgc3BhY2VcclxuICAgICAgICAvLyBzbyBpZiB3ZSBjYW4gb25seSBkbyB0aGlzIG9uY2Ugc2F2ZXMgYSB0b24gb2YgdHJhbnNmb3JtIHVwZGF0ZXNcclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm0gb2YgdGhpcy5fc29ydGVkVHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSB0cmFuc2Zvcm0ub3duZXI7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbnRpdHkgaXMgb2Zmc2NyZWVuIHNraXBcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5oYXNUYWcoJ2V4Lm9mZnNjcmVlbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAvLyBFeGl0IGlmIGdyYXBoaWNzIHNldCB0byBub3QgdmlzaWJsZVxyXG4gICAgICAgICAgICBpZiAoIWdyYXBoaWNzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uYWxseSBzZXRzIG91ciBjYW1lcmEgYmFzZWQgb24gdGhlIGVudGl0eSBjb29yZCBwbGFuICh3b3JsZCB2cy4gc2NyZWVuKVxyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIC8vIFRpY2sgYW55IGdyYXBoaWNzIHN0YXRlIChidXQgb25seSBvbmNlKSBmb3IgYW5pbWF0aW9ucyBhbmQgZ3JhcGhpY3MgZ3JvdXBzXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnVwZGF0ZShkZWx0YSwgdGhpcy5fdG9rZW4pO1xyXG4gICAgICAgICAgICAvLyBBcHBseSBwYXJhbGxheFxyXG4gICAgICAgICAgICBjb25zdCBwYXJhbGxheCA9IGVudGl0eS5nZXQoUGFyYWxsYXhDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAocGFyYWxsYXgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgVGlsZWQgZm9ybXVsYVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2MubWFwZWRpdG9yLm9yZy9lbi9sYXRlc3QvbWFudWFsL2xheWVycy8jcGFyYWxsYXgtc2Nyb2xsaW5nLWZhY3RvclxyXG4gICAgICAgICAgICAgICAgLy8gY2FtZXJhUG9zICogKDEgLSBwYXJhbGxheEZhY3RvcilcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9uZU1pbnVzRmFjdG9yID0gVmVjdG9yLk9uZS5zdWIocGFyYWxsYXgucGFyYWxsYXhGYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYWxsYXhPZmZzZXQgPSB0aGlzLl9jYW1lcmEucG9zLnNjYWxlKG9uZU1pbnVzRmFjdG9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC50cmFuc2xhdGUocGFyYWxsYXhPZmZzZXQueCwgcGFyYWxsYXhPZmZzZXQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9zaXRpb24gdGhlIGVudGl0eSArIGVzdGltYXRlIGxhZ1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybShlbnRpdHkpO1xyXG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHJ1biB0aGUgb25QcmVEcmF3IGdyYXBoaWNzIGxpZmVjeWNsZSBkcmF3XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcy5vblByZURyYXcpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLm9uUHJlRHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGhhY2sgb24gdGhlIHBhcnRpY2xlIHJlZG9cclxuICAgICAgICAgICAgY29uc3QgcGFydGljbGVPcGFjaXR5ID0gKGVudGl0eSBpbnN0YW5jZW9mIFBhcnRpY2xlKSA/IGVudGl0eS5vcGFjaXR5IDogMTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0Lm9wYWNpdHkgPSBncmFwaGljcy5vcGFjaXR5ICogcGFydGljbGVPcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBncmFwaGljcyBjb21wb25lbnRcclxuICAgICAgICAgICAgdGhpcy5fZHJhd0dyYXBoaWNzQ29tcG9uZW50KGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBydW4gdGhlIG9uUG9zdERyYXcgZ3JhcGhpY3MgbGlmZWN5Y2xlIGRyYXdcclxuICAgICAgICAgICAgaWYgKGdyYXBoaWNzLm9uUG9zdERyYXcpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLm9uUG9zdERyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRyYW5zZm9ybSBiYWNrIHRvIHRoZSBvcmlnaW5hbCB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIF9kcmF3R3JhcGhpY3NDb21wb25lbnQoZ3JhcGhpY3NDb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChncmFwaGljc0NvbXBvbmVudC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBncmFwaGljcyBzeXN0ZW1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiBncmFwaGljc0NvbXBvbmVudC5sYXllcnMuZ2V0KCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljLCBvcHRpb25zIH0gb2YgbGF5ZXIuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYW5jaG9yID0gZ3JhcGhpY3NDb21wb25lbnQuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBncmFwaGljc0NvbXBvbmVudC5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gb3B0aW9ucy5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9wdWxsLzYxOSBmb3IgZGlzY3Vzc2lvbiBvbiB0aGlzIGZvcm11bGFcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gLWdyYXBoaWMud2lkdGggKiBhbmNob3IueCArIG9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAtZ3JhcGhpYy5oZWlnaHQgKiBhbmNob3IueSArIG9mZnNldC55O1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgb2Zmc2V0WCArIGxheWVyLm9mZnNldC54LCBvZmZzZXRZICsgbGF5ZXIub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZWJ1ZykgJiYgdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdmVjKG9mZnNldFggKyBsYXllci5vZmZzZXQueCwgb2Zmc2V0WSArIGxheWVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGcgb2YgZ3JhcGhpYy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gZy5ncmFwaGljKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9jYWxCb3VuZHMudHJhbnNsYXRlKG9mZnNldC5hZGQoZy5wb3MpKS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzLmJvdW5kc0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMubG9jYWxCb3VuZHMudHJhbnNsYXRlKG9mZnNldCkuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIHRoaXMuX2VuZ2luZS5kZWJ1Zy5ncmFwaGljcy5ib3VuZHNDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgYXBwbGllcyB0aGUgY3VycmVudCBlbnRpdHkgdHJhbnNmb3JtIHRvIHRoZSBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIF9hcHBseVRyYW5zZm9ybShlbnRpdHkpIHtcclxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBlbnRpdHkuZ2V0QW5jZXN0b3JzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBhbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYW5jZXN0b3IgPT09IG51bGwgfHwgYW5jZXN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2VzdG9yLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25hbEJvZHkgPSBhbmNlc3RvciA9PT0gbnVsbCB8fCBhbmNlc3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jZXN0b3IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGVkUG9zID0gdHJhbnNmb3JtLnBvcztcclxuICAgICAgICAgICAgbGV0IGludGVycG9sYXRlZFNjYWxlID0gdHJhbnNmb3JtLnNjYWxlO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGVkUm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25hbEJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmdpbmUuZml4ZWRVcGRhdGVGcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEJvZHkuX19vbGRUcmFuc2Zvcm1DYXB0dXJlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsQm9keS5lbmFibGVGaXhlZFVwZGF0ZUludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JhcGhpY3MgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxlbmQgPSB0aGlzLl9lbmdpbmUuY3VycmVudEZyYW1lTGFnTXMgLyAoMTAwMCAvIHRoaXMuX2VuZ2luZS5maXhlZFVwZGF0ZUZwcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkUG9zID0gdHJhbnNmb3JtLnBvcy5zY2FsZShibGVuZCkuYWRkKG9wdGlvbmFsQm9keS5vbGRQb3Muc2NhbGUoMS4wIC0gYmxlbmQpKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRTY2FsZSA9IHRyYW5zZm9ybS5zY2FsZS5zY2FsZShibGVuZCkuYWRkKG9wdGlvbmFsQm9keS5vbGRTY2FsZS5zY2FsZSgxLjAgLSBibGVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0aW9uYWwgbGVycCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzAxMjkyNDhcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3NpbmUgPSAoMS4wIC0gYmxlbmQpICogTWF0aC5jb3Mob3B0aW9uYWxCb2R5Lm9sZFJvdGF0aW9uKSArIGJsZW5kICogTWF0aC5jb3ModHJhbnNmb3JtLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaW5lID0gKDEuMCAtIGJsZW5kKSAqIE1hdGguc2luKG9wdGlvbmFsQm9keS5vbGRSb3RhdGlvbikgKyBibGVuZCAqIE1hdGguc2luKHRyYW5zZm9ybS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkUm90YXRpb24gPSBNYXRoLmF0YW4yKHNpbmUsIGNvc2luZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnogPSB0cmFuc2Zvcm0uejtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC50cmFuc2xhdGUoaW50ZXJwb2xhdGVkUG9zLngsIGludGVycG9sYXRlZFBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zY2FsZShpbnRlcnBvbGF0ZWRTY2FsZS54LCBpbnRlcnBvbGF0ZWRTY2FsZS55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yb3RhdGUoaW50ZXJwb2xhdGVkUm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvRGVidWdTeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIERlYnVnU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5EcmF3O1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSA5OTk7IC8vIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dCA9IHNjZW5lLmVuZ2luZS5ncmFwaGljc0NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IHNjZW5lLmVuZ2luZTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25TeXN0ZW0gPSBzY2VuZS53b3JsZC5zeXN0ZW1NYW5hZ2VyLmdldChDb2xsaXNpb25TeXN0ZW0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVudGl0aWVzLCBfZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbHRlclNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmZpbHRlcjtcclxuICAgICAgICBsZXQgaWQ7XHJcbiAgICAgICAgbGV0IG5hbWU7XHJcbiAgICAgICAgY29uc3QgZW50aXR5U2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuZW50aXR5O1xyXG4gICAgICAgIGxldCB0eDtcclxuICAgICAgICBjb25zdCB0eFNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLnRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgbW90aW9uO1xyXG4gICAgICAgIGNvbnN0IG1vdGlvblNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLm1vdGlvbjtcclxuICAgICAgICBsZXQgY29sbGlkZXJDb21wO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyU2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuY29sbGlkZXI7XHJcbiAgICAgICAgY29uc3QgcGh5c2ljc1NldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLnBoeXNpY3M7XHJcbiAgICAgICAgbGV0IGdyYXBoaWNzO1xyXG4gICAgICAgIGNvbnN0IGdyYXBoaWNzU2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuZ3JhcGhpY3M7XHJcbiAgICAgICAgbGV0IGRlYnVnRHJhdztcclxuICAgICAgICBsZXQgYm9keTtcclxuICAgICAgICBjb25zdCBib2R5U2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuYm9keTtcclxuICAgICAgICBjb25zdCBjYW1lcmFTZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy5jYW1lcmE7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5oYXNUYWcoJ29mZnNjcmVlbicpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIG9mZnNjcmVlbiBlbnRpdGllc1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFBhcnRpY2xlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJ0aWNsZXMgY3J1c2ggdGhlIHJlbmRlcmVyIDooXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyU2V0dGluZ3MudXNlRmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxJZHMgPSBmaWx0ZXJTZXR0aW5ncy5pZHMubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWRNYXRjaCA9IGFsbElkcyB8fCBmaWx0ZXJTZXR0aW5ncy5pZHMuaW5jbHVkZXMoZW50aXR5LmlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghaWRNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsTmFtZXMgPSBmaWx0ZXJTZXR0aW5ncy5uYW1lUXVlcnkgPT09ICcnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZU1hdGNoID0gYWxsTmFtZXMgfHwgZW50aXR5Lm5hbWUuaW5jbHVkZXMoZmlsdGVyU2V0dGluZ3MubmFtZVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGlmICghbmFtZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGN1cnNvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdmVjKDAsIDE2KTtcclxuICAgICAgICAgICAgaWQgPSBlbnRpdHkuaWQ7XHJcbiAgICAgICAgICAgIG5hbWUgPSBlbnRpdHkubmFtZTtcclxuICAgICAgICAgICAgdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uYWxseSBzZXRzIG91ciBjYW1lcmEgYmFzZWQgb24gdGhlIGVudGl0eSBjb29yZCBwbGFuICh3b3JsZCB2cy4gc2NyZWVuKVxyXG4gICAgICAgICAgICB0aGlzLl9wdXNoQ2FtZXJhVHJhbnNmb3JtKHR4KTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0oZW50aXR5KTtcclxuICAgICAgICAgICAgaWYgKHR4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHhTZXR0aW5ncy5zaG93QWxsIHx8IHR4U2V0dGluZ3Muc2hvd1Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdQb2ludChWZWN0b3IuWmVybywgeyBzaXplOiA0LCBjb2xvcjogdHhTZXR0aW5ncy5wb3NpdGlvbkNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR4U2V0dGluZ3Muc2hvd0FsbCB8fCB0eFNldHRpbmdzLnNob3dQb3NpdGlvbkxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBwb3Mke3R4LnBvcy50b1N0cmluZygyKX1gLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHhTZXR0aW5ncy5zaG93QWxsIHx8IHR4U2V0dGluZ3Muc2hvd1pJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgeigke3R4LnoudG9GaXhlZCgxKX0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eVNldHRpbmdzLnNob3dBbGwgfHwgZW50aXR5U2V0dGluZ3Muc2hvd0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBpZCgke2lkfSkgJHtlbnRpdHkucGFyZW50ID8gJ2NoaWxkIG9mIGlkKCcgKyAoKF9hID0gZW50aXR5LnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSArICcpJyA6ICcnfWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbnRpdHlTZXR0aW5ncy5zaG93QWxsIHx8IGVudGl0eVNldHRpbmdzLnNob3dOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBuYW1lKCR7bmFtZX0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR4U2V0dGluZ3Muc2hvd0FsbCB8fCB0eFNldHRpbmdzLnNob3dSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kcmF3TGluZShWZWN0b3IuWmVybywgVmVjdG9yLmZyb21BbmdsZSh0eC5yb3RhdGlvbikuc2NhbGUoNTApLmFkZChWZWN0b3IuWmVybyksIHR4U2V0dGluZ3Mucm90YXRpb25Db2xvciwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGByb3QgZGVnKCR7dG9EZWdyZWVzKHR4LnJvdGF0aW9uKS50b0ZpeGVkKDIpfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHhTZXR0aW5ncy5zaG93QWxsIHx8IHR4U2V0dGluZ3Muc2hvd1NjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRyYXdMaW5lKFZlY3Rvci5aZXJvLCB0eC5zY2FsZS5hZGQoVmVjdG9yLlplcm8pLCB0eFNldHRpbmdzLnNjYWxlQ29sb3IsIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyYXBoaWNzID0gZW50aXR5LmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyYXBoaWNzU2V0dGluZ3Muc2hvd0FsbCB8fCBncmFwaGljc1NldHRpbmdzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBncmFwaGljcy5sb2NhbEJvdW5kcztcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIGdyYXBoaWNzU2V0dGluZ3MuYm91bmRzQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlYnVnRHJhdyA9IGVudGl0eS5nZXQoRGVidWdHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChkZWJ1Z0RyYXcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGVidWdEcmF3LnVzZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z0RyYXcuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWJ1Z0RyYXcudXNlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybShlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHkgPSBlbnRpdHkuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlTZXR0aW5ncy5zaG93QWxsIHx8IGJvZHlTZXR0aW5ncy5zaG93Q29sbGlzaW9uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYGNvbGxpc2lvbiBncm91cCgke2JvZHkuZ3JvdXAubmFtZX0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlTZXR0aW5ncy5zaG93QWxsIHx8IGJvZHlTZXR0aW5ncy5zaG93Q29sbGlzaW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgY29sbGlzaW9uIHR5cGUoJHtib2R5LmNvbGxpc2lvblR5cGV9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5U2V0dGluZ3Muc2hvd0FsbCB8fCBib2R5U2V0dGluZ3Muc2hvd01hc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYG1hc3MoJHtib2R5Lm1hc3N9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5U2V0dGluZ3Muc2hvd0FsbCB8fCBib2R5U2V0dGluZ3Muc2hvd01vdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgbW90aW9uKCR7Ym9keS5zbGVlcE1vdGlvbn0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlTZXR0aW5ncy5zaG93QWxsIHx8IGJvZHlTZXR0aW5ncy5zaG93U2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYHNsZWVwaW5nKCR7Ym9keS5jYW5TbGVlcCA/IGJvZHkuc2xlZXBpbmcgOiAnY2FudCBzbGVlcCd9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBtb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChtb3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb3Rpb25TZXR0aW5ncy5zaG93QWxsIHx8IG1vdGlvblNldHRpbmdzLnNob3dWZWxvY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgdmVsJHttb3Rpb24udmVsLnRvU3RyaW5nKDIpfWAsIGN1cnNvci5hZGQodHguZ2xvYmFsUG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRyYXdMaW5lKHR4Lmdsb2JhbFBvcywgdHguZ2xvYmFsUG9zLmFkZChtb3Rpb24udmVsKSwgbW90aW9uU2V0dGluZ3MudmVsb2NpdHlDb2xvciwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtb3Rpb25TZXR0aW5ncy5zaG93QWxsIHx8IG1vdGlvblNldHRpbmdzLnNob3dBY2NlbGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZHJhd0xpbmUodHguZ2xvYmFsUG9zLCB0eC5nbG9iYWxQb3MuYWRkKG1vdGlvbi5hY2MpLCBtb3Rpb25TZXR0aW5ncy5hY2NlbGVyYXRpb25Db2xvciwgMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29sbGlkZXJzIGxpdmUgaW4gd29ybGQgc3BhY2UgYWxyZWFkeSBzbyBhZnRlciB0aGUgcmVzdG9yZSgpXHJcbiAgICAgICAgICAgIGNvbGxpZGVyQ29tcCA9IGVudGl0eS5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXJDb21wKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IGNvbGxpZGVyQ29tcC5nZXQoKTtcclxuICAgICAgICAgICAgICAgIGlmICgoY29sbGlkZXJTZXR0aW5ncy5zaG93QWxsIHx8IGNvbGxpZGVyU2V0dGluZ3Muc2hvd0dlb21ldHJ5KSAmJiBjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVyLmRlYnVnKHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgY29sbGlkZXJTZXR0aW5ncy5nZW9tZXRyeUNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlclNldHRpbmdzLnNob3dBbGwgfHwgY29sbGlkZXJTZXR0aW5ncy5zaG93Qm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJzID0gY29sbGlkZXIuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBjb2xsaWRlci5ib3VuZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB2ZWMoYm91bmRzLmxlZnQsIGJvdW5kcy50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdSZWN0KHBvcy54LCBwb3MueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCB7IGNvbG9yOiBjb2xsaWRlclNldHRpbmdzLmJvdW5kc0NvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyU2V0dGluZ3Muc2hvd0FsbCB8fCBjb2xsaWRlclNldHRpbmdzLnNob3dPd25lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgb3duZXIgaWQoJHtjb2xsaWRlci5vd25lci5pZH0pYCwgcG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaWRlckNvbXAuYm91bmRzLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBjb2xsaWRlclNldHRpbmdzLmJvdW5kc0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gY29sbGlkZXJDb21wLmJvdW5kcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdmVjKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdSZWN0KHBvcy54LCBwb3MueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCB7IGNvbG9yOiBjb2xsaWRlclNldHRpbmdzLmJvdW5kc0NvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXJTZXR0aW5ncy5zaG93QWxsIHx8IGNvbGxpZGVyU2V0dGluZ3Muc2hvd093bmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYG93bmVyIGlkKCR7Y29sbGlkZXJDb21wLm93bmVyLmlkfSlgLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BvcENhbWVyYVRyYW5zZm9ybSh0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0KTtcclxuICAgICAgICBpZiAocGh5c2ljc1NldHRpbmdzLnNob3dBbGwgfHwgcGh5c2ljc1NldHRpbmdzLnNob3dCcm9hZHBoYXNlU3BhY2VQYXJ0aXRpb25EZWJ1Zykge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25TeXN0ZW0uZGVidWcodGhpcy5fZ3JhcGhpY3NDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBoeXNpY3NTZXR0aW5ncy5zaG93QWxsIHx8IHBoeXNpY3NTZXR0aW5ncy5zaG93Q29sbGlzaW9uQ29udGFjdHMgfHwgcGh5c2ljc1NldHRpbmdzLnNob3dDb2xsaXNpb25Ob3JtYWxzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW18sIGNvbnRhY3RdIG9mIHRoaXMuX2VuZ2luZS5kZWJ1Zy5zdGF0cy5jdXJyRnJhbWUucGh5c2ljcy5jb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBoeXNpY3NTZXR0aW5ncy5zaG93QWxsIHx8IHBoeXNpY3NTZXR0aW5ncy5zaG93Q29sbGlzaW9uQ29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnRhY3QucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3UG9pbnQocG9pbnQsIHsgc2l6ZTogNSwgY29sb3I6IHBoeXNpY3NTZXR0aW5ncy5jb2xsaXNpb25Db250YWN0Q29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBoeXNpY3NTZXR0aW5ncy5zaG93QWxsIHx8IHBoeXNpY3NTZXR0aW5ncy5zaG93Q29sbGlzaW9uTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdC5wb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdMaW5lKHBvaW50LCBjb250YWN0Lm5vcm1hbC5zY2FsZSgzMCkuYWRkKHBvaW50KSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHBoeXNpY3NTZXR0aW5ncy5jb2xsaXNpb25Ob3JtYWxDb2xvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICBpZiAoY2FtZXJhU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNhbWVyYVNldHRpbmdzLnNob3dBbGwgfHwgY2FtZXJhU2V0dGluZ3Muc2hvd0ZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZHJhd0NpcmNsZSh0aGlzLl9jYW1lcmEucG9zLCA0LCBjYW1lcmFTZXR0aW5ncy5mb2N1c0NvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FtZXJhU2V0dGluZ3Muc2hvd0FsbCB8fCBjYW1lcmFTZXR0aW5ncy5zaG93Wm9vbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGB6b29tKCR7dGhpcy5fY2FtZXJhLnpvb219KWAsIHRoaXMuX2NhbWVyYS5wb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5mbHVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGFwcGxpZXMgdGhlIGN1cnJlbnQgZW50aXR5IHRyYW5zZm9ybSB0byB0aGUgZ3JhcGhpY3MgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBfYXBwbHlUcmFuc2Zvcm0oZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gZW50aXR5LmdldEFuY2VzdG9ycygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgYW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGFuY2VzdG9yID09PSBudWxsIHx8IGFuY2VzdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNlc3Rvci5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnRyYW5zbGF0ZSh0cmFuc2Zvcm0ucG9zLngsIHRyYW5zZm9ybS5wb3MueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2NhbGUodHJhbnNmb3JtLnNjYWxlLngsIHRyYW5zZm9ybS5zY2FsZS55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yb3RhdGUodHJhbnNmb3JtLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgY3VycmVudCBjYW1lcmEgdHJhbnNmb3JtIGlmIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIF9wdXNoQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIC8vIEVzdGFibGlzaCBjYW1lcmEgb2Zmc2V0IHBlciBlbnRpdHlcclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuV29ybGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjdXJyZW50IGNhbWVyYSB0cmFuc2Zvcm0gaWYgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgX3BvcENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuV29ybGQpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY2FtZXJhIHdvcmxkIG9mZnNldFxyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1BvaW50ZXJTeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBQb2ludGVyU3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwYXRjaGluZyBwb2ludGVyIGV2ZW50cyB0byBlbnRpdGllc1xyXG4gKiB0aGF0IG5lZWQgdGhlbS5cclxuICpcclxuICogVGhlIFBvaW50ZXJTeXN0ZW0gY2FuIGJlIG9wdGlvbmFsbHkgY29uZmlndXJlZCBieSB0aGUgW1tQb2ludGVyQ29tcG9uZW50XV0sIGJ5IGRlZmF1bHQgRW50aXRpZXMgdXNlXHJcbiAqIHRoZSBbW0NvbGxpZGVyXV0ncyBzaGFwZSBmb3IgcG9pbnRlciBldmVudHMuXHJcbiAqL1xyXG5jbGFzcyBQb2ludGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4LnBvaW50ZXInXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLlVwZGF0ZTtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3B0aW9uYWxseSBvdmVycmlkZSBjb21wb25lbnQgY29uZmlndXJhdGlvbiBmb3IgYWxsIGVudGl0aWVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vdmVycmlkZVVzZUNvbGxpZGVyU2hhcGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcHRpb25hbGx5IG92ZXJyaWRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIGZvciBhbGwgZW50aXRpZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm92ZXJyaWRlVXNlR3JhcGhpY3NCb3VuZHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZUVudGl0eVRvUG9pbnRlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVFbnRpdHlUb1BvaW50ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9zb3J0ZWRFbnRpdGllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3pIYXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fekluZGV4VXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl96SGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBzY2VuZS5lbmdpbmU7XHJcbiAgICB9XHJcbiAgICBwcmV1cGRhdGUoKSB7XHJcbiAgICAgICAgLy8gZXZlbnQgcmVjZWl2ZXIgbWlnaHQgY2hhbmdlIHBlciBmcmFtZVxyXG4gICAgICAgIHRoaXMuX3JlY2VpdmVyID0gdGhpcy5fZW5naW5lLmlucHV0LnBvaW50ZXJzO1xyXG4gICAgICAgIGlmICh0aGlzLl96SGFzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWRUcmFuc2Zvcm1zLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiLnogLSBhLno7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWRFbnRpdGllcyA9IHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMubWFwKHQgPT4gdC5vd25lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pIYXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbm90aWZ5KGVudGl0eUFkZGVkT3JSZW1vdmVkKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRTeXN0ZW1FbnRpdHkoZW50aXR5QWRkZWRPclJlbW92ZWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gZW50aXR5QWRkZWRPclJlbW92ZWQuZGF0YS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fc29ydGVkVHJhbnNmb3Jtcy5wdXNoKHR4KTtcclxuICAgICAgICAgICAgdGhpcy5fc29ydGVkRW50aXRpZXMucHVzaCh0eC5vd25lcik7XHJcbiAgICAgICAgICAgIHR4LnpJbmRleENoYW5nZWQkLnN1YnNjcmliZSh0aGlzLl96SW5kZXhVcGRhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl96SGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IGVudGl0eUFkZGVkT3JSZW1vdmVkLmRhdGEuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHR4LnpJbmRleENoYW5nZWQkLnVuc3Vic2NyaWJlKHRoaXMuX3pJbmRleFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc29ydGVkVHJhbnNmb3Jtcy5pbmRleE9mKHR4KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZFRyYW5zZm9ybXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZEVudGl0aWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbnRpdHlDdXJyZW50bHlVbmRlclBvaW50ZXIoZW50aXR5LCBwb2ludGVySWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RnJhbWVFbnRpdHlUb1BvaW50ZXJzLmhhcyhlbnRpdHkuaWQpICYmXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lRW50aXR5VG9Qb2ludGVycy5nZXQoZW50aXR5LmlkKS5pbmNsdWRlcyhwb2ludGVySWQpO1xyXG4gICAgfVxyXG4gICAgZW50aXR5V2FzVW5kZXJQb2ludGVyKGVudGl0eSwgcG9pbnRlcklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEZyYW1lRW50aXR5VG9Qb2ludGVycy5oYXMoZW50aXR5LmlkKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmxhc3RGcmFtZUVudGl0eVRvUG9pbnRlcnMuZ2V0KGVudGl0eS5pZCkuaW5jbHVkZXMocG9pbnRlcklkKTtcclxuICAgIH1cclxuICAgIGVudGVyZWQoZW50aXR5LCBwb2ludGVySWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRpdHlDdXJyZW50bHlVbmRlclBvaW50ZXIoZW50aXR5LCBwb2ludGVySWQpICYmXHJcbiAgICAgICAgICAgICF0aGlzLmxhc3RGcmFtZUVudGl0eVRvUG9pbnRlcnMuaGFzKGVudGl0eS5pZCk7XHJcbiAgICB9XHJcbiAgICBsZWZ0KGVudGl0eSwgcG9pbnRlcklkKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmN1cnJlbnRGcmFtZUVudGl0eVRvUG9pbnRlcnMuaGFzKGVudGl0eS5pZCkgJiZcclxuICAgICAgICAgICAgdGhpcy5lbnRpdHlXYXNVbmRlclBvaW50ZXIoZW50aXR5LCBwb2ludGVySWQpO1xyXG4gICAgfVxyXG4gICAgYWRkUG9pbnRlclRvRW50aXR5KGVudGl0eSwgcG9pbnRlcklkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRGcmFtZUVudGl0eVRvUG9pbnRlcnMuaGFzKGVudGl0eS5pZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVFbnRpdHlUb1BvaW50ZXJzLnNldChlbnRpdHkuaWQsIFtwb2ludGVySWRdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb2ludGVycyA9IHRoaXMuY3VycmVudEZyYW1lRW50aXR5VG9Qb2ludGVycy5nZXQoZW50aXR5LmlkKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUVudGl0eVRvUG9pbnRlcnMuc2V0KGVudGl0eS5pZCwgcG9pbnRlcnMuY29uY2F0KHBvaW50ZXJJZCkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbnRpdGllcykge1xyXG4gICAgICAgIC8vIExvY2F0ZSBhbGwgdGhlIHBvaW50ZXIvZW50aXR5IG1hcHBpbmdzXHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1BvaW50ZXJUb0VudGl0eSh0aGlzLl9zb3J0ZWRFbnRpdGllcyk7XHJcbiAgICAgICAgLy8gRGlzcGF0Y2ggcG9pbnRlciBldmVudHMgb24gZW50aXRpZXNcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50cyh0aGlzLl9zb3J0ZWRFbnRpdGllcyk7XHJcbiAgICAgICAgLy8gQ2xlYXIgbGFzdCBmcmFtZSdzIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lRW50aXR5VG9Qb2ludGVycy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lRW50aXR5VG9Qb2ludGVycyA9IG5ldyBNYXAodGhpcy5jdXJyZW50RnJhbWVFbnRpdHlUb1BvaW50ZXJzKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUVudGl0eVRvUG9pbnRlcnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9yZWNlaXZlci5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3NQb2ludGVyVG9FbnRpdHkoZW50aXRpZXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgY29sbGlkZXI7XHJcbiAgICAgICAgbGV0IGdyYXBoaWNzO1xyXG4gICAgICAgIGxldCBwb2ludGVyO1xyXG4gICAgICAgIC8vIFRPRE8gcHJvYmFibHkgYSBzcGF0aWFsIHBhcnRpdGlvbiBvcHRpbWl6YXRpb24gaGVyZSB0byBxdWlja2x5IHF1ZXJ5IGJvdW5kcyBmb3IgcG9pbnRlclxyXG4gICAgICAgIC8vIGRvZXNuJ3Qgc2VlbSB0byBjYXVzZSBpc3N1ZXMgdGhvIGZvciBwZXJmXHJcbiAgICAgICAgLy8gUHJlLXByb2Nlc3MgZmluZCBlbnRpdGllcyB1bmRlciBwb2ludGVyc1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgcG9pbnRlciA9IChfYSA9IGVudGl0eS5nZXQoUG9pbnRlckNvbXBvbmVudCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBQb2ludGVyQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBDaGVjayBjb2xsaWRlciBjb250YWlucyBwb2ludGVyXHJcbiAgICAgICAgICAgIGNvbGxpZGVyID0gZW50aXR5LmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlciAmJiAocG9pbnRlci51c2VDb2xsaWRlclNoYXBlIHx8IHRoaXMub3ZlcnJpZGVVc2VDb2xsaWRlclNoYXBlKSkge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW9tID0gY29sbGlkZXIuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3BvaW50ZXJJZCwgcG9zXSBvZiB0aGlzLl9yZWNlaXZlci5jdXJyZW50RnJhbWVQb2ludGVyQ29vcmRzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvbS5jb250YWlucyh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCA/IHBvcy53b3JsZFBvcyA6IHBvcy5zY3JlZW5Qb3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50ZXJUb0VudGl0eShlbnRpdHksIHBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZ3JhcGhpY3MgY29udGFpbnMgcG9pbnRlclxyXG4gICAgICAgICAgICBncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoZ3JhcGhpY3MgJiYgKHBvaW50ZXIudXNlR3JhcGhpY3NCb3VuZHMgfHwgdGhpcy5vdmVycmlkZVVzZUdyYXBoaWNzQm91bmRzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ3JhcGhpY0JvdW5kcyA9IGdyYXBoaWNzLmxvY2FsQm91bmRzLnRyYW5zZm9ybSh0cmFuc2Zvcm0uZ2V0KCkubWF0cml4KTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3BvaW50ZXJJZCwgcG9zXSBvZiB0aGlzLl9yZWNlaXZlci5jdXJyZW50RnJhbWVQb2ludGVyQ29vcmRzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmFwaGljQm91bmRzLmNvbnRhaW5zKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkID8gcG9zLndvcmxkUG9zIDogcG9zLnNjcmVlblBvcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludGVyVG9FbnRpdHkoZW50aXR5LCBwb2ludGVySWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcm9jZXNzRG93bkFuZEVtaXQoZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdERvd25QZXJQb2ludGVyID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBkb3duIGFuZCBkaXNwYXRjaCB0byBlbnRpdGllc1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5fcmVjZWl2ZXIuY3VycmVudEZyYW1lRG93bikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuYWN0aXZlICYmIGVudGl0eS5hY3RpdmUgJiYgdGhpcy5lbnRpdHlDdXJyZW50bHlVbmRlclBvaW50ZXIoZW50aXR5LCBldmVudC5wb2ludGVySWQpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJkb3duJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVyLmlzRHJhZ1N0YXJ0KGV2ZW50LnBvaW50ZXJJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJkcmFnc3RhcnQnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdERvd25QZXJQb2ludGVyLnNldChldmVudC5wb2ludGVySWQsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhc3REb3duUGVyUG9pbnRlcjtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzVXBBbmRFbWl0KGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RVcFBlclBvaW50ZXIgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHVwIGFuZCBkaXNwYXRjaCB0byBlbnRpdGllc1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5fcmVjZWl2ZXIuY3VycmVudEZyYW1lVXApIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmFjdGl2ZSAmJiBlbnRpdHkuYWN0aXZlICYmIHRoaXMuZW50aXR5Q3VycmVudGx5VW5kZXJQb2ludGVyKGVudGl0eSwgZXZlbnQucG9pbnRlcklkKSkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV2ZW50cy5lbWl0KCdwb2ludGVydXAnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVjZWl2ZXIuaXNEcmFnRW5kKGV2ZW50LnBvaW50ZXJJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJkcmFnZW5kJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RVcFBlclBvaW50ZXIuc2V0KGV2ZW50LnBvaW50ZXJJZCwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFzdFVwUGVyUG9pbnRlcjtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzTW92ZUFuZEVtaXQoZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdE1vdmVQZXJQb2ludGVyID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBtb3ZlIGFuZCBkaXNwYXRjaCB0byBlbnRpdGllc1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5fcmVjZWl2ZXIuY3VycmVudEZyYW1lTW92ZSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuYWN0aXZlICYmIGVudGl0eS5hY3RpdmUgJiYgdGhpcy5lbnRpdHlDdXJyZW50bHlVbmRlclBvaW50ZXIoZW50aXR5LCBldmVudC5wb2ludGVySWQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlXHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJtb3ZlJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVyLmlzRHJhZ2dpbmcoZXZlbnQucG9pbnRlcklkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgncG9pbnRlcmRyYWdtb3ZlJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RNb3ZlUGVyUG9pbnRlci5zZXQoZXZlbnQucG9pbnRlcklkLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYXN0TW92ZVBlclBvaW50ZXI7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc0VudGVyTGVhdmVBbmRFbWl0KGVudGl0eSwgbGFzdFVwRG93bk1vdmVFdmVudHMpIHtcclxuICAgICAgICAvLyB1cCwgZG93biwgYW5kIG1vdmUgYXJlIGNvbnNpZGVyZWQgZm9yIGVudGVyIGFuZCBsZWF2ZVxyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgbGFzdFVwRG93bk1vdmVFdmVudHMpIHtcclxuICAgICAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmFjdGl2ZSAmJiBlbnRpdHkuYWN0aXZlICYmIHRoaXMuZW50ZXJlZChlbnRpdHksIGV2ZW50LnBvaW50ZXJJZCkpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgncG9pbnRlcmVudGVyJywgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY2VpdmVyLmlzRHJhZ2dpbmcoZXZlbnQucG9pbnRlcklkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgncG9pbnRlcmRyYWdlbnRlcicsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudC5hY3RpdmUgJiYgZW50aXR5LmFjdGl2ZSAmJlxyXG4gICAgICAgICAgICAgICAgLy8gbGVhdmUgY2FuIGhhcHBlbiBvbiBtb3ZlXHJcbiAgICAgICAgICAgICAgICAodGhpcy5sZWZ0KGVudGl0eSwgZXZlbnQucG9pbnRlcklkKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIGxlYXZlIGNhbiBoYXBwZW4gb24gcG9pbnRlciB1cFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmVudGl0eUN1cnJlbnRseVVuZGVyUG9pbnRlcihlbnRpdHksIGV2ZW50LnBvaW50ZXJJZCkgJiYgZXZlbnQudHlwZSA9PT0gJ3VwJykpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJsZWF2ZScsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWNlaXZlci5pc0RyYWdnaW5nKGV2ZW50LnBvaW50ZXJJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJkcmFnbGVhdmUnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcm9jZXNzQ2FuY2VsQW5kRW1pdChlbnRpdHkpIHtcclxuICAgICAgICAvLyBjYW5jZWxcclxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuX3JlY2VpdmVyLmN1cnJlbnRGcmFtZUNhbmNlbCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuYWN0aXZlICYmIGVudGl0eS5hY3RpdmUgJiYgdGhpcy5lbnRpdHlDdXJyZW50bHlVbmRlclBvaW50ZXIoZW50aXR5LCBldmVudC5wb2ludGVySWQpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJjYW5jZWwnLCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc1doZWVsQW5kRW1pdChlbnRpdHkpIHtcclxuICAgICAgICAvLyB3aGVlbFxyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5fcmVjZWl2ZXIuY3VycmVudEZyYW1lV2hlZWwpIHtcclxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoZSB3aGVlbCBvbmx5IGZpcmVzIHVuZGVyIHRoZSBwcmltYXJ5IHBvaW50ZXIgJzAnXHJcbiAgICAgICAgICAgIGlmIChldmVudC5hY3RpdmUgJiYgZW50aXR5LmFjdGl2ZSAmJiB0aGlzLmVudGl0eUN1cnJlbnRseVVuZGVyUG9pbnRlcihlbnRpdHksIDApKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3BvaW50ZXJ3aGVlbCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kaXNwYXRjaEV2ZW50cyhlbnRpdGllcykge1xyXG4gICAgICAgIGNvbnN0IGxhc3RGcmFtZUVudGl0aWVzID0gbmV3IFNldCh0aGlzLmxhc3RGcmFtZUVudGl0eVRvUG9pbnRlcnMua2V5cygpKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50RnJhbWVFbnRpdGllcyA9IG5ldyBTZXQodGhpcy5jdXJyZW50RnJhbWVFbnRpdHlUb1BvaW50ZXJzLmtleXMoKSk7XHJcbiAgICAgICAgLy8gRmlsdGVyIHByZXNlcnZlcyB6IG9yZGVyXHJcbiAgICAgICAgY29uc3QgZW50aXRpZXNXaXRoRXZlbnRzID0gZW50aXRpZXMuZmlsdGVyKGUgPT4gbGFzdEZyYW1lRW50aXRpZXMuaGFzKGUuaWQpIHx8IGN1cnJlbnRGcmFtZUVudGl0aWVzLmhhcyhlLmlkKSk7XHJcbiAgICAgICAgbGV0IGxhc3RNb3ZlUGVyUG9pbnRlcjtcclxuICAgICAgICBsZXQgbGFzdFVwUGVyUG9pbnRlcjtcclxuICAgICAgICBsZXQgbGFzdERvd25QZXJQb2ludGVyO1xyXG4gICAgICAgIC8vIERpc3BhdGNoIGV2ZW50cyBpbiBlbnRpdHkgeiBvcmRlclxyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzV2l0aEV2ZW50cykge1xyXG4gICAgICAgICAgICBsYXN0RG93blBlclBvaW50ZXIgPSB0aGlzLl9wcm9jZXNzRG93bkFuZEVtaXQoZW50aXR5KTtcclxuICAgICAgICAgICAgbGFzdFVwUGVyUG9pbnRlciA9IHRoaXMuX3Byb2Nlc3NVcEFuZEVtaXQoZW50aXR5KTtcclxuICAgICAgICAgICAgbGFzdE1vdmVQZXJQb2ludGVyID0gdGhpcy5fcHJvY2Vzc01vdmVBbmRFbWl0KGVudGl0eSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RVcERvd25Nb3ZlRXZlbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgLi4ubGFzdE1vdmVQZXJQb2ludGVyLnZhbHVlcygpLFxyXG4gICAgICAgICAgICAgICAgLi4ubGFzdERvd25QZXJQb2ludGVyLnZhbHVlcygpLFxyXG4gICAgICAgICAgICAgICAgLi4ubGFzdFVwUGVyUG9pbnRlci52YWx1ZXMoKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRW50ZXJMZWF2ZUFuZEVtaXQoZW50aXR5LCBsYXN0VXBEb3duTW92ZUV2ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NDYW5jZWxBbmRFbWl0KGVudGl0eSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NXaGVlbEFuZEVtaXQoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbnNTeXN0ZW0udHNcblxyXG5cclxuY2xhc3MgQWN0aW9uc1N5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSBbJ2V4LmFjdGlvbnMnXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLlVwZGF0ZTtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTE7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgbm90aWZ5KGVudGl0eUFkZGVkT3JSZW1vdmVkKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRTeXN0ZW1FbnRpdHkoZW50aXR5QWRkZWRPclJlbW92ZWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGVudGl0eUFkZGVkT3JSZW1vdmVkLmRhdGEuZ2V0KEFjdGlvbnNDb21wb25lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGVudGl0eUFkZGVkT3JSZW1vdmVkLmRhdGEuZ2V0KEFjdGlvbnNDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbnRpdGllcywgZGVsdGEpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbnMgb2YgdGhpcy5fYWN0aW9ucykge1xyXG4gICAgICAgICAgICBhY3Rpb25zLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVGlsZU1hcC9Jc29tZXRyaWNFbnRpdHlDb21wb25lbnQudHNcblxyXG5jbGFzcyBJc29tZXRyaWNFbnRpdHlDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoZSBpc29tZXRyaWMgbWFwIHRvIHVzZSB0byBwb3NpdGlvbiB0aGlzIGVudGl0eSdzIHotaW5kZXhcclxuICAgICAqIEBwYXJhbSBtYXBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWFwKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguaXNvbWV0cmljZW50aXR5JztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJ0aWNhbCBcImhlaWdodFwiIGluIHRoZSBpc29tZXRyaWMgd29ybGRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVsZXZhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UaWxlTWFwL0lzb21ldHJpY0VudGl0eVN5c3RlbS50c1xuXHJcblxyXG5cclxuY2xhc3MgSXNvbWV0cmljRW50aXR5U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4Lmlzb21ldHJpY2VudGl0eSddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuVXBkYXRlO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSA5OTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbnRpdGllcywgX2RlbHRhKSB7XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgaXNvO1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaXNvID0gZW50aXR5LmdldChJc29tZXRyaWNFbnRpdHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhaaW5kZXhQZXJFbGV2YXRpb24gPSBNYXRoLm1heChpc28ubWFwLmNvbHVtbnMgKiBpc28ubWFwLnRpbGVXaWR0aCwgaXNvLm1hcC5yb3dzICogaXNvLm1hcC50aWxlSGVpZ2h0KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3WiA9IG1heFppbmRleFBlckVsZXZhdGlvbiAqIGlzby5lbGV2YXRpb24gKyB0cmFuc2Zvcm0ucG9zLnk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS56ID0gbmV3WjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9PZmZzY3JlZW5TeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBPZmZzY3JlZW5TeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nLCAnZXguZ3JhcGhpY3MnXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLkRyYXc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IHNjZW5lLmNhbWVyYTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbnRpdGllcykge1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm07XHJcbiAgICAgICAgbGV0IGdyYXBoaWNzO1xyXG4gICAgICAgIGxldCBtYXliZVBhcmFsbGF4O1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzID0gZW50aXR5LmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgbWF5YmVQYXJhbGxheCA9IGVudGl0eS5nZXQoUGFyYWxsYXhDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBsZXQgcGFyYWxsYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChtYXliZVBhcmFsbGF4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIFRpbGVkIGZvcm11bGFcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jLm1hcGVkaXRvci5vcmcvZW4vbGF0ZXN0L21hbnVhbC9sYXllcnMvI3BhcmFsbGF4LXNjcm9sbGluZy1mYWN0b3JcclxuICAgICAgICAgICAgICAgIC8vIGNhbWVyYVBvcyAqICgxIC0gcGFyYWxsYXhGYWN0b3IpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbmVNaW51c0ZhY3RvciA9IFZlY3Rvci5PbmUuc3ViKG1heWJlUGFyYWxsYXgucGFyYWxsYXhGYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgcGFyYWxsYXhPZmZzZXQgPSB0aGlzLl9jYW1lcmEucG9zLnNjYWxlKG9uZU1pbnVzRmFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIGVudGl0aWVzIGFyZSBvZmZzY3JlZW5cclxuICAgICAgICAgICAgY29uc3QgZW50aXR5T2Zmc2NyZWVuID0gdGhpcy5faXNPZmZzY3JlZW4odHJhbnNmb3JtLCBncmFwaGljcywgcGFyYWxsYXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5T2Zmc2NyZWVuICYmICFlbnRpdHkuaGFzVGFnKCdleC5vZmZzY3JlZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdleGl0dmlld3BvcnQnLCBuZXcgRXhpdFZpZXdQb3J0RXZlbnQoZW50aXR5KSk7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuYWRkVGFnKCdleC5vZmZzY3JlZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWVudGl0eU9mZnNjcmVlbiAmJiBlbnRpdHkuaGFzVGFnKCdleC5vZmZzY3JlZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdlbnRlcnZpZXdwb3J0JywgbmV3IEVudGVyVmlld1BvcnRFdmVudChlbnRpdHkpKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5yZW1vdmVUYWcoJ2V4Lm9mZnNjcmVlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzT2Zmc2NyZWVuKHRyYW5zZm9ybSwgZ3JhcGhpY3MsIHBhcmFsbGF4T2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBncmFwaGljcy5sb2NhbEJvdW5kcztcclxuICAgICAgICAgICAgaWYgKHBhcmFsbGF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBib3VuZHMudHJhbnNsYXRlKHBhcmFsbGF4T2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvdW5kcyA9IGJvdW5kcy50cmFuc2Zvcm0odHJhbnNmb3JtLmdldCgpLm1hdHJpeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoaWNzT2Zmc2NyZWVuID0gIXRoaXMuX2NhbWVyYS52aWV3cG9ydC5vdmVybGFwcyh0cmFuc2Zvcm1lZEJvdW5kcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBncmFwaGljc09mZnNjcmVlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc2NyZWVuIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9TY2VuZS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFtbQWN0b3J8QWN0b3JzXV0gYXJlIGNvbXBvc2VkIHRvZ2V0aGVyIGludG8gZ3JvdXBpbmdzIGNhbGxlZCBTY2VuZXMgaW5cclxuICogRXhjYWxpYnVyLiBUaGUgbWV0YXBob3IgbW9kZWxzIHRoZSBzYW1lIGlkZWEgYmVoaW5kIHJlYWwgd29ybGRcclxuICogYWN0b3JzIGluIGEgc2NlbmUuIE9ubHkgYWN0b3JzIGluIHNjZW5lcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGRyYXduLlxyXG4gKlxyXG4gKiBUeXBpY2FsIHVzYWdlcyBvZiBhIHNjZW5lIGluY2x1ZGU6IGxldmVscywgbWVudXMsIGxvYWRpbmcgc2NyZWVucywgZXRjLlxyXG4gKi9cclxuY2xhc3MgU2NlbmUgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBjYW1lcmEgZm9yIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBFQ1Mgd29ybGQgZm9yIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud29ybGQgPSBuZXcgV29ybGQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RpbWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlID0gW107XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzeXN0ZW1zXHJcbiAgICAgICAgLy8gVXBkYXRlXHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IEFjdGlvbnNTeXN0ZW0oKSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IE1vdGlvblN5c3RlbSgpKTtcclxuICAgICAgICB0aGlzLndvcmxkLmFkZChuZXcgQ29sbGlzaW9uU3lzdGVtKCkpO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBQb2ludGVyU3lzdGVtKCkpO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBJc29tZXRyaWNFbnRpdHlTeXN0ZW0oKSk7XHJcbiAgICAgICAgLy8gRHJhd1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBPZmZzY3JlZW5TeXN0ZW0oKSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IEdyYXBoaWNzU3lzdGVtKCkpO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBEZWJ1Z1N5c3RlbSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFjdG9ycyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0b3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMuZmlsdGVyKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQWN0b3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbnRpdGllcyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBnZXQgZW50aXRpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQuZW50aXR5TWFuYWdlci5lbnRpdGllcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRyaWdnZXJzIGluIHRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGdldCB0cmlnZ2VycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5lbnRpdHlNYW5hZ2VyLmVudGl0aWVzLmZpbHRlcigoZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFRyaWdnZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1RpbGVNYXBdXXMgaW4gdGhlIHNjZW5lLCBpZiBhbnlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGVNYXBzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMuZmlsdGVyKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVGlsZU1hcDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCB0aW1lcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVycztcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIFtbU2NlbmVdXS4gSW5pdGlhbGl6ZXMgc2NlbmUgbWVtYmVycyBsaWtlIHRoZSBjYW1lcmEuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXHJcbiAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAqL1xyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSBhY3RpdmUgYW5kIHN0YXJ0ZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4sXHJcbiAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgc2V0dXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgb25BY3RpdmF0ZShfY29udGV4dCkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYW5kIHN0b3BwZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4sXHJcbiAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgY2xlYW51cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBvbkRlYWN0aXZhdGUoX2NvbnRleHQpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZVVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZVVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhIHNjZW5lIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdFVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3RVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhIHNjZW5lIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdFVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZURyYXcgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVEcmF3YCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGEgc2NlbmUgaXMgZHJhd24uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBvblByZURyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0RHJhdyBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3REcmF3YCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYSBzY2VuZSBpcyBkcmF3bi5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdERyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGFjdG9ycyBpbiB0aGUgc2NlbmVcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgY2hpbGQuX2luaXRpYWxpemUodGhpcy5lbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgW1tTY2VuZV1dIGhhcyBiZWVuIGluaXRpYWxpemVkXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzY2VuZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSwgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGVuZ2luZSBub3QgYnkgdXNlcnMgb2ZcclxuICAgICAqIEV4Y2FsaWJ1clxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGNhbWVyYSBmaXJzdFxyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkLnN5c3RlbU1hbmFnZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCEgd2Ugd2FudCB0byBiZSBzdXJlIGFueSBjdXN0b20gaW5pdCB0aGF0IGFkZCBhY3RvcnNcclxuICAgICAgICAgICAgLy8gZmlyZSBiZWZvcmUgdGhlIGFjdG9yIGluaXRcclxuICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUuY2FsbCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkluaXRpYWxpemUnLCB0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEFjdGl2YXRlcyB0aGUgc2NlbmUgd2l0aCB0aGUgYmFzZSBiZWhhdmlvciwgdGhlbiBjYWxscyB0aGUgb3ZlcnJpZGFibGUgYG9uQWN0aXZhdGVgIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9hY3RpdmF0ZShjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkFjdGl2YXRlJywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkFjdGl2YXRlKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIERlYWN0aXZhdGVzIHRoZSBzY2VuZSB3aXRoIHRoZSBiYXNlIGJlaGF2aW9yLCB0aGVuIGNhbGxzIHRoZSBvdmVycmlkYWJsZSBgb25EZWFjdGl2YXRlYCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfZGVhY3RpdmF0ZShjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkRlYWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRGVhY3RpdmF0ZShjb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25QcmVVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQoX2VuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKF9lbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUG9zdFVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0dXBkYXRlKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IFBvc3RVcGRhdGVFdmVudChfZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0VXBkYXRlKF9lbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJlZHJhdyBoYW5kbGVyIGZvciBbW29uUHJlRHJhd11dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJlZHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgUHJlRHJhd0V2ZW50KF9jdHgsIF9kZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVEcmF3KF9jdHgsIF9kZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3Bvc3RkcmF3IGhhbmRsZXIgZm9yIFtbb25Qb3N0RHJhd11dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdGRyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBQb3N0RHJhd0V2ZW50KF9jdHgsIF9kZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0RHJhdyhfY3R4LCBfZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFsbCB0aGUgYWN0b3JzIGFuZCB0aW1lcnMgaW4gdGhlIHNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRW5naW5lXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9wcmV1cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgLy8gVE9ETyBkaWZmZXJlZCBlbnRpdHkgcmVtb3ZhbCBmb3IgdGltZXJzXHJcbiAgICAgICAgbGV0IGksIGxlbjtcclxuICAgICAgICAvLyBSZW1vdmUgdGltZXJzIGluIHRoZSBjYW5jZWwgcXVldWUgYmVmb3JlIHVwZGF0aW5nIHRoZW1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKHRoaXMuX2NhbmNlbFF1ZXVlW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRpbWVycyB1cGRhdGluZyB0aW1lcnNcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuX3RpbWVycykge1xyXG4gICAgICAgICAgICB0aW1lci51cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndvcmxkLnVwZGF0ZShTeXN0ZW1UeXBlLlVwZGF0ZSwgZGVsdGEpO1xyXG4gICAgICAgIC8vIENhbWVyYSBsYXN0IGtlZXBzIHJlbmRlcnMgc21vb3RoIHRoYXQgYXJlIGJhc2VkIG9uIGVudGl0eS9hY3RvclxyXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbGxlY3RBY3RvclN0YXRzKGVuZ2luZSk7XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMgaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAgICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGRlbHRhICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl9wcmVkcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgIHRoaXMud29ybGQudXBkYXRlKFN5c3RlbVR5cGUuRHJhdywgZGVsdGEpO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9zdGRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzJyBkZWJ1ZyBpbmZvcm1hdGlvbiBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAqIEBwYXJhbSBjdHggIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBkZWJ1Z0RyYXcoY3R4KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkZWJ1Z2RyYXcnLCBuZXcgUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdGRlYnVnZHJhdycsIG5ldyBQb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGFjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGlzIHNjZW5lIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgYWRkKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgnZW50aXR5YWRkZWQnLCB7IHRhcmdldDogZW50aXR5IH0pO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKGVudGl0eSk7XHJcbiAgICAgICAgZW50aXR5LnNjZW5lID0gdGhpcztcclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXIpIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWlucyh0aGlzLl90aW1lcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbnRpdHlyZW1vdmVkJywgeyB0YXJnZXQ6IGVudGl0eSB9KTtcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yZW1vdmUoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGVudGl0aWVzIGFuZCB0aW1lcnMgZnJvbSB0aGUgc2NlbmUsIG9wdGlvbmFsbHkgaW5kaWNhdGUgd2hldGhlciBkZWZlcnJlZCBzaG91bGQgb3Igc2hvdWxkbid0IGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCBlbnRpdGllcyB1c2UgZGVmZXJyZWQgcmVtb3ZhbFxyXG4gICAgICogQHBhcmFtIGRlZmVycmVkXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKGRlZmVycmVkID0gdHJ1ZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yZW1vdmUoZW50aXR5LCBkZWZlcnJlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy50aW1lcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcih0aW1lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tUaW1lcl1dIHRvIHRoZSBzY2VuZVxyXG4gICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZFRpbWVyKHRpbWVyKSB7XHJcbiAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgICAgIHRpbWVyLnNjZW5lID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgc2NlbmUuXHJcbiAgICAgKiBAd2FybmluZyBDYW4gYmUgZGFuZ2Vyb3VzLCB1c2UgW1tjYW5jZWxUaW1lcl1dIGluc3RlYWRcclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVUaW1lcih0aW1lcikge1xyXG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcik7XHJcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhIFtbVGltZXJdXSwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NlbmUgbmljZWx5XHJcbiAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBjYW5jZWxcclxuICAgICAqL1xyXG4gICAgY2FuY2VsVGltZXIodGltZXIpIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5wdXNoKHRpbWVyKTtcclxuICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBbW1RpbWVyXV0gaXMgYWN0aXZlIGluIHRoZSBzY2VuZVxyXG4gICAgICovXHJcbiAgICBpc1RpbWVyQWN0aXZlKHRpbWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKSA+IC0xICYmICF0aW1lci5jb21wbGV0ZTtcclxuICAgIH1cclxuICAgIGlzQ3VycmVudFNjZW5lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVuZ2luZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUuY3VycmVudFNjZW5lID09PSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29sbGVjdEFjdG9yU3RhdHMoZW5naW5lKSB7XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuRWxlbWVudHMgPSB0aGlzLmFjdG9ycy5maWx0ZXIoKGEpID0+IGEgaW5zdGFuY2VvZiBTY3JlZW5FbGVtZW50KTtcclxuICAgICAgICBmb3IgKGNvbnN0IF91aSBvZiBzY3JlZW5FbGVtZW50cykge1xyXG4gICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIHRoaXMuYWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYWN0b3IuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NjcmVlbkVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBub3QgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLnVpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5hbGl2ZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUG9zdFByb2Nlc3Nvci9Db2xvckJsaW5kbmVzc01vZGUudHNcbnZhciBDb2xvckJsaW5kbmVzc01vZGU7XHJcbihmdW5jdGlvbiAoQ29sb3JCbGluZG5lc3NNb2RlKSB7XHJcbiAgICBDb2xvckJsaW5kbmVzc01vZGVbXCJQcm90YW5vcGVcIl0gPSBcIlByb3Rhbm9wZVwiO1xyXG4gICAgQ29sb3JCbGluZG5lc3NNb2RlW1wiRGV1dGVyYW5vcGVcIl0gPSBcIkRldXRlcmFub3BlXCI7XHJcbiAgICBDb2xvckJsaW5kbmVzc01vZGVbXCJUcml0YW5vcGVcIl0gPSBcIlRyaXRhbm9wZVwiO1xyXG59KShDb2xvckJsaW5kbmVzc01vZGUgfHwgKENvbG9yQmxpbmRuZXNzTW9kZSA9IHt9KSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUG9zdFByb2Nlc3Nvci9jb2xvci1ibGluZC1mcmFnbWVudC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbG9yX2JsaW5kX2ZyYWdtZW50ID0gKFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxuLy8gb3VyIHRleHR1cmVcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcclxcbi8vIHRoZSB0ZXhDb29yZHMgcGFzc2VkIGluIGZyb20gdGhlIHZlcnRleCBzaGFkZXIuXFxyXFxuaW4gdmVjMiB2X3RleGNvb3JkO1xcclxcblxcclxcbi8vIGNvbG9yIGJsaW5kIHR5cGVcXHJcXG51bmlmb3JtIGludCB1X3R5cGU7XFxyXFxuXFxyXFxuLy8gc2ltdWxhdGlvbj9cXHJcXG51bmlmb3JtIGJvb2wgdV9zaW11bGF0ZTtcXHJcXG5cXHJcXG5vdXQgdmVjNCBmcmFnQ29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgdmVjNCBvID0gIHRleHR1cmUodV9pbWFnZSwgdl90ZXhjb29yZCk7XFxyXFxuICAvLyBSR0IgdG8gTE1TIG1hdHJpeCBjb252ZXJzaW9uXFxyXFxuICBmbG9hdCBMID0gKDE3Ljg4MjQgKiBvLnIpICsgKDQzLjUxNjEgKiBvLmcpICsgKDQuMTE5MzUgKiBvLmIpO1xcclxcbiAgZmxvYXQgTSA9ICgzLjQ1NTY1ICogby5yKSArICgyNy4xNTU0ICogby5nKSArICgzLjg2NzE0ICogby5iKTtcXHJcXG4gIGZsb2F0IFMgPSAoMC4wMjk5NTY2ICogby5yKSArICgwLjE4NDMwOSAqIG8uZykgKyAoMS40NjcwOSAqIG8uYik7XFxyXFxuICAvLyBTaW11bGF0ZSBjb2xvciBibGluZG5lc3NcXHJcXG4gIGZsb2F0IGw7XFxyXFxuICBmbG9hdCBtO1xcclxcbiAgZmxvYXQgcztcXHJcXG4gIC8vTU9ERSBDT0RFLy9cXHJcXG4gIGlmICh1X3R5cGUgPT0gMCkge1xcclxcbiAgICAvLyBQcm90YW5vcGVcXHJcXG4gICAgbCA9IDAuMCAqIEwgKyAyLjAyMzQ0ICogTSArIC0yLjUyNTgxICogUztcXHJcXG4gICAgbSA9IDAuMCAqIEwgKyAxLjAgKiBNICsgMC4wICogUztcXHJcXG4gICAgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzs7XFxyXFxuICB9IGVsc2UgaWYgKHVfdHlwZSA9PSAxKSB7XFxyXFxuICAgIC8vIERldXRlcmFub3BlXFxyXFxuICAgIGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7XFxyXFxuICAgIG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7XFxyXFxuICAgIHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7XFxyXFxuICB9IGVsc2UgaWYgKHVfdHlwZSA9PSAyKSB7XFxyXFxuICAgIC8vIFRyaXRhbm9wZVxcclxcbiAgICBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTO1xcclxcbiAgICBtID0gMC4wICogTCArIDEuMCAqIE0gKyAwLjAgKiBTO1xcclxcbiAgICBzID0gLTAuMzk1OTEzICogTCArIDAuODAxMTA5ICogTSArIDAuMCAqIFM7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvLyBMTVMgdG8gUkdCIG1hdHJpeCBjb252ZXJzaW9uXFxyXFxuICB2ZWM0IGVycm9yOyAvLyBzaW11bGF0ZSB0aGUgY29sb3JzXFxyXFxuICBlcnJvci5yID0gKDAuMDgwOTQ0NDQ3OSAqIGwpICsgKC0wLjEzMDUwNDQwOSAqIG0pICsgKDAuMTE2NzIxMDY2ICogcyk7XFxyXFxuICBlcnJvci5nID0gKC0wLjAxMDI0ODUzMzUgKiBsKSArICgwLjA1NDAxOTMyNjYgKiBtKSArICgtMC4xMTM2MTQ3MDggKiBzKTtcXHJcXG4gIGVycm9yLmIgPSAoLTAuMDAwMzY1Mjk2OTM4ICogbCkgKyAoLTAuMDA0MTIxNjE0NjkgKiBtKSArICgwLjY5MzUxMTQwNSAqIHMpO1xcclxcbiAgZXJyb3IuYSA9IDEuMDtcXHJcXG4gIHZlYzQgZGlmZiA9IG8gLSBlcnJvcjtcXHJcXG4gIHZlYzQgY29ycmVjdGlvbjsgLy8gY29ycmVjdCB0aGUgY29sb3JzXFxyXFxuICBjb3JyZWN0aW9uLnIgPSAwLjA7XFxyXFxuICBjb3JyZWN0aW9uLmcgPSAgKGRpZmYuciAqIDAuNykgKyAoZGlmZi5nICogMS4wKTtcXHJcXG4gIGNvcnJlY3Rpb24uYiA9ICAoZGlmZi5yICogMC43KSArIChkaWZmLmIgKiAxLjApO1xcclxcbiAgY29ycmVjdGlvbiA9IG8gKyBjb3JyZWN0aW9uO1xcclxcbiAgY29ycmVjdGlvbi5hID0gby5hO1xcclxcbiAgLy9TSU1VTEFURS8vXFxyXFxuXFxyXFxuICAvLyBzaW0gXFxyXFxuICBpZiAodV9zaW11bGF0ZSkge1xcclxcbiAgICBmcmFnQ29sb3IgPSBlcnJvci5yZ2JhO1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgZnJhZ0NvbG9yID0gY29ycmVjdGlvbi5yZ2JhO1xcclxcbiAgfVxcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Qb3N0UHJvY2Vzc29yL1NjcmVlblNoYWRlci50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciB0aGF0IGRlZmluZXMgYSB3aG9sZSBzY3JlZW4gcmVuZGVyZXIsIGp1c3QgcHJvdmlkZSBhIGZyYWdtZW50IHNvdXJjZSFcclxuICpcclxuICogQ3VycmVudGx5IHN1cHBvcnRzIDEgdmFyeWluZ1xyXG4gKiAtIHZlYzIgYV90ZXhjb29yZCBiZXR3ZWVuIDAtMSB3aGljaCBjb3JyZXNwb25kcyB0byBzY3JlZW4gcG9zaXRpb25cclxuICovXHJcbmNsYXNzIFNjcmVlblNoYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudFNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuX3NoYWRlciA9IG5ldyBTaGFkZXIoe1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTb3VyY2U6IGAjdmVyc2lvbiAzMDAgZXNcclxuICAgICAgaW4gdmVjMiBhX3Bvc2l0aW9uO1xyXG4gICAgICBpbiB2ZWMyIGFfdGV4Y29vcmQ7XHJcbiAgICAgIG91dCB2ZWMyIHZfdGV4Y29vcmQ7XHJcblxyXG4gICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcclxuICAgICAgICAvLyBQYXNzIHRoZSB0ZXhjb29yZCB0byB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gICAgICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xyXG4gICAgICB9YCxcclxuICAgICAgICAgICAgZnJhZ21lbnRTb3VyY2U6IGZyYWdtZW50U291cmNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2hhZGVyLmNvbXBpbGUoKTtcclxuICAgICAgICAvLyBTZXR1cCBtZW1vcnkgbGF5b3V0XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzdGF0aWMnLFxyXG4gICAgICAgICAgICAvLyBjbGlwIHNwYWNlIHF1YWQgKyB1diBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgY2FtZXJhXHJcbiAgICAgICAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAgICAgLTEsIC0xLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDEsXHJcbiAgICAgICAgICAgICAgICAxLCAtMSwgMSwgMCxcclxuICAgICAgICAgICAgICAgIDEsIC0xLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgLTEsIDEsIDAsIDEsXHJcbiAgICAgICAgICAgICAgICAxLCAxLCAxLCAxXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFZlcnRleExheW91dCh7XHJcbiAgICAgICAgICAgIHNoYWRlcjogdGhpcy5fc2hhZGVyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHRoaXMuX2J1ZmZlcixcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgWydhX3Bvc2l0aW9uJywgMl0sXHJcbiAgICAgICAgICAgICAgICBbJ2FfdGV4Y29vcmQnLCAyXVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyLnVwbG9hZCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2hhZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRMYXlvdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Bvc3RQcm9jZXNzb3IvQ29sb3JCbGluZG5lc3NQb3N0UHJvY2Vzc29yLnRzXG5cclxuXHJcblxyXG5jbGFzcyBDb2xvckJsaW5kbmVzc1Bvc3RQcm9jZXNzb3Ige1xyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yQmxpbmRuZXNzTW9kZSwgc2ltdWxhdGUgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbG9yQmxpbmRuZXNzTW9kZSA9IF9jb2xvckJsaW5kbmVzc01vZGU7XHJcbiAgICAgICAgdGhpcy5fc2ltdWxhdGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zaW11bGF0ZSA9IHNpbXVsYXRlO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShfZ2wpIHtcclxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBuZXcgU2NyZWVuU2hhZGVyKGNvbG9yX2JsaW5kX2ZyYWdtZW50KTtcclxuICAgICAgICB0aGlzLnNpbXVsYXRlID0gdGhpcy5fc2ltdWxhdGU7XHJcbiAgICAgICAgdGhpcy5jb2xvckJsaW5kbmVzc01vZGUgPSB0aGlzLl9jb2xvckJsaW5kbmVzc01vZGU7XHJcbiAgICB9XHJcbiAgICBnZXRTaGFkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRlci5nZXRTaGFkZXIoKTtcclxuICAgIH1cclxuICAgIGdldExheW91dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyLmdldExheW91dCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbG9yQmxpbmRuZXNzTW9kZShjb2xvckJsaW5kTW9kZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbG9yQmxpbmRuZXNzTW9kZSA9IGNvbG9yQmxpbmRNb2RlO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fc2hhZGVyLmdldFNoYWRlcigpO1xyXG4gICAgICAgICAgICBzaGFkZXIudXNlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xvckJsaW5kbmVzc01vZGUgPT09IENvbG9yQmxpbmRuZXNzTW9kZS5Qcm90YW5vcGUpIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlci5zZXRVbmlmb3JtSW50KCd1X3R5cGUnLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb2xvckJsaW5kbmVzc01vZGUgPT09IENvbG9yQmxpbmRuZXNzTW9kZS5EZXV0ZXJhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm1JbnQoJ3VfdHlwZScsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbG9yQmxpbmRuZXNzTW9kZSA9PT0gQ29sb3JCbGluZG5lc3NNb2RlLlRyaXRhbm9wZSkge1xyXG4gICAgICAgICAgICAgICAgc2hhZGVyLnNldFVuaWZvcm1JbnQoJ3VfdHlwZScsIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGNvbG9yQmxpbmRuZXNzTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JCbGluZG5lc3NNb2RlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNpbXVsYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2ltdWxhdGUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5fc2hhZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX3NoYWRlci5nZXRTaGFkZXIoKTtcclxuICAgICAgICAgICAgc2hhZGVyLnVzZSgpO1xyXG4gICAgICAgICAgICBzaGFkZXIuc2V0VW5pZm9ybUJvb2xlYW4oJ3Vfc2ltdWxhdGUnLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHNpbXVsYXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaW11bGF0ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RlYnVnL0RlYnVnRmxhZ3MudHNcblxyXG5cclxuXHJcbmNsYXNzIENvbG9yQmxpbmRGbGFncyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5fY29sb3JCbGluZFBvc3RQcm9jZXNzb3IgPSBuZXcgQ29sb3JCbGluZG5lc3NQb3N0UHJvY2Vzc29yKENvbG9yQmxpbmRuZXNzTW9kZS5Qcm90YW5vcGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3JyZWN0IGNvbG9ycyBmb3IgYSBzcGVjaWZpZWQgY29sb3IgYmxpbmRuZXNzXHJcbiAgICAgKiBAcGFyYW0gY29sb3JCbGluZG5lc3NcclxuICAgICAqL1xyXG4gICAgY29ycmVjdChjb2xvckJsaW5kbmVzcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUuZ3JhcGhpY3NDb250ZXh0IGluc3RhbmNlb2YgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xvckJsaW5kUG9zdFByb2Nlc3Nvci5jb2xvckJsaW5kbmVzc01vZGUgPSBjb2xvckJsaW5kbmVzcztcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JCbGluZFBvc3RQcm9jZXNzb3Iuc2ltdWxhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmdyYXBoaWNzQ29udGV4dC5hZGRQb3N0UHJvY2Vzc29yKHRoaXMuX2NvbG9yQmxpbmRQb3N0UHJvY2Vzc29yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlIGNvbG9ycyBmb3IgYSBzcGVjaWZpZWQgY29sb3IgYmxpbmRuZXNzXHJcbiAgICAgKiBAcGFyYW0gY29sb3JCbGluZG5lc3NcclxuICAgICAqL1xyXG4gICAgc2ltdWxhdGUoY29sb3JCbGluZG5lc3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW5naW5lLmdyYXBoaWNzQ29udGV4dCBpbnN0YW5jZW9mIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JCbGluZFBvc3RQcm9jZXNzb3IuY29sb3JCbGluZG5lc3NNb2RlID0gY29sb3JCbGluZG5lc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yQmxpbmRQb3N0UHJvY2Vzc29yLnNpbXVsYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmdyYXBoaWNzQ29udGV4dC5hZGRQb3N0UHJvY2Vzc29yKHRoaXMuX2NvbG9yQmxpbmRQb3N0UHJvY2Vzc29yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBjb2xvciBibGluZG5lc3MgcG9zdCBwcm9jZXNzb3JcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLmdyYXBoaWNzQ29udGV4dC5yZW1vdmVQb3N0UHJvY2Vzc29yKHRoaXMuX2NvbG9yQmxpbmRQb3N0UHJvY2Vzc29yKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RlYnVnL0RlYnVnLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBEZWJ1ZyBzdGF0aXN0aWNzIGFuZCBmbGFncyBmb3IgRXhjYWxpYnVyLiBJZiBwb2xsaW5nIHRoZXNlIHZhbHVlcywgaXQgd291bGQgYmVcclxuICogYmVzdCB0byBkbyBzbyBvbiB0aGUgYHBvc3R1cGRhdGVgIGV2ZW50IGZvciBbW0VuZ2luZV1dLCBhZnRlciBhbGwgdmFsdWVzIGhhdmUgYmVlblxyXG4gKiB1cGRhdGVkIGR1cmluZyBhIGZyYW1lLlxyXG4gKi9cclxuY2xhc3MgRGVidWcge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybWFuY2Ugc3RhdGlzdGljc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDdXJyZW50IGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAqIEJlc3QgYWNjZXNzZWQgb24gW1twb3N0ZnJhbWVdXSBldmVudC4gU2VlIFtbRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjdXJyRnJhbWU6IG5ldyBGcmFtZVN0YXRzKCksXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcmV2aW91cyBmcmFtZSBzdGF0aXN0aWNzLiBFbmdpbmUgcmV1c2VzIHRoaXMgaW5zdGFuY2UsIHVzZSBbW0ZyYW1lU3RhdHMuY2xvbmVdXSB0byBjb3B5IGZyYW1lIHN0YXRzLlxyXG4gICAgICAgICAgICAgKiBCZXN0IGFjY2Vzc2VkIG9uIFtbcHJlZnJhbWVdXSBldmVudC4gQmVzdCBpbnNwZWN0ZWQgb24gZW5naW5lIGV2ZW50IGBwcmVmcmFtZWAuIFNlZSBbW0ZyYW1lU3RhdHNdXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcHJldkZyYW1lOiBuZXcgRnJhbWVTdGF0cygpXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaWx0ZXIgZGVidWcgY29udGV4dCB0byBuYW1lZCBlbnRpdGllcyBvciBlbnRpdHkgaWRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUb2dnbGUgZmlsdGVyIG9uIG9yIG9mZiAoZGVmYXVsdCBvZmYpIG11c3QgYmUgb24gZm9yIERlYnVnRHJhdyB0byB1c2UgZmlsdGVyc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdXNlRmlsdGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFF1ZXJ5IGZvciBlbnRpdGllcyBieSBuYW1lLCBpZiB0aGUgZW50aXR5IG5hbWUgY29udGFpbnMgYG5hbWVRdWVyeWAgaXQgd2lsbCBiZSBpbmNsdWRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbmFtZVF1ZXJ5OiAnJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFF1ZXJ5IGZvciBFbnRpdHkgaWRzLCBpZiB0aGUgaWQgbWF0Y2hlcyBpdCB3aWxsIGJlIGluY2x1ZGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZHM6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbnRpdHkgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVudGl0eSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dJZDogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvd05hbWU6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm0gY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UG9zaXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UG9zaXRpb25MYWJlbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uQ29sb3I6IENvbG9yLlllbGxvdyxcclxuICAgICAgICAgICAgc2hvd1pJbmRleDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dTY2FsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNjYWxlQ29sb3I6IENvbG9yLkdyZWVuLFxyXG4gICAgICAgICAgICBzaG93Um90YXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICByb3RhdGlvbkNvbG9yOiBDb2xvci5CbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmFwaGljcyBjb21wb25lbnQgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0ge1xyXG4gICAgICAgICAgICBzaG93QWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0JvdW5kczogdHJ1ZSxcclxuICAgICAgICAgICAgYm91bmRzQ29sb3I6IENvbG9yLlllbGxvd1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGlkZXIgY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dCb3VuZHM6IHRydWUsXHJcbiAgICAgICAgICAgIGJvdW5kc0NvbG9yOiBDb2xvci5CbHVlLFxyXG4gICAgICAgICAgICBzaG93T3duZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93R2VvbWV0cnk6IHRydWUsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5Q29sb3I6IENvbG9yLkdyZWVuXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQaHlzaWNzIHNpbXVsYXRpb24gZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBoeXNpY3MgPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93QnJvYWRwaGFzZVNwYWNlUGFydGl0aW9uRGVidWc6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uTm9ybWFsczogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbk5vcm1hbENvbG9yOiBDb2xvci5DeWFuLFxyXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uQ29udGFjdHM6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkNvbnRhY3RDb2xvcjogQ29sb3IuUmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb3Rpb24gY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tb3Rpb24gPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eUNvbG9yOiBDb2xvci5ZZWxsb3csXHJcbiAgICAgICAgICAgIHNob3dBY2NlbGVyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBhY2NlbGVyYXRpb25Db2xvcjogQ29sb3IuUmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5IGNvbXBvbmVudCBkZWJ1ZyBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm9keSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Hcm91cDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25UeXBlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd1NsZWVwaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd01vdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dNYXNzOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FtZXJhIGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Rm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBDb2xvci5SZWQsXHJcbiAgICAgICAgICAgIHNob3dab29tOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuY29sb3JCbGluZE1vZGUgPSBuZXcgQ29sb3JCbGluZEZsYWdzKHRoaXMuX2VuZ2luZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaCB0aGUgY3VycmVudCBleGNhbGlidXIgY2xvY2sgd2l0aCB0aGUgW1tUZXN0Q2xvY2tdXSBhbmQgcmV0dXJuXHJcbiAgICAgKiBpdCBpbiB0aGUgc2FtZSBydW5uaW5nIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gZGVidWcgZnJhbWUgYnkgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHVzZVRlc3RDbG9jaygpIHtcclxuICAgICAgICBjb25zdCBjbG9jayA9IHRoaXMuX2VuZ2luZS5jbG9jaztcclxuICAgICAgICBjb25zdCB3YXNSdW5uaW5nID0gY2xvY2suaXNSdW5uaW5nKCk7XHJcbiAgICAgICAgY2xvY2suc3RvcCgpO1xyXG4gICAgICAgIGNvbnN0IHRlc3RDbG9jayA9IGNsb2NrLnRvVGVzdENsb2NrKCk7XHJcbiAgICAgICAgaWYgKHdhc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgdGVzdENsb2NrLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5jbG9jayA9IHRlc3RDbG9jaztcclxuICAgICAgICByZXR1cm4gdGVzdENsb2NrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2ggdGhlIGN1cnJlbnQgZXhjYWxpYnVyIGNsb2NrIHdpdGggdGhlIFtbU3RhbmRhcmRDbG9ja11dIGFuZFxyXG4gICAgICogcmV0dXJuIGl0IGluIHRoZSBzYW1lIHJ1bm5pbmcgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBzd2l0Y2ggYmFjayB0byBub3JtYWwgbW9kZSBhZnRlclxyXG4gICAgICogZGVidWdnaW5nLlxyXG4gICAgICovXHJcbiAgICB1c2VTdGFuZGFyZENsb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDbG9jayA9IHRoaXMuX2VuZ2luZS5jbG9jaztcclxuICAgICAgICBjb25zdCB3YXNSdW5uaW5nID0gY3VycmVudENsb2NrLmlzUnVubmluZygpO1xyXG4gICAgICAgIGN1cnJlbnRDbG9jay5zdG9wKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRDbG9jayA9IGN1cnJlbnRDbG9jay50b1N0YW5kYXJkQ2xvY2soKTtcclxuICAgICAgICBpZiAod2FzUnVubmluZykge1xyXG4gICAgICAgICAgICBzdGFuZGFyZENsb2NrLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5jbG9jayA9IHN0YW5kYXJkQ2xvY2s7XHJcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkQ2xvY2s7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgZnJhbWUncyBzdGF0cy4gTWVhbnQgdG8gaGF2ZSB2YWx1ZXMgY29waWVkIHZpYSBbW0ZyYW1lU3RhdHMucmVzZXRdXSwgYXZvaWRcclxuICogY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZXZlcnkgZnJhbWUuXHJcbiAqL1xyXG5jbGFzcyBGcmFtZVN0YXRzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lkID0gMDtcclxuICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZnBzID0gMDtcclxuICAgICAgICB0aGlzLl9hY3RvclN0YXRzID0ge1xyXG4gICAgICAgICAgICBhbGl2ZTogMCxcclxuICAgICAgICAgICAga2lsbGVkOiAwLFxyXG4gICAgICAgICAgICB1aTogMCxcclxuICAgICAgICAgICAgZ2V0IHJlbWFpbmluZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaXZlIC0gdGhpcy5raWxsZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCB0b3RhbCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZyArIHRoaXMudWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogMCxcclxuICAgICAgICAgICAgZHJhdzogMCxcclxuICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlICsgdGhpcy5kcmF3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMgPSBuZXcgUGh5c2ljc1N0YXRzKCk7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NTdGF0cyA9IHtcclxuICAgICAgICAgICAgZHJhd0NhbGxzOiAwLFxyXG4gICAgICAgICAgICBkcmF3bkltYWdlczogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJRnJhbWVTdGF0IHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFtvdGhlclN0YXRzXSBPcHRpb25hbCBzdGF0cyB0byBjbG9uZVxyXG4gICAgICovXHJcbiAgICByZXNldChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgaWYgKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG90aGVyU3RhdHMuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSBvdGhlclN0YXRzLmRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLmZwcyA9IG90aGVyU3RhdHMuZnBzO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycy5hbGl2ZSA9IG90aGVyU3RhdHMuYWN0b3JzLmFsaXZlO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycy5raWxsZWQgPSBvdGhlclN0YXRzLmFjdG9ycy5raWxsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLnVpID0gb3RoZXJTdGF0cy5hY3RvcnMudWk7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gb3RoZXJTdGF0cy5kdXJhdGlvbi51cGRhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24uZHJhdyA9IG90aGVyU3RhdHMuZHVyYXRpb24uZHJhdztcclxuICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzLnJlc2V0KG90aGVyU3RhdHMucGh5c2ljcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NhbGxzID0gb3RoZXJTdGF0cy5ncmFwaGljcy5kcmF3Q2FsbHM7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd25JbWFnZXMgPSBvdGhlclN0YXRzLmdyYXBoaWNzLmRyYXduSW1hZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuZGVsdGEgPSB0aGlzLmZwcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLmFsaXZlID0gdGhpcy5hY3RvcnMua2lsbGVkID0gdGhpcy5hY3RvcnMudWkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uLnVwZGF0ZSA9IHRoaXMuZHVyYXRpb24uZHJhdyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXduSW1hZ2VzID0gdGhpcy5ncmFwaGljcy5kcmF3Q2FsbHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBmcyA9IG5ldyBGcmFtZVN0YXRzKCk7XHJcbiAgICAgICAgZnMucmVzZXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGZzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGlkXHJcbiAgICAgKi9cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAqL1xyXG4gICAgc2V0IGlkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBkZWx0YSAodGltZSBzaW5jZSBsYXN0IGZyYW1lKVxyXG4gICAgICovXHJcbiAgICBnZXQgZGVsdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpLiBJbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzZXQgZGVsdGEodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9kZWx0YSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpXHJcbiAgICAgKi9cclxuICAgIGdldCBmcHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZwcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZnJhbWUncyBmcmFtZXMtcGVyLXNlY29uZCAoRlBTKS4gSW50ZXJuYWwgdXNlIG9ubHkuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0IGZwcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2ZwcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGFjdG9yIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IGFjdG9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0b3JTdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBkdXJhdGlvbiBzdGF0aXN0aWNzXHJcbiAgICAgKi9cclxuICAgIGdldCBkdXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb25TdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBwaHlzaWNzIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IHBoeXNpY3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY3NTdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBncmFwaGljcyBzdGF0aXN0aWNzXHJcbiAgICAgKi9cclxuICAgIGdldCBncmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NTdGF0cztcclxuICAgIH1cclxufVxyXG5jbGFzcyBQaHlzaWNzU3RhdHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFpcnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBaZXJvIG91dCB2YWx1ZXMgb3IgY2xvbmUgb3RoZXIgSVBoeXNpY3NTdGF0cyBzdGF0cy4gQWxsb3dzIGluc3RhbmNlIHJldXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3RoZXJTdGF0c10gT3B0aW9uYWwgc3RhdHMgdG8gY2xvbmVcclxuICAgICAqL1xyXG4gICAgcmVzZXQob3RoZXJTdGF0cykge1xyXG4gICAgICAgIGlmIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSBvdGhlclN0YXRzLnBhaXJzO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBvdGhlclN0YXRzLmNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFjdHMgPSBvdGhlclN0YXRzLmNvbnRhY3RzO1xyXG4gICAgICAgICAgICB0aGlzLmZhc3RCb2RpZXMgPSBvdGhlclN0YXRzLmZhc3RCb2RpZXM7XHJcbiAgICAgICAgICAgIHRoaXMuZmFzdEJvZHlDb2xsaXNpb25zID0gb3RoZXJTdGF0cy5mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRwaGFzZSA9IG90aGVyU3RhdHMuYnJvYWRwaGFzZTtcclxuICAgICAgICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG90aGVyU3RhdHMubmFycm93cGhhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzID0gdGhpcy5jb2xsaXNpb25zID0gdGhpcy5mYXN0Qm9kaWVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSB0aGlzLmJyb2FkcGhhc2UgPSB0aGlzLm5hcnJvd3BoYXNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0cy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBwcyA9IG5ldyBQaHlzaWNzU3RhdHMoKTtcclxuICAgICAgICBwcy5yZXNldCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gcHM7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFpcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhaXJzO1xyXG4gICAgfVxyXG4gICAgc2V0IHBhaXJzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFpcnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBjb2xsaXNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25zO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbGxpc2lvbnModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGFjdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbnRhY3RzKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFjdHMgPSBjb250YWN0cztcclxuICAgIH1cclxuICAgIGdldCBmYXN0Qm9kaWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9kaWVzO1xyXG4gICAgfVxyXG4gICAgc2V0IGZhc3RCb2RpZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mYXN0Qm9kaWVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZmFzdEJvZHlDb2xsaXNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICB9XHJcbiAgICBzZXQgZmFzdEJvZHlDb2xsaXNpb25zKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgYnJvYWRwaGFzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnJvYWRwaGFzZTtcclxuICAgIH1cclxuICAgIHNldCBicm9hZHBoYXNlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hcnJvd3BoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYXJyb3dwaGFzZTtcclxuICAgIH1cclxuICAgIHNldCBuYXJyb3dwaGFzZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX25hcnJvd3BoYXNlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9Qb2ludGVyU2NvcGUudHNcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSBzY29wZSBvZiBoYW5kbGluZyBtb3VzZS90b3VjaCBldmVudHMuXHJcbiAqL1xyXG52YXIgUG9pbnRlclNjb3BlO1xyXG4oZnVuY3Rpb24gKFBvaW50ZXJTY29wZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZXZlbnRzIG9uIHRoZSBgY2FudmFzYCBlbGVtZW50IG9ubHkuIEV2ZW50cyBvcmlnaW5hdGluZyBvdXRzaWRlIHRoZVxyXG4gICAgICogYGNhbnZhc2Agd2lsbCBub3QgYmUgaGFuZGxlZC5cclxuICAgICAqL1xyXG4gICAgUG9pbnRlclNjb3BlW1wiQ2FudmFzXCJdID0gXCJDYW52YXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIGVudGlyZSBkb2N1bWVudC4gQWxsIGV2ZW50cyB3aWxsIGJlIGhhbmRsZWQgYnkgRXhjYWxpYnVyLlxyXG4gICAgICovXHJcbiAgICBQb2ludGVyU2NvcGVbXCJEb2N1bWVudFwiXSA9IFwiRG9jdW1lbnRcIjtcclxufSkoUG9pbnRlclNjb3BlIHx8IChQb2ludGVyU2NvcGUgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L0tleWJvYXJkLnRzXG5cclxuXHJcblxyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgcGh5c2ljYWwgaW5wdXQga2V5IGNvZGVzXHJcbiAqL1xyXG52YXIgS2V5cztcclxuKGZ1bmN0aW9uIChLZXlzKSB7XHJcbiAgICAvLyBOVU1QQURcclxuICAgIEtleXNbXCJOdW0wXCJdID0gXCJOdW1wYWQwXCI7XHJcbiAgICBLZXlzW1wiTnVtMVwiXSA9IFwiTnVtcGFkMVwiO1xyXG4gICAgS2V5c1tcIk51bTJcIl0gPSBcIk51bXBhZDJcIjtcclxuICAgIEtleXNbXCJOdW0zXCJdID0gXCJOdW1wYWQzXCI7XHJcbiAgICBLZXlzW1wiTnVtNFwiXSA9IFwiTnVtcGFkNFwiO1xyXG4gICAgS2V5c1tcIk51bTVcIl0gPSBcIk51bXBhZDVcIjtcclxuICAgIEtleXNbXCJOdW02XCJdID0gXCJOdW1wYWQ2XCI7XHJcbiAgICBLZXlzW1wiTnVtN1wiXSA9IFwiTnVtcGFkN1wiO1xyXG4gICAgS2V5c1tcIk51bThcIl0gPSBcIk51bXBhZDhcIjtcclxuICAgIEtleXNbXCJOdW05XCJdID0gXCJOdW1wYWQ5XCI7XHJcbiAgICBLZXlzW1wiTnVtQWRkXCJdID0gXCJOdW1wYWRBZGRcIjtcclxuICAgIEtleXNbXCJOdW1TdWJ0cmFjdFwiXSA9IFwiTnVtcGFkU3VidHJhY3RcIjtcclxuICAgIEtleXNbXCJOdW1NdWx0aXBseVwiXSA9IFwiTnVtcGFkTXVsdGlwbHlcIjtcclxuICAgIEtleXNbXCJOdW1EaXZpZGVcIl0gPSBcIk51bXBhZERpdmlkZVwiO1xyXG4gICAgLy8gTnVtQ29tbWEgPSAnTnVtcGFkQ29tbWEnLCAvLyBub3QgeC1icm93c2VyXHJcbiAgICBLZXlzW1wiTnVtRGVjaW1hbFwiXSA9IFwiTnVtcGFkRGVjaW1hbFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDBcIl0gPSBcIk51bXBhZDBcIjtcclxuICAgIEtleXNbXCJOdW1wYWQxXCJdID0gXCJOdW1wYWQxXCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkMlwiXSA9IFwiTnVtcGFkMlwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDNcIl0gPSBcIk51bXBhZDNcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ0XCJdID0gXCJOdW1wYWQ0XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkNVwiXSA9IFwiTnVtcGFkNVwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDZcIl0gPSBcIk51bXBhZDZcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ3XCJdID0gXCJOdW1wYWQ3XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkOFwiXSA9IFwiTnVtcGFkOFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDlcIl0gPSBcIk51bXBhZDlcIjtcclxuICAgIEtleXNbXCJOdW1wYWRBZGRcIl0gPSBcIk51bXBhZEFkZFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZFN1YnRyYWN0XCJdID0gXCJOdW1wYWRTdWJ0cmFjdFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZE11bHRpcGx5XCJdID0gXCJOdW1wYWRNdWx0aXBseVwiO1xyXG4gICAgS2V5c1tcIk51bXBhZERpdmlkZVwiXSA9IFwiTnVtcGFkRGl2aWRlXCI7XHJcbiAgICAvLyBOdW1wYWRDb21tYSA9ICdOdW1wYWRDb21tYScsIC8vIG5vdCB4LWJyb3dzZXJcclxuICAgIEtleXNbXCJOdW1wYWREZWNpbWFsXCJdID0gXCJOdW1wYWREZWNpbWFsXCI7XHJcbiAgICAvLyBNT0RJRklFUlNcclxuICAgIEtleXNbXCJOdW1Mb2NrXCJdID0gXCJOdW1Mb2NrXCI7XHJcbiAgICBLZXlzW1wiU2hpZnRMZWZ0XCJdID0gXCJTaGlmdExlZnRcIjtcclxuICAgIEtleXNbXCJTaGlmdFJpZ2h0XCJdID0gXCJTaGlmdFJpZ2h0XCI7XHJcbiAgICBLZXlzW1wiQWx0TGVmdFwiXSA9IFwiQWx0TGVmdFwiO1xyXG4gICAgS2V5c1tcIkFsdFJpZ2h0XCJdID0gXCJBbHRSaWdodFwiO1xyXG4gICAgS2V5c1tcIkNvbnRyb2xMZWZ0XCJdID0gXCJDb250cm9sTGVmdFwiO1xyXG4gICAgS2V5c1tcIkNvbnRyb2xSaWdodFwiXSA9IFwiQ29udHJvbFJpZ2h0XCI7XHJcbiAgICBLZXlzW1wiTWV0YUxlZnRcIl0gPSBcIk1ldGFMZWZ0XCI7XHJcbiAgICBLZXlzW1wiTWV0YVJpZ2h0XCJdID0gXCJNZXRhUmlnaHRcIjtcclxuICAgIC8vIE5VTUJFUlNcclxuICAgIEtleXNbXCJLZXkwXCJdID0gXCJEaWdpdDBcIjtcclxuICAgIEtleXNbXCJLZXkxXCJdID0gXCJEaWdpdDFcIjtcclxuICAgIEtleXNbXCJLZXkyXCJdID0gXCJEaWdpdDJcIjtcclxuICAgIEtleXNbXCJLZXkzXCJdID0gXCJEaWdpdDNcIjtcclxuICAgIEtleXNbXCJLZXk0XCJdID0gXCJEaWdpdDRcIjtcclxuICAgIEtleXNbXCJLZXk1XCJdID0gXCJEaWdpdDVcIjtcclxuICAgIEtleXNbXCJLZXk2XCJdID0gXCJEaWdpdDZcIjtcclxuICAgIEtleXNbXCJLZXk3XCJdID0gXCJEaWdpdDdcIjtcclxuICAgIEtleXNbXCJLZXk4XCJdID0gXCJEaWdpdDhcIjtcclxuICAgIEtleXNbXCJLZXk5XCJdID0gXCJEaWdpdDlcIjtcclxuICAgIEtleXNbXCJEaWdpdDBcIl0gPSBcIkRpZ2l0MFwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0MVwiXSA9IFwiRGlnaXQxXCI7XHJcbiAgICBLZXlzW1wiRGlnaXQyXCJdID0gXCJEaWdpdDJcIjtcclxuICAgIEtleXNbXCJEaWdpdDNcIl0gPSBcIkRpZ2l0M1wiO1xyXG4gICAgS2V5c1tcIkRpZ2l0NFwiXSA9IFwiRGlnaXQ0XCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ1XCJdID0gXCJEaWdpdDVcIjtcclxuICAgIEtleXNbXCJEaWdpdDZcIl0gPSBcIkRpZ2l0NlwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0N1wiXSA9IFwiRGlnaXQ3XCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ4XCJdID0gXCJEaWdpdDhcIjtcclxuICAgIEtleXNbXCJEaWdpdDlcIl0gPSBcIkRpZ2l0OVwiO1xyXG4gICAgLy8gRlVOQ1RJT04gS0VZU1xyXG4gICAgS2V5c1tcIkYxXCJdID0gXCJGMVwiO1xyXG4gICAgS2V5c1tcIkYyXCJdID0gXCJGMlwiO1xyXG4gICAgS2V5c1tcIkYzXCJdID0gXCJGM1wiO1xyXG4gICAgS2V5c1tcIkY0XCJdID0gXCJGNFwiO1xyXG4gICAgS2V5c1tcIkY1XCJdID0gXCJGNVwiO1xyXG4gICAgS2V5c1tcIkY2XCJdID0gXCJGNlwiO1xyXG4gICAgS2V5c1tcIkY3XCJdID0gXCJGN1wiO1xyXG4gICAgS2V5c1tcIkY4XCJdID0gXCJGOFwiO1xyXG4gICAgS2V5c1tcIkY5XCJdID0gXCJGOVwiO1xyXG4gICAgS2V5c1tcIkYxMFwiXSA9IFwiRjEwXCI7XHJcbiAgICBLZXlzW1wiRjExXCJdID0gXCJGMTFcIjtcclxuICAgIEtleXNbXCJGMTJcIl0gPSBcIkYxMlwiO1xyXG4gICAgLy8gTEVUVEVSU1xyXG4gICAgS2V5c1tcIkFcIl0gPSBcIktleUFcIjtcclxuICAgIEtleXNbXCJCXCJdID0gXCJLZXlCXCI7XHJcbiAgICBLZXlzW1wiQ1wiXSA9IFwiS2V5Q1wiO1xyXG4gICAgS2V5c1tcIkRcIl0gPSBcIktleURcIjtcclxuICAgIEtleXNbXCJFXCJdID0gXCJLZXlFXCI7XHJcbiAgICBLZXlzW1wiRlwiXSA9IFwiS2V5RlwiO1xyXG4gICAgS2V5c1tcIkdcIl0gPSBcIktleUdcIjtcclxuICAgIEtleXNbXCJIXCJdID0gXCJLZXlIXCI7XHJcbiAgICBLZXlzW1wiSVwiXSA9IFwiS2V5SVwiO1xyXG4gICAgS2V5c1tcIkpcIl0gPSBcIktleUpcIjtcclxuICAgIEtleXNbXCJLXCJdID0gXCJLZXlLXCI7XHJcbiAgICBLZXlzW1wiTFwiXSA9IFwiS2V5TFwiO1xyXG4gICAgS2V5c1tcIk1cIl0gPSBcIktleU1cIjtcclxuICAgIEtleXNbXCJOXCJdID0gXCJLZXlOXCI7XHJcbiAgICBLZXlzW1wiT1wiXSA9IFwiS2V5T1wiO1xyXG4gICAgS2V5c1tcIlBcIl0gPSBcIktleVBcIjtcclxuICAgIEtleXNbXCJRXCJdID0gXCJLZXlRXCI7XHJcbiAgICBLZXlzW1wiUlwiXSA9IFwiS2V5UlwiO1xyXG4gICAgS2V5c1tcIlNcIl0gPSBcIktleVNcIjtcclxuICAgIEtleXNbXCJUXCJdID0gXCJLZXlUXCI7XHJcbiAgICBLZXlzW1wiVVwiXSA9IFwiS2V5VVwiO1xyXG4gICAgS2V5c1tcIlZcIl0gPSBcIktleVZcIjtcclxuICAgIEtleXNbXCJXXCJdID0gXCJLZXlXXCI7XHJcbiAgICBLZXlzW1wiWFwiXSA9IFwiS2V5WFwiO1xyXG4gICAgS2V5c1tcIllcIl0gPSBcIktleVlcIjtcclxuICAgIEtleXNbXCJaXCJdID0gXCJLZXlaXCI7XHJcbiAgICBLZXlzW1wiS2V5QVwiXSA9IFwiS2V5QVwiO1xyXG4gICAgS2V5c1tcIktleUJcIl0gPSBcIktleUJcIjtcclxuICAgIEtleXNbXCJLZXlDXCJdID0gXCJLZXlDXCI7XHJcbiAgICBLZXlzW1wiS2V5RFwiXSA9IFwiS2V5RFwiO1xyXG4gICAgS2V5c1tcIktleUVcIl0gPSBcIktleUVcIjtcclxuICAgIEtleXNbXCJLZXlGXCJdID0gXCJLZXlGXCI7XHJcbiAgICBLZXlzW1wiS2V5R1wiXSA9IFwiS2V5R1wiO1xyXG4gICAgS2V5c1tcIktleUhcIl0gPSBcIktleUhcIjtcclxuICAgIEtleXNbXCJLZXlJXCJdID0gXCJLZXlJXCI7XHJcbiAgICBLZXlzW1wiS2V5SlwiXSA9IFwiS2V5SlwiO1xyXG4gICAgS2V5c1tcIktleUtcIl0gPSBcIktleUtcIjtcclxuICAgIEtleXNbXCJLZXlMXCJdID0gXCJLZXlMXCI7XHJcbiAgICBLZXlzW1wiS2V5TVwiXSA9IFwiS2V5TVwiO1xyXG4gICAgS2V5c1tcIktleU5cIl0gPSBcIktleU5cIjtcclxuICAgIEtleXNbXCJLZXlPXCJdID0gXCJLZXlPXCI7XHJcbiAgICBLZXlzW1wiS2V5UFwiXSA9IFwiS2V5UFwiO1xyXG4gICAgS2V5c1tcIktleVFcIl0gPSBcIktleVFcIjtcclxuICAgIEtleXNbXCJLZXlSXCJdID0gXCJLZXlSXCI7XHJcbiAgICBLZXlzW1wiS2V5U1wiXSA9IFwiS2V5U1wiO1xyXG4gICAgS2V5c1tcIktleVRcIl0gPSBcIktleVRcIjtcclxuICAgIEtleXNbXCJLZXlVXCJdID0gXCJLZXlVXCI7XHJcbiAgICBLZXlzW1wiS2V5VlwiXSA9IFwiS2V5VlwiO1xyXG4gICAgS2V5c1tcIktleVdcIl0gPSBcIktleVdcIjtcclxuICAgIEtleXNbXCJLZXlYXCJdID0gXCJLZXlYXCI7XHJcbiAgICBLZXlzW1wiS2V5WVwiXSA9IFwiS2V5WVwiO1xyXG4gICAgS2V5c1tcIktleVpcIl0gPSBcIktleVpcIjtcclxuICAgIC8vIFNZTUJPTFNcclxuICAgIEtleXNbXCJTZW1pY29sb25cIl0gPSBcIlNlbWljb2xvblwiO1xyXG4gICAgS2V5c1tcIlF1b3RlXCJdID0gXCJRdW90ZVwiO1xyXG4gICAgS2V5c1tcIkNvbW1hXCJdID0gXCJDb21tYVwiO1xyXG4gICAgS2V5c1tcIk1pbnVzXCJdID0gXCJNaW51c1wiO1xyXG4gICAgS2V5c1tcIlBlcmlvZFwiXSA9IFwiUGVyaW9kXCI7XHJcbiAgICBLZXlzW1wiU2xhc2hcIl0gPSBcIlNsYXNoXCI7XHJcbiAgICBLZXlzW1wiRXF1YWxcIl0gPSBcIkVxdWFsXCI7XHJcbiAgICBLZXlzW1wiQnJhY2tldExlZnRcIl0gPSBcIkJyYWNrZXRMZWZ0XCI7XHJcbiAgICBLZXlzW1wiQmFja3NsYXNoXCJdID0gXCJCYWNrc2xhc2hcIjtcclxuICAgIEtleXNbXCJCcmFja2V0UmlnaHRcIl0gPSBcIkJyYWNrZXRSaWdodFwiO1xyXG4gICAgS2V5c1tcIkJhY2txdW90ZVwiXSA9IFwiQmFja3F1b3RlXCI7XHJcbiAgICAvLyBESVJFQ1RJT05TXHJcbiAgICBLZXlzW1wiVXBcIl0gPSBcIkFycm93VXBcIjtcclxuICAgIEtleXNbXCJEb3duXCJdID0gXCJBcnJvd0Rvd25cIjtcclxuICAgIEtleXNbXCJMZWZ0XCJdID0gXCJBcnJvd0xlZnRcIjtcclxuICAgIEtleXNbXCJSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xyXG4gICAgS2V5c1tcIkFycm93VXBcIl0gPSBcIkFycm93VXBcIjtcclxuICAgIEtleXNbXCJBcnJvd0Rvd25cIl0gPSBcIkFycm93RG93blwiO1xyXG4gICAgS2V5c1tcIkFycm93TGVmdFwiXSA9IFwiQXJyb3dMZWZ0XCI7XHJcbiAgICBLZXlzW1wiQXJyb3dSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xyXG4gICAgLy8gT1RIRVJcclxuICAgIEtleXNbXCJTcGFjZVwiXSA9IFwiU3BhY2VcIjtcclxuICAgIEtleXNbXCJCYWNrc3BhY2VcIl0gPSBcIkJhY2tzcGFjZVwiO1xyXG4gICAgS2V5c1tcIkRlbGV0ZVwiXSA9IFwiRGVsZXRlXCI7XHJcbiAgICBLZXlzW1wiRXNjXCJdID0gXCJFc2NhcGVcIjtcclxuICAgIEtleXNbXCJFc2NhcGVcIl0gPSBcIkVzY2FwZVwiO1xyXG4gICAgS2V5c1tcIkVudGVyXCJdID0gXCJFbnRlclwiO1xyXG4gICAgS2V5c1tcIk51bXBhZEVudGVyXCJdID0gXCJOdW1wYWRFbnRlclwiO1xyXG4gICAgS2V5c1tcIkNvbnRleHRNZW51XCJdID0gXCJDb250ZXh0TWVudVwiO1xyXG59KShLZXlzIHx8IChLZXlzID0ge30pKTtcclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhIGdhbWUgb2JqZWN0IGZvciBhIGtleSBldmVudFxyXG4gKi9cclxuY2xhc3MgS2V5RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5ICBUaGUga2V5IHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyB0aGUgZXZlbnRcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUga2V5J3MgdHlwZWQgdmFsdWUgdGhlIGJyb3dzZXIgZGV0ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEV2ZW50IFRoZSBvcmlnaW5hbCBrZXlib2FyZCBldmVudCB0aGF0IEV4Y2FsaWJ1ciBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIG9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBrZXlib2FyZCBzdXBwb3J0IGZvciBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBLZXlib2FyZCBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2tleXNVcCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2tleXNEb3duID0gW107XHJcbiAgICAgICAgdGhpcy5faGFuZGxlS2V5RG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXYuY29kZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2tleXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNEb3duLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChjb2RlLCBldi5rZXksIGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Rvd24nLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwcmVzcycsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5faGFuZGxlS2V5VXAgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGV2LmNvZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX2tleXMuaW5kZXhPZihjb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICAgICAgdGhpcy5fa2V5c1VwLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGNvZGUsIGV2LmtleSwgZXYpO1xyXG4gICAgICAgICAgICAvLyBhbGlhcyB0aGUgb2xkIGFwaSwgd2UgbWF5IHdhbnQgdG8gZGVwcmVjYXRlIHRoaXMgaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCd1cCcsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgncmVsZWFzZScsIGtleUV2ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBLZXlib2FyZCBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqL1xyXG4gICAgaW5pdChnbG9iYWwpIHtcclxuICAgICAgICBpZiAoIWdsb2JhbCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IGFuZCBsaXN0ZW4gdG8gZXZlbnRzIG9uIHRvcCB3aW5kb3cgZnJhbWUgaWYgd2l0aGluIGFuIGlmcmFtZS5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMTI5NFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyLCB3aGljaCB0cmlnZ2VycyBhIERPTUV4Y2VwdGlvbiBvblxyXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3Mtb3JpZ2luIGlmcmFtZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy50b3AuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnRvcC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgbm9vcCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgd2luZG93IGlmIG5vdCBlbWJlZGRlZCB3aXRoaW4gYW4gaWZyYW1lXHJcbiAgICAgICAgICAgICAgICBnbG9iYWwgPSB3aW5kb3cudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gY3VycmVudCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gd2luZG93O1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIGJpbmQgdG8ga2V5Ym9hcmQgZXZlbnRzIHRvIHRvcCBmcmFtZS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ0lmIHlvdSBhcmUgdHJ5aW5nIHRvIGVtYmVkIEV4Y2FsaWJ1ciBpbiBhIGNyb3NzLW9yaWdpbiBpZnJhbWUsIGtleWJvYXJkIGV2ZW50cyB3aWxsIG5vdCBmaXJlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBrZXkgdXAgaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5faGFuZGxlS2V5VXApO1xyXG4gICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgLy8gUmVzZXQga2V5c0Rvd24gYW5kIGtleXNVcCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGVcclxuICAgICAgICB0aGlzLl9rZXlzRG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2tleXNVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIEVtaXQgc3ludGhldGljIFwiaG9sZFwiIGV2ZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hvbGQnLCBuZXcgS2V5RXZlbnQodGhpcy5fa2V5c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBsaXN0IG9mIGtleXMgYmVpbmcgcHJlc3NlZCBkb3duXHJcbiAgICAgKi9cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIGtleSBUZXN0IHdoZXRoZXIgYSBrZXkgd2FzIGp1c3QgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICB3YXNQcmVzc2VkKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzRG93bi5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBoZWxkIGRvd24uIFRoaXMgaXMgcGVyc2lzdGVkIGJldHdlZW4gZnJhbWVzLlxyXG4gICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IGlzIGhlbGQgZG93blxyXG4gICAgICovXHJcbiAgICBpc0hlbGQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMuaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcmVsZWFzZWQgdGhpcyBmcmFtZS4gVGhpcyBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgdGhlIHVwZGF0ZSBmcmFtZS5cclxuICAgICAqIEBwYXJhbSBrZXkgIFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCByZWxlYXNlZFxyXG4gICAgICovXHJcbiAgICB3YXNSZWxlYXNlZChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1VwLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGEgbWFudWFsIGtleSBldmVudFxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXJcclxuICAgICAqL1xyXG4gICAgdHJpZ2dlckV2ZW50KHR5cGUsIGtleSwgY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkb3duJykge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVLZXlEb3duKG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xyXG4gICAgICAgICAgICAgICAgY29kZToga2V5LFxyXG4gICAgICAgICAgICAgICAga2V5OiBjaGFyYWN0ZXIgIT09IG51bGwgJiYgY2hhcmFjdGVyICE9PSB2b2lkIDAgPyBjaGFyYWN0ZXIgOiBudWxsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlS2V5VXAobmV3IEtleWJvYXJkRXZlbnQoJ2tleXVwJywge1xyXG4gICAgICAgICAgICAgICAgY29kZToga2V5LFxyXG4gICAgICAgICAgICAgICAga2V5OiBjaGFyYWN0ZXIgIT09IG51bGwgJiYgY2hhcmFjdGVyICE9PSB2b2lkIDAgPyBjaGFyYWN0ZXIgOiBudWxsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9HYW1lcGFkLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgbGV2ZXJhZ2VzIHRoZSBIVE1MNSBHYW1lcGFkIEFQSSBbd2hlcmUgaXQgaXMgc3VwcG9ydGVkXShodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9Z2FtZXBhZClcclxuICogdG8gcHJvdmlkZSBjb250cm9sbGVyIHN1cHBvcnQgZm9yIHlvdXIgZ2FtZXMuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkcyBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcG9sbCBmb3IgR2FtZXBhZCBpbnB1dCAoZGVmYXVsdDogYGZhbHNlYClcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBHYW1lcGFkIEFQSSBpcyBzdXBwb3J0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1cHBvcnRlZCA9ICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgIHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuX29sZFBhZHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9wYWRzID0gW107XHJcbiAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XHJcbiAgICAgICAgdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW4gQ2hyb21lLCB0aGlzIHdpbGwgcmV0dXJuIDQgdW5kZWZpbmVkIGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAvLyBJbiBGRiwgdGhpcyB3aWxsIG5vdCByZXR1cm4gYW55IGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICB0aGlzLl9vbGRQYWRzID0gdGhpcy5fY2xvbmVQYWRzKHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpKTtcclxuICAgICAgICBpZiAodGhpcy5fb2xkUGFkcy5sZW5ndGggJiYgdGhpcy5fb2xkUGFkc1swXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0U3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGdhbWVwYWQgY29uZmlndXJhdGlvbiwgZm9yIGV4YW1wbGUge2F4aXM6IDQsIGJ1dHRvbnM6IDR9IG1lYW5zXHJcbiAgICAgKiB0aGlzIGdhbWUgcmVxdWlyZXMgYXQgbWluaW11bSA0IGF4aXMgaW5wdXRzIGFuZCA0IGJ1dHRvbnMsIHRoaXMgaXMgbm90IHJlc3RyaWN0aXZlXHJcbiAgICAgKiBhbGwgb3RoZXIgY29udHJvbGxlcnMgd2l0aCBtb3JlIGF4aXMgb3IgYnV0dG9ucyBhcmUgdmFsaWQgYXMgd2VsbC4gSWYgbm8gbWluaW11bVxyXG4gICAgICogY29uZmlndXJhdGlvbiBpcyBzZXQgYWxsIHBhZHMgYXJlIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzZXRNaW5pbXVtR2FtZXBhZENvbmZpZ3VyYXRpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGlmIGNvbmZpZyBpcyB1c2VkLCBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgIHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGltcGxpY2l0bHkgZW5hYmxlZCwgc2V0IHRoZSBlbmFibGVkIGZsYWcgYW5kIHJ1biBhbiB1cGRhdGUgc28gaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxyXG4gICAgICovXHJcbiAgICBfZW5hYmxlQW5kVXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgYSBuYXZpZ2F0b3IgZ2FtZXBhZCBhZ2FpbnN0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gaWYgcHJlc2VudC5cclxuICAgICAqL1xyXG4gICAgX2lzR2FtZXBhZFZhbGlkKHBhZCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXhlc0xlbmd0aCA9IHBhZC5heGVzLmZpbHRlcigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBidXR0b25MZW5ndGggPSBwYWQuYnV0dG9ucy5maWx0ZXIoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGF4ZXNMZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYXhpcyAmJiBidXR0b25MZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYnV0dG9ucyAmJiBwYWQuY29ubmVjdGVkO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBHYW1lcGFkIHN0YXRlIGFuZCBwdWJsaXNoZXMgR2FtZXBhZCBldmVudHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICAgIGNvbnN0IGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWVwYWRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnYW1lcGFkID0gdGhpcy5hdChpKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdhcyBjb25uZWN0ZWQsIGJ1dCBub3cgaXNuJ3QgZW1pdCB0aGUgZGlzY29ubmVjdCBldmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGlzY29ubmVjdCcsIG5ldyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KGksIGdhbWVwYWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICBnYW1lcGFkLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXQoaSkuY29ubmVjdGVkICYmIHRoaXMuX2lzR2FtZXBhZFZhbGlkKGdhbWVwYWRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgR2FtZXBhZENvbm5lY3RFdmVudChpLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbiBzdGF0dXNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWVcclxuICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgLy8gQWRkIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3IgZ2FtZXBhZFxyXG4gICAgICAgICAgICB0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQgPSBnYW1lcGFkc1tpXTtcclxuICAgICAgICAgICAgLy8gQnV0dG9uc1xyXG4gICAgICAgICAgICBsZXQgYiwgYmksIGEsIGFpLCB2YWx1ZTtcclxuICAgICAgICAgICAgZm9yIChiIGluIEJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgIGJpID0gQnV0dG9uc1tiXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRCdXR0b24oYmkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0ucHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYnV0dG9uJywgbmV3IEdhbWVwYWRCdXR0b25FdmVudChiaSwgdmFsdWUsIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBeGVzXHJcbiAgICAgICAgICAgIGZvciAoYSBpbiBBeGVzKSB7XHJcbiAgICAgICAgICAgICAgICBhaSA9IEF4ZXNbYV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYXhlc1thaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEF4ZXMoYWkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQXhlcyhhaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdheGlzJywgbmV3IEdhbWVwYWRBeGlzRXZlbnQoYWksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29sZFBhZHNbaV0gPSB0aGlzLl9jbG9uZVBhZChnYW1lcGFkc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlbHkgcmV0cmlldmVzIGEgR2FtZXBhZCBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICovXHJcbiAgICBhdChpbmRleCkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZSBnYW1lcGFkcyB3aGVuIGF0KCkgaXMgY2FsbGVkXHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BhZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhIHBhZCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHNbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdmFsaWQgZ2FtZXBhZHMgdGhhdCBtZWV0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gcmVxdWlyZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldFZhbGlkR2FtZXBhZHMoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0dhbWVwYWRWYWxpZCh0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQpICYmIHRoaXMuYXQoaSkuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmF0KGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29ubmVjdGVkIGdhbWVwYWRzXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRzLmZpbHRlcigocCkgPT4gcC5jb25uZWN0ZWQpLmxlbmd0aDtcclxuICAgIH1cclxuICAgIF9jbG9uZVBhZHMocGFkcykge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuX2Nsb25lUGFkKHBhZHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmFzdGVzdCB3YXkgdG8gY2xvbmUgYSBrbm93biBvYmplY3QgaXMgdG8gZG8gaXQgeW91cnNlbGZcclxuICAgICAqL1xyXG4gICAgX2Nsb25lUGFkKHBhZCkge1xyXG4gICAgICAgIGxldCBpLCBsZW47XHJcbiAgICAgICAgY29uc3QgY2xvbmVkUGFkID0gbmV3IEdhbWVwYWQoKTtcclxuICAgICAgICBpZiAoIXBhZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFkLmJ1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVCdXR0b24oaSwgcGFkLmJ1dHRvbnNbaV0udmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5heGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVBeGVzKGksIHBhZC5heGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIG1pbmltdW0gdmFsdWUgYW4gYXhpcyBoYXMgdG8gbW92ZSBiZWZvcmUgY29uc2lkZXJpbmcgaXQgYSBjaGFuZ2VcclxuICovXHJcbkdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkID0gMC4wNTtcclxuLyoqXHJcbiAqIEdhbWVwYWQgaG9sZHMgc3RhdGUgaW5mb3JtYXRpb24gZm9yIGEgY29ubmVjdGVkIGNvbnRyb2xsZXIuIFNlZSBbW0dhbWVwYWRzXV1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaGFuZGxpbmcgY29udHJvbGxlciBpbnB1dC5cclxuICovXHJcbmNsYXNzIEdhbWVwYWQgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYnV0dG9ucyA9IG5ldyBBcnJheSgxNik7XHJcbiAgICAgICAgdGhpcy5fYXhlcyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1dHRvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYnV0dG9uc1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICogQHBhcmFtIGJ1dHRvbiAgICAgVGhlIGJ1dHRvbiB0byBxdWVyeVxyXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCAgVGhlIHRocmVzaG9sZCBvdmVyIHdoaWNoIHRoZSBidXR0b24gaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzc2VkXHJcbiAgICAgKi9cclxuICAgIGlzQnV0dG9uUHJlc3NlZChidXR0b24sIHRocmVzaG9sZCA9IDEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dID49IHRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZ2l2ZW4gYnV0dG9uIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICovXHJcbiAgICBnZXRCdXR0b24oYnV0dG9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZ2l2ZW4gYXhpcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBWYWx1ZXMgYmVsb3dcclxuICAgICAqIFtbTWluQXhpc01vdmVUaHJlc2hvbGRdXSBhcmUgY29uc2lkZXJlZCAwLlxyXG4gICAgICovXHJcbiAgICBnZXRBeGVzKGF4ZXMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2F4ZXNbYXhlc107XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9idXR0b25zW2J1dHRvbkluZGV4XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXhlcyhheGVzSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYXhlc1theGVzSW5kZXhdID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgQnV0dG9ucyBlbnVtZXJhdGlvblxyXG4gKi9cclxudmFyIEJ1dHRvbnM7XHJcbihmdW5jdGlvbiAoQnV0dG9ucykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNlIDEgYnV0dG9uIChlLmcuIEEpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UxXCJdID0gMF0gPSBcIkZhY2UxXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZhY2UgMiBidXR0b24gKGUuZy4gQilcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTJcIl0gPSAxXSA9IFwiRmFjZTJcIjtcclxuICAgIC8qKlxyXG4gICAgICogRmFjZSAzIGJ1dHRvbiAoZS5nLiBYKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlM1wiXSA9IDJdID0gXCJGYWNlM1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNlIDQgYnV0dG9uIChlLmcuIFkpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2U0XCJdID0gM10gPSBcIkZhY2U0XCI7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0QnVtcGVyXCJdID0gNF0gPSBcIkxlZnRCdW1wZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmlnaHQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodEJ1bXBlclwiXSA9IDVdID0gXCJSaWdodEJ1bXBlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRUcmlnZ2VyXCJdID0gNl0gPSBcIkxlZnRUcmlnZ2VyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJTZWxlY3RcIl0gPSA4XSA9IFwiU2VsZWN0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJTdGFydFwiXSA9IDldID0gXCJTdGFydFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBMMylcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFN0aWNrXCJdID0gMTBdID0gXCJMZWZ0U3RpY2tcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmlnaHQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIFIzKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFN0aWNrXCJdID0gMTFdID0gXCJSaWdodFN0aWNrXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIHVwXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRVcFwiXSA9IDEyXSA9IFwiRHBhZFVwXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIGRvd25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZERvd25cIl0gPSAxM10gPSBcIkRwYWREb3duXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIGxlZnRcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIHJpZ2h0XHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRSaWdodFwiXSA9IDE1XSA9IFwiRHBhZFJpZ2h0XCI7XHJcbn0pKEJ1dHRvbnMgfHwgKEJ1dHRvbnMgPSB7fSkpO1xyXG4vKipcclxuICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXHJcbiAqL1xyXG52YXIgQXhlcztcclxuKGZ1bmN0aW9uIChBeGVzKSB7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tYXCI7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWVwiXSA9IDFdID0gXCJMZWZ0U3RpY2tZXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tYXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tYXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tZXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tZXCI7XHJcbn0pKEF4ZXMgfHwgKEF4ZXMgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvQnJvd3Nlci50c1xuY2xhc3MgQnJvd3NlckNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYXRpdmVDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLm5hdGl2ZUNvbXBvbmVudCA9IG5hdGl2ZUNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVIYW5kbGVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUhhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlSGFuZGxlcnNbZXZlbnROYW1lXSA9IHRoaXMuX2RlY29yYXRlKGhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMubmF0aXZlQ29tcG9uZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX25hdGl2ZUhhbmRsZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmF0aXZlQ29tcG9uZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgIH1cclxuICAgIF9kZWNvcmF0ZShoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9uYXRpdmVIYW5kbGVycykge1xyXG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEJyb3dzZXJFdmVudHMge1xyXG4gICAgY29uc3RydWN0b3IoX3dpbmRvd0dsb2JhbCwgX2RvY3VtZW50R2xvYmFsKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93R2xvYmFsID0gX3dpbmRvd0dsb2JhbDtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudEdsb2JhbCA9IF9kb2N1bWVudEdsb2JhbDtcclxuICAgICAgICB0aGlzLl93aW5kb3dDb21wb25lbnQgPSBuZXcgQnJvd3NlckNvbXBvbmVudCh0aGlzLl93aW5kb3dHbG9iYWwpO1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50Q29tcG9uZW50ID0gbmV3IEJyb3dzZXJDb21wb25lbnQodGhpcy5fZG9jdW1lbnRHbG9iYWwpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpbmRvdygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93Q29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IGRvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudENvbXBvbmVudDtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIHRoaXMud2luZG93LnBhdXNlKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudC5wYXVzZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMud2luZG93LnJlc3VtZSgpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQucmVzdW1lKCk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLndpbmRvdy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvZ2xvYmFsLWNvb3JkaW5hdGVzLnRzXG5cclxuY2xhc3MgR2xvYmFsQ29vcmRpbmF0ZXMge1xyXG4gICAgY29uc3RydWN0b3Iod29ybGRQb3MsIHBhZ2VQb3MsIHNjcmVlblBvcykge1xyXG4gICAgICAgIHRoaXMud29ybGRQb3MgPSB3b3JsZFBvcztcclxuICAgICAgICB0aGlzLnBhZ2VQb3MgPSBwYWdlUG9zO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuUG9zID0gc2NyZWVuUG9zO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21QYWdlUG9zaXRpb24oeE9yUG9zLCB5T3JFbmdpbmUsIGVuZ2luZU9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGV0IHBhZ2VYO1xyXG4gICAgICAgIGxldCBwYWdlWTtcclxuICAgICAgICBsZXQgcGFnZVBvcztcclxuICAgICAgICBsZXQgZW5naW5lO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIHBhZ2VYID0geE9yUG9zO1xyXG4gICAgICAgICAgICBwYWdlWSA9IHlPckVuZ2luZTtcclxuICAgICAgICAgICAgcGFnZVBvcyA9IG5ldyBWZWN0b3IocGFnZVgsIHBhZ2VZKTtcclxuICAgICAgICAgICAgZW5naW5lID0gZW5naW5lT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdlUG9zID0geE9yUG9zO1xyXG4gICAgICAgICAgICBwYWdlWCA9IHBhZ2VQb3MueDtcclxuICAgICAgICAgICAgcGFnZVkgPSBwYWdlUG9zLnk7XHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHlPckVuZ2luZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuUG9zID0gZW5naW5lLnNjcmVlbi5wYWdlVG9TY3JlZW5Db29yZGluYXRlcyhwYWdlUG9zKTtcclxuICAgICAgICBjb25zdCB3b3JsZFBvcyA9IGVuZ2luZS5zY3JlZW4uc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKHNjcmVlblBvcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb29yZGluYXRlcyh3b3JsZFBvcywgcGFnZVBvcywgc2NyZWVuUG9zKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1BvaW50ZXJFdmVudC50c1xuY2xhc3MgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBvaW50ZXJJZCwgYnV0dG9uLCBwb2ludGVyVHlwZSwgY29vcmRpbmF0ZXMsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnBvaW50ZXJJZCA9IHBvaW50ZXJJZDtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xyXG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBwYWdlUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLnBhZ2VQb3M7XHJcbiAgICB9XHJcbiAgICBnZXQgc2NyZWVuUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLnNjcmVlblBvcztcclxuICAgIH1cclxuICAgIGdldCB3b3JsZFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcy53b3JsZFBvcztcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1doZWVsRXZlbnQudHNcbmNsYXNzIFdoZWVsRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgcGFnZVgsIHBhZ2VZLCBzY3JlZW5YLCBzY3JlZW5ZLCBpbmRleCwgZGVsdGFYLCBkZWx0YVksIGRlbHRhWiwgZGVsdGFNb2RlLCBldikge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnBhZ2VYID0gcGFnZVg7XHJcbiAgICAgICAgdGhpcy5wYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuWCA9IHNjcmVlblg7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5ZID0gc2NyZWVuWTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5kZWx0YVggPSBkZWx0YVg7XHJcbiAgICAgICAgdGhpcy5kZWx0YVkgPSBkZWx0YVk7XHJcbiAgICAgICAgdGhpcy5kZWx0YVogPSBkZWx0YVo7XHJcbiAgICAgICAgdGhpcy5kZWx0YU1vZGUgPSBkZWx0YU1vZGU7XHJcbiAgICAgICAgdGhpcy5ldiA9IGV2O1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvUG9pbnRlckFic3RyYWN0aW9uLnRzXG5cclxuXHJcbmNsYXNzIFBvaW50ZXJBYnN0cmFjdGlvbiBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gb24gdGhlIGRvY3VtZW50IHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFBhZ2VQb3MgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBnYW1lIHdvcmxkIGNvb3JkaW5hdGVzIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFdvcmxkUG9zID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5fb25Qb2ludGVyTW92ZSA9IChldikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbmV3IFZlY3Rvcihldi5wYWdlUG9zLngsIGV2LnBhZ2VQb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBWZWN0b3IoZXYuc2NyZWVuUG9zLngsIGV2LnNjcmVlblBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0V29ybGRQb3MgPSBuZXcgVmVjdG9yKGV2LndvcmxkUG9zLngsIGV2LndvcmxkUG9zLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fb25Qb2ludGVyRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbmV3IFZlY3Rvcihldi5wYWdlUG9zLngsIGV2LnBhZ2VQb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBWZWN0b3IoZXYuc2NyZWVuUG9zLngsIGV2LnNjcmVlblBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0V29ybGRQb3MgPSBuZXcgVmVjdG9yKGV2LndvcmxkUG9zLngsIGV2LndvcmxkUG9zLnkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vbignbW92ZScsIHRoaXMuX29uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgIHRoaXMub24oJ2Rvd24nLCB0aGlzLl9vblBvaW50ZXJEb3duKTtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb25jZShldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1doZWVsRGVsdGFNb2RlLnRzXG52YXIgV2hlZWxEZWx0YU1vZGU7XHJcbihmdW5jdGlvbiAoV2hlZWxEZWx0YU1vZGUpIHtcclxuICAgIFdoZWVsRGVsdGFNb2RlW1wiUGl4ZWxcIl0gPSBcIlBpeGVsXCI7XHJcbiAgICBXaGVlbERlbHRhTW9kZVtcIkxpbmVcIl0gPSBcIkxpbmVcIjtcclxuICAgIFdoZWVsRGVsdGFNb2RlW1wiUGFnZVwiXSA9IFwiUGFnZVwiO1xyXG59KShXaGVlbERlbHRhTW9kZSB8fCAoV2hlZWxEZWx0YU1vZGUgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L05hdGl2ZVBvaW50ZXJCdXR0b24udHNcbi8qKlxyXG4gKiBOYXRpdmUgYnJvd3NlciBidXR0b24gZW51bWVyYXRpb25cclxuICovXHJcbnZhciBOYXRpdmVQb2ludGVyQnV0dG9uO1xyXG4oZnVuY3Rpb24gKE5hdGl2ZVBvaW50ZXJCdXR0b24pIHtcclxuICAgIE5hdGl2ZVBvaW50ZXJCdXR0b25bTmF0aXZlUG9pbnRlckJ1dHRvbltcIk5vQnV0dG9uXCJdID0gLTFdID0gXCJOb0J1dHRvblwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICBOYXRpdmVQb2ludGVyQnV0dG9uW05hdGl2ZVBvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XHJcbiAgICBOYXRpdmVQb2ludGVyQnV0dG9uW05hdGl2ZVBvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbn0pKE5hdGl2ZVBvaW50ZXJCdXR0b24gfHwgKE5hdGl2ZVBvaW50ZXJCdXR0b24gPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1BvaW50ZXJCdXR0b24udHNcbi8qKlxyXG4gKiBUaGUgbW91c2UgYnV0dG9uIGJlaW5nIHByZXNzZWQuXHJcbiAqL1xyXG52YXIgUG9pbnRlckJ1dHRvbjtcclxuKGZ1bmN0aW9uIChQb2ludGVyQnV0dG9uKSB7XHJcbiAgICBQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IFwiTGVmdFwiO1xyXG4gICAgUG9pbnRlckJ1dHRvbltcIk1pZGRsZVwiXSA9IFwiTWlkZGxlXCI7XHJcbiAgICBQb2ludGVyQnV0dG9uW1wiUmlnaHRcIl0gPSBcIlJpZ2h0XCI7XHJcbiAgICBQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IFwiVW5rbm93blwiO1xyXG4gICAgUG9pbnRlckJ1dHRvbltcIk5vQnV0dG9uXCJdID0gXCJOb0J1dHRvblwiO1xyXG59KShQb2ludGVyQnV0dG9uIHx8IChQb2ludGVyQnV0dG9uID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9Qb2ludGVyVHlwZS50c1xuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHBvaW50ZXIgZm9yIGEgW1tQb2ludGVyRXZlbnRdXS5cclxuICovXHJcbnZhciBQb2ludGVyVHlwZTtcclxuKGZ1bmN0aW9uIChQb2ludGVyVHlwZSkge1xyXG4gICAgUG9pbnRlclR5cGVbXCJUb3VjaFwiXSA9IFwiVG91Y2hcIjtcclxuICAgIFBvaW50ZXJUeXBlW1wiTW91c2VcIl0gPSBcIk1vdXNlXCI7XHJcbiAgICBQb2ludGVyVHlwZVtcIlBlblwiXSA9IFwiUGVuXCI7XHJcbiAgICBQb2ludGVyVHlwZVtcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcclxufSkoUG9pbnRlclR5cGUgfHwgKFBvaW50ZXJUeXBlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9Qb2ludGVyRXZlbnRSZWNlaXZlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJcyB0aGlzIGV2ZW50IGEgbmF0aXZlIHRvdWNoIGV2ZW50P1xyXG4gKi9cclxuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KHZhbHVlKSB7XHJcbiAgICAvLyBHdWFyZCBmb3IgU2FmYXJpIDw9IDEzLjFcclxuICAgIHJldHVybiBnbG9iYWxUaGlzLlRvdWNoRXZlbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlRvdWNoRXZlbnQ7XHJcbn1cclxuLyoqXHJcbiAqIElzIHRoaXMgZXZlbnQgYSBuYXRpdmUgcG9pbnRlciBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNQb2ludGVyRXZlbnQodmFsdWUpIHtcclxuICAgIC8vIEd1YXJkIGZvciBTYWZhcmkgPD0gMTMuMVxyXG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuUG9pbnRlckV2ZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5Qb2ludGVyRXZlbnQ7XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBQb2ludGVyRXZlbnRQcm9jZXNzb3IgaXMgcmVzcG9uc2libGUgZm9yIGNvbGxlY3RpbmcgYWxsIHRoZSBldmVudHMgZnJvbSB0aGUgY2FudmFzIGFuZCB0cmFuc2Zvcm1pbmcgdGhlbSBpbnRvIEdsb2JhbENvb3JkaW5hdGVzXHJcbiAqL1xyXG5jbGFzcyBQb2ludGVyRXZlbnRSZWNlaXZlciBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLnByaW1hcnkgPSBuZXcgUG9pbnRlckFic3RyYWN0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlTmF0aXZlUG9pbnRlcklkc1RvTm9ybWFsaXplZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZVBvaW50ZXJDb29yZHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVQb2ludGVyQ29vcmRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lUG9pbnRlckRvd24gPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVQb2ludGVyRG93biA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZURvd24gPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVVwID0gW107XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVNb3ZlID0gW107XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVDYW5jZWwgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVdoZWVsID0gW107XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlcnMgPSBbdGhpcy5wcmltYXJ5XTtcclxuICAgICAgICB0aGlzLl9ib3VuZEhhbmRsZSA9IHRoaXMuX2hhbmRsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kV2hlZWwgPSB0aGlzLl9oYW5kbGVXaGVlbC5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvaW50ZXJFdmVudFJlY2VpdmVyIHdpdGggYSBuZXcgdGFyZ2V0IGFuZCBlbmdpbmUgd2hpbGUgcHJlc2VydmluZyBleGlzdGluZyBwb2ludGVyIGV2ZW50XHJcbiAgICAgKiBoYW5kbGVycy5cclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBlbmdpbmVcclxuICAgICAqL1xyXG4gICAgcmVjcmVhdGUodGFyZ2V0LCBlbmdpbmUpIHtcclxuICAgICAgICBjb25zdCBldmVudFJlY2VpdmVyID0gbmV3IFBvaW50ZXJFdmVudFJlY2VpdmVyKHRhcmdldCwgZW5naW5lKTtcclxuICAgICAgICBldmVudFJlY2VpdmVyLnByaW1hcnkgPSB0aGlzLnByaW1hcnk7XHJcbiAgICAgICAgZXZlbnRSZWNlaXZlci5fcG9pbnRlcnMgPSB0aGlzLl9wb2ludGVycztcclxuICAgICAgICByZXR1cm4gZXZlbnRSZWNlaXZlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9jYXRlcyBhIHNwZWNpZmljIHBvaW50ZXIgYnkgaWQsIGNyZWF0ZXMgaXQgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICogQHBhcmFtIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGF0KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBwb2ludGVyIHRvIHJldHJpZXZlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wb2ludGVycy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyQWJzdHJhY3Rpb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzW2luZGV4XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBwb2ludGVycyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZCBieSBleGNhbGlidXJcclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHNwZWNpZmllZCBwb2ludGVyIGlkIGRvd24gdGhpcyBmcmFtZVxyXG4gICAgICogQHBhcmFtIHBvaW50ZXJJZFxyXG4gICAgICovXHJcbiAgICBpc0Rvd24ocG9pbnRlcklkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmN1cnJlbnRGcmFtZVBvaW50ZXJEb3duLmdldChwb2ludGVySWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2FzIHRoZSBzcGVjaWZpZWQgcG9pbnRlciBpZCBkb3duIGxhc3QgZnJhbWVcclxuICAgICAqIEBwYXJhbSBwb2ludGVySWRcclxuICAgICAqL1xyXG4gICAgd2FzRG93bihwb2ludGVySWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubGFzdEZyYW1lUG9pbnRlckRvd24uZ2V0KHBvaW50ZXJJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBQb2ludGVyIGlzIGN1cnJlbnRseSBkcmFnZ2luZy5cclxuICAgICAqL1xyXG4gICAgaXNEcmFnZ2luZyhwb2ludGVySWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0Rvd24ocG9pbnRlcklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgUG9pbnRlciBqdXN0IHN0YXJ0ZWQgZHJhZ2dpbmcuXHJcbiAgICAgKi9cclxuICAgIGlzRHJhZ1N0YXJ0KHBvaW50ZXJJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRG93bihwb2ludGVySWQpICYmICF0aGlzLndhc0Rvd24ocG9pbnRlcklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgUG9pbnRlciBqdXN0IGVuZGVkIGRyYWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBpc0RyYWdFbmQocG9pbnRlcklkKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRG93bihwb2ludGVySWQpICYmIHRoaXMud2FzRG93bihwb2ludGVySWQpO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudCwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudCwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgaW50ZXJuYWxseSBieSBleGNhbGlidXJcclxuICAgICAqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IGZyYW1lIHBvaW50ZXIgaW5mbyBhbmQgZW1pdHMgcmF3IHBvaW50ZXIgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBkb2VzIG5vdCBlbWl0IGV2ZW50cyB0byBlbnRpdGllcywgc2VlIFBvaW50ZXJTeXN0ZW1cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lUG9pbnRlckRvd24gPSBuZXcgTWFwKHRoaXMuY3VycmVudEZyYW1lUG9pbnRlckRvd24pO1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lUG9pbnRlckNvb3JkcyA9IG5ldyBNYXAodGhpcy5jdXJyZW50RnJhbWVQb2ludGVyQ29vcmRzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuY3VycmVudEZyYW1lRG93bikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rvd24nLCBldmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmF0KGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdCgnZG93bicsIGV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5LmVtaXQoJ3BvaW50ZXJkb3duJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuY3VycmVudEZyYW1lVXApIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMuYXQoZXZlbnQucG9pbnRlcklkKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0KCd1cCcsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmN1cnJlbnRGcmFtZU1vdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdtb3ZlJywgZXZlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hdChldmVudC5wb2ludGVySWQpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXQoJ21vdmUnLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5jdXJyZW50RnJhbWVDYW5jZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjYW5jZWwnLCBldmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmF0KGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdCgnY2FuY2VsJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHRoaXMuY3VycmVudEZyYW1lV2hlZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCd3aGVlbCcsIGV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5LmVtaXQoJ3BvaW50ZXJ3aGVlbCcsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCBmcmFtZSBldmVudCBhbmQgcG9pbnRlciBkYXRhXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgdGhpcy5jdXJyZW50RnJhbWVVcCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVBvaW50ZXJDb29yZHMuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IHRoaXMuX2FjdGl2ZU5hdGl2ZVBvaW50ZXJJZHNUb05vcm1hbGl6ZWQuZW50cmllcygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYXRpdmUsIG5vcm1hbGl6ZWRdIG9mIGlkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPT09IGV2ZW50LnBvaW50ZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZU5hdGl2ZVBvaW50ZXJJZHNUb05vcm1hbGl6ZWQuZGVsZXRlKG5hdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVEb3duLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lTW92ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lQ2FuY2VsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVXaGVlbC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcG9pbnRlciBldmVudCByZWNlaXZlciBzbyB0aGF0IGl0IGNhbiBzdGFydCBsaXN0ZW5pbmcgdG8gbmF0aXZlXHJcbiAgICAgKiBicm93c2VyIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICAvLyBEaXNhYmxpbmcgdGhlIHRvdWNoIGFjdGlvbiBhdm9pZHMgYnJvd3Nlci9wbGF0Zm9ybSBnZXN0dXJlcyBmcm9tIGZpcmluZyBvbiB0aGUgY2FudmFzXHJcbiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IG9uIG1vYmlsZSB0byBoYXZlIHRvdWNoIGFjdGlvbiAnbm9uZSdcclxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODEyNDM3Mi9wb2ludGVybW92ZS1ldmVudC1ub3Qtd29ya2luZy13aXRoLXRvdWNoLXdoeS1ub3RcclxuICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IHRoaXMuZW5naW5lLmNhbnZhcykge1xyXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcmVmZXJyZWQgcG9pbnRlciBldmVudHNcclxuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRvdWNoIEV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgLy8gTW91c2UgRXZlbnRzXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNRE4gTW91c2VXaGVlbEV2ZW50XHJcbiAgICAgICAgY29uc3Qgd2hlZWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwYXNzaXZlOiAhKHRoaXMuZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gU2Nyb2xsUHJldmVudGlvbk1vZGUuQWxsIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IFNjcm9sbFByZXZlbnRpb25Nb2RlLkNhbnZhcylcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcclxuICAgICAgICAgICAgLy8gTW9kZXJuIEJyb3dzZXJzXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fYm91bmRXaGVlbCwgd2hlZWxPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gV2Via2l0IGFuZCBJRVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fYm91bmRXaGVlbCwgd2hlZWxPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBicm93c2VyIGFuZCBvbGRlciBGaXJlZm94XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB0aGlzLl9ib3VuZFdoZWVsLCB3aGVlbE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaCgpIHtcclxuICAgICAgICAvLyBQcmVmZXJyZWQgcG9pbnRlciBldmVudHNcclxuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRvdWNoIEV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgLy8gTW91c2UgRXZlbnRzXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2JvdW5kSGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fYm91bmRIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJ29ud2hlZWwnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSB7XHJcbiAgICAgICAgICAgIC8vIE1vZGVybiBCcm93c2Vyc1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2JvdW5kV2hlZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIElFXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9ib3VuZFdoZWVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBicm93c2VyIGFuZCBvbGRlciBGaXJlZm94XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB0aGlzLl9ib3VuZFdoZWVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRha2UgbmF0aXZlIHBvaW50ZXIgaWQgYW5kIG1hcCBpdCB0byBpbmRleCBpbiBhY3RpdmUgcG9pbnRlcnNcclxuICAgICAqIEBwYXJhbSBuYXRpdmVQb2ludGVySWRcclxuICAgICAqL1xyXG4gICAgX25vcm1hbGl6ZVBvaW50ZXJJZChuYXRpdmVQb2ludGVySWQpIHtcclxuICAgICAgICAvLyBBZGQgdG8gdGhlIHRoZSBuYXRpdmUgcG9pbnRlciBzZXQgaWRcclxuICAgICAgICB0aGlzLl9hY3RpdmVOYXRpdmVQb2ludGVySWRzVG9Ob3JtYWxpemVkLnNldChuYXRpdmVQb2ludGVySWQsIC0xKTtcclxuICAgICAgICAvLyBOYXRpdmUgcG9pbnRlciBpZHMgaW4gYXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ZXJJZHMgPSBBcnJheS5mcm9tKHRoaXMuX2FjdGl2ZU5hdGl2ZVBvaW50ZXJJZHNUb05vcm1hbGl6ZWQua2V5cygpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICAgICAgLy8gVGhlIGluZGV4IGludG8gc29ydGVkIGlkcyB3aWxsIGJlIHRoZSBuZXcgaWQsIHdpbGwgYWx3YXlzIGhhdmUgYW4gaWRcclxuICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRQb2ludGVySWRzLmZpbmRJbmRleChwID0+IHAgPT09IG5hdGl2ZVBvaW50ZXJJZCk7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgbWFwcGluZyBzbyB3ZSBjYW4gcmV2ZXJzZSBpdCBsYXRlclxyXG4gICAgICAgIHRoaXMuX2FjdGl2ZU5hdGl2ZVBvaW50ZXJJZHNUb05vcm1hbGl6ZWQuc2V0KG5hdGl2ZVBvaW50ZXJJZCwgaWQpO1xyXG4gICAgICAgIC8vIGlnbm9yZSBwb2ludGVyIGJlY2F1c2UgZ2FtZSBpc24ndCB3YXRjaGluZ1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIGFuZCBwYXJzaW5nIHBvaW50ZXIgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIF9oYW5kbGUoZXYpIHtcclxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50Q29vcmRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBidXR0b247XHJcbiAgICAgICAgbGV0IHBvaW50ZXJUeXBlO1xyXG4gICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZXYpKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbiA9IFBvaW50ZXJCdXR0b24uVW5rbm93bjtcclxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZS5Ub3VjaDtcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RvdWNoRXZlbnRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBldi5jaGFuZ2VkVG91Y2hlc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gR2xvYmFsQ29vcmRpbmF0ZXMuZnJvbVBhZ2VQb3NpdGlvbih0b3VjaC5wYWdlWCwgdG91Y2gucGFnZVksIHRoaXMuZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVBvaW50ZXJJZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRlcklkID0gdGhpcy5fbm9ybWFsaXplUG9pbnRlcklkKG5hdGl2ZVBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVBvaW50ZXJDb29yZHMuc2V0KHBvaW50ZXJJZCwgY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRDb29yZHMuc2V0KHBvaW50ZXJJZCwgY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBidXR0b24gPSB0aGlzLl9uYXRpdmVCdXR0b25Ub1BvaW50ZXJCdXR0b24oZXYuYnV0dG9uKTtcclxuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZS5Nb3VzZTtcclxuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBHbG9iYWxDb29yZGluYXRlcy5mcm9tUGFnZVBvc2l0aW9uKGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5lbmdpbmUpO1xyXG4gICAgICAgICAgICBsZXQgbmF0aXZlUG9pbnRlcklkID0gMTtcclxuICAgICAgICAgICAgaWYgKGlzUG9pbnRlckV2ZW50KGV2KSkge1xyXG4gICAgICAgICAgICAgICAgbmF0aXZlUG9pbnRlcklkID0gZXYucG9pbnRlcklkO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSB0aGlzLl9zdHJpbmdUb1BvaW50ZXJUeXBlKGV2LnBvaW50ZXJUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludGVySWQgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVySWQobmF0aXZlUG9pbnRlcklkKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVQb2ludGVyQ29vcmRzLnNldChwb2ludGVySWQsIGNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgICAgZXZlbnRDb29yZHMuc2V0KHBvaW50ZXJJZCwgY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFtwb2ludGVySWQsIGNvb3JkXSBvZiBldmVudENvb3Jkcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChldi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncG9pbnRlcmRvd24nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVEb3duLnB1c2gobmV3IFBvaW50ZXJFdmVudCgnZG93bicsIHBvaW50ZXJJZCwgYnV0dG9uLCBwb2ludGVyVHlwZSwgY29vcmQsIGV2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVQb2ludGVyRG93bi5zZXQocG9pbnRlcklkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncG9pbnRlcnVwJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZVVwLnB1c2gobmV3IFBvaW50ZXJFdmVudCgndXAnLCBwb2ludGVySWQsIGJ1dHRvbiwgcG9pbnRlclR5cGUsIGNvb3JkLCBldikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lUG9pbnRlckRvd24uc2V0KHBvaW50ZXJJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVNb3ZlLnB1c2gobmV3IFBvaW50ZXJFdmVudCgnbW92ZScsIHBvaW50ZXJJZCwgYnV0dG9uLCBwb2ludGVyVHlwZSwgY29vcmQsIGV2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3VjaGNhbmNlbCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZUNhbmNlbC5wdXNoKG5ldyBQb2ludGVyRXZlbnQoJ2NhbmNlbCcsIHBvaW50ZXJJZCwgYnV0dG9uLCBwb2ludGVyVHlwZSwgY29vcmQsIGV2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlV2hlZWwoZXYpIHtcclxuICAgICAgICAvLyBTaG91bGQgd2UgcHJldmVudCBwYWdlIHNjcm9sbCBiZWNhdXNlIG9mIHRoaXMgZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5lbmdpbmUucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID09PSBTY3JvbGxQcmV2ZW50aW9uTW9kZS5BbGwgfHxcclxuICAgICAgICAgICAgKHRoaXMuZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzICYmIGV2LnRhcmdldCA9PT0gdGhpcy5lbmdpbmUuY2FudmFzKSkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY3JlZW4gPSB0aGlzLmVuZ2luZS5zY3JlZW4ucGFnZVRvU2NyZWVuQ29vcmRpbmF0ZXModmVjKGV2LnBhZ2VYLCBldi5wYWdlWSkpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkID0gdGhpcy5lbmdpbmUuc2NyZWVuLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhzY3JlZW4pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY29uc3RhbnQgdXNlZCB0byBub3JtYWxpemUgd2hlZWwgZXZlbnRzIGFjcm9zcyBkaWZmZXJlbnQgYnJvd3NlcnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgbm9ybWFsaXphdGlvbiBmYWN0b3IgaXMgcHVsbGVkIGZyb21cclxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWwjTGlzdGVuaW5nX3RvX3RoaXNfZXZlbnRfYWNyb3NzX2Jyb3dzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgPSAtMSAvIDQwO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IGV2LmRlbHRhWCB8fCBldi53aGVlbERlbHRhWCAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvciB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IGV2LmRlbHRhWSB8fCBldi53aGVlbERlbHRhWSAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvciB8fCBldi53aGVlbERlbHRhICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yIHx8IGV2LmRldGFpbCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhWiA9IGV2LmRlbHRhWiB8fCAwO1xyXG4gICAgICAgIGxldCBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QaXhlbDtcclxuICAgICAgICBpZiAoZXYuZGVsdGFNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChldi5kZWx0YU1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLkxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXYuZGVsdGFNb2RlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdlID0gbmV3IFdoZWVsRXZlbnQod29ybGQueCwgd29ybGQueSwgZXYucGFnZVgsIGV2LnBhZ2VZLCBzY3JlZW4ueCwgc2NyZWVuLnksIDAsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZXYpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lV2hlZWwucHVzaCh3ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGFuIGV4Y2FsaWJ1ciBwb2ludGVyIGV2ZW50IGluIGEgd29ybGQgc3BhY2UgcG9zXHJcbiAgICAgKlxyXG4gICAgICogVXNlZnVsIGZvciB0ZXN0aW5nIHBvaW50ZXJzIGluIGV4Y2FsaWJ1clxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqIEBwYXJhbSBwb3NcclxuICAgICAqL1xyXG4gICAgdHJpZ2dlckV2ZW50KHR5cGUsIHBvcykge1xyXG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmVuZ2luZS5zY3JlZW4ud29ybGRUb1BhZ2VDb29yZGluYXRlcyhwb3MpO1xyXG4gICAgICAgIC8vIFNlbmQgYW4gZXZlbnQgdG8gdGhlIGV2ZW50IHJlY2VpdmVyXHJcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlKG5ldyB3aW5kb3cuUG9pbnRlckV2ZW50KCdwb2ludGVyJyArIHR5cGUsIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJJZDogMCxcclxuICAgICAgICAgICAgICAgIGNsaWVudFg6IHBhZ2UueCxcclxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHBhZ2UueVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgaGFja1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGUobmV3IHdpbmRvdy5Nb3VzZUV2ZW50KCdtb3VzZScgKyB0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRYOiBwYWdlLngsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRZOiBwYWdlLnlcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3JjZSB1cGRhdGUgcG9pbnRlciBzeXN0ZW1cclxuICAgICAgICBjb25zdCBwb2ludGVyU3lzdGVtID0gdGhpcy5lbmdpbmUuY3VycmVudFNjZW5lLndvcmxkLnN5c3RlbU1hbmFnZXIuZ2V0KFBvaW50ZXJTeXN0ZW0pO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUVudGl0aWVzID0gdGhpcy5lbmdpbmUuY3VycmVudFNjZW5lLndvcmxkLnF1ZXJ5TWFuYWdlci5jcmVhdGVRdWVyeShwb2ludGVyU3lzdGVtLnR5cGVzKTtcclxuICAgICAgICBwb2ludGVyU3lzdGVtLnByZXVwZGF0ZSgpO1xyXG4gICAgICAgIHBvaW50ZXJTeXN0ZW0udXBkYXRlKHRyYW5zZm9ybUVudGl0aWVzLmdldEVudGl0aWVzKCkpO1xyXG4gICAgfVxyXG4gICAgX25hdGl2ZUJ1dHRvblRvUG9pbnRlckJ1dHRvbihzKSB7XHJcbiAgICAgICAgc3dpdGNoIChzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTmF0aXZlUG9pbnRlckJ1dHRvbi5Ob0J1dHRvbjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyQnV0dG9uLk5vQnV0dG9uO1xyXG4gICAgICAgICAgICBjYXNlIE5hdGl2ZVBvaW50ZXJCdXR0b24uTGVmdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyQnV0dG9uLkxlZnQ7XHJcbiAgICAgICAgICAgIGNhc2UgTmF0aXZlUG9pbnRlckJ1dHRvbi5NaWRkbGU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlckJ1dHRvbi5NaWRkbGU7XHJcbiAgICAgICAgICAgIGNhc2UgTmF0aXZlUG9pbnRlckJ1dHRvbi5SaWdodDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyQnV0dG9uLlJpZ2h0O1xyXG4gICAgICAgICAgICBjYXNlIE5hdGl2ZVBvaW50ZXJCdXR0b24uVW5rbm93bjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyQnV0dG9uLlVua25vd247XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbChzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc3RyaW5nVG9Qb2ludGVyVHlwZShzKSB7XHJcbiAgICAgICAgc3dpdGNoIChzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvdWNoJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Ub3VjaDtcclxuICAgICAgICAgICAgY2FzZSAnbW91c2UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLk1vdXNlO1xyXG4gICAgICAgICAgICBjYXNlICdwZW4nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlBlbjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Vbmtub3duO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvRnBzLnRzXG5jbGFzcyBGcHNTYW1wbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5fc2FtcGxlUGVyaW9kID0gMTAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTYW1wbGVUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9iZWdpbkZyYW1lVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZnBzID0gb3B0aW9ucy5pbml0aWFsRnBzO1xyXG4gICAgICAgIHRoaXMuX3NhbXBsZVBlcmlvZCA9IChfYSA9IG9wdGlvbnMuc2FtcGxlUGVyaW9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9zYW1wbGVQZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lVGltZSA9IDEwMDAgLyBvcHRpb25zLmluaXRpYWxGcHM7XHJcbiAgICAgICAgdGhpcy5fbm93Rm4gPSBvcHRpb25zLm5vd0ZuO1xyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU2FtcGxlVGltZSA9IHRoaXMuX25vd0ZuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IG9mIGNvZGUgYmxvY2sgdG8gc2FtcGxlIEZQUyBmb3JcclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5fYmVnaW5GcmFtZVRpbWUgPSB0aGlzLl9ub3dGbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmQgb2YgY29kZSBibG9jayB0byBzYW1wbGUgRlBTIGZvclxyXG4gICAgICovXHJcbiAgICBlbmQoKSB7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVzKys7XHJcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMuX25vd0ZuKCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lVGltZSA9IHRpbWUgLSB0aGlzLl9iZWdpbkZyYW1lVGltZTtcclxuICAgICAgICBpZiAodGltZSA+PSB0aGlzLl9wcmV2aW91c1NhbXBsZVRpbWUgKyB0aGlzLl9zYW1wbGVQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnBzID0gKHRoaXMuX2ZyYW1lcyAqIDEwMDApIC8gKHRpbWUgLSB0aGlzLl9wcmV2aW91c1NhbXBsZVRpbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1NhbXBsZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZXMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50bHkgc2FtcGxlZCBmcHMgb3ZlciB0aGUgbGFzdCBzYW1wbGUgcGVyaW9kLCBieSBkZWZhdWx0IGV2ZXJ5IDEwMG1zXHJcbiAgICAgKi9cclxuICAgIGdldCBmcHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZwcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbnN0YW50YW5lb3VzIGZwcywgdGhpcyBjYW4gYmUgbGVzcyB1c2VmdWwgYmVjYXVzZSBpdCB3aWxsIGZsdWN0dWF0ZSBnaXZlbiB0aGUgY3VycmVudCBmcmFtZXMgdGltZVxyXG4gICAgICovXHJcbiAgICBnZXQgaW5zdGFudCgpIHtcclxuICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX2N1cnJlbnRGcmFtZVRpbWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0Nsb2NrLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBDbG9jayBpcyB0aGUgYmFzZSB0eXBlIG9mIGFsbCBDbG9ja3NcclxuICpcclxuICogSXQgaGFzIGEgZmV3IG9waW5pb25zXHJcbiAqIDEuIEl0IG1hbmFnZXMgdGhlIGNhbGN1bGF0aW9uIG9mIHdoYXQgXCJlbGFwc2VkXCIgdGltZSBtZWFucyBhbmQgdGh1cyBtYXhpbXVtIGZwc1xyXG4gKiAyLiBUaGUgZGVmYXVsdCB0aW1pbmcgYXBpIGlzIGltcGxlbWVudGVkIGluIG5vdygpXHJcbiAqXHJcbiAqIFRvIGltcGxlbWVudCB5b3VyIG93biBjbG9jaywgZXh0ZW5kIENsb2NrIGFuZCBvdmVycmlkZSBzdGFydC9zdG9wIHRvIHN0YXJ0IGFuZCBzdG9wIHRoZSBjbG9jaywgdGhlbiBjYWxsIHVwZGF0ZSgpIHdpdGggd2hhdGV2ZXJcclxuICogbWV0aG9kIGlzIHVuaXF1ZSB0byB5b3VyIGNsb2NrIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxuY2xhc3MgQ2xvY2sge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMuX29uRmF0YWxFeGNlcHRpb24gPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5fbWF4RnBzID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWQgPSAxO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZENicyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsRWxhcHNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy50aWNrID0gb3B0aW9ucy50aWNrO1xyXG4gICAgICAgIHRoaXMuX2xhc3RUaW1lID0gKF9hID0gdGhpcy5ub3coKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICB0aGlzLl9tYXhGcHMgPSAoX2IgPSBvcHRpb25zLm1heEZwcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5fbWF4RnBzO1xyXG4gICAgICAgIHRoaXMuX29uRmF0YWxFeGNlcHRpb24gPSAoX2MgPSBvcHRpb25zLm9uRmF0YWxFeGNlcHRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuX29uRmF0YWxFeGNlcHRpb247XHJcbiAgICAgICAgdGhpcy5mcHNTYW1wbGVyID0gbmV3IEZwc1NhbXBsZXIoe1xyXG4gICAgICAgICAgICBpbml0aWFsRnBzOiA2MCxcclxuICAgICAgICAgICAgbm93Rm46ICgpID0+IHRoaXMubm93KClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBlbGFwc2VkIHRpbWUgZm9yIHRoZSBsYXN0IGNvbXBsZXRlZCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBlbGFwc2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGFwc2VkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgbm93KCkge1xyXG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuICAgIHRvVGVzdENsb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IHRlc3RDbG9jayA9IG5ldyBUZXN0Q2xvY2soe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zLFxyXG4gICAgICAgICAgICBkZWZhdWx0VXBkYXRlTXM6IDE2LjZcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGVzdENsb2NrO1xyXG4gICAgfVxyXG4gICAgdG9TdGFuZGFyZENsb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IGNsb2NrID0gbmV3IFN0YW5kYXJkQ2xvY2soe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9vcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNsb2NrO1xyXG4gICAgfVxyXG4gICAgc2V0RmF0YWxFeGNlcHRpb25IYW5kbGVyKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9vbkZhdGFsRXhjZXB0aW9uID0gaGFuZGxlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGUgYSBjYWxsYmFjayB0byBmaXJlIGdpdmVuIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdXNpbmcgdGhlIGV4Y2FsaWJ1ciBbW0Nsb2NrXV1cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB0byB1c2Ugb3ZlciB0aGUgYnVpbHQgaW4gYnJvd3NlciBgc2V0VGltZW91dGAgYmVjYXVzZSBjYWxsYmFja3Mgd2lsbCBiZSB0aWVkIHRvIHRoZVxyXG4gICAgICogZXhjYWxpYnVyIHVwZGF0ZSBjbG9jaywgaW5zdGVhZCBvZiBicm93c2VyIHRpbWUsIHRoaXMgbWVhbnMgdGhhdCBjYWxsYmFja3Mgd29udCBmaXJlIGlmIHRoZSBnYW1lIGlzXHJcbiAgICAgKiBzdG9wcGVkIG9yIHBhdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gZmlyZVxyXG4gICAgICogQHBhcmFtIHRpbWVvdXRNcyBPcHRpb25hbGx5IHNwZWNpZnkgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmcm9tIG5vdywgZGVmYXVsdCBpcyAwbXMgd2hpY2ggbWVhbnMgdGhlIG5leHQgcG9zc2libGUgdGlja1xyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZShjYiwgdGltZW91dE1zID0gMCkge1xyXG4gICAgICAgIC8vIFNjaGVkdWxlZCBiYXNlZCBvbiBpbnRlcm5hbCBlbGFwc2VkIHRpbWVcclxuICAgICAgICBjb25zdCBzY2hlZHVsZWRUaW1lID0gdGhpcy5fdG90YWxFbGFwc2VkICsgdGltZW91dE1zO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZENicy5wdXNoKFtjYiwgc2NoZWR1bGVkVGltZV0pO1xyXG4gICAgfVxyXG4gICAgX3J1blNjaGVkdWxlZENicygpIHtcclxuICAgICAgICAvLyB3YWxrIGJhY2t3YXJkcyB0byBkZWxldGUgaXRlbXMgYXMgd2UgbG9vcFxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zY2hlZHVsZWRDYnMubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjaGVkdWxlZENic1tpXVsxXSA8PSB0aGlzLl90b3RhbEVsYXBzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZENic1tpXVswXSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkQ2JzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShvdmVycmlkZVVwZGF0ZU1zKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5mcHNTYW1wbGVyLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZSB0byBjYWxjdWxhdGUgdGltZS1lbGFwc2VkXHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHRoaXMubm93KCk7XHJcbiAgICAgICAgICAgIGxldCBlbGFwc2VkID0gbm93IC0gdGhpcy5fbGFzdFRpbWUgfHwgMTsgLy8gZmlyc3QgZnJhbWVcclxuICAgICAgICAgICAgLy8gQ29uc3RyYWluIGZwc1xyXG4gICAgICAgICAgICBjb25zdCBmcHNJbnRlcnZhbCA9ICgxMDAwIC8gdGhpcy5fbWF4RnBzKTtcclxuICAgICAgICAgICAgLy8gb25seSBydW4gZnJhbWUgaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWRcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPj0gZnBzSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0b3ZlciA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnBzSW50ZXJ2YWwgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlciA9IChlbGFwc2VkICUgZnBzSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSBlbGFwc2VkIC0gbGVmdG92ZXI7IC8vIHNoaWZ0IGVsYXBzZWQgdG8gYmUgXCJpbiBwaGFzZVwiIHdpdGggdGhlIGN1cnJlbnQgbG9vcCBmcHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmVzIGlzc3VlICMxMzggaWYgdGhlIGdhbWUgaGFzIGJlZW4gcGF1c2VkLCBvciBibHVycmVkIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gbW9yZSB0aGFuIGEgMjAwIG1pbGxpc2Vjb25kcywgcmVzZXQgZWxhcHNlZCB0aW1lIHRvIDEuIFRoaXMgaW1wcm92ZXMgcmVsaWFiaWxpdHlcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlcyBtb3JlIGV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSBjb21lcyBiYWNrXHJcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGZvY3VzXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCA+IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGljayB0aGUgbWFpbmxvb3AgYW5kIHJ1biBzY2hlZHVsZWQgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkID0gb3ZlcnJpZGVVcGRhdGVNcyB8fCBlbGFwc2VkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxFbGFwc2VkICs9IHRoaXMuX2VsYXBzZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5TY2hlZHVsZWRDYnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGljayhvdmVycmlkZVVwZGF0ZU1zIHx8IGVsYXBzZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZwc0ludGVydmFsICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBub3cgLSBsZWZ0b3ZlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcHNTYW1wbGVyLmVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRmF0YWxFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIFtbU3RhbmRhcmRDbG9ja11dIGltcGxlbWVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBicm93c2VyIGFwaSB0byBydW4gdGhlIHRpY2soKVxyXG4gKi9cclxuY2xhc3MgU3RhbmRhcmRDbG9jayBleHRlbmRzIENsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpc1J1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcnVubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IG1haW5sb29wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBsb29wXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IG5leHQgbG9vcFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtYWlubG9vcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGJlZ2luIHRoZSBmaXJzdCBmcmFtZVxyXG4gICAgICAgIG1haW5sb29wKCk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIFRlc3RDbG9jayBpcyBtZWFudCBmb3IgZGVidWdnaW5nIGludGVyYWN0aW9ucyBpbiBleGNhbGlidXIgdGhhdCByZXF1aXJlIHByZWNpc2UgdGltaW5nIHRvIHJlcGxpY2F0ZSBvciB0ZXN0XHJcbiAqL1xyXG5jbGFzcyBUZXN0Q2xvY2sgZXh0ZW5kcyBDbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICAuLi5vcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl91cGRhdGVNcyA9IG9wdGlvbnMuZGVmYXVsdFVwZGF0ZU1zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgbm93KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fY3VycmVudFRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICB9XHJcbiAgICBpc1J1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW51YWxseSBzdGVwIHRoZSBjbG9jayBmb3J3YXJkIDEgdGljaywgb3B0aW9uYWxseSBzcGVjaWZ5IGFuIGVsYXBzZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBvdmVycmlkZVVwZGF0ZU1zXHJcbiAgICAgKi9cclxuICAgIHN0ZXAob3ZlcnJpZGVVcGRhdGVNcykge1xyXG4gICAgICAgIGNvbnN0IHRpbWUgPSBvdmVycmlkZVVwZGF0ZU1zICE9PSBudWxsICYmIG92ZXJyaWRlVXBkYXRlTXMgIT09IHZvaWQgMCA/IG92ZXJyaWRlVXBkYXRlTXMgOiB0aGlzLl91cGRhdGVNcztcclxuICAgICAgICBpZiAodGhpcy5fcnVubmluZykge1xyXG4gICAgICAgICAgICAvLyB0byBiZSBjb21wYXJhYmxlIHRvIFJBRiB0aGlzIG5lZWRzIHRvIGJlIGEgZnVsbCBibG93biBUYXNrXHJcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBpbWFnZXMgY2Fubm90IGRlY29kZSBzeW5jaHJvbm91c2x5IGluIGEgc2luZ2xlIHN0ZXBcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUodGltZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignVGhlIGNsb2NrIGlzIG5vdCBydW5uaW5nLCBubyBzdGVwIHdpbGwgYmUgcGVyZm9ybWVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gYSBudW1iZXIgb2Ygc3RlcHMgdGhhdCB0aWNrIHRoZSBjbG9jaywgb3B0aW9uYWxseSBzcGVjaWZ5IGFuIGVsYXBzZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBudW1iZXJPZlN0ZXBzXHJcbiAgICAgKiBAcGFyYW0gb3ZlcnJpZGVVcGRhdGVNc1xyXG4gICAgICovXHJcbiAgICBydW4obnVtYmVyT2ZTdGVwcywgb3ZlcnJpZGVVcGRhdGVNcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdGVwczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcChvdmVycmlkZVVwZGF0ZU1zICE9PSBudWxsICYmIG92ZXJyaWRlVXBkYXRlTXMgIT09IHZvaWQgMCA/IG92ZXJyaWRlVXBkYXRlTXMgOiB0aGlzLl91cGRhdGVNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL1V0aWwvVG9hc3Rlci5jc3NcbnZhciBVdGlsX1RvYXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczNzkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9Ub2FzdGVyLnRzXG5cclxuLyoqXHJcbiAqIFRoZSBUb2FzdGVyIGlzIG9ubHkgbWVhbnQgdG8gYmUgY2FsbGVkIGZyb20gaW5zaWRlIEV4Y2FsaWJ1ciB0byBkaXNwbGF5IG1lc3NhZ2VzIHRvIHBsYXllcnNcclxuICovXHJcbmNsYXNzIFRvYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fdG9hc3RlckNzcyA9IFV0aWxfVG9hc3Rlci8qIGRlZmF1bHQudG9TdHJpbmcgKi8uWi50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmlkID0gJ2V4LXRvYXN0LWNvbnRhaW5lcic7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlQmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZUJsb2NrLnRleHRDb250ZW50ID0gdGhpcy5fdG9hc3RlckNzcztcclxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9zdHlsZUJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5fc3R5bGVCbG9jay5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3N0eWxlQmxvY2spO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVGcmFnbWVudChtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgdG9hc3RNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgIHRvYXN0TWVzc2FnZS5pbm5lclRleHQgPSBtZXNzYWdlO1xyXG4gICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXkgYSB0b2FzdCBtZXNzYWdlIHRvIGEgcGxheWVyXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUZXh0IG9mIHRoZSBtZXNzYWdlLCBtZXNzYWdlcyBtYXkgaGF2ZSBhIHNpbmdsZSBcIltMSU5LXVwiIHRvIGluZmx1ZW5jZSBwbGFjZW1lbnRcclxuICAgICAqIEBwYXJhbSBsaW5rVGFyZ2V0IE9wdGlvbmFsbHkgc3BlY2lmeSBhIGxpbmsgbG9jYXRpb25cclxuICAgICAqIEBwYXJhbSBsaW5rTmFtZSBPcHRpb25hbGx5IHNwZWNpZnkgYSBuYW1lIGZvciB0aGF0IGxpbmsgbG9jYXRpb25cclxuICAgICAqL1xyXG4gICAgdG9hc3QobWVzc2FnZSwgbGlua1RhcmdldCwgbGlua05hbWUpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0b2FzdC5jbGFzc05hbWUgPSAnZXgtdG9hc3QtbWVzc2FnZSc7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZUZyYWdtZW50cyA9IG1lc3NhZ2Uuc3BsaXQoJ1tMSU5LXScpLm1hcChtZXNzYWdlID0+IHRoaXMuX2NyZWF0ZUZyYWdtZW50KG1lc3NhZ2UpKTtcclxuICAgICAgICBpZiAobGlua1RhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgICAgICBsaW5rLmhyZWYgPSBsaW5rVGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAobGlua05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGxpbmsuaW5uZXJUZXh0ID0gbGlua05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmlubmVyVGV4dCA9IGxpbmtUYXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVzc2FnZUZyYWdtZW50cy5zcGxpY2UoMSwgMCwgbGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFzc2VtYmx5IG1lc3NhZ2VcclxuICAgICAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBtZXNzYWdlRnJhZ21lbnRzLmZvckVhY2gobWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgIGZpbmFsTWVzc2FnZS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZChmaW5hbE1lc3NhZ2UpO1xyXG4gICAgICAgIC8vIERpc21pc3MgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgZGlzbWlzc0J0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgIGRpc21pc3NCdG4uaW5uZXJUZXh0ID0gJ3gnO1xyXG4gICAgICAgIGRpc21pc3NCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0b2FzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdG9hc3QuYXBwZW5kQ2hpbGQoZGlzbWlzc0J0bik7XHJcbiAgICAgICAgLy8gRXNjYXBlIHRvIGRpc21pc3NcclxuICAgICAgICBjb25zdCBrZXlkb3duSGFuZGxlciA9IChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2dC5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0b2FzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd25IYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duSGFuZGxlcik7XHJcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gY29udGFpbmVyXHJcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9jb250YWluZXIuZmlyc3RDaGlsZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRvYXN0LCBmaXJzdCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbmdpbmUudHNcblxyXG5cclxuXHJcbnBvbHlmaWxsKCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IG1vdXNld2hlZWwgZXZlbnQgYnViYmxlIHByZXZlbnRpb25cclxuICovXHJcbnZhciBTY3JvbGxQcmV2ZW50aW9uTW9kZTtcclxuKGZ1bmN0aW9uIChTY3JvbGxQcmV2ZW50aW9uTW9kZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEbyBub3QgcHJldmVudCBhbnkgcGFnZSBzY3JvbGxpbmdcclxuICAgICAqL1xyXG4gICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudCBwYWdlIHNjcm9sbCBpZiBtb3VzZSBpcyBvdmVyIHRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIkNhbnZhc1wiXSA9IDFdID0gXCJDYW52YXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudCBhbGwgcGFnZSBzY3JvbGxpbmcgdmlhIG1vdXNlIHdoZWVsXHJcbiAgICAgKi9cclxuICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQWxsXCJdID0gMl0gPSBcIkFsbFwiO1xyXG59KShTY3JvbGxQcmV2ZW50aW9uTW9kZSB8fCAoU2Nyb2xsUHJldmVudGlvbk1vZGUgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIEV4Y2FsaWJ1ciBFbmdpbmVcclxuICpcclxuICogVGhlIFtbRW5naW5lXV0gaXMgdGhlIG1haW4gZHJpdmVyIGZvciBhIGdhbWUuIEl0IGlzIHJlc3BvbnNpYmxlIGZvclxyXG4gKiBzdGFydGluZy9zdG9wcGluZyB0aGUgZ2FtZSwgbWFpbnRhaW5pbmcgc3RhdGUsIHRyYW5zbWl0dGluZyBldmVudHMsXHJcbiAqIGxvYWRpbmcgcmVzb3VyY2VzLCBhbmQgbWFuYWdpbmcgdGhlIHNjZW5lLlxyXG4gKi9cclxuY2xhc3MgRW5naW5lIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGdhbWUgdXNpbmcgdGhlIGdpdmVuIFtbRW5naW5lT3B0aW9uc11dLiBCeSBkZWZhdWx0LCBpZiBubyBvcHRpb25zIGFyZSBwcm92aWRlZCxcclxuICAgICAqIHRoZSBnYW1lIHdpbGwgYmUgcmVuZGVyZWQgZnVsbCBzY3JlZW4gKHRha2luZyB1cCBhbGwgYXZhaWxhYmxlIGJyb3dzZXIgd2luZG93IHNwYWNlKS5cclxuICAgICAqIFlvdSBjYW4gY3VzdG9taXplIHRoZSBnYW1lIHJlbmRlcmluZyB0aHJvdWdoIFtbRW5naW5lT3B0aW9uc11dLlxyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGU6XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIHZhciBnYW1lID0gbmV3IGV4LkVuZ2luZSh7XHJcbiAgICAgKiAgIHdpZHRoOiAwLCAvLyB0aGUgd2lkdGggb2YgdGhlIGNhbnZhc1xyXG4gICAgICogICBoZWlnaHQ6IDAsIC8vIHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gICAgICogICBlbmFibGVDYW52YXNUcmFuc3BhcmVuY3k6IHRydWUsIC8vIHRoZSB0cmFuc3BhcmVuY3lTZWN0aW9uIG9mIHRoZSBjYW52YXNcclxuICAgICAqICAgY2FudmFzRWxlbWVudElkOiAnJywgLy8gdGhlIERPTSBjYW52YXMgZWxlbWVudCBJRCwgaWYgeW91IGFyZSBwcm92aWRpbmcgeW91ciBvd25cclxuICAgICAqICAgZGlzcGxheU1vZGU6IGV4LkRpc3BsYXlNb2RlLkZ1bGxTY3JlZW4sIC8vIHRoZSBkaXNwbGF5IG1vZGVcclxuICAgICAqICAgcG9pbnRlclNjb3BlOiBleC5JbnB1dC5Qb2ludGVyU2NvcGUuRG9jdW1lbnQsIC8vIHRoZSBzY29wZSBvZiBjYXB0dXJpbmcgcG9pbnRlciAobW91c2UvdG91Y2gpIGV2ZW50c1xyXG4gICAgICogICBiYWNrZ3JvdW5kQ29sb3I6IGV4LkNvbG9yLmZyb21IZXgoJyMyMTg1ZDAnKSAvLyBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBlbmdpbmVcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIGNhbGwgZ2FtZS5zdGFydCwgd2hpY2ggaXMgYSBQcm9taXNlXHJcbiAgICAgKiBnYW1lLnN0YXJ0KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgKiAgIC8vIHJlYWR5LCBzZXQsIGdvIVxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3B0aW9uYWxseSBzZXQgdGhlIG1heGltdW0gZnBzIGlmIG5vdCBzZXQgRXhjYWxpYnVyIHdpbGwgZ28gYXMgZmFzdCBhcyB0aGUgZGV2aWNlIGFsbG93cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFlvdSBtYXkgd2FudCB0byBjb25zdHJhaW4gbWF4IGZwcyBpZiB5b3VyIGdhbWUgY2Fubm90IG1haW50YWluIGZwcyBjb25zaXN0ZW50bHksIGl0IGNhbiBsb29rIGFuZCBmZWVsIGJldHRlciB0byBoYXZlIGEgMzBmcHMgZ2FtZSB0aGFuXHJcbiAgICAgICAgICogb25lIHRoYXQgYm91bmNlcyBiZXR3ZWVuIDMwZnBzIGFuZCA2MGZwc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4RnBzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhaW5zIGFsbCB0aGUgc2NlbmVzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggRXhjYWxpYnVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2VuZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhdWRpbyBzaG91bGQgYmUgcGF1c2VkIHdoZW4gdGhlIGdhbWUgaXMgbm8gbG9uZ2VyIHZpc2libGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXVzZUF1ZGlvV2hlbkhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgZHJhdyB3aXRoIGRlYnVnIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faXNEZWJ1ZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIFRyYW5zcGFyZW5jeSBmb3IgdGhlIGVuZ2luZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFjdGlvbiB0byB0YWtlIHdoZW4gYSBmYXRhbCBleGNlcHRpb24gaXMgdGhyb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbkZhdGFsRXhjZXB0aW9uID0gKGUpID0+IHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZmF0YWwoZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl90b2FzdGVyID0gbmV3IFRvYXN0ZXIoKTtcclxuICAgICAgICB0aGlzLl90aW1lc2NhbGUgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlZmVycmVkR29UbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5fcGVyZm9ybWFuY2VUaHJlc2hvbGRUcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9mcHNTYW1wbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ0NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzUmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZyYW1lcyBlbGFwc2VkIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lRWxhcHNlZE1zID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZyYW1lIGxhZyB3aGVuIGluIGZpeGVkIHVwZGF0ZSBtb2RlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVMYWdNcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFnTXMgPSAwO1xyXG4gICAgICAgIHRoaXMuX3NjcmVlblNob3RSZXF1ZXN0cyA9IFtdO1xyXG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLkVuZ2luZS5fREVGQVVMVF9FTkdJTkVfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgRmxhZ3MuZnJlZXplKCk7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBicm93c2VyIGV2ZW50cyBmYWNhZGVcclxuICAgICAgICB0aGlzLmJyb3dzZXIgPSBuZXcgQnJvd3NlckV2ZW50cyh3aW5kb3csIGRvY3VtZW50KTtcclxuICAgICAgICAvLyBDaGVjayBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgY29uc3QgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoKTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb24gJiYgISh0aGlzLl9jb21wYXRpYmxlID0gZGV0ZWN0b3IudGVzdCgpKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJUZXh0ID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbGwgdGhlIGZlYXR1cmVzIG5lZWRlZCBmb3IgRXhjYWxpYnVyJztcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGV0ZWN0b3IuZmFpbGVkVGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIHRlc3RNZXNzYWdlLmlubmVyVGV4dCA9ICdCcm93c2VyIGZlYXR1cmUgbWlzc2luZyAnICsgdGVzdDtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wYXRpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb25zb2xlIEFQSSBmb3IgY29sb3IgZnVuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICBpZiAoY29uc29sZS5sb2cgJiYgIW9wdGlvbnMuc3VwcHJlc3NDb25zb2xlQm9vdE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCVjUG93ZXJlZCBieSBFeGNhbGlidXIuanMgKHYke0VYX1ZFUlNJT059KWAsICdiYWNrZ3JvdW5kOiAjMTc2QkFBOyBjb2xvcjogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDVweDsgcGFkZGluZzogMTVweDsgZm9udC1zaXplOiAxLjVlbTsgbGluZS1oZWlnaHQ6IDgwcHg7Jyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG5cXFxyXG4gICAgICAvfCBfX19fX19fX19fX19fX19fXFxuXFxcclxuT3w9PT18KiA+X19fX19fX19fX19fX19fXz5cXG5cXFxyXG4gICAgICBcXFxcfCcpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVmlzaXQnLCAnaHR0cDovL2V4Y2FsaWJ1cmpzLmNvbScsICdmb3IgbW9yZSBpbmZvcm1hdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdXBwcmVzcyBwbGF5IGJ1dHRvblxyXG4gICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUGxheUJ1dHRvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkLCBsZXQncyBsb2cgYnJvd3NlciBmZWF0dXJlcyB0byB0aGUgY29uc29sZS5cclxuICAgICAgICBpZiAodGhpcy5fbG9nZ2VyLmRlZmF1bHRMZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcpIHtcclxuICAgICAgICAgICAgZGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnQnVpbGRpbmcgZW5naW5lLi4uJyk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50SWQgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZDtcclxuICAgICAgICBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6ICcgKyBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6Jywgb3B0aW9ucy5jYW52YXNFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1VzaW5nIGdlbmVyYXRlZCBjYW52YXMgZWxlbWVudCcpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlzcGxheU1vZGUgPSAoX2EgPSBvcHRpb25zLmRpc3BsYXlNb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICBpZiAoKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHx8IG9wdGlvbnMudmlld3BvcnQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzcGxheU1vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBzaXplICcgKyBvcHRpb25zLndpZHRoICsgJyB4ICcgKyBvcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnRW5naW5lIHZpZXdwb3J0IGlzIGZpdCcpO1xyXG4gICAgICAgICAgICBkaXNwbGF5TW9kZSA9IERpc3BsYXlNb2RlLkZpdFNjcmVlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxEaXNwbGF5TW9kZSA9IGRpc3BsYXlNb2RlO1xyXG4gICAgICAgIC8vIENhbnZhcyAyRCBmYWxsYmFjayBjYW4gYmUgZmxhZ2dlZCBvblxyXG4gICAgICAgIGxldCB1c2VDYW52YXNHcmFwaGljc0NvbnRleHQgPSBGbGFncy5pc0VuYWJsZWQoJ3VzZS1jYW52YXMtY29udGV4dCcpO1xyXG4gICAgICAgIGlmICghdXNlQ2FudmFzR3JhcGhpY3NDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgd2ViZ2wgZmlyc3RcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0ID0gbmV3IEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMKHtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50OiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVUcmFuc3BhcmVuY3k6IHRoaXMuZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5LFxyXG4gICAgICAgICAgICAgICAgICAgIHNtb290aGluZzogb3B0aW9ucy5hbnRpYWxpYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBzbmFwVG9QaXhlbDogb3B0aW9ucy5zbmFwVG9QaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VEcmF3U29ydGluZzogb3B0aW9ucy51c2VEcmF3U29ydGluZ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBFeGNhbGlidXIgY291bGQgbm90IGxvYWQgd2ViZ2wgZm9yIHNvbWUgcmVhc29uICgke2UubWVzc2FnZX0pIGFuZCBsb2FkZWQgYSBDYW52YXMgMkQgZmFsbGJhY2suIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBTb21lIGZlYXR1cmVzIG9mIEV4Y2FsaWJ1ciB3aWxsIG5vdCB3b3JrIGluIHRoaXMgbW9kZS4gXFxuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWQgbW9yZSBhYm91dCB0aGlzIGlzc3VlIGF0IGh0dHBzOi8vZXhjYWxpYnVyanMuY29tL2RvY3Mvd2ViZ2wnKTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGNhbnZhcyBpbiBjYXNlIG9mIGZhaWx1cmVcclxuICAgICAgICAgICAgICAgIHVzZUNhbnZhc0dyYXBoaWNzQ29udGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZUNhbnZhc0dyYXBoaWNzQ29udGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dCA9IG5ldyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyh7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50OiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYW5zcGFyZW5jeTogdGhpcy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3ksXHJcbiAgICAgICAgICAgICAgICBzbW9vdGhpbmc6IG9wdGlvbnMuYW50aWFsaWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgIHNuYXBUb1BpeGVsOiBvcHRpb25zLnNuYXBUb1BpeGVsLFxyXG4gICAgICAgICAgICAgICAgdXNlRHJhd1NvcnRpbmc6IG9wdGlvbnMudXNlRHJhd1NvcnRpbmdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbih7XHJcbiAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JhcGhpY3NDb250ZXh0LFxyXG4gICAgICAgICAgICBhbnRpYWxpYXNpbmc6IChfYiA9IG9wdGlvbnMuYW50aWFsaWFzaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlLFxyXG4gICAgICAgICAgICBicm93c2VyOiB0aGlzLmJyb3dzZXIsXHJcbiAgICAgICAgICAgIHZpZXdwb3J0OiAoX2MgPSBvcHRpb25zLnZpZXdwb3J0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCA/IHsgd2lkdGg6IG9wdGlvbnMud2lkdGgsIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfSA6IFJlc29sdXRpb24uU1ZHQSksXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IG9wdGlvbnMucmVzb2x1dGlvbixcclxuICAgICAgICAgICAgZGlzcGxheU1vZGUsXHJcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IG9wdGlvbnMuc3VwcHJlc3NIaURQSVNjYWxpbmcgPyAxIDogKChfZCA9IG9wdGlvbnMucGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTZXQgZGVmYXVsdCBmaWx0ZXJpbmcgYmFzZWQgb24gYW50aWFsaWFzaW5nXHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5maWx0ZXJpbmcgPSBvcHRpb25zLmFudGlhbGlhc2luZyA/IEltYWdlRmlsdGVyaW5nLkJsZW5kZWQgOiBJbWFnZUZpbHRlcmluZy5QaXhlbDtcclxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1heEZwcyA9IChfZSA9IG9wdGlvbnMubWF4RnBzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLm1heEZwcztcclxuICAgICAgICB0aGlzLmZpeGVkVXBkYXRlRnBzID0gKF9mID0gb3B0aW9ucy5maXhlZFVwZGF0ZUZwcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5maXhlZFVwZGF0ZUZwcztcclxuICAgICAgICB0aGlzLmNsb2NrID0gbmV3IFN0YW5kYXJkQ2xvY2soe1xyXG4gICAgICAgICAgICBtYXhGcHM6IHRoaXMubWF4RnBzLFxyXG4gICAgICAgICAgICB0aWNrOiB0aGlzLl9tYWlubG9vcC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBvbkZhdGFsRXhjZXB0aW9uOiAoZSkgPT4gdGhpcy5vbkZhdGFsRXhjZXB0aW9uKGUpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3kgPSBvcHRpb25zLmVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeTtcclxuICAgICAgICB0aGlzLl9sb2FkZXIgPSBuZXcgTG9hZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG5ldyBEZWJ1Zyh0aGlzKTtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucm9vdFNjZW5lID0gdGhpcy5jdXJyZW50U2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuICAgICAgICB0aGlzLmFkZFNjZW5lKCdyb290JywgdGhpcy5yb290U2NlbmUpO1xyXG4gICAgICAgIHdpbmRvdy5fX19FWENBTElCVVJfREVWVE9PTCA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgKiByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5jYW52YXNXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgd2lkdGggY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5oYWxmQ2FudmFzV2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscywgKHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQgb2ZcclxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uY2FudmFzSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZDYW52YXNIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmhhbGZDYW52YXNIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uZHJhd1dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmhhbGZEcmF3V2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBkcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5kcmF3SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmRHJhd0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBleGNhbGlidXIgZGV0ZWN0cyB0aGUgY3VycmVudCBzY3JlZW4gdG8gYmUgSGlEUElcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzSGlEcGkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzSGlEcGk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyBbW3N0YXRzXV0gdGhhdCBob2xkcyBmcmFtZSBzdGF0aXN0aWNzLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3RhdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWcuc3RhdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2V0IHRvIGZ1bGxzY3JlZW4gb3Igbm90XHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGxzY3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzRnVsbFNjcmVlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IFtbRGlzcGxheU1vZGVdXSBvZiB0aGUgZW5naW5lLlxyXG4gICAgICovXHJcbiAgICBnZXQgZGlzcGxheU1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmRpc3BsYXlNb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHBpeGVsIHJhdGlvbiBmb3IgdXNlIGluIHJlbmRlcmluZ1xyXG4gICAgICovXHJcbiAgICBnZXQgcGl4ZWxSYXRpbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4ucGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBpc0RlYnVnKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlYnVnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIaW50cyB0aGUgZ3JhcGhpY3MgY29udGV4dCB0byB0cnVuY2F0ZSBmcmFjdGlvbmFsIHdvcmxkIHNwYWNlIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBzbmFwVG9QaXhlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaGljc0NvbnRleHQuc25hcFRvUGl4ZWw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgc25hcFRvUGl4ZWwoc2hvdWxkU25hcFRvUGl4ZWwpIHtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC5zbmFwVG9QaXhlbCA9IHNob3VsZFNuYXBUb1BpeGVsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgX21vbml0b3JQZXJmb3JtYW5jZVRocmVzaG9sZEFuZFRyaWdnZXJGYWxsYmFjaygpIHtcclxuICAgICAgICBjb25zdCB7IGFsbG93IH0gPSB0aGlzLl9vcmlnaW5hbE9wdGlvbnMuY29uZmlndXJlUGVyZm9ybWFuY2VDYW52YXMyREZhbGxiYWNrO1xyXG4gICAgICAgIGxldCB7IHRocmVzaG9sZCwgc2hvd1BsYXllck1lc3NhZ2UgfSA9IHRoaXMuX29yaWdpbmFsT3B0aW9ucy5jb25maWd1cmVQZXJmb3JtYW5jZUNhbnZhczJERmFsbGJhY2s7XHJcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IEVuZ2luZS5fREVGQVVMVF9FTkdJTkVfT1BUSU9OUy5jb25maWd1cmVQZXJmb3JtYW5jZUNhbnZhczJERmFsbGJhY2sudGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvd1BsYXllck1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzaG93UGxheWVyTWVzc2FnZSA9IEVuZ2luZS5fREVGQVVMVF9FTkdJTkVfT1BUSU9OUy5jb25maWd1cmVQZXJmb3JtYW5jZUNhbnZhczJERmFsbGJhY2suc2hvd1BsYXllck1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghRmxhZ3MuaXNFbmFibGVkKCd1c2UtY2FudmFzLWNvbnRleHQnKSAmJiBhbGxvdyAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLl9wZXJmb3JtYW5jZVRocmVzaG9sZFRyaWdnZXJlZCkge1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgQXZlcmFnZSBmcHMgZm9yIGxhc3QgWCBudW1iZXIgb2YgZnJhbWVzIGFmdGVyIHN0YXJ0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9mcHNTYW1wbGVzLmxlbmd0aCA9PT0gdGhyZXNob2xkLm51bWJlck9mRnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcHNTYW1wbGVzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9mcHNTYW1wbGVzLnB1c2godGhpcy5jbG9jay5mcHNTYW1wbGVyLmZwcyk7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZnBzU2FtcGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5fZnBzU2FtcGxlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlID0gdG90YWwgLyB0aGlzLl9mcHNTYW1wbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2Zwc1NhbXBsZXMubGVuZ3RoID09PSB0aHJlc2hvbGQubnVtYmVyT2ZGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdmVyYWdlIDw9IHRocmVzaG9sZC5mcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtYW5jZVRocmVzaG9sZFRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFN3aXRjaGluZyB0byBicm93c2VyIDJEIENhbnZhcyBmYWxsYmFjayBkdWUgdG8gcGVyZm9ybWFuY2UuIFNvbWUgZmVhdHVyZXMgb2YgRXhjYWxpYnVyIHdpbGwgbm90IHdvcmsgaW4gdGhpcyBtb2RlLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAndGhpcyBtaWdodCBtZWFuIHlvdXIgYnJvd3NlciBkb2VzblxcJ3QgaGF2ZSB3ZWJnbCBlbmFibGVkIG9yIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiBpcyB1bmF2YWlsYWJsZS5cXG5cXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lmIGluIENocm9tZTpcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgKiBWaXNpdCBTZXR0aW5ncyA+IEFkdmFuY2VkID4gU3lzdGVtLCBhbmQgZW5zdXJlIFwiVXNlIEhhcmR3YXJlIEFjY2VsZXJhdGlvblwiIGlzIGNoZWNrZWQuXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICogVmlzaXQgY2hyb21lOi8vZmxhZ3MvI2lnbm9yZS1ncHUtYmxvY2tsaXN0IGFuZCBlbnN1cmUgXCJPdmVycmlkZSBzb2Z0d2FyZSByZW5kZXJpbmcgbGlzdFwiIGlzIFwiZW5hYmxlZFwiXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdJZiBpbiBGaXJlZm94LCB2aXNpdCBhYm91dDpjb25maWdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyAgKiBFbnN1cmUgd2ViZ2wuZGlzYWJsZWQgPSBmYWxzZVxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAqIEVuc3VyZSB3ZWJnbC5mb3JjZS1lbmFibGVkID0gdHJ1ZVxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAqIEVuc3VyZSBsYXllcnMuYWNjZWxlcmF0aW9uLmZvcmNlLWVuYWJsZWQgPSB0cnVlXFxuXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWFkIG1vcmUgYWJvdXQgdGhpcyBpc3N1ZSBhdCBodHRwczovL2V4Y2FsaWJ1cmpzLmNvbS9kb2NzL3BlcmZvcm1hbmNlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dQbGF5ZXJNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvYXN0ZXIudG9hc3QoJ0V4Y2FsaWJ1ciBpcyBlbmNvdW50ZXJpbmcgcGVyZm9ybWFuY2UgaXNzdWVzLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJdFxcJ3MgcG9zc2libGUgdGhhdCB5b3VyIGJyb3dzZXIgZG9lc25cXCd0IGhhdmUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uIGVuYWJsZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Zpc2l0IFtMSU5LXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgcG90ZW50aWFsIHNvbHV0aW9ucy4nLCAnaHR0cHM6Ly9leGNhbGlidXJqcy5jb20vZG9jcy9wZXJmb3JtYW5jZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZUNhbnZhczJERmFsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZhbGxiYWNrZ3JhcGhpY3Njb250ZXh0JywgdGhpcy5ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2hlcyB0aGUgZW5naW5lJ3MgZ3JhcGhpY3MgY29udGV4dCB0byB0aGUgMkQgQ2FudmFzLlxyXG4gICAgICogQHdhcm5pbmcgU29tZSBmZWF0dXJlcyBvZiBFeGNhbGlidXIgd2lsbCBub3Qgd29yayBpbiB0aGlzIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIHVzZUNhbnZhczJERmFsbGJhY2soKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgLy8gU3dhcCBvdXQgdGhlIGNhbnZhc1xyXG4gICAgICAgIGNvbnN0IG5ld0NhbnZhcyA9IHRoaXMuY2FudmFzLmNsb25lTm9kZShmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2FudmFzLCB0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXdDYW52YXM7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29yaWdpbmFsT3B0aW9ucztcclxuICAgICAgICBjb25zdCBkaXNwbGF5TW9kZSA9IHRoaXMuX29yaWdpbmFsRGlzcGxheU1vZGU7XHJcbiAgICAgICAgLy8gTmV3IGdyYXBoaWNzIGNvbnRleHRcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dCA9IG5ldyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyh7XHJcbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQ6IHRoaXMuY2FudmFzLFxyXG4gICAgICAgICAgICBlbmFibGVUcmFuc3BhcmVuY3k6IHRoaXMuZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5LFxyXG4gICAgICAgICAgICBzbW9vdGhpbmc6IG9wdGlvbnMuYW50aWFsaWFzaW5nLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICBzbmFwVG9QaXhlbDogb3B0aW9ucy5zbmFwVG9QaXhlbCxcclxuICAgICAgICAgICAgdXNlRHJhd1NvcnRpbmc6IG9wdGlvbnMudXNlRHJhd1NvcnRpbmdcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXNldCBzY3JlZW5cclxuICAgICAgICBpZiAodGhpcy5zY3JlZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcmVlbiA9IG5ldyBTY3JlZW4oe1xyXG4gICAgICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmdyYXBoaWNzQ29udGV4dCxcclxuICAgICAgICAgICAgYW50aWFsaWFzaW5nOiAoX2EgPSBvcHRpb25zLmFudGlhbGlhc2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcclxuICAgICAgICAgICAgYnJvd3NlcjogdGhpcy5icm93c2VyLFxyXG4gICAgICAgICAgICB2aWV3cG9ydDogKF9iID0gb3B0aW9ucy52aWV3cG9ydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQgPyB7IHdpZHRoOiBvcHRpb25zLndpZHRoLCBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0IH0gOiBSZXNvbHV0aW9uLlNWR0EpLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiBvcHRpb25zLnJlc29sdXRpb24sXHJcbiAgICAgICAgICAgIGRpc3BsYXlNb2RlLFxyXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBvcHRpb25zLnN1cHByZXNzSGlEUElTY2FsaW5nID8gMSA6ICgoX2MgPSBvcHRpb25zLnBpeGVsUmF0aW8pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uc2V0Q3VycmVudENhbWVyYSh0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpO1xyXG4gICAgICAgIC8vIFJlc2V0IHBvaW50ZXJzXHJcbiAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy5kZXRhY2goKTtcclxuICAgICAgICBjb25zdCBwb2ludGVyVGFyZ2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50ZXJTY29wZSA9PT0gUG9pbnRlclNjb3BlLkRvY3VtZW50ID8gZG9jdW1lbnQgOiB0aGlzLmNhbnZhcztcclxuICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzID0gdGhpcy5pbnB1dC5wb2ludGVycy5yZWNyZWF0ZShwb2ludGVyVGFyZ2V0LCB0aGlzKTtcclxuICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLmluaXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEJvdW5kaW5nQm94IG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNjcmVlblxyXG4gICAgICogYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIGdldFdvcmxkQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5nZXRXb3JsZEJvdW5kcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGVuZ2luZSB0aW1lc2NhbGUgZmFjdG9yIChkZWZhdWx0IGlzIDEuMCB3aGljaCBpcyAxOjEgdGltZSlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbWVzY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZXNjYWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGVuZ2luZSB0aW1lc2NhbGUgZmFjdG9yLiBVc2VmdWwgZm9yIGNyZWF0aW5nIHNsb3ctbW90aW9uIGVmZmVjdHMgb3IgZmFzdC1mb3J3YXJkIGVmZmVjdHNcclxuICAgICAqIHdoZW4gdXNpbmcgdGltZS1iYXNlZCBtb3ZlbWVudC5cclxuICAgICAqL1xyXG4gICAgc2V0IHRpbWVzY2FsZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDYW5ub3Qgc2V0IGVuZ2luZS50aW1lc2NhbGUgdG8gYSB2YWx1ZSBvZiAwIG9yIGxlc3MgdGhhbiAwLicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpbWVzY2FsZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tUaW1lcl1dIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gYWRkIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICovXHJcbiAgICBhZGRUaW1lcih0aW1lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaW1lcih0aW1lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGltZXIodGltZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGltZXIodGltZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tTY2VuZV1dIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBFeGNhbGlidXIgYXMgeW91XHJcbiAgICAgKiB3b3VsZCBsZXZlbHMgb3IgbWVudXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAgVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdG8gdGhlIGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBhZGRTY2VuZShrZXksIHNjZW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ1NjZW5lJywga2V5LCAnYWxyZWFkeSBleGlzdHMgb3ZlcndyaXRpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY2VuZXNba2V5XSA9IHNjZW5lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlU2NlbmUoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNjZW5lcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSA9PT0gZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1tlbnRpdHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChlbnRpdHkpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFNjZW5lKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRHb1RvICYmIHRoaXMuc2NlbmVzW3RoaXMuX2RlZmVycmVkR29Ub10pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZXNbdGhpcy5fZGVmZXJyZWRHb1RvXS5hZGQoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShlbnRpdHkpIHtcclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgU2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxyXG4gICAgICogbmFtZWQgc2NlbmUuIENhbGxzIHRoZSBbW1NjZW5lXV0gbGlmZWN5Y2xlIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBrZXkgIFRoZSBrZXkgb2YgdGhlIHNjZW5lIHRvIHRyYW5zaXRpb24gdG8uXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBPcHRpb25hbCBkYXRhIHRvIHNlbmQgdG8gdGhlIHNjZW5lJ3Mgb25BY3RpdmF0ZSBtZXRob2RcclxuICAgICAqL1xyXG4gICAgZ29Ub1NjZW5lKGtleSwgZGF0YSkge1xyXG4gICAgICAgIC8vIGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgZGVmZXIgZ29Ub1NjZW5lXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWRHb1RvID0ga2V5O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFNjZW5lID0gdGhpcy5zY2VuZXNba2V5XTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHb2luZyB0byBzY2VuZTonLCBrZXkpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IGRlYWN0aXZhdGUgd2hlbiBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHsgZW5naW5lOiB0aGlzLCBwcmV2aW91c1NjZW5lLCBuZXh0U2NlbmUgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9kZWFjdGl2YXRlLmFwcGx5KHRoaXMuY3VycmVudFNjZW5lLCBbY29udGV4dCwgbmV4dFNjZW5lXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGVhY3RpdmF0ZScsIG5ldyBEZWFjdGl2YXRlRXZlbnQoY29udGV4dCwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzY2VuZSB0byBuZXcgb25lXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gbmV4dFNjZW5lO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbi5zZXRDdXJyZW50Q2FtZXJhKG5leHRTY2VuZS5jYW1lcmEpO1xyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjdXJyZW50IHNjZW5lIGlmIGhhcyBub3QgYmVlbiBhbHJlYWR5XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0geyBlbmdpbmU6IHRoaXMsIHByZXZpb3VzU2NlbmUsIG5leHRTY2VuZSwgZGF0YSB9O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5fYWN0aXZhdGUuYXBwbHkodGhpcy5jdXJyZW50U2NlbmUsIFtjb250ZXh0LCBuZXh0U2NlbmVdKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2FjdGl2YXRlJywgbmV3IEFjdGl2YXRlRXZlbnQoY29udGV4dCwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignU2NlbmUnLCBrZXksICdkb2VzIG5vdCBleGlzdCEnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGN1cnJlbnQgeCwgeSBmcm9tIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHBvaW50ICBTY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgKi9cclxuICAgIHNjcmVlblRvV29ybGRDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIGEgd29ybGQgY29vcmRpbmF0ZSwgdG8gYSBzY3JlZW4gY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHBvaW50ICBXb3JsZCBjb29yZGluYXRlIHRvIGNvbnZlcnRcclxuICAgICAqL1xyXG4gICAgd29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBjYW52YXMsIHJlbmRlcmluZyBjb250ZXh0LCBkaXNwbGF5IG1vZGUsIGFuZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9IG9wdGlvbnMuc2Nyb2xsUHJldmVudGlvbk1vZGU7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBpbnB1dHNcclxuICAgICAgICBjb25zdCBwb2ludGVyVGFyZ2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50ZXJTY29wZSA9PT0gUG9pbnRlclNjb3BlLkRvY3VtZW50ID8gZG9jdW1lbnQgOiB0aGlzLmNhbnZhcztcclxuICAgICAgICB0aGlzLmlucHV0ID0ge1xyXG4gICAgICAgICAgICBrZXlib2FyZDogbmV3IEtleWJvYXJkKCksXHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiBuZXcgUG9pbnRlckV2ZW50UmVjZWl2ZXIocG9pbnRlclRhcmdldCwgdGhpcyksXHJcbiAgICAgICAgICAgIGdhbWVwYWRzOiBuZXcgR2FtZXBhZHMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy5pbml0KCk7XHJcbiAgICAgICAgLy8gSXNzdWUgIzM4NSBtYWtlIHVzZSBvZiB0aGUgdmlzaWJpbGl0eSBhcGlcclxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9Vc2VyX2V4cGVyaWVuY2UvVXNpbmdfdGhlX1BhZ2VfVmlzaWJpbGl0eV9BUElcclxuICAgICAgICBsZXQgaGlkZGVuLCB2aXNpYmlsaXR5Q2hhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ21zSGlkZGVuJyBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCd3ZWJraXRIaWRkZW4nIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJyb3dzZXIuZG9jdW1lbnQub24odmlzaWJpbGl0eUNoYW5nZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRbaGlkZGVuXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaGlkZGVuJywgbmV3IEhpZGRlbkV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnV2luZG93IGhpZGRlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndmlzaWJsZScsIG5ldyBWaXNpYmxlRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdXaW5kb3cgdmlzaWJsZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhc0VsZW1lbnRJZCAmJiAhb3B0aW9ucy5jYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uSW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgc2V0IHRoZSBhbnRpYWxpYXNpbmcgZmxhZyBvbiB0aGVcclxuICAgICAqIGNhbnZhcy4gU2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCBhICdqYWdnZWQnIHBpeGVsIGFydCBsb29rIHRvIHlvdXJcclxuICAgICAqIGltYWdlIHJlc291cmNlcy5cclxuICAgICAqIEBwYXJhbSBpc1Ntb290aCAgU2V0IHNtb290aGluZyB0byB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHNldEFudGlhbGlhc2luZyhpc1Ntb290aCkge1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLmFudGlhbGlhc2luZyA9IGlzU21vb3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc21vb3RoaW5nIHN0YXR1cyBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGdldEFudGlhbGlhc2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uYW50aWFsaWFzaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGFjdG9yIGlzIEluaXRpYWxpemVkXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgX292ZXJyaWRlSW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICBzdXBlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWZlcnJlZEdvVG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkU2NlbmUgPSB0aGlzLl9kZWZlcnJlZEdvVG87XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZlcnJlZEdvVG8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvU2NlbmUoZGVmZXJyZWRTY2VuZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdvVG9TY2VuZSgncm9vdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhlIGdhbWVcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWFkeSkge1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5kIHVwZGF0ZXMgdW50aWwgbG9hZGluZyBpcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1Ymxpc2ggcHJldXBkYXRlIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgLy8gcHJvY2VzcyBlbmdpbmUgbGV2ZWwgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAvLyBQdWJsaXNoIHVwZGF0ZSBldmVudFxyXG4gICAgICAgIHRoaXMuX3Bvc3R1cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGVudGlyZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBkcmF3LlxyXG4gICAgICovXHJcbiAgICBfZHJhdyhkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LmJlZ2luRHJhd0xpZmVjeWNsZSgpO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJlZHJhdyh0aGlzLmdyYXBoaWNzQ29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgIC8vIERyYXdpbmcgbm90aGluZyBlbHNlIHdoaWxlIGxvYWRpbmdcclxuICAgICAgICBpZiAoIXRoaXMuX2lzUmVhZHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmNhbnZhcy5kcmF3KHRoaXMuZ3JhcGhpY3NDb250ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQuZmx1c2goKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5kcmF3KHRoaXMuZ3JhcGhpY3NDb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5fcG9zdGRyYXcodGhpcy5ncmFwaGljc0NvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICAvLyBGbHVzaCBhbnkgcGVuZGluZyBkcmF3aW5nc1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LmZsdXNoKCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQuZW5kRHJhd0xpZmVjeWNsZSgpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrRm9yU2NyZWVuU2hvdHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmVkcmF3KF9jdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IFByZURyYXdFdmVudChfY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVEcmF3KF9jdHgsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIG9uUHJlRHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3RkcmF3KF9jdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBQb3N0RHJhd0V2ZW50KF9jdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3REcmF3KF9jdHgsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIG9uUG9zdERyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgRXhjYWxpYnVyIGRlYnVnZ2luZyBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICogQHBhcmFtIHRvZ2dsZSBhIHZhbHVlIHRoYXQgZGVidWcgZHJhd2luZyB3aWxsIGJlIGNoYW5nZWQgdG9cclxuICAgICAqL1xyXG4gICAgc2hvd0RlYnVnKHRvZ2dsZSkge1xyXG4gICAgICAgIHRoaXMuX2lzRGVidWcgPSB0b2dnbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZSBFeGNhbGlidXIgZGVidWdnaW5nIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKi9cclxuICAgIHRvZ2dsZURlYnVnKCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGVidWcgPSAhdGhpcy5faXNEZWJ1ZztcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWJ1ZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIHdoZW4gbG9hZGluZyBpcyB0b3RhbGx5IGNvbXBsZXRlIGFuZCB0aGUgcGxheWVyIGhhcyBjbGlja2VkIHN0YXJ0XHJcbiAgICAgKi9cclxuICAgIGdldCBsb2FkaW5nQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmdDb21wbGV0ZTtcclxuICAgIH1cclxuICAgIGdldCByZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNSZWFkeTtcclxuICAgIH1cclxuICAgIGlzUmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVhZHlQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGdhbWUgbG9vcCBmb3IgRXhjYWxpYnVyIGFmdGVyIGxvYWRpbmdcclxuICAgICAqIGFueSBwcm92aWRlZCBhc3NldHMuXHJcbiAgICAgKiBAcGFyYW0gbG9hZGVyICBPcHRpb25hbCBbW0xvYWRlcl1dIHRvIHVzZSB0byBsb2FkIHJlc291cmNlcy4gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIFtbTG9hZGVyXV0sIG92ZXJyaWRlIHRvIHByb3ZpZGUgeW91ciBvd25cclxuICAgICAqIGN1c3RvbSBsb2FkZXIuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogc3RhcnQoKSBvbmx5IHJlc29sdmVzIEFGVEVSIHRoZSB1c2VyIGhhcyBjbGlja2VkIHRoZSBwbGF5IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBhc3luYyBzdGFydChsb2FkZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbXBhdGlibGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNhbGlidXIgaXMgaW5jb21wYXRpYmxlIHdpdGggeW91ciBicm93c2VyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdpcmUgbG9hZGVyIGlmIHdlIGhhdmUgaXRcclxuICAgICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgdXNlciBlbnRlcmVkIHJlc29sdXRpb24vdmlld3BvcnRcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4ucHVzaFJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICAvLyBDb25maWd1cmUgcmVzb2x1dGlvbiBmb3IgbG9hZGVyLCBpdCBleHBlY3RzIHJlc29sdXRpb24gPT09IHZpZXdwb3J0XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuLnJlc29sdXRpb24gPSB0aGlzLnNjcmVlbi52aWV3cG9ydDtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4uYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuc3VwcHJlc3NQbGF5QnV0dG9uID0gdGhpcy5fc3VwcHJlc3NQbGF5QnV0dG9uIHx8IHRoaXMuX2xvYWRlci5zdXBwcmVzc1BsYXlCdXR0b247XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci53aXJlRW5naW5lKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGFydCB0aGUgZXhjYWxpYnVyIGNsb2NrIHdoaWNoIGRyaXZlcyB0aGUgbWFpbmxvb3BcclxuICAgICAgICAvLyBoYXMgc3RhcnRlZCBpcyBhIHNsaWdodCBtaXNub21lciwgaXQncyByZWFsbHkgbWFpbmxvb3Agc3RhcnRlZFxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU3RhcnRpbmcgZ2FtZSBjbG9jay4uLicpO1xyXG4gICAgICAgIHRoaXMuYnJvd3Nlci5yZXN1bWUoKTtcclxuICAgICAgICB0aGlzLmNsb2NrLnN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIGNsb2NrIHN0YXJ0ZWQnKTtcclxuICAgICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZCh0aGlzLl9sb2FkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyByZXNldCBiYWNrIHRvIHByZXZpb3VzIHVzZXIgcmVzb2x1dGlvbi92aWV3cG9ydFxyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbi5wb3BSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4uYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ0NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAvLyBJbml0aWFsaXplIGJlZm9yZSByZWFkeVxyXG4gICAgICAgIHRoaXMuX292ZXJyaWRlSW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pc1JlYWR5UmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBuZXcgR2FtZVN0YXJ0RXZlbnQodGhpcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1JlYWR5UHJvbWlzZTtcclxuICAgIH1cclxuICAgIF9tYWlubG9vcChlbGFwc2VkKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVmcmFtZScsIG5ldyBQcmVGcmFtZUV2ZW50KHRoaXMsIHRoaXMuc3RhdHMucHJldkZyYW1lKSk7XHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBlbGFwc2VkICogdGhpcy50aW1lc2NhbGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVFbGFwc2VkTXMgPSBkZWx0YTtcclxuICAgICAgICAvLyByZXNldCBmcmFtZSBzdGF0cyAocmV1c2UgZXhpc3RpbmcgaW5zdGFuY2VzKVxyXG4gICAgICAgIGNvbnN0IGZyYW1lSWQgPSB0aGlzLnN0YXRzLnByZXZGcmFtZS5pZCArIDE7XHJcbiAgICAgICAgdGhpcy5zdGF0cy5jdXJyRnJhbWUucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnN0YXRzLmN1cnJGcmFtZS5pZCA9IGZyYW1lSWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0cy5jdXJyRnJhbWUuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICB0aGlzLnN0YXRzLmN1cnJGcmFtZS5mcHMgPSB0aGlzLmNsb2NrLmZwc1NhbXBsZXIuZnBzO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuY2xlYXIoKTtcclxuICAgICAgICBjb25zdCBiZWZvcmVVcGRhdGUgPSB0aGlzLmNsb2NrLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGZpeGVkVGltZXN0ZXBNcyA9IDEwMDAgLyB0aGlzLmZpeGVkVXBkYXRlRnBzO1xyXG4gICAgICAgIGlmICh0aGlzLmZpeGVkVXBkYXRlRnBzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhZ01zICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbGFnTXMgPj0gZml4ZWRUaW1lc3RlcE1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoZml4ZWRUaW1lc3RlcE1zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhZ01zIC09IGZpeGVkVGltZXN0ZXBNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWZ0ZXJVcGRhdGUgPSB0aGlzLmNsb2NrLm5vdygpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lTGFnTXMgPSB0aGlzLl9sYWdNcztcclxuICAgICAgICB0aGlzLl9kcmF3KGRlbHRhKTtcclxuICAgICAgICBjb25zdCBhZnRlckRyYXcgPSB0aGlzLmNsb2NrLm5vdygpO1xyXG4gICAgICAgIHRoaXMuc3RhdHMuY3VyckZyYW1lLmR1cmF0aW9uLnVwZGF0ZSA9IGFmdGVyVXBkYXRlIC0gYmVmb3JlVXBkYXRlO1xyXG4gICAgICAgIHRoaXMuc3RhdHMuY3VyckZyYW1lLmR1cmF0aW9uLmRyYXcgPSBhZnRlckRyYXcgLSBhZnRlclVwZGF0ZTtcclxuICAgICAgICB0aGlzLnN0YXRzLmN1cnJGcmFtZS5ncmFwaGljcy5kcmF3bkltYWdlcyA9IEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudDtcclxuICAgICAgICB0aGlzLnN0YXRzLmN1cnJGcmFtZS5ncmFwaGljcy5kcmF3Q2FsbHMgPSBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQ7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZnJhbWUnLCBuZXcgUG9zdEZyYW1lRXZlbnQodGhpcywgdGhpcy5zdGF0cy5jdXJyRnJhbWUpKTtcclxuICAgICAgICB0aGlzLnN0YXRzLnByZXZGcmFtZS5yZXNldCh0aGlzLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgdGhpcy5fbW9uaXRvclBlcmZvcm1hbmNlVGhyZXNob2xkQW5kVHJpZ2dlckZhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIEV4Y2FsaWJ1cidzIG1haW4gbG9vcCwgdXNlZnVsIGZvciBwYXVzaW5nIHRoZSBnYW1lLlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNsb2NrLmlzUnVubmluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5ldyBHYW1lU3RvcEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5icm93c2VyLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvY2suc3RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dhbWUgc3RvcHBlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgRW5naW5lJ3MgcnVubmluZyBzdGF0dXMsIFVzZWZ1bCBmb3IgY2hlY2tpbmcgd2hldGhlciBlbmdpbmUgaXMgcnVubmluZyBvciBwYXVzZWQuXHJcbiAgICAgKi9cclxuICAgIGlzUnVubmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9jay5pc1J1bm5pbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBzY3JlZW4gc2hvdCBvZiB0aGUgY3VycmVudCB2aWV3cG9ydCBhbmQgcmV0dXJucyBpdCBhcyBhblxyXG4gICAgICogSFRNTCBJbWFnZSBFbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHByZXNlcnZlSGlEUElSZXNvbHV0aW9uIGluIHRoZSBjYXNlIG9mIEhpRFBJIHJldHVybiB0aGUgZnVsbCBzY2FsZWQgYmFja2luZyBpbWFnZSwgYnkgZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzY3JlZW5zaG90KHByZXNlcnZlSGlEUElSZXNvbHV0aW9uID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBzY3JlZW5TaG90UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjcmVlblNob3RSZXF1ZXN0cy5wdXNoKHsgcHJlc2VydmVIaURQSVJlc29sdXRpb24sIHJlc29sdmUgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNjcmVlblNob3RQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgX2NoZWNrRm9yU2NyZWVuU2hvdHMoKSB7XHJcbiAgICAgICAgLy8gV2UgbXVzdCBncmFiIHRoZSBkcmF3IGJ1ZmZlciBiZWZvcmUgd2UgeWllbGQgdG8gdGhlIGJyb3dzZXJcclxuICAgICAgICAvLyB0aGUgZHJhdyBidWZmZXIgaXMgY2xlYXJlZCBhZnRlciBjb21wb3NpdGluZ1xyXG4gICAgICAgIC8vIHRoZSByZWFzb24gZm9yIHRoZSBhc3luY2hyb255IGlzIHNldHRpbmcgYHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZWBcclxuICAgICAgICAvLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gY29weSBidWZmZXJzIHdoaWNoIGNhbiBoYXZlIGEgbWFzcyBwZXJmIGltcGFjdCBvbiBtb2JpbGVcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5fc2NyZWVuU2hvdFJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsV2lkdGggPSByZXF1ZXN0LnByZXNlcnZlSGlEUElSZXNvbHV0aW9uID8gdGhpcy5jYW52YXMud2lkdGggOiB0aGlzLnNjcmVlbi5yZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbEhlaWdodCA9IHJlcXVlc3QucHJlc2VydmVIaURQSVJlc29sdXRpb24gPyB0aGlzLmNhbnZhcy5oZWlnaHQgOiB0aGlzLnNjcmVlbi5yZXNvbHV0aW9uLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuc2hvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBzY3JlZW5zaG90LndpZHRoID0gZmluYWxXaWR0aDtcclxuICAgICAgICAgICAgc2NyZWVuc2hvdC5oZWlnaHQgPSBmaW5hbEhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gc2NyZWVuc2hvdC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzLCAwLCAwLCBmaW5hbFdpZHRoLCBmaW5hbEhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBjb25zdCByYXcgPSBzY3JlZW5zaG90LnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zcmMgPSByYXc7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXNldCBzdGF0ZVxyXG4gICAgICAgIHRoaXMuX3NjcmVlblNob3RSZXF1ZXN0cy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbm90aGVyIG9wdGlvbiBhdmFpbGFibGUgdG8geW91IHRvIGxvYWQgcmVzb3VyY2VzIGludG8gdGhlIGdhbWUuXHJcbiAgICAgKiBJbW1lZGlhdGVseSBhZnRlciBjYWxsaW5nIHRoaXMgdGhlIGdhbWUgd2lsbCBwYXVzZSBhbmQgdGhlIGxvYWRpbmcgc2NyZWVuXHJcbiAgICAgKiB3aWxsIGFwcGVhci5cclxuICAgICAqIEBwYXJhbSBsb2FkZXIgIFNvbWUgW1tMb2FkYWJsZV1dIHN1Y2ggYXMgYSBbW0xvYWRlcl1dIGNvbGxlY3Rpb24sIFtbU291bmRdXSwgb3IgW1tUZXh0dXJlXV0uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxvYWQobG9hZGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgbG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHJlc291cmNlcywgdGhpbmdzIG1heSBub3QgYmVoYXZlIHByb3Blcmx5JywgZSk7XHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGVmYXVsdCBbW0VuZ2luZU9wdGlvbnNdXVxyXG4gKi9cclxuRW5naW5lLl9ERUZBVUxUX0VOR0lORV9PUFRJT05TID0ge1xyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgICBlbmFibGVDYW52YXNUcmFuc3BhcmVuY3k6IHRydWUsXHJcbiAgICB1c2VEcmF3U29ydGluZzogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyZVBlcmZvcm1hbmNlQ2FudmFzMkRGYWxsYmFjazoge1xyXG4gICAgICAgIGFsbG93OiB0cnVlLFxyXG4gICAgICAgIHNob3dQbGF5ZXJNZXNzYWdlOiBmYWxzZSxcclxuICAgICAgICB0aHJlc2hvbGQ6IHsgZnBzOiAyMCwgbnVtYmVyT2ZGcmFtZXM6IDEwMCB9XHJcbiAgICB9LFxyXG4gICAgY2FudmFzRWxlbWVudElkOiAnJyxcclxuICAgIGNhbnZhc0VsZW1lbnQ6IHVuZGVmaW5lZCxcclxuICAgIHNuYXBUb1BpeGVsOiBmYWxzZSxcclxuICAgIHBvaW50ZXJTY29wZTogUG9pbnRlclNjb3BlLkNhbnZhcyxcclxuICAgIHN1cHByZXNzQ29uc29sZUJvb3RNZXNzYWdlOiBudWxsLFxyXG4gICAgc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb246IG51bGwsXHJcbiAgICBzdXBwcmVzc0hpRFBJU2NhbGluZzogbnVsbCxcclxuICAgIHN1cHByZXNzUGxheUJ1dHRvbjogbnVsbCxcclxuICAgIHNjcm9sbFByZXZlbnRpb25Nb2RlOiBTY3JvbGxQcmV2ZW50aW9uTW9kZS5DYW52YXMsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLmZyb21IZXgoJyMyMTg1ZDAnKSAvLyBFeGNhbGlidXIgYmx1ZVxyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvSW5kZXgudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvaW5kZXgudHNcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTGFiZWwudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIExhYmVscyBhcmUgdGhlIHdheSB0byBkcmF3IHNtYWxsIGFtb3VudHMgb2YgdGV4dCB0byB0aGUgc2NyZWVuLiBUaGV5IGFyZVxyXG4gKiBhY3RvcnMgYW5kIGluaGVyaXQgYWxsIG9mIHRoZSBiZW5lZml0cyBhbmQgY2FwYWJpbGl0aWVzLlxyXG4gKi9cclxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBBY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgbmV3IGxhYmVsXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fZm9udCA9IG5ldyBGb250KCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9IG5ldyBUZXh0KHsgdGV4dDogJycsIGZvbnQ6IHRoaXMuX2ZvbnQgfSk7XHJcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBwb3MsIHgsIHksIHNwcml0ZUZvbnQsIGZvbnQsIGNvbG9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogKHggJiYgeSA/IHZlYyh4LCB5KSA6IHRoaXMucG9zKTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy5mb250ID0gZm9udCAhPT0gbnVsbCAmJiBmb250ICE9PSB2b2lkIDAgPyBmb250IDogdGhpcy5mb250O1xyXG4gICAgICAgIHRoaXMuc3ByaXRlRm9udCA9IHNwcml0ZUZvbnQgIT09IG51bGwgJiYgc3ByaXRlRm9udCAhPT0gdm9pZCAwID8gc3ByaXRlRm9udCA6IHRoaXMuc3ByaXRlRm9udDtcclxuICAgICAgICB0aGlzLl90ZXh0LmNvbG9yID0gY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogdGhpcy5jb2xvcjtcclxuICAgICAgICBjb25zdCBnZnggPSB0aGlzLmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgZ2Z4LmFuY2hvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIGdmeC51c2UodGhpcy5fdGV4dCk7XHJcbiAgICB9XHJcbiAgICBnZXQgZm9udCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcclxuICAgIH1cclxuICAgIHNldCBmb250KG5ld0ZvbnQpIHtcclxuICAgICAgICB0aGlzLl9mb250ID0gbmV3Rm9udDtcclxuICAgICAgICB0aGlzLl90ZXh0LmZvbnQgPSBuZXdGb250O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCB0byBkcmF3LlxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dC50ZXh0O1xyXG4gICAgfVxyXG4gICAgc2V0IHRleHQodGV4dCkge1xyXG4gICAgICAgIHRoaXMuX3RleHQudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQuY29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3IoY29sb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQub3BhY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcclxuICAgICAgICB0aGlzLl90ZXh0Lm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tTcHJpdGVGb250XV0gdG8gdXNlLCBpZiBhbnkuIE92ZXJyaWRlcyBbW0ZvbnR8Zm9udF1dIGlmIHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBzcHJpdGVGb250KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGVGb250O1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcml0ZUZvbnQoc2YpIHtcclxuICAgICAgICBpZiAoc2YpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlRm9udCA9IHNmO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LmZvbnQgPSB0aGlzLl9zcHJpdGVGb250O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGluIHRoZSBsYWJlbCAoaW4gcGl4ZWxzKTtcclxuICAgICAqL1xyXG4gICAgZ2V0VGV4dFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0LndpZHRoO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVGlsZU1hcC9Jc29tZXRyaWNNYXAudHNcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgSXNvbWV0cmljVGlsZSBleHRlbmRzIEVudGl0eSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBJc29tZXRyaWNUaWxlXHJcbiAgICAgKiBAcGFyYW0geCB0aWxlIGNvb3JkaW5hdGUgaW4geCAobm90IHdvcmxkIHBvc2l0aW9uKVxyXG4gICAgICogQHBhcmFtIHkgdGlsZSBjb29yZGluYXRlIGluIHkgKG5vdCB3b3JsZCBwb3NpdGlvbilcclxuICAgICAqIEBwYXJhbSBncmFwaGljc09mZnNldCBvZmZzZXQgdGhhdCB0aWxlIHNob3VsZCBiZSBzaGlmdGVkIGJ5IChkZWZhdWx0ICgwLCAwKSlcclxuICAgICAqIEBwYXJhbSBtYXAgcmVmZXJlbmNlIHRvIG93bmluZyBJc29tZXRyaWNNYXBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgZ3JhcGhpY3NPZmZzZXQsIG1hcCkge1xyXG4gICAgICAgIHN1cGVyKFtcclxuICAgICAgICAgICAgbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpLFxyXG4gICAgICAgICAgICBuZXcgR3JhcGhpY3NDb21wb25lbnQoe1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBncmFwaGljc09mZnNldCAhPT0gbnVsbCAmJiBncmFwaGljc09mZnNldCAhPT0gdm9pZCAwID8gZ3JhcGhpY3NPZmZzZXQgOiBWZWN0b3IuWmVybyxcclxuICAgICAgICAgICAgICAgIG9uUG9zdERyYXc6IChnZngsIGVsYXBzZWQpID0+IHRoaXMuZHJhdyhnZngsIGVsYXBzZWQpXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBuZXcgSXNvbWV0cmljRW50aXR5Q29tcG9uZW50KG1hcClcclxuICAgICAgICBdKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRpbGUgaXMgc29saWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvbGlkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdGlsZUJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGlsZSBjb2xsaWRlcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9pc29tZXRyaWNFbnRpdHlDb21wb25lbnQgPSB0aGlzLmdldChJc29tZXRyaWNFbnRpdHlDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IGhhbGZUaWxlV2lkdGggPSB0aGlzLm1hcC50aWxlV2lkdGggLyAyO1xyXG4gICAgICAgIGNvbnN0IGhhbGZUaWxlSGVpZ2h0ID0gdGhpcy5tYXAudGlsZUhlaWdodCAvIDI7XHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY2xpbnRiZWxsYW5nZXIubmV0L2FydGljbGVzL2lzb21ldHJpY19tYXRoLyBmb3IgZm9ybXVsYVxyXG4gICAgICAgIC8vIFRoZSB4IHBvc2l0aW9uIHNoaWZ0cyBsZWZ0IHdpdGggZXZlcnkgeSBzdGVwXHJcbiAgICAgICAgY29uc3QgeFBvcyA9ICh0aGlzLnggLSB0aGlzLnkpICogaGFsZlRpbGVXaWR0aDtcclxuICAgICAgICAvLyBUaGUgeSBwb3NpdGlvbiBuZWVkcyB0byBnbyBkb3duIHdpdGggZXZlcnkgeCBzdGVwXHJcbiAgICAgICAgY29uc3QgeVBvcyA9ICh0aGlzLnggKyB0aGlzLnkpICogaGFsZlRpbGVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnBvcyA9IHZlYyh4UG9zLCB5UG9zKTtcclxuICAgICAgICB0aGlzLl9pc29tZXRyaWNFbnRpdHlDb21wb25lbnQuZWxldmF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9nZnggPSB0aGlzLmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZ2Z4LnZpc2libGUgPSBmYWxzZTsgLy8gc3RhcnQgbm90IHZpc2libGVcclxuICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gdGhpcy5tYXAudGlsZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGhpcy5tYXAudGlsZUhlaWdodDtcclxuICAgICAgICAvLyBpbml0aWFsIGd1ZXNzIGF0IGdmeCBib3VuZHMgYmFzZWQgb24gdGhlIHRpbGVcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB2ZWMoMCwgKHRoaXMubWFwLnJlbmRlckZyb21Ub3BPZkdyYXBoaWMgPyB0b3RhbEhlaWdodCA6IDApKTtcclxuICAgICAgICB0aGlzLl9nZngubG9jYWxCb3VuZHMgPSB0aGlzLl90aWxlQm91bmRzID0gbmV3IEJvdW5kaW5nQm94KHtcclxuICAgICAgICAgICAgbGVmdDogLXRvdGFsV2lkdGggLyAyLFxyXG4gICAgICAgICAgICB0b3A6IC10b3RhbEhlaWdodCxcclxuICAgICAgICAgICAgcmlnaHQ6IHRvdGFsV2lkdGggLyAyLFxyXG4gICAgICAgICAgICBib3R0b206IHRvdGFsSGVpZ2h0XHJcbiAgICAgICAgfSkudHJhbnNsYXRlKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBnZXRHcmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRpbGUgZ3JhcGhpY3NcclxuICAgICAqL1xyXG4gICAgYWRkR3JhcGhpYyhncmFwaGljKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MucHVzaChncmFwaGljKTtcclxuICAgICAgICB0aGlzLl9nZngudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZ2Z4LmxvY2FsQm91bmRzID0gdGhpcy5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgIH1cclxuICAgIF9yZWNhbGN1bGF0ZUJvdW5kcygpIHtcclxuICAgICAgICBsZXQgYm91bmRzID0gdGhpcy5fdGlsZUJvdW5kcy5jbG9uZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZ3JhcGhpYyBvZiB0aGlzLl9ncmFwaGljcykge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB2ZWModGhpcy5tYXAuZ3JhcGhpY3NPZmZzZXQueCAtIHRoaXMubWFwLnRpbGVXaWR0aCAvIDIsIHRoaXMubWFwLmdyYXBoaWNzT2Zmc2V0LnkgLSAodGhpcy5tYXAucmVuZGVyRnJvbVRvcE9mR3JhcGhpYyA/IDAgOiAoZ3JhcGhpYy5oZWlnaHQgLSB0aGlzLm1hcC50aWxlSGVpZ2h0KSkpO1xyXG4gICAgICAgICAgICBib3VuZHMgPSBib3VuZHMuY29tYmluZShncmFwaGljLmxvY2FsQm91bmRzLnRyYW5zbGF0ZShvZmZzZXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuICAgIHJlbW92ZUdyYXBoaWMoZ3JhcGhpYykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ3JhcGhpY3MuaW5kZXhPZihncmFwaGljKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9nZngubG9jYWxCb3VuZHMgPSB0aGlzLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJHcmFwaGljcygpIHtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2dmeC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ2Z4LmxvY2FsQm91bmRzID0gdGhpcy5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgIH1cclxuICAgIGdldENvbGxpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY29sbGlkZXIgdG8gdGhlIElzb21ldHJpY1RpbGVcclxuICAgICAqXHJcbiAgICAgKiAqKk5vdGUhKiogdGhlIFtbVGlsZS5zb2xpZF1dIG11c3QgYmUgc2V0IHRvIHRydWUgZm9yIGl0IHRvIGFjdCBhcyBhIFwiZml4ZWRcIiBjb2xsaWRlclxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGFkZENvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzLnB1c2goY29sbGlkZXIpO1xyXG4gICAgICAgIHRoaXMubWFwLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29sbGlkZXIgZnJvbSB0aGUgSXNvbWV0cmljVGlsZVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jb2xsaWRlcnMuaW5kZXhPZihjb2xsaWRlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFwLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIGNvbGxpZGVycyBmcm9tIHRoZSBJc29tZXRyaWNUaWxlXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQ29sbGlkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMubWFwLmZsYWdDb2xsaWRlcnNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIFtbSXNvbWV0cmljVGlsZV1dIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnRpbGVUb1dvcmxkKHZlYyh0aGlzLngsIHRoaXMueSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIFtbSXNvbWV0cmljVGlsZV1dXHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh2ZWMoMCwgdGhpcy5tYXAudGlsZUhlaWdodCAvIDIpKTtcclxuICAgIH1cclxuICAgIGRyYXcoZ2Z4LCBfZWxhcHNlZCkge1xyXG4gICAgICAgIGNvbnN0IGhhbGZUaWxlV2lkdGggPSB0aGlzLm1hcC50aWxlV2lkdGggLyAyO1xyXG4gICAgICAgIGdmeC5zYXZlKCk7XHJcbiAgICAgICAgLy8gc2hpZnQgbGVmdCBvcmlnaW4gdG8gY29ybmVyIG9mIG1hcCwgbm90IHRoZSBsZWZ0IGNvcm5lciBvZiB0aGUgZmlyc3Qgc3ByaXRlXHJcbiAgICAgICAgZ2Z4LnRyYW5zbGF0ZSgtaGFsZlRpbGVXaWR0aCwgMCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBncmFwaGljIG9mIHRoaXMuX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWMuZHJhdyhnZngsIHRoaXMubWFwLmdyYXBoaWNzT2Zmc2V0LngsIHRoaXMubWFwLmdyYXBoaWNzT2Zmc2V0LnkgLSAodGhpcy5tYXAucmVuZGVyRnJvbVRvcE9mR3JhcGhpYyA/IDAgOiAoZ3JhcGhpYy5oZWlnaHQgLSB0aGlzLm1hcC50aWxlSGVpZ2h0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZngucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgSXNvbWV0cmljTWFwIGlzIGEgc3BlY2lhbCB0aWxlIG1hcCB0aGF0IHByb3ZpZGVzIGlzb21ldHJpYyByZW5kZXJpbmcgc3VwcG9ydCB0byBFeGNhbGlidXJcclxuICpcclxuICogVGhlIHRpbGVXaWR0aCBhbmQgdGlsZUhlaWdodCBzaG91bGQgYmUgdGhlIGhlaWdodCBhbmQgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBwYXJhbGxlbG9ncmFtIG9mIHRoZSBiYXNlIG9mIHRoZSB0aWxlIGFydCBhc3NldC5cclxuICogVGhlIHRpbGVXaWR0aCBhbmQgdGlsZUhlaWdodCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgYXMgeW91ciBncmFwaGljIHBpeGVsIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAqXHJcbiAqIFBsZWFzZSByZWZlciB0byB0aGUgZG9jcyBodHRwczovL2V4Y2FsaWJ1cmpzLmNvbSBmb3IgbW9yZSBkZXRhaWxzIGNhbGN1bGF0aW5nIHdoYXQgeW91ciB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgc2hvdWxkIGJlIGdpdmVuXHJcbiAqIHlvdXIgYXJ0IGFzc2V0cy5cclxuICovXHJcbmNsYXNzIElzb21ldHJpY01hcCBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoW1xyXG4gICAgICAgICAgICBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCksXHJcbiAgICAgICAgICAgIG5ldyBCb2R5Q29tcG9uZW50KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IENvbGxpc2lvblR5cGUuRml4ZWRcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG5ldyBDb2xsaWRlckNvbXBvbmVudCgpLFxyXG4gICAgICAgICAgICBuZXcgRGVidWdHcmFwaGljc0NvbXBvbmVudCgoY3R4KSA9PiB0aGlzLmRlYnVnKGN0eCksIGZhbHNlKVxyXG4gICAgICAgIF0sIG9wdGlvbnMubmFtZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVuZGVyIHRoZSB0aWxlIGdyYXBoaWMgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgdGhlIGJvdHRvbVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogZGVmYXVsdCBpcyBgZmFsc2VgIG1lYW5pbmcgcmVuZGVyaW5nIGZyb20gdGhlIGJvdHRvbVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVuZGVyRnJvbVRvcE9mR3JhcGhpYyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NPZmZzZXQgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9mZnNldHMgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIGNvbnN0IHsgcG9zLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGNvbHVtbnM6IHdpZHRoLCByb3dzOiBoZWlnaHQsIHJlbmRlckZyb21Ub3BPZkdyYXBoaWMsIGdyYXBoaWNzT2Zmc2V0IH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnBvcyA9IHBvcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IHRoaXMuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICBpZiAodGhpcy5jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpZGVyLnNldCh0aGlzLl9jb21wb3NpdGUgPSBuZXcgQ29tcG9zaXRlQ29sbGlkZXIoW10pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGcm9tVG9wT2ZHcmFwaGljID0gcmVuZGVyRnJvbVRvcE9mR3JhcGhpYyAhPT0gbnVsbCAmJiByZW5kZXJGcm9tVG9wT2ZHcmFwaGljICE9PSB2b2lkIDAgPyByZW5kZXJGcm9tVG9wT2ZHcmFwaGljIDogdGhpcy5yZW5kZXJGcm9tVG9wT2ZHcmFwaGljO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NPZmZzZXQgPSBncmFwaGljc09mZnNldCAhPT0gbnVsbCAmJiBncmFwaGljc09mZnNldCAhPT0gdm9pZCAwID8gZ3JhcGhpY3NPZmZzZXQgOiB0aGlzLmdyYXBoaWNzT2Zmc2V0O1xyXG4gICAgICAgIHRoaXMudGlsZVdpZHRoID0gdGlsZVdpZHRoO1xyXG4gICAgICAgIHRoaXMudGlsZUhlaWdodCA9IHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudGlsZXMgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIC8vIGJ1aWxkIHVwIHRpbGUgcmVwcmVzZW50YXRpb25cclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGlsZSA9IG5ldyBJc29tZXRyaWNUaWxlKHgsIHksIHRoaXMuZ3JhcGhpY3NPZmZzZXQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlc1t4ICsgeSAqIHdpZHRoXSA9IHRpbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyByb3cvY29sdW1ucyBoZWxwZXJzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGVyc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sbGlkZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmxhZ0NvbGxpZGVyc0RpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVyc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9nZXRPclNldENvbGxpZGVyT3JpZ2luYWxPZmZzZXQoY29sbGlkZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29yaWdpbmFsT2Zmc2V0cy5oYXMoY29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsT2Zmc2V0ID0gY29sbGlkZXIub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE9mZnNldHMuc2V0KGNvbGxpZGVyLCBvcmlnaW5hbE9mZnNldCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbE9mZnNldHMuZ2V0KGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlLmNsZWFyQ29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5wb3M7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMudGlsZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRpbGUuc29saWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgdGlsZS5nZXRDb2xsaWRlcnMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsT2Zmc2V0ID0gdGhpcy5fZ2V0T3JTZXRDb2xsaWRlck9yaWdpbmFsT2Zmc2V0KGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlci5vZmZzZXQgPSB0aGlzLnRpbGVUb1dvcmxkKHZlYyh0aWxlLngsIHRpbGUueSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWIocG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKG9yaWdpbmFsT2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3ViKHZlYyh0aGlzLnRpbGVXaWR0aCAvIDIsIHRoaXMudGlsZUhlaWdodCkpOyAvLyBXZSBuZWVkIHRvIHVuc2hpZnQgaGVpZ2h0IGJhc2VkIG9uIGRyYXdpbmdcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlci5vd25lciA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlLmFkZENvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbGxpZGVyLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHdvcmxkIHNwYWNlIGNvb3JkaW5hdGVzIHRvIHRoZSB0aWxlIHgsIHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICB3b3JsZFRvVGlsZSh3b3JsZENvb3JkaW5hdGUpIHtcclxuICAgICAgICB3b3JsZENvb3JkaW5hdGUgPSB3b3JsZENvb3JkaW5hdGUuc3ViKHRoaXMudHJhbnNmb3JtLmdsb2JhbFBvcyk7XHJcbiAgICAgICAgY29uc3QgaGFsZlRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoIC8gMjtcclxuICAgICAgICBjb25zdCBoYWxmVGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodCAvIDI7XHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY2xpbnRiZWxsYW5nZXIubmV0L2FydGljbGVzL2lzb21ldHJpY19tYXRoLyBmb3IgZm9ybXVsYVxyXG4gICAgICAgIHJldHVybiB2ZWMofn4oKHdvcmxkQ29vcmRpbmF0ZS54IC8gaGFsZlRpbGVXaWR0aCArICh3b3JsZENvb3JkaW5hdGUueSAvIGhhbGZUaWxlSGVpZ2h0KSkgLyAyKSwgfn4oKHdvcmxkQ29vcmRpbmF0ZS55IC8gaGFsZlRpbGVIZWlnaHQgLSAod29ybGRDb29yZGluYXRlLnggLyBoYWxmVGlsZVdpZHRoKSkgLyAyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgdGlsZSBjb29yZGluYXRlLCByZXR1cm4gdGhlIHRvcCBsZWZ0IGNvcm5lciBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICogQHBhcmFtIHRpbGVDb29yZGluYXRlXHJcbiAgICAgKi9cclxuICAgIHRpbGVUb1dvcmxkKHRpbGVDb29yZGluYXRlKSB7XHJcbiAgICAgICAgY29uc3QgaGFsZlRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoIC8gMjtcclxuICAgICAgICBjb25zdCBoYWxmVGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodCAvIDI7XHJcbiAgICAgICAgLy8gVGhlIHggcG9zaXRpb24gc2hpZnRzIGxlZnQgd2l0aCBldmVyeSB5IHN0ZXBcclxuICAgICAgICBjb25zdCB4UG9zID0gKHRpbGVDb29yZGluYXRlLnggLSB0aWxlQ29vcmRpbmF0ZS55KSAqIGhhbGZUaWxlV2lkdGg7XHJcbiAgICAgICAgLy8gVGhlIHkgcG9zaXRpb24gbmVlZHMgdG8gZ28gZG93biB3aXRoIGV2ZXJ5IHggc3RlcFxyXG4gICAgICAgIGNvbnN0IHlQb3MgPSAodGlsZUNvb3JkaW5hdGUueCArIHRpbGVDb29yZGluYXRlLnkpICogaGFsZlRpbGVIZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHZlYyh4UG9zLCB5UG9zKS5hZGQodGhpcy50cmFuc2Zvcm0ucG9zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgW1tJc29tZXRyaWNUaWxlXV0gYnkgaXRzIHggYW5kIHkgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZSh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2x1bW5zIHx8IHkgPj0gdGhpcy5yb3dzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlc1t4ICsgeSAqIHRoaXMuY29sdW1uc107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbSXNvbWV0cmljVGlsZV1dIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyxcclxuICAgICAqIHJldHVybnMgYG51bGxgIGlmIG5vIFRpbGUgd2FzIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQnlQb2ludChwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRoaXMud29ybGRUb1RpbGUocG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLmdldFRpbGUodGlsZUNvb3JkLngsIHRpbGVDb29yZC55KTtcclxuICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgIH1cclxuICAgIF9nZXRNYXhaSW5kZXgoKSB7XHJcbiAgICAgICAgbGV0IG1heFogPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMudGlsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFogPSB0aWxlLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLno7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50WiA+IG1heFopIHtcclxuICAgICAgICAgICAgICAgIG1heFogPSBjdXJyZW50WjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4WjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVidWcgZHJhdyBmb3IgSXNvbWV0cmljTWFwLCBjYWxsZWQgaW50ZXJuYWxseSBieSBleGNhbGlidXIgd2hlbiBkZWJ1ZyBtb2RlIGlzIHRvZ2dsZWQgb25cclxuICAgICAqIEBwYXJhbSBnZnhcclxuICAgICAqL1xyXG4gICAgZGVidWcoZ2Z4KSB7XHJcbiAgICAgICAgZ2Z4LnNhdmUoKTtcclxuICAgICAgICBnZngueiA9IHRoaXMuX2dldE1heFpJbmRleCgpICsgMC41O1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5yb3dzICsgMTsgeSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnRpbGVUb1dvcmxkKHZlYygwLCB5KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy50aWxlVG9Xb3JsZCh2ZWModGhpcy5jb2x1bW5zLCB5KSk7XHJcbiAgICAgICAgICAgIGdmeC5kcmF3TGluZShsZWZ0LCByaWdodCwgQ29sb3IuUmVkLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLmNvbHVtbnMgKyAxOyB4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy50aWxlVG9Xb3JsZCh2ZWMoeCwgMCkpO1xyXG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSB0aGlzLnRpbGVUb1dvcmxkKHZlYyh4LCB0aGlzLnJvd3MpKTtcclxuICAgICAgICAgICAgZ2Z4LmRyYXdMaW5lKHRvcCwgYm90dG9tLCBDb2xvci5SZWQsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy50aWxlcykge1xyXG4gICAgICAgICAgICBnZnguZHJhd0NpcmNsZSh0aGlzLnRpbGVUb1dvcmxkKHZlYyh0aWxlLngsIHRpbGUueSkpLCAzLCBDb2xvci5ZZWxsb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZngucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVGlsZU1hcC9pbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vQWN0aW9uU2VxdWVuY2UudHNcblxyXG4vKipcclxuICogQWN0aW9uIHRoYXQgY2FuIHJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIGFjdGlvbnMsIHRoaXMgY2FuIGJlIHVzZWZ1bCBpbiBjb25qdW5jdGlvbiB3aXRoXHJcbiAqIFtbUGFyYWxsZWxBY3Rpb25zXV0gdG8gcnVuIG11bHRpcGxlIHNlcXVlbmNlcyBpbiBwYXJhbGxlbC5cclxuICovXHJcbmNsYXNzIEFjdGlvblNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgYWN0aW9uQnVpbGRlcikge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zZXF1ZW5jZUJ1aWxkZXIgPSBhY3Rpb25CdWlsZGVyO1xyXG4gICAgICAgIHRoaXMuX3NlcXVlbmNlQ29udGV4dCA9IG5ldyBBY3Rpb25Db250ZXh0KGVudGl0eSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSB0aGlzLl9zZXF1ZW5jZUNvbnRleHQuZ2V0UXVldWUoKTtcclxuICAgICAgICB0aGlzLl9zZXF1ZW5jZUJ1aWxkZXIodGhpcy5fc2VxdWVuY2VDb250ZXh0KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX2FjdGlvblF1ZXVlLmlzQ29tcGxldGUoKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUucmVzZXQoKTtcclxuICAgIH1cclxuICAgIGNsb25lKGVudGl0eSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uU2VxdWVuY2UoZW50aXR5LCB0aGlzLl9zZXF1ZW5jZUJ1aWxkZXIpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vUGFyYWxsZWxBY3Rpb25zLnRzXG4vKipcclxuICogQWN0aW9uIHRoYXQgY2FuIHJ1biBtdWx0aXBsZSBbW0FjdGlvbl1dcyBvciBbW0FjdGlvblNlcXVlbmNlXV1zIGF0IHRoZSBzYW1lIHRpbWVcclxuICovXHJcbmNsYXNzIFBhcmFsbGVsQWN0aW9ucyB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbGxlbEFjdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zID0gcGFyYWxsZWxBY3Rpb25zO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnNbaV0udXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKGVudGl0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmV2ZXJ5KGEgPT4gYS5pc0NvbXBsZXRlKGVudGl0eSkpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGEgPT4gYS5yZXNldCgpKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGEgPT4gYS5zdG9wKCkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0dyb3VwL0NvbGxpc2lvbkdyb3VwTWFuYWdlci50c1xuXHJcbi8qKlxyXG4gKiBTdGF0aWMgY2xhc3MgZm9yIG1hbmFnaW5nIGNvbGxpc2lvbiBncm91cHMgaW4gZXhjYWxpYnVyLCB0aGVyZSBpcyBhIG1heGltdW0gb2YgMzIgY29sbGlzaW9uIGdyb3VwcyBwb3NzaWJsZSBpbiBleGNhbGlidXJcclxuICovXHJcbmNsYXNzIENvbGxpc2lvbkdyb3VwTWFuYWdlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBuYW1lZCBjb2xsaXNpb24gZ3JvdXAgdXAgdG8gYSBtYXggb2YgMzIuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgY29sbGlzaW9uIGdyb3VwXHJcbiAgICAgKiBAcGFyYW0gbWFzayBPcHRpb25hbGx5IHByb3ZpZGUgeW91ciBvd24gMzItYml0IG1hc2ssIGlmIG5vbmUgaXMgcHJvdmlkZSB0aGUgbWFuYWdlciB3aWxsIGdlbmVyYXRlIG9uZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKG5hbWUsIG1hc2spIHtcclxuICAgICAgICBpZiAodGhpcy5fQ1VSUkVOVF9HUk9VUCA+IHRoaXMuX01BWF9HUk9VUFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGF2ZSBtb3JlIHRoYW4gJHt0aGlzLl9NQVhfR1JPVVBTfSBjb2xsaXNpb24gZ3JvdXBzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9HUk9VUFMuZ2V0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29sbGlzaW9uIGdyb3VwICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgQ29sbGlzaW9uR3JvdXAobmFtZSwgdGhpcy5fQ1VSUkVOVF9CSVQsIG1hc2sgIT09IHVuZGVmaW5lZCA/IG1hc2sgOiB+dGhpcy5fQ1VSUkVOVF9CSVQpO1xyXG4gICAgICAgIHRoaXMuX0NVUlJFTlRfQklUID0gKHRoaXMuX0NVUlJFTlRfQklUIDw8IDEpIHwgMDtcclxuICAgICAgICB0aGlzLl9DVVJSRU5UX0dST1VQKys7XHJcbiAgICAgICAgdGhpcy5fR1JPVVBTLnNldChuYW1lLCBncm91cCk7XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIGNvbGxpc2lvbiBncm91cHMgY3VycmVudGx5IHRyYWNrZWQgYnkgZXhjYWxpYnVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgZ3JvdXBzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX0dST1VQUy52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGNvbGxpc2lvbiBncm91cCBieSBpdCdzIG5hbWVcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBncm91cEJ5TmFtZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX0dST1VQUy5nZXQobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWFuYWdlcnMgaW50ZXJuYWwgZ3JvdXAgbWFuYWdlbWVudCBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fR1JPVVBTID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX0NVUlJFTlRfQklUID0gdGhpcy5fU1RBUlRJTkdfQklUO1xyXG4gICAgICAgIHRoaXMuX0NVUlJFTlRfR1JPVVAgPSAxO1xyXG4gICAgfVxyXG59XHJcbi8vIHVzaW5nIGJpdG1hc2tpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIGdyb3VwcyBpcyAzMiwgYmVjYXVzZSB0aGF0IGlzIHRoZSBoaWdoZXN0IDMyYml0IGludGVnZXIgdGhhdCBKUyBjYW4gcHJlc2VudC5cclxuQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9TVEFSVElOR19CSVQgPSAwYjEgfCAwO1xyXG5Db2xsaXNpb25Hcm91cE1hbmFnZXIuX01BWF9HUk9VUFMgPSAzMjtcclxuQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9DVVJSRU5UX0dST1VQID0gMTtcclxuQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9DVVJSRU5UX0JJVCA9IENvbGxpc2lvbkdyb3VwTWFuYWdlci5fU1RBUlRJTkdfQklUO1xyXG5Db2xsaXNpb25Hcm91cE1hbmFnZXIuX0dST1VQUyA9IG5ldyBNYXAoKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vSW5kZXgudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0ludGVyZmFjZXMvTGlmZWN5Y2xlRXZlbnRzLnRzXG4vKipcclxuICogVHlwZSBndWFyZCBjaGVja2luZyBmb3IgaW50ZXJuYWwgaW5pdGlhbGl6ZSBtZXRob2RcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSBhXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNfaW5pdGlhbGl6ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLl9pbml0aWFsaXplO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzT25Jbml0aWFsaXplKGEpIHtcclxuICAgIHJldHVybiAhIWEub25Jbml0aWFsaXplO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzX3ByZXVwZGF0ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLl9wcmV1cGRhdGU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNPblByZVVwZGF0ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uUHJlVXBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzX3Bvc3R1cGRhdGUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vblBvc3RVcGRhdGU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNPblBvc3RVcGRhdGUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vblBvc3RVcGRhdGU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNQcmVEcmF3KGEpIHtcclxuICAgIHJldHVybiAhIWEub25QcmVEcmF3O1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzUG9zdERyYXcoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vblBvc3REcmF3O1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW50ZXJmYWNlcy9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1NvdW5kL0luZGV4LnRzXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9HaWYudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgW1tUZXh0dXJlXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXHJcbiAqIFtbVGV4dHVyZV1dIGlzIGFuIFtbTG9hZGFibGVdXSB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXVxyXG4gKiB0byBwcmUtbG9hZCBiZWZvcmUgc3RhcnRpbmcgYSBsZXZlbCBvciBnYW1lLlxyXG4gKi9cclxuY2xhc3MgR2lmIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGggICAgICAgUGF0aCB0byB0aGUgaW1hZ2UgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBjb2xvciAgICAgIE9wdGlvbmFsbHkgc2V0IHRoZSBjb2xvciB0byB0cmVhdCBhcyB0cmFuc3BhcmVudCB0aGUgZ2lmLCBieSBkZWZhdWx0IFtbQ29sb3IuTWFnZW50YV1dXHJcbiAgICAgKiBAcGFyYW0gYnVzdENhY2hlICBPcHRpb25hbGx5IGxvYWQgdGV4dHVyZSB3aXRoIGNhY2hlIGJ1c3RpbmdcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sb3IgPSBDb2xvci5NYWdlbnRhLCBidXN0Q2FjaGUgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgdGhpcy5fc3RyZWFtID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9naWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudENvbG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShwYXRoLCAnYXJyYXlidWZmZXInLCBidXN0Q2FjaGUpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcGFyZW50Q29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRleHR1cmUgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAqL1xyXG4gICAgYXN5bmMgbG9hZCgpIHtcclxuICAgICAgICBjb25zdCBhcnJheWJ1ZmZlciA9IGF3YWl0IHRoaXMuX3Jlc291cmNlLmxvYWQoKTtcclxuICAgICAgICB0aGlzLl9zdHJlYW0gPSBuZXcgU3RyZWFtKGFycmF5YnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9naWYgPSBuZXcgUGFyc2VHaWYodGhpcy5fc3RyZWFtLCB0aGlzLl90cmFuc3BhcmVudENvbG9yKTtcclxuICAgICAgICBjb25zdCBpbWFnZXMgPSB0aGlzLl9naWYuaW1hZ2VzLm1hcChpID0+IG5ldyBJbWFnZVNvdXJjZShpLnNyYywgZmFsc2UpKTtcclxuICAgICAgICAvLyBMb2FkIGFsbCB0ZXh0dXJlc1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGltYWdlcy5tYXAodCA9PiB0LmxvYWQoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPSB0aGlzLl90ZXh0dXJlcyA9IGltYWdlcztcclxuICAgIH1cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgZnJhbWUgb2YgdGhlIGdpZiBhcyBhIHNwcml0ZSBieSBpZFxyXG4gICAgICogQHBhcmFtIGlkXHJcbiAgICAgKi9cclxuICAgIHRvU3ByaXRlKGlkID0gMCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuX3RleHR1cmVzW2lkXS50b1Nwcml0ZSgpO1xyXG4gICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZ2lmIGFzIGEgc3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgdG9TcHJpdGVTaGVldCgpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5fdGV4dHVyZXMubWFwKChpbWFnZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2UudG9TcHJpdGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZVNoZWV0KHsgc3ByaXRlcyB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRoZSBHSUYgaW50byBhbiBhbmltYXRpb24gd2l0aCBkdXJhdGlvbiBwZXIgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdG9BbmltYXRpb24oZHVyYXRpb25QZXJGcmFtZU1zKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlU2hlZXQgPSB0aGlzLnRvU3ByaXRlU2hlZXQoKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBzcHJpdGVTaGVldC5zcHJpdGVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBBbmltYXRpb24uZnJvbVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0LCByYW5nZSgwLCBsZW5ndGgpLCBkdXJhdGlvblBlckZyYW1lTXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb247XHJcbiAgICB9XHJcbiAgICBnZXQgcmVhZENoZWNrQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dpZi5jaGVja0J5dGVzO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGJpdHNUb051bSA9IChiYSkgPT4ge1xyXG4gICAgcmV0dXJuIGJhLnJlZHVjZShmdW5jdGlvbiAocywgbikge1xyXG4gICAgICAgIHJldHVybiBzICogMiArIG47XHJcbiAgICB9LCAwKTtcclxufTtcclxuY29uc3QgYnl0ZVRvQml0QXJyID0gKGJpdGUpID0+IHtcclxuICAgIGNvbnN0IGEgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGEucHVzaCghIShiaXRlICYgKDEgPDwgaSkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59O1xyXG5jbGFzcyBTdHJlYW0ge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YUFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWFkQnl0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPj0gdGhpcy5kYXRhLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHJlYWQgcGFzdCBlbmQgb2Ygc3RyZWFtLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5wb3NpdGlvbisrXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVhZEJ5dGVzID0gKG4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2godGhpcy5yZWFkQnl0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlYWQgPSAobikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEJ5dGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlYWRVbnNpZ25lZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gTGl0dGxlLWVuZGlhbi5cclxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMucmVhZEJ5dGVzKDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGFbMV0gPDwgOCkgKyBhWzBdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUFycmF5KTtcclxuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmICh0aGlzLmxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgbG9hZGVkIGZyb20gZmlsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBsendEZWNvZGUgPSBmdW5jdGlvbiAobWluQ29kZVNpemUsIGRhdGEpIHtcclxuICAgIC8vIFRPRE86IE5vdyB0aGF0IHRoZSBHSUYgcGFyc2VyIGlzIGEgYml0IGRpZmZlcmVudCwgbWF5YmUgdGhpcyBzaG91bGQgZ2V0IGFuIGFycmF5IG9mIGJ5dGVzIGluc3RlYWQgb2YgYSBTdHJpbmc/XHJcbiAgICBsZXQgcG9zID0gMDsgLy8gTWF5YmUgdGhpcyBzdHJlYW1pbmcgdGhpbmcgc2hvdWxkIGJlIG1lcmdlZCB3aXRoIHRoZSBTdHJlYW0/XHJcbiAgICBjb25zdCByZWFkQ29kZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgbGV0IGNvZGUgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmNoYXJDb2RlQXQocG9zID4+IDMpICYgKDEgPDwgKHBvcyAmIDcpKSkge1xyXG4gICAgICAgICAgICAgICAgY29kZSB8PSAxIDw8IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgY29uc3QgY2xlYXJDb2RlID0gMSA8PCBtaW5Db2RlU2l6ZTtcclxuICAgIGNvbnN0IGVvaUNvZGUgPSBjbGVhckNvZGUgKyAxO1xyXG4gICAgbGV0IGNvZGVTaXplID0gbWluQ29kZVNpemUgKyAxO1xyXG4gICAgbGV0IGRpY3QgPSBbXTtcclxuICAgIGNvbnN0IGNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRpY3QgPSBbXTtcclxuICAgICAgICBjb2RlU2l6ZSA9IG1pbkNvZGVTaXplICsgMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFyQ29kZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpY3RbaV0gPSBbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpY3RbY2xlYXJDb2RlXSA9IFtdO1xyXG4gICAgICAgIGRpY3RbZW9pQ29kZV0gPSBudWxsO1xyXG4gICAgfTtcclxuICAgIGxldCBjb2RlO1xyXG4gICAgbGV0IGxhc3Q7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxhc3QgPSBjb2RlO1xyXG4gICAgICAgIGNvZGUgPSByZWFkQ29kZShjb2RlU2l6ZSk7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IGNsZWFyQ29kZSkge1xyXG4gICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IGVvaUNvZGUpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2RlIDwgZGljdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3QgIT09IGNsZWFyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgZGljdC5wdXNoKGRpY3RbbGFzdF0uY29uY2F0KGRpY3RbY29kZV1bMF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNvZGUgIT09IGRpY3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTFpXIGNvZGUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGljdC5wdXNoKGRpY3RbbGFzdF0uY29uY2F0KGRpY3RbbGFzdF1bMF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0LnB1c2guYXBwbHkob3V0cHV0LCBkaWN0W2NvZGVdKTtcclxuICAgICAgICBpZiAoZGljdC5sZW5ndGggPT09IDEgPDwgY29kZVNpemUgJiYgY29kZVNpemUgPCAxMikge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCBjb2RlIGFuZCBjb2RlU2l6ZSBpcyAxMiwgdGhlIG5leHQgY29kZSB3aWxsIGJlIGEgY2xlYXJDb2RlLCBhbmQgaXQnbGwgYmUgMTIgYml0cyBsb25nLlxyXG4gICAgICAgICAgICBjb2RlU2l6ZSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEkgZG9uJ3Qga25vdyBpZiB0aGlzIGlzIHRlY2huaWNhbGx5IGFuIGVycm9yLCBidXQgc29tZSBHSUZzIGRvIGl0LlxyXG4gICAgLy9pZiAoTWF0aC5jZWlsKHBvcyAvIDgpICE9PSBkYXRhLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdFeHRyYW5lb3VzIExaVyBieXRlcy4nKTtcclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcbi8vIFRoZSBhY3R1YWwgcGFyc2luZzsgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzLlxyXG5jbGFzcyBQYXJzZUdpZiB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGNvbG9yID0gQ29sb3IuTWFnZW50YSkge1xyXG4gICAgICAgIHRoaXMuX3N0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9oYW5kbGVyID0ge307XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRDb2xvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsQ29sb3JUYWJsZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hlY2tCeXRlcyA9IFtdO1xyXG4gICAgICAgIC8vIExaVyAoR0lGLXNwZWNpZmljKVxyXG4gICAgICAgIHRoaXMucGFyc2VDb2xvclRhYmxlID0gKGVudHJpZXMpID0+IHtcclxuICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBpcyAzIGJ5dGVzLCBmb3IgUkdCLlxyXG4gICAgICAgICAgICBjb25zdCBjdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmdiID0gdGhpcy5fc3QucmVhZEJ5dGVzKDMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmdiYSA9ICcjJyArXHJcbiAgICAgICAgICAgICAgICAgICAgcmdiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGV4ID0geC50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgIGN0LnB1c2gocmdiYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWFkU3ViQmxvY2tzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc2l6ZSwgZGF0YTtcclxuICAgICAgICAgICAgZGF0YSA9ICcnO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIGRhdGEgKz0gdGhpcy5fc3QucmVhZChzaXplKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAoc2l6ZSAhPT0gMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZUhlYWRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGRyID0ge1xyXG4gICAgICAgICAgICAgICAgc2lnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdmVyOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjb2xvclJlczogbnVsbCxcclxuICAgICAgICAgICAgICAgIGdsb2JhbENvbG9yVGFibGVTaXplOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZ2N0RmxhZzogbnVsbCxcclxuICAgICAgICAgICAgICAgIHNvcnRlZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGdsb2JhbENvbG9yVGFibGU6IFtdLFxyXG4gICAgICAgICAgICAgICAgYmdDb2xvcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHBpeGVsQXNwZWN0UmF0aW86IG51bGwgLy8gaWYgbm90IDAsIGFzcGVjdFJhdGlvID0gKHBpeGVsQXNwZWN0UmF0aW8gKyAxNSkgLyA2NFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoZHIuc2lnID0gdGhpcy5fc3QucmVhZCgzKTtcclxuICAgICAgICAgICAgaGRyLnZlciA9IHRoaXMuX3N0LnJlYWQoMyk7XHJcbiAgICAgICAgICAgIGlmIChoZHIuc2lnICE9PSAnR0lGJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBHSUYgZmlsZS4nKTsgLy8gWFhYOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIG1vcmUgbmljZWx5LlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhkci53aWR0aCA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBoZHIuaGVpZ2h0ID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBieXRlVG9CaXRBcnIodGhpcy5fc3QucmVhZEJ5dGUoKSk7XHJcbiAgICAgICAgICAgIGhkci5nY3RGbGFnID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBoZHIuY29sb3JSZXMgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xyXG4gICAgICAgICAgICBoZHIuc29ydGVkID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBoZHIuZ2xvYmFsQ29sb3JUYWJsZVNpemUgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xyXG4gICAgICAgICAgICBoZHIuYmdDb2xvciA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgIGhkci5waXhlbEFzcGVjdFJhdGlvID0gdGhpcy5fc3QucmVhZEJ5dGUoKTsgLy8gaWYgbm90IDAsIGFzcGVjdFJhdGlvID0gKHBpeGVsQXNwZWN0UmF0aW8gKyAxNSkgLyA2NFxyXG4gICAgICAgICAgICBpZiAoaGRyLmdjdEZsYWcpIHtcclxuICAgICAgICAgICAgICAgIGhkci5nbG9iYWxDb2xvclRhYmxlID0gdGhpcy5wYXJzZUNvbG9yVGFibGUoMSA8PCAoaGRyLmdsb2JhbENvbG9yVGFibGVTaXplICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxDb2xvclRhYmxlID0gaGRyLmdsb2JhbENvbG9yVGFibGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuaGRyICYmIHRoaXMuX2hhbmRsZXIuaGRyKGhkcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuaGRyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZUV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZUdDRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9zdC5yZWFkQnl0ZSgpKTsgLy8gQWx3YXlzIDRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBieXRlVG9CaXRBcnIodGhpcy5fc3QucmVhZEJ5dGUoKSk7XHJcbiAgICAgICAgICAgICAgICBibG9jay5yZXNlcnZlZCA9IGJpdHMuc3BsaWNlKDAsIDMpOyAvLyBSZXNlcnZlZDsgc2hvdWxkIGJlIDAwMC5cclxuICAgICAgICAgICAgICAgIGJsb2NrLmRpc3Bvc2FsTWV0aG9kID0gYml0c1RvTnVtKGJpdHMuc3BsaWNlKDAsIDMpKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnVzZXJJbnB1dCA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnRyYW5zcGFyZW5jeUdpdmVuID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suZGVsYXlUaW1lID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgICAgICBibG9jay50cmFuc3BhcmVuY3lJbmRleCA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICBibG9jay50ZXJtaW5hdG9yID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmdjZSAmJiB0aGlzLl9oYW5kbGVyLmdjZShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmdjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlQ29tRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBibG9jay5jb21tZW50ID0gdGhpcy5yZWFkU3ViQmxvY2tzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5jb20gJiYgdGhpcy5faGFuZGxlci5jb20oYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5jb20pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZVBURXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9zdC5yZWFkQnl0ZSgpKTsgLy8gQWx3YXlzIDEyXHJcbiAgICAgICAgICAgICAgICBibG9jay5wdEhlYWRlciA9IHRoaXMuX3N0LnJlYWRCeXRlcygxMik7XHJcbiAgICAgICAgICAgICAgICBibG9jay5wdERhdGEgPSB0aGlzLnJlYWRTdWJCbG9ja3MoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLnB0ZSAmJiB0aGlzLl9oYW5kbGVyLnB0ZShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLnB0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlQXBwRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZU5ldHNjYXBlRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5fc3QucmVhZEJ5dGUoKSk7IC8vIEFsd2F5cyAzXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudW5rbm93biA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7IC8vIFE6IEFsd2F5cyAxPyBXaGF0IGlzIHRoaXM/XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suaXRlcmF0aW9ucyA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnRlcm1pbmF0b3IgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmFwcCAmJiB0aGlzLl9oYW5kbGVyLmFwcC5ORVRTQ0FQRSAmJiB0aGlzLl9oYW5kbGVyLmFwcC5ORVRTQ0FQRShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5hcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZVVua25vd25BcHBFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5hcHBEYXRhID0gdGhpcy5yZWFkU3ViQmxvY2tzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgd29uJ3Qgd29yayBpZiBhIGhhbmRsZXIgd2FudHMgdG8gbWF0Y2ggb24gYW55IGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuYXBwICYmIHRoaXMuX2hhbmRsZXIuYXBwW2Jsb2NrLmlkZW50aWZpZXJdICYmIHRoaXMuX2hhbmRsZXIuYXBwW2Jsb2NrLmlkZW50aWZpZXJdKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmFwcFtibG9jay5pZGVudGlmaWVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX3N0LnJlYWRCeXRlKCkpOyAvLyBBbHdheXMgMTFcclxuICAgICAgICAgICAgICAgIGJsb2NrLmlkZW50aWZpZXIgPSB0aGlzLl9zdC5yZWFkKDgpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suYXV0aENvZGUgPSB0aGlzLl9zdC5yZWFkKDMpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChibG9jay5pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTkVUU0NBUEUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZU5ldHNjYXBlRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VVbmtub3duQXBwRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlVW5rbm93bkV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmxvY2suZGF0YSA9IHRoaXMucmVhZFN1YkJsb2NrcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIudW5rbm93biAmJiB0aGlzLl9oYW5kbGVyLnVua25vd24oYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci51bmtub3duKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYmxvY2subGFiZWwgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJsb2NrLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Zjk6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICdnY2UnO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlR0NFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweGZlOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAnY29tJztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUNvbUV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4MDE6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICdwdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlUFRFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweGZmOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAnYXBwJztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUFwcEV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAndW5rbm93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VVbmtub3duRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZUltZyA9IChpbWcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGVpbnRlcmxhY2UgPSAocGl4ZWxzLCB3aWR0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gT2YgY291cnNlIHRoaXMgZGVmZWF0cyB0aGUgcHVycG9zZSBvZiBpbnRlcmxhY2luZy4gQW5kIGl0J3MgKnByb2JhYmx5KlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxlYXN0IGVmZmljaWVudCB3YXkgaXQncyBldmVyIGJlZW4gaW1wbGVtZW50ZWQuIEJ1dCBuZXZlcnRoZWxlc3MuLi5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BpeGVscyA9IG5ldyBBcnJheShwaXhlbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBwaXhlbHMubGVuZ3RoIC8gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjcFJvdyA9ICh0b1JvdywgZnJvbVJvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21QaXhlbHMgPSBwaXhlbHMuc2xpY2UoZnJvbVJvdyAqIHdpZHRoLCAoZnJvbVJvdyArIDEpICogd2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BpeGVscy5zcGxpY2UuYXBwbHkobmV3UGl4ZWxzLCBbdG9Sb3cgKiB3aWR0aCwgd2lkdGhdLmNvbmNhdChmcm9tUGl4ZWxzKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IFswLCA0LCAyLCAxXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBzID0gWzgsIDgsIDQsIDJdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Sb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcGFzcyA9IDA7IHBhc3MgPCA0OyBwYXNzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0b1JvdyA9IG9mZnNldHNbcGFzc107IHRvUm93IDwgcm93czsgdG9Sb3cgKz0gc3RlcHNbcGFzc10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3BSb3codG9Sb3csIGZyb21Sb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tUm93Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BpeGVscztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaW1nLmxlZnRQb3MgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaW1nLnRvcFBvcyA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBpbWcud2lkdGggPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaW1nLmhlaWdodCA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBiaXRzID0gYnl0ZVRvQml0QXJyKHRoaXMuX3N0LnJlYWRCeXRlKCkpO1xyXG4gICAgICAgICAgICBpbWcubGN0RmxhZyA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaW1nLmludGVybGFjZWQgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGltZy5zb3J0ZWQgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGltZy5yZXNlcnZlZCA9IGJpdHMuc3BsaWNlKDAsIDIpO1xyXG4gICAgICAgICAgICBpbWcubGN0U2l6ZSA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XHJcbiAgICAgICAgICAgIGlmIChpbWcubGN0RmxhZykge1xyXG4gICAgICAgICAgICAgICAgaW1nLmxjdCA9IHRoaXMucGFyc2VDb2xvclRhYmxlKDEgPDwgKGltZy5sY3RTaXplICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGltZy5sendNaW5Db2RlU2l6ZSA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGx6d0RhdGEgPSB0aGlzLnJlYWRTdWJCbG9ja3MoKTtcclxuICAgICAgICAgICAgaW1nLnBpeGVscyA9IGx6d0RlY29kZShpbWcubHp3TWluQ29kZVNpemUsIGx6d0RhdGEpO1xyXG4gICAgICAgICAgICBpZiAoaW1nLmludGVybGFjZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vdmVcclxuICAgICAgICAgICAgICAgIGltZy5waXhlbHMgPSBkZWludGVybGFjZShpbWcucGl4ZWxzLCBpbWcud2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goaW1nKTtcclxuICAgICAgICAgICAgdGhpcy5hcnJheVRvSW1hZ2UoaW1nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuaW1nICYmIHRoaXMuX2hhbmRsZXIuaW1nKGltZykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBhcnNlQmxvY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0ge1xyXG4gICAgICAgICAgICAgICAgc2VudGluZWw6IHRoaXMuX3N0LnJlYWRCeXRlKCksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja0NoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJsb2NrLnNlbnRpbmVsKTtcclxuICAgICAgICAgICAgc3dpdGNoIChibG9ja0NoYXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnR5cGUgPSAnZXh0JztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnR5cGUgPSAnaW1nJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSW1nKGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJzsnOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnR5cGUgPSAnZW9mJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5lb2YgJiYgdGhpcy5faGFuZGxlci5lb2YoYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuZW9mKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBibG9jazogMHgnICsgYmxvY2suc2VudGluZWwudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYmxvY2sudHlwZSAhPT0gJ2VvZicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VCbG9jaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFycmF5VG9JbWFnZSA9IChmcmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGMuaWQgPSBjb3VudC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjLndpZHRoID0gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgICAgIGMuaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBwaXhTaXplID0gMTtcclxuICAgICAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWUucGl4ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCAlIGZyYW1lLndpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsQ29sb3JUYWJsZVtmcmFtZS5waXhlbHNbaV1dID09PSB0aGlzLl90cmFuc3BhcmVudENvbG9yLnRvSGV4KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGByZ2JhKDAsIDAsIDAsIDApYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5nbG9iYWxDb2xvclRhYmxlW2ZyYW1lLnBpeGVsc1tpXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHBpeFNpemUsIHBpeFNpemUpO1xyXG4gICAgICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBpbWcuc3JjID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaChpbWcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fc3QgPSBzdHJlYW07XHJcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcGFyZW50Q29sb3IgPSBjb2xvcjtcclxuICAgICAgICB0aGlzLnBhcnNlSGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5wYXJzZUJsb2NrKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvSW5kZXgudHNcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL2luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9MaW5lLnRzXG5cclxuXHJcblxyXG5jbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuQmxhY2s7XHJcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAxO1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgY29sb3IsIHRoaWNrbmVzcyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9PSBudWxsICYmIGNvbG9yICE9PSB2b2lkIDAgPyBjb2xvciA6IHRoaXMuY29sb3I7XHJcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSB0aGlja25lc3MgIT09IG51bGwgJiYgdGhpY2tuZXNzICE9PSB2b2lkIDAgPyB0aGlja25lc3MgOiB0aGlzLnRoaWNrbmVzcztcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IEJvdW5kaW5nQm94LmZyb21Qb2ludHMoW3N0YXJ0LCBlbmRdKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGN0eCwgX3gsIF95KSB7XHJcbiAgICAgICAgY3R4LmRyYXdMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLmNvbG9yLCB0aGlzLnRoaWNrbmVzcyk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUoe1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcclxuICAgICAgICAgICAgZW5kOiB0aGlzLmVuZCxcclxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXHJcbiAgICAgICAgICAgIHRoaWNrbmVzczogdGhpcy50aGlja25lc3NcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1BvbHlnb24udHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIHBvbHlnb24gW1tHcmFwaGljXV0gZm9yIGRyYXdpbmcgYXJiaXRyYXJ5IHBvbHlnb25zIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dXHJcbiAqXHJcbiAqIFBvbHlnb25zIGRlZmF1bHQgdG8gW1tJbWFnZUZpbHRlcmluZy5CbGVuZGVkXV1cclxuICovXHJcbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBSYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gb3B0aW9ucy5wb2ludHM7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBJbWFnZUZpbHRlcmluZy5CbGVuZGVkO1xyXG4gICAgICAgIHRoaXMucmFzdGVyaXplKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcG9pbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XHJcbiAgICB9XHJcbiAgICBzZXQgcG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pblBvaW50O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9wb2ludHMucmVkdWNlKChtYXgsIHApID0+IE1hdGgubWF4KHAueCwgbWF4KSwgMCkgLSBtaW4ueDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1heCwgcCkgPT4gTWF0aC5tYXgocC55LCBtYXgpLCAwKSAtIG1pbi55O1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluUG9pbnQoKSB7XHJcbiAgICAgICAgY29uc3QgbWluWCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1pbiwgcCkgPT4gTWF0aC5taW4ocC54LCBtaW4pLCBJbmZpbml0eSk7XHJcbiAgICAgICAgY29uc3QgbWluWSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1pbiwgcCkgPT4gTWF0aC5taW4ocC55LCBtaW4pLCBJbmZpbml0eSk7XHJcbiAgICAgICAgcmV0dXJuIHZlYyhtaW5YLCBtaW5ZKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbih7XHJcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5wb2ludHMubWFwKChwKSA9PiBwLmNsb25lKCkpLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSxcclxuICAgICAgICAgICAgLi4udGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5wb2ludHMgJiYgdGhpcy5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pblBvaW50Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5wb2ludHNbMF0uYWRkKG1pbik7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54ICsgbWluLngsIHBvaW50LnkgKyBtaW4ueSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvaW5kZXgudHNcbi8vIEdyYXBoaWNzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBHcmFwaGljcyBFQ1NcclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBSYXN0ZXIgZ3JhcGhpY3NcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIFBvc3QgUHJvY2Vzc29yXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIFJlbmRlcmluZ1xyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIFV0aWxcclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L0luZGV4LnRzXG4vKipcclxuICogQG1vZHVsZVxyXG4gKiBQcm92aWRlcyBzdXBwb3J0IGZvciBtaWNlLCBrZXlib2FyZHMsIGFuZCBjb250cm9sbGVycy5cclxuICovXHJcbi8qKlxyXG4gKiBAdHlwZWRvY1xyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvSW5kZXgudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9TZW1hcGhvcmUudHNcblxyXG5jbGFzcyBBc3luY1dhaXRRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBDb2RlIGZyb20gU3RlcGhlbkNsZWFyeSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TdGVwaGVuQ2xlYXJ5L2JhNTBiMmRhNDE5YzAzYjljYmExZDIwY2I0NjU0ZDVlXHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcclxuICAgIH1cclxuICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGVucXVldWUoKSB7XHJcbiAgICAgICAgY29uc3QgZnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZnV0dXJlKTtcclxuICAgICAgICByZXR1cm4gZnV0dXJlLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBkZXF1ZXVlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZnV0dXJlID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcclxuICAgICAgICBmdXR1cmUucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNlbWFwaG9yZSBhbGxvd3MgeW91IHRvIGxpbWl0IHRoZSBhbW91bnQgb2YgYXN5bmMgY2FsbHMgaGFwcGVuaW5nIGJldHdlZW4gYGVudGVyKClgIGFuZCBgZXhpdCgpYFxyXG4gKlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBsaW1pdGluZyB0aGUgbnVtYmVyIG9mIGh0dHAgY2FsbHMsIGJyb3dzZXIgYXBpIGNhbGxzLCBldGMgZWl0aGVyIGZvciBwZXJmb3JtYW5jZSBvciB0byB3b3JrXHJcbiAqIGFyb3VuZCBicm93c2VyIGxpbWl0YXRpb25zIGxpa2UgbWF4IEltYWdlLmRlY29kZSgpIGNhbGxzIGluIGNocm9taXVtIGJlaW5nIDI1Ni5cclxuICovXHJcbmNsYXNzIFNlbWFwaG9yZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfY291bnQpIHtcclxuICAgICAgICB0aGlzLl9jb3VudCA9IF9jb3VudDtcclxuICAgICAgICB0aGlzLl93YWl0UXVldWUgPSBuZXcgQXN5bmNXYWl0UXVldWUoKTtcclxuICAgIH1cclxuICAgIGdldCBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgd2FpdGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2FpdFF1ZXVlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGFzeW5jIGVudGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb3VudCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb3VudC0tO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93YWl0UXVldWUuZW5xdWV1ZSgpO1xyXG4gICAgfVxyXG4gICAgZXhpdChjb3VudCA9IDEpIHtcclxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY291bnQgIT09IDAgJiYgdGhpcy5fd2FpdFF1ZXVlLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0UXVldWUuZGVxdWV1ZShudWxsKTtcclxuICAgICAgICAgICAgY291bnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY291bnQgKz0gY291bnQ7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9pbmRleC50c1xuLyoqXHJcbiAqIFRoZSBjdXJyZW50IEV4Y2FsaWJ1ciB2ZXJzaW9uIHN0cmluZ1xyXG4gKiBAZGVzY3JpcHRpb24gYHByb2Nlc3MuZW52Ll9fRVhfVkVSU0lPTmAgZ2V0cyByZXBsYWNlZCBieSBXZWJwYWNrIG9uIGJ1aWxkXHJcbiAqL1xyXG5jb25zdCBFWF9WRVJTSU9OID0gXCIwLjI3LjBcIjtcclxuXHJcbnBvbHlmaWxsKCk7XHJcbi8vIFRoaXMgZmlsZSBpcyB1c2VkIGFzIHRoZSBidW5kbGUgZW50cnkgcG9pbnQgYW5kIGV4cG9ydHMgZXZlcnl0aGluZ1xyXG4vLyB0aGF0IHdpbGwgYmUgZXhwb3NlZCBhcyB0aGUgYGV4YCBnbG9iYWwgdmFyaWFibGUuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIGV4LkV2ZW50cyBuYW1lc3BhY2VcclxuXHJcblxyXG4vLyBleC5JbnB1dCBuYW1lc3BhY2VcclxuXHJcblxyXG5cclxuXHJcbi8vIGV4LlV0aWwgbmFtZXNwYWNlc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZXguRGVwcmVjYXRlZFxyXG4vLyBpbXBvcnQgKiBhcyBkZXByZWNhdGVkIGZyb20gJy4vRGVwcmVjYXRlZCc7XHJcbi8vIGV4cG9ydCB7IGRlcHJlY2F0ZWQgYXMgRGVwcmVjYXRlZCB9O1xyXG4vLyBleHBvcnQgKiBmcm9tICcuL0RlcHJlY2F0ZWQnO1xyXG5cbn0pKCk7XG5cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uQ29udGV4dCA9IF9fd2VicGFja19leHBvcnRzX18uZlduO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25RdWV1ZSA9IF9fd2VicGFja19leHBvcnRzX18uSWE4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25TZXF1ZW5jZSA9IF9fd2VicGFja19leHBvcnRzX18ucnF2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25zQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oTEk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbnNTeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLnl5djtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aXZhdGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18udFg1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3RvciA9IF9fd2VicGFja19leHBvcnRzX18udnRYO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZGRlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ucjdLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZGRlZEVudGl0eSA9IF9fd2VicGFja19leHBvcnRzX18ubENoO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZmZpbmVNYXRyaXggPSBfX3dlYnBhY2tfZXhwb3J0c19fLmNFNDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5md0Y7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvbkRpcmVjdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uc2NlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb25TdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uX2M3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BcmNhZGVTb2x2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLktVcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQXVkaW9Db250ZXh0RmFjdG9yeSA9IF9fd2VicGFja19leHBvcnRzX18uQWpwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BeGlzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SRGg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jhc2VBbGlnbiA9IF9fd2VicGFja19leHBvcnRzX18uX0g5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19CbGluayA9IF9fd2VicGFja19leHBvcnRzX18ubXhzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Cb2R5Q29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PbUQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0JvdW5kaW5nQm94ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5rQmY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb2FkcGhhc2VTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uQzRGO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5OUXQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb3dzZXJFdmVudHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkpqTjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2FtZXJhID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WMXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NhbnZhcyA9IF9fd2VicGFja19leHBvcnRzX18uWHo3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19DaXJjbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNkYztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2lyY2xlQ29sbGlkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZLbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2xhc3MgPSBfX3dlYnBhY2tfZXhwb3J0c19fLndUVztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2xvY2sgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNVWTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2xvc2VzdExpbmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmFiMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2xvc2VzdExpbmVKdW1wVGFibGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkdmWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLllNUztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlkZXJDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm95djtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uQ29udGFjdCA9IF9fd2VicGFja19leHBvcnRzX18uYVViO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25FbmRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uU2REO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Hcm91cCA9IF9fd2VicGFja19leHBvcnRzX18uSlV2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Hcm91cE1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmpFajtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uSnVtcFRhYmxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5URnE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblBvc3RTb2x2ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5IRFU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblByZVNvbHZlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJfeTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy55ZE47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblN0YXJ0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnQ1MDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zJCQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnYyRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLklsaztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZEZsYWdzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zOWk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yQmxpbmRuZXNzTW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uZHhMO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kbmVzc1Bvc3RQcm9jZXNzb3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkxMWDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy53QTI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbXBvc2l0ZUNvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SX3A7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbmZpZ3VyYWJsZSA9IF9fd2VicGFja19leHBvcnRzX18uSVEkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db25zb2xlQXBwZW5kZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkk1RjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IF9fd2VicGFja19leHBvcnRzX18uWDgkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db250YWN0RW5kRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZSNjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdFN0YXJ0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlU4bztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29vcmRQbGFuZSA9IF9fd2VicGFja19leHBvcnRzX18ua2JHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWFjdGl2YXRlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmlTXztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmNHRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWdHcmFwaGljc0NvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uUlBOO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1N5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18uc2tiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1RleHQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNMVTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGVncmVlT2ZGcmVlZG9tID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SZEo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RlbGF5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jTnU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RldGVjdG9yID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nVTc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RpZSA9IF9fd2VicGFja19leHBvcnRzX18uTFNrO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EaXJlY3Rpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLk5tcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGlzcGxheU1vZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmQxWTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhyTDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNSVztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRVhfVkVSU0lPTiA9IF9fd2VicGFja19leHBvcnRzX18uY21WO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FYXNlQnkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnFXejtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRWFzZVRvID0gX193ZWJwYWNrX2V4cG9ydHNfXy5OMFE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Vhc2luZ0Z1bmN0aW9ucyA9IF9fd2VicGFja19leHBvcnRzX18ucThiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FZGdlQ29sbGlkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnluQjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRWxhc3RpY1RvQWN0b3JTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18ualQ5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbWl0dGVyVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18ud0F6O1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbmdpbmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkQ0VjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW50ZXJUcmlnZ2VyRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk42SDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW50ZXJWaWV3UG9ydEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5XMUE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VudGl0eSA9IF9fd2VicGFja19leHBvcnRzX18uSkhXO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbnRpdHlNYW5hZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy52Mks7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50RGlzcGF0Y2hlciA9IF9fd2VicGFja19leHBvcnRzX18ucEJmO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FdmVudFR5cGVzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5HTWw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50cyA9IF9fd2VicGFja19leHBvcnRzX18uelcyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeFJlc3BvbnNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5CMEs7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Odjc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DX3A7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4Y2FsaWJ1cldlYkdMQ29udGV4dEFjY2Vzc29yID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pcXc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4aXRUcmlnZ2VyRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1VQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXhpdFZpZXdQb3J0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhxVTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRmFkZSA9IF9fd2VicGFja19leHBvcnRzX18ucFRwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19GbGFncyA9IF9fd2VicGFja19leHBvcnRzX18udlVLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Gb2xsb3cgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmo5bDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRm9udCA9IF9fd2VicGFja19leHBvcnRzX18uWnh3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Gb250U3R5bGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkhkeDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRm9udFVuaXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlokZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRnBzU2FtcGxlciA9IF9fd2VicGFja19leHBvcnRzX18uaXFWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19GcmFtZVN0YXRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5vJDc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Z1dHVyZSA9IF9fd2VicGFja19leHBvcnRzX18ub2xNO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlptJDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZVN0YXJ0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLiRRSDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZVN0b3BFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaTc4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQXhpc0V2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oNnU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWRCdXR0b25FdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaHRzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQ29ubmVjdEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qODg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWREaXNjb25uZWN0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlZNRTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2lmID0gX193ZWJwYWNrX2V4cG9ydHNfXy5udDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2xvYmFsQ29vcmRpbmF0ZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlVrcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpYyA9IF9fd2VicGFja19leHBvcnRzX18uenN1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0NvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ub0E2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0dyb3VwID0gX193ZWJwYWNrX2V4cG9ydHNfXy5UVmg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzTGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlR3WjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NMYXllcnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkdUVDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NTeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLnh4ajtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSGlkZGVuRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlhkSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VGaWx0ZXJpbmcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkptYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VTb3VyY2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmNYbztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW5pdGlhbGl6ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EbTU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0lucHV0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JSUI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ludGVncmF0b3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnpJMDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSXNvbWV0cmljRW50aXR5Q29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5MWUQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0lzb21ldHJpY0VudGl0eVN5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18uY0VHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Jc29tZXRyaWNNYXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNFbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSXNvbWV0cmljVGlsZSA9IF9fd2VicGFja19leHBvcnRzX18udDlWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19LaWxsRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNLWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGFiZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLl9fSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uUkkkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MaW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy54MTI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xpbmVTZWdtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jY3o7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvYWRlciA9IF9fd2VicGFja19leHBvcnRzX18uYU53O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18ueHduO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kTks7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ0xldmVsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pbmk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ2dlciA9IF9fd2VicGFja19leHBvcnRzX18uWWRIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NYXRyaXggPSBfX3dlYnBhY2tfZXhwb3J0c19fLnkzRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWF0cml4TG9jYXRpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5sNTc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01lZGlhRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhuMDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWVldCA9IF9fd2VicGFja19leHBvcnRzX18udDJWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Nb3Rpb25Db21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnV4QjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTW90aW9uU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jcGQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01vdmVCeSA9IF9fd2VicGFja19leHBvcnRzX18uZml5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Nb3ZlVG8gPSBfX3dlYnBhY2tfZXhwb3J0c19fLiRYWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTmF0aXZlU291bmRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18udXFLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TVEU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX09ic2VydmFibGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnkkejtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fT2Zmc2NyZWVuU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5tQUQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhaXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNPcTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYWxsYXhDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmhVdztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYWxsZWxBY3Rpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5fMEc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnNlR2lmID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TcXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ocFo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlRW1pdHRlciA9IF9fd2VicGFja19leHBvcnRzX18uVm9sO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzID0gX193ZWJwYWNrX2V4cG9ydHNfXy53SVo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BoeXNpY3NTdGF0cyA9IF9fd2VicGFja19leHBvcnRzX18uY0JpO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb2ludGVyQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SRnY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BvaW50ZXJTeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmtmQztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbiA9IF9fd2VicGFja19leHBvcnRzX18ubWdxO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb2x5Z29uQ29sbGlkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLllWQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9vbCA9IF9fd2VicGFja19leHBvcnRzX18uS2dwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0Q29sbGlzaW9uRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkhIJDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdERlYnVnRHJhd0V2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NX2Q7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3REcmF3RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnJnaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdEZyYW1lRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJhNjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdEtpbGxFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uS2hSO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0VXBkYXRlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkJTNTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlQ29sbGlzaW9uRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhoejtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlRGVidWdEcmF3RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhPcTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlRHJhd0V2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hOWo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZUZyYW1lRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmJIaztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlS2lsbEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DZ0s7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZVVwZGF0ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jdVk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Byb2plY3Rpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmt2RTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUXVhZEluZGV4QnVmZmVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TQnU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1F1ZXJ5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BRV87XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1F1ZXJ5TWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uY3RPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PTEg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JhbmRvbSA9IF9fd2VicGFja19leHBvcnRzX18ua2t5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SYXN0ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5TRjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmF5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy56SG47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlYWxpc3RpY1NvbHZlciA9IF9fd2VicGFja19leHBvcnRzX18uend4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZWN0YW5nbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFlSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVtb3ZlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaEx6O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EOWc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlcGVhdCA9IF9fd2VicGFja19leHBvcnRzX18ud0E7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlcGVhdEZvcmV2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmpocjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb2x1dGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uR1ZzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZXNvdXJjZSA9IF9fd2VicGFja19leHBvcnRzX18uX3pPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVCeSA9IF9fd2VicGFja19leHBvcnRzX18udzYkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVUbyA9IF9fd2VicGFja19leHBvcnRzX18ubWhWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGlvblR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1PRDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2NhbGVCeSA9IF9fd2VicGFja19leHBvcnRzX18ua3dkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY2FsZVRvID0gX193ZWJwYWNrX2V4cG9ydHNfXy5MbXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjZW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy54c1M7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjcmVlbiA9IF9fd2VicGFja19leHBvcnRzX18ubExyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JlZW5BcHBlbmRlciA9IF9fd2VicGFja19leHBvcnRzX18uWiRyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JlZW5FbGVtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JWGI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjcmVlblNoYWRlciA9IF9fd2VicGFja19leHBvcnRzX18uU0dIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JvbGxQcmV2ZW50aW9uTW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uU01qO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TZW1hcGhvcmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkwzNDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2hhZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5leGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NoYXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ibkY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NpZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1GQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU291bmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLiR1VTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qeWk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZUZvbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkUwMztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlU2hlZXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlY2cTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3RhbmRhcmRDbG9jayA9IF9fd2VicGFja19leHBvcnRzX18ucmcyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TdGF0ZU1hY2hpbmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkRWVztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3RyYXRlZ3lDb250YWluZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5WbztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3RyZWFtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GNk47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18ueFA3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1NYW5hZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PZHE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbVR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlppZjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGFnQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aR0o7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Rlc3RDbG9jayA9IF9fd2VicGFja19leHBvcnRzX18uTUprO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UZXh0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy54dlQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RleHRBbGlnbiA9IF9fd2VicGFja19leHBvcnRzX18uUEhNO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UZXh0dXJlTG9hZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kcFI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RpbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm45TDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGlsZU1hcCA9IF9fd2VicGFja19leHBvcnRzX18uS3dPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UaW1lciA9IF9fd2VicGFja19leHBvcnRzX18uQjd5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Ub2FzdGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy54N3I7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RyYW5zZm9ybSA9IF9fd2VicGFja19leHBvcnRzX18ud3g3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19UcmFuc2Zvcm1Db21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlV2bjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVHJlZU5vZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk9GVDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVHJpZ2dlciA9IF9fd2VicGFja19leHBvcnRzX18ueHpOO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Ud29QSSA9IF9fd2VicGFja19leHBvcnRzX18uTTVaO1xudmFyIF9fd2VicGFja19leHBvcnRzX19VdGlsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ack47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ZlY3RvciA9IF9fd2VicGFja19leHBvcnRzX18uT1dzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19WZWN0b3JWaWV3ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kRjk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ZlcnRleEJ1ZmZlciA9IF9fd2VicGFja19leHBvcnRzX18ub1p5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19WZXJ0ZXhMYXlvdXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnJEMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVmlzaWJsZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WSG87XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1dlYkF1ZGlvID0gX193ZWJwYWNrX2V4cG9ydHNfXy5vaEU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1dlYkF1ZGlvSW5zdGFuY2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlIkRTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fV29ybGQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnEzSTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY2Fub25pY2FsaXplQW5nbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBhYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY2xhbXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnVaNTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlSWQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1jSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZnJhYyA9IF9fd2VicGFja19leHBvcnRzX18uRjljO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNHcmFwaGljc1RpY2sgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmswYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25Jbml0aWFsaXplID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oblQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uUG9zdFVwZGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18uUlNKO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNPblByZVVwZGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18uTWt1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNQb3N0RHJhdyA9IF9fd2VicGFja19leHBvcnRzX18uaDkwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNQcmVEcmF3ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ybXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19pbml0aWFsaXplID0gX193ZWJwYWNrX2V4cG9ydHNfXy5FclA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19wb3N0dXBkYXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hVmc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19wcmV1cGRhdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmxQYztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNBZGRlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uWjhFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkU3lzdGVtRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5fTjI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlU3lzdGVtRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy55Rm47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ubE52O1xudmFyIF9fd2VicGFja19leHBvcnRzX19pc1NjcmVlbkVsZW1lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmN1OTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fbWF4TWVzc2FnZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1aUTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fb2Jzb2xldGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZVTTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcGl4ZWxTbmFwRXBzaWxvbiA9IF9fd2VicGFja19leHBvcnRzX18uQnhSO1xudmFyIF9fd2VicGFja19leHBvcnRzX19yYW5kb21JblJhbmdlID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZGY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmRvbUludEluUmFuZ2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmlhTDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZ2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnc2SDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcmVzZXRPYnNvbGV0ZUNvdW50ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlE0YztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2lnbiA9IF9fd2VicGFja19leHBvcnRzX18uWHhlO1xudmFyIF9fd2VicGFja19leHBvcnRzX190b0RlZ3JlZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlV4YjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fdG9SYWRpYW5zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ZcjU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3ZlYyA9IF9fd2VicGFja19leHBvcnRzX18uQmh3O1xudmFyIF9fd2VicGFja19leHBvcnRzX193ZWJnbCA9IF9fd2VicGFja19leHBvcnRzX18ueU9BO1xuZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbkNvbnRleHQgYXMgQWN0aW9uQ29udGV4dCwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvblF1ZXVlIGFzIEFjdGlvblF1ZXVlLCBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uU2VxdWVuY2UgYXMgQWN0aW9uU2VxdWVuY2UsIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25zQ29tcG9uZW50IGFzIEFjdGlvbnNDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25zU3lzdGVtIGFzIEFjdGlvbnNTeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19BY3RpdmF0ZUV2ZW50IGFzIEFjdGl2YXRlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19BY3RvciBhcyBBY3RvciwgX193ZWJwYWNrX2V4cG9ydHNfX0FkZGVkQ29tcG9uZW50IGFzIEFkZGVkQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQWRkZWRFbnRpdHkgYXMgQWRkZWRFbnRpdHksIF9fd2VicGFja19leHBvcnRzX19BZmZpbmVNYXRyaXggYXMgQWZmaW5lTWF0cml4LCBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uIGFzIEFuaW1hdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvbkRpcmVjdGlvbiBhcyBBbmltYXRpb25EaXJlY3Rpb24sIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb25TdHJhdGVneSBhcyBBbmltYXRpb25TdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0FyY2FkZVNvbHZlciBhcyBBcmNhZGVTb2x2ZXIsIF9fd2VicGFja19leHBvcnRzX19BdWRpb0NvbnRleHRGYWN0b3J5IGFzIEF1ZGlvQ29udGV4dEZhY3RvcnksIF9fd2VicGFja19leHBvcnRzX19BeGlzIGFzIEF4aXMsIF9fd2VicGFja19leHBvcnRzX19CYXNlQWxpZ24gYXMgQmFzZUFsaWduLCBfX3dlYnBhY2tfZXhwb3J0c19fQmxpbmsgYXMgQmxpbmssIF9fd2VicGFja19leHBvcnRzX19Cb2R5Q29tcG9uZW50IGFzIEJvZHlDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Cb3VuZGluZ0JveCBhcyBCb3VuZGluZ0JveCwgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb2FkcGhhc2VTdHJhdGVneSBhcyBCcm9hZHBoYXNlU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyQ29tcG9uZW50IGFzIEJyb3dzZXJDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyRXZlbnRzIGFzIEJyb3dzZXJFdmVudHMsIF9fd2VicGFja19leHBvcnRzX19DYW1lcmEgYXMgQ2FtZXJhLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2FudmFzIGFzIENhbnZhcywgX193ZWJwYWNrX2V4cG9ydHNfX0NpcmNsZSBhcyBDaXJjbGUsIF9fd2VicGFja19leHBvcnRzX19DaXJjbGVDb2xsaWRlciBhcyBDaXJjbGVDb2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0NsYXNzIGFzIENsYXNzLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2xvY2sgYXMgQ2xvY2ssIF9fd2VicGFja19leHBvcnRzX19DbG9zZXN0TGluZSBhcyBDbG9zZXN0TGluZSwgX193ZWJwYWNrX2V4cG9ydHNfX0Nsb3Nlc3RMaW5lSnVtcFRhYmxlIGFzIENsb3Nlc3RMaW5lSnVtcFRhYmxlLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlkZXIgYXMgQ29sbGlkZXIsIF9fd2VicGFja19leHBvcnRzX19Db2xsaWRlckNvbXBvbmVudCBhcyBDb2xsaWRlckNvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkNvbnRhY3QgYXMgQ29sbGlzaW9uQ29udGFjdCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkVuZEV2ZW50IGFzIENvbGxpc2lvbkVuZEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uR3JvdXAgYXMgQ29sbGlzaW9uR3JvdXAsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Hcm91cE1hbmFnZXIgYXMgQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uSnVtcFRhYmxlIGFzIENvbGxpc2lvbkp1bXBUYWJsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblBvc3RTb2x2ZUV2ZW50IGFzIENvbGxpc2lvblBvc3RTb2x2ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUHJlU29sdmVFdmVudCBhcyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5IGFzIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblN0YXJ0RXZlbnQgYXMgQ29sbGlzaW9uU3RhcnRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblN5c3RlbSBhcyBDb2xsaXNpb25TeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25UeXBlIGFzIENvbGxpc2lvblR5cGUsIF9fd2VicGFja19leHBvcnRzX19Db2xvciBhcyBDb2xvciwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yQmxpbmRGbGFncyBhcyBDb2xvckJsaW5kRmxhZ3MsIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kbmVzc01vZGUgYXMgQ29sb3JCbGluZG5lc3NNb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZG5lc3NQb3N0UHJvY2Vzc29yIGFzIENvbG9yQmxpbmRuZXNzUG9zdFByb2Nlc3NvciwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbXBvbmVudCBhcyBDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Db21wb3NpdGVDb2xsaWRlciBhcyBDb21wb3NpdGVDb2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbmZpZ3VyYWJsZSBhcyBDb25maWd1cmFibGUsIF9fd2VicGFja19leHBvcnRzX19Db25zb2xlQXBwZW5kZXIgYXMgQ29uc29sZUFwcGVuZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdENvbnN0cmFpbnRQb2ludCBhcyBDb250YWN0Q29uc3RyYWludFBvaW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdEVuZEV2ZW50IGFzIENvbnRhY3RFbmRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnRhY3RTdGFydEV2ZW50IGFzIENvbnRhY3RTdGFydEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29vcmRQbGFuZSBhcyBDb29yZFBsYW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fRGVhY3RpdmF0ZUV2ZW50IGFzIERlYWN0aXZhdGVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnIGFzIERlYnVnLCBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWdHcmFwaGljc0NvbXBvbmVudCBhcyBEZWJ1Z0dyYXBoaWNzQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWdTeXN0ZW0gYXMgRGVidWdTeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1RleHQgYXMgRGVidWdUZXh0LCBfX3dlYnBhY2tfZXhwb3J0c19fRGVncmVlT2ZGcmVlZG9tIGFzIERlZ3JlZU9mRnJlZWRvbSwgX193ZWJwYWNrX2V4cG9ydHNfX0RlbGF5IGFzIERlbGF5LCBfX3dlYnBhY2tfZXhwb3J0c19fRGV0ZWN0b3IgYXMgRGV0ZWN0b3IsIF9fd2VicGFja19leHBvcnRzX19EaWUgYXMgRGllLCBfX3dlYnBhY2tfZXhwb3J0c19fRGlyZWN0aW9uIGFzIERpcmVjdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0Rpc3BsYXlNb2RlIGFzIERpc3BsYXlNb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWUgYXMgRHluYW1pY1RyZWUsIF9fd2VicGFja19leHBvcnRzX19EeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciBhcyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciwgX193ZWJwYWNrX2V4cG9ydHNfX0VYX1ZFUlNJT04gYXMgRVhfVkVSU0lPTiwgX193ZWJwYWNrX2V4cG9ydHNfX0Vhc2VCeSBhcyBFYXNlQnksIF9fd2VicGFja19leHBvcnRzX19FYXNlVG8gYXMgRWFzZVRvLCBfX3dlYnBhY2tfZXhwb3J0c19fRWFzaW5nRnVuY3Rpb25zIGFzIEVhc2luZ0Z1bmN0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX0VkZ2VDb2xsaWRlciBhcyBFZGdlQ29sbGlkZXIsIF9fd2VicGFja19leHBvcnRzX19FbGFzdGljVG9BY3RvclN0cmF0ZWd5IGFzIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19FbWl0dGVyVHlwZSBhcyBFbWl0dGVyVHlwZSwgX193ZWJwYWNrX2V4cG9ydHNfX0VuZ2luZSBhcyBFbmdpbmUsIF9fd2VicGFja19leHBvcnRzX19FbnRlclRyaWdnZXJFdmVudCBhcyBFbnRlclRyaWdnZXJFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0VudGVyVmlld1BvcnRFdmVudCBhcyBFbnRlclZpZXdQb3J0RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19FbnRpdHkgYXMgRW50aXR5LCBfX3dlYnBhY2tfZXhwb3J0c19fRW50aXR5TWFuYWdlciBhcyBFbnRpdHlNYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnREaXNwYXRjaGVyIGFzIEV2ZW50RGlzcGF0Y2hlciwgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50VHlwZXMgYXMgRXZlbnRUeXBlcywgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50cyBhcyBFdmVudHMsIF9fd2VicGFja19leHBvcnRzX19FeFJlc3BvbnNlIGFzIEV4UmVzcG9uc2UsIF9fd2VicGFja19leHBvcnRzX19FeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyBhcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcywgX193ZWJwYWNrX2V4cG9ydHNfX0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMIGFzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMLCBfX3dlYnBhY2tfZXhwb3J0c19fRXhjYWxpYnVyV2ViR0xDb250ZXh0QWNjZXNzb3IgYXMgRXhjYWxpYnVyV2ViR0xDb250ZXh0QWNjZXNzb3IsIF9fd2VicGFja19leHBvcnRzX19FeGl0VHJpZ2dlckV2ZW50IGFzIEV4aXRUcmlnZ2VyRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19FeGl0Vmlld1BvcnRFdmVudCBhcyBFeGl0Vmlld1BvcnRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0ZhZGUgYXMgRmFkZSwgX193ZWJwYWNrX2V4cG9ydHNfX0ZsYWdzIGFzIEZsYWdzLCBfX3dlYnBhY2tfZXhwb3J0c19fRm9sbG93IGFzIEZvbGxvdywgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnQgYXMgRm9udCwgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnRTdHlsZSBhcyBGb250U3R5bGUsIF9fd2VicGFja19leHBvcnRzX19Gb250VW5pdCBhcyBGb250VW5pdCwgX193ZWJwYWNrX2V4cG9ydHNfX0Zwc1NhbXBsZXIgYXMgRnBzU2FtcGxlciwgX193ZWJwYWNrX2V4cG9ydHNfX0ZyYW1lU3RhdHMgYXMgRnJhbWVTdGF0cywgX193ZWJwYWNrX2V4cG9ydHNfX0Z1dHVyZSBhcyBGdXR1cmUsIF9fd2VicGFja19leHBvcnRzX19HYW1lRXZlbnQgYXMgR2FtZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZVN0YXJ0RXZlbnQgYXMgR2FtZVN0YXJ0RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lU3RvcEV2ZW50IGFzIEdhbWVTdG9wRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQXhpc0V2ZW50IGFzIEdhbWVwYWRBeGlzRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQnV0dG9uRXZlbnQgYXMgR2FtZXBhZEJ1dHRvbkV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZENvbm5lY3RFdmVudCBhcyBHYW1lcGFkQ29ubmVjdEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZERpc2Nvbm5lY3RFdmVudCBhcyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2lmIGFzIEdpZiwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbENvb3JkaW5hdGVzIGFzIEdsb2JhbENvb3JkaW5hdGVzLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpYyBhcyBHcmFwaGljLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NDb21wb25lbnQgYXMgR3JhcGhpY3NDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0dyb3VwIGFzIEdyYXBoaWNzR3JvdXAsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVyIGFzIEdyYXBoaWNzTGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVycyBhcyBHcmFwaGljc0xheWVycywgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzU3lzdGVtIGFzIEdyYXBoaWNzU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fSGlkZGVuRXZlbnQgYXMgSGlkZGVuRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19JbWFnZUZpbHRlcmluZyBhcyBJbWFnZUZpbHRlcmluZywgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlU291cmNlIGFzIEltYWdlU291cmNlLCBfX3dlYnBhY2tfZXhwb3J0c19fSW5pdGlhbGl6ZUV2ZW50IGFzIEluaXRpYWxpemVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0lucHV0IGFzIElucHV0LCBfX3dlYnBhY2tfZXhwb3J0c19fSW50ZWdyYXRvciBhcyBJbnRlZ3JhdG9yLCBfX3dlYnBhY2tfZXhwb3J0c19fSXNvbWV0cmljRW50aXR5Q29tcG9uZW50IGFzIElzb21ldHJpY0VudGl0eUNvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0lzb21ldHJpY0VudGl0eVN5c3RlbSBhcyBJc29tZXRyaWNFbnRpdHlTeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19Jc29tZXRyaWNNYXAgYXMgSXNvbWV0cmljTWFwLCBfX3dlYnBhY2tfZXhwb3J0c19fSXNvbWV0cmljVGlsZSBhcyBJc29tZXRyaWNUaWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fS2lsbEV2ZW50IGFzIEtpbGxFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0xhYmVsIGFzIExhYmVsLCBfX3dlYnBhY2tfZXhwb3J0c19fTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneSBhcyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fTGluZSBhcyBMaW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fTGluZVNlZ21lbnQgYXMgTGluZVNlZ21lbnQsIF9fd2VicGFja19leHBvcnRzX19Mb2FkZXIgYXMgTG9hZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kgYXMgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5IGFzIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Mb2dMZXZlbCBhcyBMb2dMZXZlbCwgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ2dlciBhcyBMb2dnZXIsIF9fd2VicGFja19leHBvcnRzX19NYXRyaXggYXMgTWF0cml4LCBfX3dlYnBhY2tfZXhwb3J0c19fTWF0cml4TG9jYXRpb25zIGFzIE1hdHJpeExvY2F0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX01lZGlhRXZlbnQgYXMgTWVkaWFFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX01lZXQgYXMgTWVldCwgX193ZWJwYWNrX2V4cG9ydHNfX01vdGlvbkNvbXBvbmVudCBhcyBNb3Rpb25Db21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Nb3Rpb25TeXN0ZW0gYXMgTW90aW9uU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fTW92ZUJ5IGFzIE1vdmVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX01vdmVUbyBhcyBNb3ZlVG8sIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZEV2ZW50IGFzIE5hdGl2ZVNvdW5kRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50IGFzIE5hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19PYnNlcnZhYmxlIGFzIE9ic2VydmFibGUsIF9fd2VicGFja19leHBvcnRzX19PZmZzY3JlZW5TeXN0ZW0gYXMgT2Zmc2NyZWVuU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFpciBhcyBQYWlyLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYWxsYXhDb21wb25lbnQgYXMgUGFyYWxsYXhDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19QYXJhbGxlbEFjdGlvbnMgYXMgUGFyYWxsZWxBY3Rpb25zLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFyc2VHaWYgYXMgUGFyc2VHaWYsIF9fd2VicGFja19leHBvcnRzX19QYXJ0aWNsZSBhcyBQYXJ0aWNsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlRW1pdHRlciBhcyBQYXJ0aWNsZUVtaXR0ZXIsIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzIGFzIFBoeXNpY3MsIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzU3RhdHMgYXMgUGh5c2ljc1N0YXRzLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9pbnRlckNvbXBvbmVudCBhcyBQb2ludGVyQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUG9pbnRlclN5c3RlbSBhcyBQb2ludGVyU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbiBhcyBQb2x5Z29uLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbkNvbGxpZGVyIGFzIFBvbHlnb25Db2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvb2wgYXMgUG9vbCwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RDb2xsaXNpb25FdmVudCBhcyBQb3N0Q29sbGlzaW9uRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0RGVidWdEcmF3RXZlbnQgYXMgUG9zdERlYnVnRHJhd0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdERyYXdFdmVudCBhcyBQb3N0RHJhd0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdEZyYW1lRXZlbnQgYXMgUG9zdEZyYW1lRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0S2lsbEV2ZW50IGFzIFBvc3RLaWxsRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0VXBkYXRlRXZlbnQgYXMgUG9zdFVwZGF0ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUHJlQ29sbGlzaW9uRXZlbnQgYXMgUHJlQ29sbGlzaW9uRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVEZWJ1Z0RyYXdFdmVudCBhcyBQcmVEZWJ1Z0RyYXdFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1ByZURyYXdFdmVudCBhcyBQcmVEcmF3RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVGcmFtZUV2ZW50IGFzIFByZUZyYW1lRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVLaWxsRXZlbnQgYXMgUHJlS2lsbEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUHJlVXBkYXRlRXZlbnQgYXMgUHJlVXBkYXRlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qcm9qZWN0aW9uIGFzIFByb2plY3Rpb24sIF9fd2VicGFja19leHBvcnRzX19RdWFkSW5kZXhCdWZmZXIgYXMgUXVhZEluZGV4QnVmZmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fUXVlcnkgYXMgUXVlcnksIF9fd2VicGFja19leHBvcnRzX19RdWVyeU1hbmFnZXIgYXMgUXVlcnlNYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSBhcyBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fUmFuZG9tIGFzIFJhbmRvbSwgX193ZWJwYWNrX2V4cG9ydHNfX1Jhc3RlciBhcyBSYXN0ZXIsIF9fd2VicGFja19leHBvcnRzX19SYXkgYXMgUmF5LCBfX3dlYnBhY2tfZXhwb3J0c19fUmVhbGlzdGljU29sdmVyIGFzIFJlYWxpc3RpY1NvbHZlciwgX193ZWJwYWNrX2V4cG9ydHNfX1JlY3RhbmdsZSBhcyBSZWN0YW5nbGUsIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkQ29tcG9uZW50IGFzIFJlbW92ZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkRW50aXR5IGFzIFJlbW92ZWRFbnRpdHksIF9fd2VicGFja19leHBvcnRzX19SZXBlYXQgYXMgUmVwZWF0LCBfX3dlYnBhY2tfZXhwb3J0c19fUmVwZWF0Rm9yZXZlciBhcyBSZXBlYXRGb3JldmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb2x1dGlvbiBhcyBSZXNvbHV0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb3VyY2UgYXMgUmVzb3VyY2UsIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVCeSBhcyBSb3RhdGVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX1JvdGF0ZVRvIGFzIFJvdGF0ZVRvLCBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRpb25UeXBlIGFzIFJvdGF0aW9uVHlwZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NjYWxlQnkgYXMgU2NhbGVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX1NjYWxlVG8gYXMgU2NhbGVUbywgX193ZWJwYWNrX2V4cG9ydHNfX1NjZW5lIGFzIFNjZW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuIGFzIFNjcmVlbiwgX193ZWJwYWNrX2V4cG9ydHNfX1NjcmVlbkFwcGVuZGVyIGFzIFNjcmVlbkFwcGVuZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuRWxlbWVudCBhcyBTY3JlZW5FbGVtZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuU2hhZGVyIGFzIFNjcmVlblNoYWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Njcm9sbFByZXZlbnRpb25Nb2RlIGFzIFNjcm9sbFByZXZlbnRpb25Nb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fU2VtYXBob3JlIGFzIFNlbWFwaG9yZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NoYWRlciBhcyBTaGFkZXIsIF9fd2VicGFja19leHBvcnRzX19TaGFwZSBhcyBTaGFwZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NpZGUgYXMgU2lkZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NvdW5kIGFzIFNvdW5kLCBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlIGFzIFNwcml0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZUZvbnQgYXMgU3ByaXRlRm9udCwgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZVNoZWV0IGFzIFNwcml0ZVNoZWV0LCBfX3dlYnBhY2tfZXhwb3J0c19fU3RhbmRhcmRDbG9jayBhcyBTdGFuZGFyZENsb2NrLCBfX3dlYnBhY2tfZXhwb3J0c19fU3RhdGVNYWNoaW5lIGFzIFN0YXRlTWFjaGluZSwgX193ZWJwYWNrX2V4cG9ydHNfX1N0cmF0ZWd5Q29udGFpbmVyIGFzIFN0cmF0ZWd5Q29udGFpbmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fU3RyZWFtIGFzIFN0cmVhbSwgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbSBhcyBTeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1NYW5hZ2VyIGFzIFN5c3RlbU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1UeXBlIGFzIFN5c3RlbVR5cGUsIF9fd2VicGFja19leHBvcnRzX19UYWdDb21wb25lbnQgYXMgVGFnQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fVGVzdENsb2NrIGFzIFRlc3RDbG9jaywgX193ZWJwYWNrX2V4cG9ydHNfX1RleHQgYXMgVGV4dCwgX193ZWJwYWNrX2V4cG9ydHNfX1RleHRBbGlnbiBhcyBUZXh0QWxpZ24sIF9fd2VicGFja19leHBvcnRzX19UZXh0dXJlTG9hZGVyIGFzIFRleHR1cmVMb2FkZXIsIF9fd2VicGFja19leHBvcnRzX19UaWxlIGFzIFRpbGUsIF9fd2VicGFja19leHBvcnRzX19UaWxlTWFwIGFzIFRpbGVNYXAsIF9fd2VicGFja19leHBvcnRzX19UaW1lciBhcyBUaW1lciwgX193ZWJwYWNrX2V4cG9ydHNfX1RvYXN0ZXIgYXMgVG9hc3RlciwgX193ZWJwYWNrX2V4cG9ydHNfX1RyYW5zZm9ybSBhcyBUcmFuc2Zvcm0sIF9fd2VicGFja19leHBvcnRzX19UcmFuc2Zvcm1Db21wb25lbnQgYXMgVHJhbnNmb3JtQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fVHJlZU5vZGUgYXMgVHJlZU5vZGUsIF9fd2VicGFja19leHBvcnRzX19UcmlnZ2VyIGFzIFRyaWdnZXIsIF9fd2VicGFja19leHBvcnRzX19Ud29QSSBhcyBUd29QSSwgX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwgYXMgVXRpbCwgX193ZWJwYWNrX2V4cG9ydHNfX1ZlY3RvciBhcyBWZWN0b3IsIF9fd2VicGFja19leHBvcnRzX19WZWN0b3JWaWV3IGFzIFZlY3RvclZpZXcsIF9fd2VicGFja19leHBvcnRzX19WZXJ0ZXhCdWZmZXIgYXMgVmVydGV4QnVmZmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fVmVydGV4TGF5b3V0IGFzIFZlcnRleExheW91dCwgX193ZWJwYWNrX2V4cG9ydHNfX1Zpc2libGVFdmVudCBhcyBWaXNpYmxlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19XZWJBdWRpbyBhcyBXZWJBdWRpbywgX193ZWJwYWNrX2V4cG9ydHNfX1dlYkF1ZGlvSW5zdGFuY2UgYXMgV2ViQXVkaW9JbnN0YW5jZSwgX193ZWJwYWNrX2V4cG9ydHNfX1dvcmxkIGFzIFdvcmxkLCBfX3dlYnBhY2tfZXhwb3J0c19fY2Fub25pY2FsaXplQW5nbGUgYXMgY2Fub25pY2FsaXplQW5nbGUsIF9fd2VicGFja19leHBvcnRzX19jbGFtcCBhcyBjbGFtcCwgX193ZWJwYWNrX2V4cG9ydHNfX2NyZWF0ZUlkIGFzIGNyZWF0ZUlkLCBfX3dlYnBhY2tfZXhwb3J0c19fZnJhYyBhcyBmcmFjLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzR3JhcGhpY3NUaWNrIGFzIGhhc0dyYXBoaWNzVGljaywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uSW5pdGlhbGl6ZSBhcyBoYXNPbkluaXRpYWxpemUsIF9fd2VicGFja19leHBvcnRzX19oYXNPblBvc3RVcGRhdGUgYXMgaGFzT25Qb3N0VXBkYXRlLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25QcmVVcGRhdGUgYXMgaGFzT25QcmVVcGRhdGUsIF9fd2VicGFja19leHBvcnRzX19oYXNQb3N0RHJhdyBhcyBoYXNQb3N0RHJhdywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc1ByZURyYXcgYXMgaGFzUHJlRHJhdywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19pbml0aWFsaXplIGFzIGhhc19pbml0aWFsaXplLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzX3Bvc3R1cGRhdGUgYXMgaGFzX3Bvc3R1cGRhdGUsIF9fd2VicGFja19leHBvcnRzX19oYXNfcHJldXBkYXRlIGFzIGhhc19wcmV1cGRhdGUsIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkQ29tcG9uZW50IGFzIGlzQWRkZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkU3lzdGVtRW50aXR5IGFzIGlzQWRkZWRTeXN0ZW1FbnRpdHksIF9fd2VicGFja19leHBvcnRzX19pc1JlbW92ZVN5c3RlbUVudGl0eSBhcyBpc1JlbW92ZVN5c3RlbUVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlZENvbXBvbmVudCBhcyBpc1JlbW92ZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19pc1NjcmVlbkVsZW1lbnQgYXMgaXNTY3JlZW5FbGVtZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fbWF4TWVzc2FnZXMgYXMgbWF4TWVzc2FnZXMsIF9fd2VicGFja19leHBvcnRzX19vYnNvbGV0ZSBhcyBvYnNvbGV0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX3BpeGVsU25hcEVwc2lsb24gYXMgcGl4ZWxTbmFwRXBzaWxvbiwgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmRvbUluUmFuZ2UgYXMgcmFuZG9tSW5SYW5nZSwgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmRvbUludEluUmFuZ2UgYXMgcmFuZG9tSW50SW5SYW5nZSwgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmdlIGFzIHJhbmdlLCBfX3dlYnBhY2tfZXhwb3J0c19fcmVzZXRPYnNvbGV0ZUNvdW50ZXIgYXMgcmVzZXRPYnNvbGV0ZUNvdW50ZXIsIF9fd2VicGFja19leHBvcnRzX19zaWduIGFzIHNpZ24sIF9fd2VicGFja19leHBvcnRzX190b0RlZ3JlZXMgYXMgdG9EZWdyZWVzLCBfX3dlYnBhY2tfZXhwb3J0c19fdG9SYWRpYW5zIGFzIHRvUmFkaWFucywgX193ZWJwYWNrX2V4cG9ydHNfX3ZlYyBhcyB2ZWMsIF9fd2VicGFja19leHBvcnRzX193ZWJnbCBhcyB3ZWJnbCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNhbGlidXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9